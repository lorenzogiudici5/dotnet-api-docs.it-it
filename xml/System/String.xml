<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="String.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52995513b1f67d4db1b556f9a57e9c9f8d760d982.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2995513b1f67d4db1b556f9a57e9c9f8d760d982</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Represents text as a sequence of UTF-16 code units.</source>
          <target state="translated">Rappresenta il testo come sequenza di unità di codice UTF-16.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string is a sequential collection of characters that is used to represent text.</source>
          <target state="translated">Una stringa è una raccolta sequenziale di caratteri utilizzato per rappresentare del testo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is a sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects that represent a string; a <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> object corresponds to a UTF-16 code unit.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto è una raccolta sequenziale di <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> gli oggetti che rappresentano una stringa, un <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> oggetto corrisponde a un'unità di codice UTF-16.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object is the content of the sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects, and that value is immutable (that is, it is read-only).</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto è il contenuto della raccolta sequenziale di <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> oggetti e che il valore è non modificabile (ovvero, è in sola lettura).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about the immutability of strings, see the <bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept> section later in this topic.</source>
          <target state="translated">Per ulteriori informazioni sull'immutabilità delle stringhe, vedere il <bpt id="p1">[</bpt>immutabilità e della classe StringBuilder<ept id="p1">](#Immutability)</ept> sezione più avanti in questo argomento.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The maximum size of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in memory is 2GB, or about 1 billion characters.</source>
          <target state="translated">Le dimensioni massime di un <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto in memoria è 2 GB o circa 1 miliardo caratteri.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">Contenuto della sezione:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Instantiating a String object<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Creazione di un oggetto String<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Char objects and Unicode characters<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Oggetti char e caratteri Unicode<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and The Unicode Standard<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Le stringhe e lo Standard Unicode<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and embedded null characters<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Le stringhe e caratteri null incorporati<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and indexes<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Le stringhe e indici<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Null strings and empty strings<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Le stringhe null e stringhe vuote<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Immutabilità e della classe StringBuilder<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Ordinal vs. culture-sensitive operations<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Numero ordinale di operazioni dipendenti dalle impostazioni cultura<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Normalizzazione<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Operazioni su stringhe per categoria<ept id="p1">](#ByCategory)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instantiating a String object</source>
          <target state="translated">Creazione di un oggetto String</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in the following ways:</source>
          <target state="translated">È possibile creare un'istanza di un <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto nei modi seguenti:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By assigning a string literal to a <ph id="ph1">&lt;xref:System.String&gt;</ph> variable.</source>
          <target state="translated">Assegnando una valore letterale stringa a un <ph id="ph1">&lt;xref:System.String&gt;</ph> variabile.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the most commonly used method for creating a string.</source>
          <target state="translated">Questo è il metodo più comunemente usato per la creazione di una stringa.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses assignment to create several strings.</source>
          <target state="translated">Nell'esempio seguente usa l'assegnazione per creare più stringhe.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that in C#, because the backslash (<ph id="ph1">\\</ph>) is an escape character, literal backslashes in a string must be escaped or the entire string must be <ph id="ph2">@-quoted</ph>.</source>
          <target state="translated">Si noti che in c#, perché la barra rovesciata (<ph id="ph1">\\</ph>) è un carattere di escape, deve usare caratteri di escape barra rovesciata letterale in una stringa o l'intera stringa deve essere <ph id="ph2">@-quoted</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a <ph id="ph1">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Chiamando un <ph id="ph1">&lt;xref:System.String&gt;</ph> costruttore della classe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example instantiates strings by calling several class constructors.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di stringhe chiamando diversi costruttori di classe.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</source>
          <target state="translated">Si noti che alcuni costruttori includono puntatori a matrici di caratteri o matrici di byte con segno come parametri.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Visual Basic does not support calls to these constructors.</source>
          <target state="translated">Visual Basic non supporta le chiamate a questi costruttori.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per informazioni dettagliate su <ph id="ph1">&lt;xref:System.String&gt;</ph> costruttori, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By using the string concatenation operator (+ in C# and &amp; or + in Visual Basic) to create a single string from any combination of <ph id="ph1">&lt;xref:System.String&gt;</ph> instances and string literals.</source>
          <target state="translated">Utilizzando l'operatore di concatenazione di stringhe (+ in c# e &amp; o + in Visual Basic) per creare una singola stringa da qualsiasi combinazione di <ph id="ph1">&lt;xref:System.String&gt;</ph> istanze e i valori letterali stringa.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the use of the string concatenation operator.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo dell'operatore di concatenazione di stringhe.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By retrieving a property or calling a method that returns a string.</source>
          <target state="translated">Recupero di una proprietà o chiamando un metodo che restituisce una stringa.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the methods of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class to extract a substring from a larger string.</source>
          <target state="translated">L'esempio seguente usa i metodi del <ph id="ph1">&lt;xref:System.String&gt;</ph> classe per estrarre una sottostringa da una stringa più grande.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a formatting method to convert a value or object to its string representation.</source>
          <target state="translated">Chiamando un metodo di formattazione per convertire un valore o un oggetto nella relativa rappresentazione di stringa.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the                <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature to embed the string representation of two objects into a string.</source>
          <target state="translated">L'esempio seguente usa il <bpt id="p1">[</bpt>formattazione composita<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> funzionalità per incorporare la rappresentazione di stringa di due oggetti in una stringa.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Char objects and Unicode characters</source>
          <target state="translated">Oggetti char e caratteri Unicode</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</source>
          <target state="translated">Ogni carattere in una stringa è definito da un valore scalare Unicode, definito anche come un punto di codice Unicode o il valore ordinale (numerico) del carattere Unicode.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Ogni punto di codice verrà codificato utilizzando la codifica UTF-16 e il valore numerico di ogni elemento della codifica è rappresentato da un <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that, because a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that is not a well-formed Unicode string.</source>
          <target state="translated">Si noti che, poiché un <ph id="ph1">&lt;xref:System.String&gt;</ph> istanza è costituita da una raccolta sequenziale di unità di codice UTF-16, è possibile creare un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto che non è una stringa Unicode in formato corretto.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</source>
          <target state="translated">Ad esempio, è possibile creare una stringa che contiene un surrogato basso senza un surrogato alto corrispondente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although some methods, such as the methods of encoding and decoding objects in the <ph id="ph1">&lt;xref:System.Text&gt;</ph> namespace, may performs checks to ensure that strings are well-formed, <ph id="ph2">&lt;xref:System.String&gt;</ph> class members don't ensure that a string is well-formed.</source>
          <target state="translated">Anche se alcuni metodi, ad esempio i metodi di codifica e decodifica gli oggetti di <ph id="ph1">&lt;xref:System.Text&gt;</ph> dello spazio dei nomi, potrebbe esegue i controlli per assicurarsi che le stringhe siano in formato corretto, <ph id="ph2">&lt;xref:System.String&gt;</ph> i membri di classe non garantiscono che una stringa è ben formata.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object usually represents a single code point; that is, the numeric value of the <ph id="ph2">&lt;xref:System.Char&gt;</ph> equals the code point.</source>
          <target state="translated">Un singolo <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto in genere rappresenta un singolo punto di codice, vale a dire il valore numerico del <ph id="ph2">&lt;xref:System.Char&gt;</ph> è uguale al punto di codice.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the code point for the character "a" is U+0061.</source>
          <target state="translated">Ad esempio, il punto di codice per il carattere "a" è U + 0061.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, a code point might require more than one encoded element (more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object).</source>
          <target state="translated">Tuttavia, un punto di codice potrebbe richiedere più di un elemento codificato (più <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines two types of characters that correspond to multiple <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</source>
          <target state="translated">Lo standard Unicode definisce due tipi di caratteri che corrispondono a più <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetti: grafema e punti di codice supplementari Unicode che corrispondono ai caratteri nei piani supplementari Unicode.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A grapheme is represented by a base character followed by one or more combining characters.</source>
          <target state="translated">Un grafemi sono rappresentato da un carattere di base seguito da uno o più caratteri di combinazione.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the character ä is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is U+0061 followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is U+0308.</source>
          <target state="translated">Ad esempio, il carattere ä è rappresentato da un <ph id="ph1">&lt;xref:System.Char&gt;</ph> il cui punto di codice è U + 0061 seguito da un oggetto <ph id="ph2">&lt;xref:System.Char&gt;</ph> oggetto il cui punto di codice è U + 0308.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This character can also be defined by a single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object that has a code point of U+00E4.</source>
          <target state="translated">Questo carattere può essere definito anche da un singolo <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto con un punto di codice di U + 00E4.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</source>
          <target state="translated">Come illustrato nell'esempio seguente, un confronto con distinzione delle impostazioni cultura per verificarne l'uguaglianza indica che le due rappresentazioni sono uguali, anche se non esegue un confronto ordinale comune.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</source>
          <target state="translated">Tuttavia, se le due stringhe sono normalizzate, un confronto ordinale anche indica che sono uguali.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(For more information on normalizing strings, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section.)</source>
          <target state="translated">(Per ulteriori informazioni sulla normalizzazione di stringhe, vedere il <bpt id="p1">[</bpt>normalizzazione<ept id="p1">](#Normalization)</ept> sezione.)</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode supplementary code point (a surrogate pair) is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is a high surrogate followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is a low surrogate.</source>
          <target state="translated">Unicode punto di codice supplementare (una coppia di surrogati) è rappresentato da un <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto il cui punto di codice è un surrogato alto seguito da un <ph id="ph2">&lt;xref:System.Char&gt;</ph> oggetto il cui punto di codice è un surrogato basso.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of high surrogates range from U+D800 to U+DBFF.</source>
          <target state="translated">Le unità di codice di surrogati alti compreso tra U + D800 e U + DBFF.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of low surrogates range from U+DC00 to U+DFFF.</source>
          <target state="translated">Le unità di codice di surrogati bassi compreso tra U + DC00 e U + DFFF.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</source>
          <target state="translated">Le coppie di surrogati vengono utilizzate per rappresentare i caratteri nei piani supplementari Unicode 16.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a surrogate character and passes it to the <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> method to determine whether it is a surrogate pair.</source>
          <target state="translated">Nell'esempio seguente viene creato un carattere surrogato e lo passa al <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> metodo per determinare se si tratta di una coppia di surrogati.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and The Unicode Standard</source>
          <target state="translated">Le stringhe e lo Standard Unicode</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Characters in a string are represented by UTF-16 encoded code units, which correspond to <ph id="ph1">&lt;xref:System.Char&gt;</ph> values.</source>
          <target state="translated">In una stringa di caratteri sono rappresentati dalle unità di codice codificata UTF-16, che corrisponde a <ph id="ph1">&lt;xref:System.Char&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> enumeration.</source>
          <target state="translated">Ogni carattere in una stringa è una categoria di caratteri Unicode associata, che viene rappresentata in .NET Framework per il <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The category of a character or a surrogate pair can be determined by calling the <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">La categoria di un carattere o una coppia di surrogati può essere determinata chiamando il <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</source>
          <target state="translated">.NET gestisce la propria tabella di caratteri e le rispettive categorie corrispondente, che assicura che una versione specifica di un'implementazione di .NET in esecuzione su piattaforme diverse restituisce informazioni sulle categorie di caratteri identici.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</source>
          <target state="translated">La tabella seguente elenca le versioni di .NET e le versioni di Unicode Standard in cui sono in base alle categorie di caratteri.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">Versione di .NET Framework</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Versione dello Standard Unicode</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">.NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Core (all versions)</source>
          <target state="translated">.NET core (tutte le versioni)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</source>
          <target state="translated">Inoltre, .NET Framework supporta il confronto di stringa e ordinamento in base allo standard Unicode.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In versions of the .NET Framework through the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the .NET Framework maintains its own table of string data.</source>
          <target state="translated">Nelle versioni di .NET Framework tramite il <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, .NET Framework gestisce la propria tabella di dati stringa.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is also true of versions of the .NET Framework starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Windows 7.</source>
          <target state="translated">Ciò vale anche delle versioni di .NET Framework a partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> in esecuzione in Windows 7.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> i delegati di runtime in esecuzione in Windows 8 e versioni successive del sistema operativo Windows, stringa di confronto e ordinamento di operazioni al sistema operativo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</source>
          <target state="translated">La tabella seguente elenca le versioni di .NET Framework e le versioni dello Unicode Standard su quale carattere si basano confronto e ordinamento.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">Versione di .NET Framework</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Versione dello Standard Unicode</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">.NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 7</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> e versioni successive in Windows 7</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 8 and later Windows operating systems</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> e versioni successive in Windows 8 e versioni successive i sistemi operativi Windows</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo Standard Unicode, versione 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In .NET Core, sorting and comparison operations are based on <bpt id="p1">[</bpt>Version 8.0.0 of the Unicode Standard<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept>.</source>
          <target state="translated">In .NET Core, si basano le operazioni di ordinamento e confronto <bpt id="p1">[</bpt>versione 8.0.0 dello Unicode Standard<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and embedded null characters</source>
          <target state="translated">Le stringhe e caratteri null incorporati</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework, a <ph id="ph1">&lt;xref:System.String&gt;</ph> object can include embedded null characters, which count as a part of the string's length.</source>
          <target state="translated">In .NET Framework, un <ph id="ph1">&lt;xref:System.String&gt;</ph> l'oggetto può includere caratteri null incorporati vengono contati come parte di lunghezza della stringa.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</source>
          <target state="translated">Tuttavia, in alcune lingue, ad esempio C e C++, un carattere null indica la fine di una stringa, ma non viene considerato parte della stringa e non viene contato come parte della lunghezza della stringa.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <ph id="ph1">&lt;xref:System.String&gt;</ph> objects:</source>
          <target state="translated">Ciò significa che i seguenti presupposti comuni che potrebbero risultare ai programmatori di C e C++ o in librerie scritte in C o C++ sulle stringhe non sono necessariamente validi quando applicato a <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetti:</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value returned by the <ph id="ph1">`strlen`</ph> or <ph id="ph2">`wcslen`</ph> functions does not necessarily equal <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il valore restituito dal <ph id="ph1">`strlen`</ph> o <ph id="ph2">`wcslen`</ph> funzioni non è necessariamente uguale <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string created by the <ph id="ph1">`strcpy_s`</ph> or <ph id="ph2">`wcscpy_s`</ph> functions is not necessarily identical to the string created by the <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">La stringa creata mediante il <ph id="ph1">`strcpy_s`</ph> o <ph id="ph2">`wcscpy_s`</ph> funzioni non è necessariamente identico alla stringa creata dal <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should ensure that native C and C++ code that instantiates <ph id="ph1">&lt;xref:System.String&gt;</ph> objects, and code that is passed <ph id="ph2">&lt;xref:System.String&gt;</ph> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</source>
          <target state="translated">È necessario assicurarsi che C e C++ il codice nativo che crea un'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetti e il codice che viene passato <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetti mediante platform invoke, non presupporre che un carattere null incorporato contrassegna la fine della stringa.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</source>
          <target state="translated">Caratteri null incorporati in una stringa sono inoltre trattati in modo diverso quando è una stringa ordinata (o confrontata) e quando viene eseguita la ricerca di una stringa.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</source>
          <target state="translated">Caratteri null vengono ignorati quando si eseguono confronti dipendenti dalle impostazioni cultura tra due stringhe, inclusi i confronti usando la lingua inglese.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They are considered only for ordinal or case-insensitive ordinal comparisons.</source>
          <target state="translated">Vengono considerati solo per i confronti ordinali ordinali o tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, embedded null characters are always considered when searching a string with methods such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</source>
          <target state="translated">D'altra parte, i caratteri null incorporati vengono sempre considerati durante la ricerca di una stringa con metodi come <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and indexes</source>
          <target state="translated">Le stringhe e indici</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is the position of a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object (not a Unicode character) in a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Un indice è la posizione di un <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto (non un carattere Unicode) in un <ph id="ph2">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</source>
          <target state="translated">Un indice è un numero non negativo in base zero che inizia dalla prima posizione nella stringa, ovvero la posizione di indice zero.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of search methods, such as <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, return the index of a character or substring in the string instance.</source>
          <target state="translated">Un numero di metodi di ricerca, ad esempio <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, restituisce l'indice di un carattere o una sottostringa nell'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property lets you access individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects by their index position in the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> proprietà consente di accedere a singoli <ph id="ph2">&lt;xref:System.Char&gt;</ph> oggetti in base alla posizione nella stringa di indice.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in a string by using code such as the following.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> è la proprietà predefinita (in Visual Basic) o l'indicizzatore (in c#), è possibile accedere ai singoli <ph id="ph2">&lt;xref:System.Char&gt;</ph> oggetti in una stringa utilizzando codice simile al seguente.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This code looks for white space or punctuation characters in a string to determine how many words the string contains.</source>
          <target state="translated">Questo codice cerca gli spazi vuoti o punteggiatura in una stringa per determinare la stringa contiene il numero di parole.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, you can also iterate through the <ph id="ph3">&lt;xref:System.Char&gt;</ph> objects in a string by using a <ph id="ph4">`foreach`</ph> construct, as the following example shows.</source>
          <target state="translated">Perché il <ph id="ph1">&lt;xref:System.String&gt;</ph> classe implementa il <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interfaccia, è anche possibile scorrere il <ph id="ph3">&lt;xref:System.Char&gt;</ph> oggetti in una stringa con un <ph id="ph4">`foreach`</ph> costrutto, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">I valori di indice consecutive potrebbero non corrispondere ai caratteri Unicode consecutivi, dal momento che un carattere Unicode può essere codificato in più di un <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</source>
          <target state="translated">In particolare, una stringa può contenere più caratteri unità di testo che sono costituite da un carattere di base seguito da uno o più caratteri di unione o da coppie di surrogati.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To work with Unicode characters instead of <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, use the <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classes.</source>
          <target state="translated">Per utilizzare i caratteri Unicode anziché <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetti, utilizzare il <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classi.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between code that works with <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects and code that works with Unicode characters.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la differenza tra il codice che interagisce con <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetti e il codice che funziona con i caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It compares the number of characters or text elements in each word of a sentence.</source>
          <target state="translated">Confronta il numero di caratteri o elementi di testo di ogni parola di una frase.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string includes two sequences of a base character followed by a combining character.</source>
          <target state="translated">La stringa include due sequenze di un carattere di base seguiti da un carattere di combinazione.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example works with text elements by using the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> class to enumerate all the text elements in a string.</source>
          <target state="translated">In questo esempio funziona con elementi di testo utilizzando il <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classe per enumerare tutti gli elementi di testo in una stringa.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also retrieve an array that contains the starting index of each text element by calling the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">È inoltre possibile recuperare una matrice che contiene l'indice iniziale di ogni elemento di testo chiamando il <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about working with units of text rather than individual <ph id="ph1">&lt;xref:System.Char&gt;</ph> values, see the <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> class.</source>
          <target state="translated">Per ulteriori informazioni sull'utilizzo di unità di testo anziché singoli <ph id="ph1">&lt;xref:System.Char&gt;</ph> valori, vedere la <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null strings and empty strings</source>
          <target state="translated">Le stringhe null e stringhe vuote</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that has been declared but has not been assigned a value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">È una stringa che è stata dichiarata ma non è stata assegnata un valore <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to call methods on that string throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">Il tentativo di chiamare metodi su quella stringa genera un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A null string is different from an empty string, which is a string whose value is "" or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Una stringa null è diversa da una stringa vuota, che è una stringa il cui valore è "" o <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</source>
          <target state="translated">In alcuni casi, passando una stringa null o una stringa vuota come argomento in una chiamata al metodo genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, passing a null string to the <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, and passing an empty string throws a <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Ad esempio, passare una stringa null per il <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> metodo genera un <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>e passando una stringa vuota genera un <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In other cases, a method argument can be either a null string or an empty string.</source>
          <target state="translated">In altri casi, un argomento del metodo può essere una stringa null o una stringa vuota.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if you are providing an <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</source>
          <target state="translated">Ad esempio, se si fornisce un <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> implementazione per una classe, che si desidera compensare sia una stringa null e una stringa vuota con l'identificatore di formato generale ("G").</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following two convenience methods that enable you to test whether a string is <ph id="ph2">`null`</ph> or empty:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String&gt;</ph> classe include i seguenti due metodi pratici che consentono di verificare se è una stringa <ph id="ph2">`null`</ph> o vuoto:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, which indicates whether a string is either <ph id="ph2">`null`</ph> or is equal to  <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, che indica se una stringa è <ph id="ph2">`null`</ph> o è uguale a <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">Questo metodo elimina la necessità di usare codice analogo al seguente:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, which indicates whether a string is <ph id="ph2">`null`</ph>, equals <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, or consists exclusively of white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, che indica se una stringa è <ph id="ph2">`null`</ph>, è uguale a <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, o composto solo da spazi vuoti.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">Questo metodo elimina la necessità di usare codice analogo al seguente:</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method in the <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation of a custom <ph id="ph3">`Temperature`</ph> class.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementazione di un oggetto personalizzato <ph id="ph3">`Temperature`</ph> classe.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method supports the "G", "C", "F", and "K" format strings.</source>
          <target state="translated">Il metodo supporta le stringhe di formato "G", "C", "F" e "K".</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If an empty format string or a format string whose value is <ph id="ph1">`null`</ph> is passed to the method, its value is changed to the "G" format string.</source>
          <target state="translated">Se una stringa di formato vuoto o un formato stringa il cui valore è <ph id="ph1">`null`</ph> viene passato al metodo, il valore viene modificato per la stringa di formato "G".</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Immutability and the StringBuilder class</source>
          <target state="translated">Immutabilità e della classe StringBuilder</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is called immutable (read-only), because its value cannot be modified after it has been created.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto viene chiamato non modificabile (sola lettura), perché il relativo valore non può essere modificato dopo che è stato creato.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that appear to modify a <ph id="ph1">&lt;xref:System.String&gt;</ph> object actually return a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains the modification.</source>
          <target state="translated">Metodi che vengono visualizzati per modificare un <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto restituiscono in realtà un nuovo <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto che contiene la modifica.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</source>
          <target state="translated">Poiché le stringhe non sono modificabili, routine di modifica di stringhe che eseguono aggiunte o eliminazioni ripetute a quello che sembra essere che una singola stringa possa esatte una riduzione significativa delle prestazioni.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</source>
          <target state="translated">Ad esempio, il codice seguente viene utilizzato un generatore di numeri casuali per creare una stringa con 1000 caratteri nell'intervallo 0x0001 a 0x052F.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although the code appears to use string concatenation to append a new character to the existing string named <ph id="ph1">`str`</ph>, it actually creates a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each concatenation operation.</source>
          <target state="translated">Anche se il codice sembra utilizzare concatenazione di stringhe per aggiungere un carattere di nuova stringa esistente denominata <ph id="ph1">`str`</ph>, effettivamente crea un nuovo <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni operazione di concatenazione.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class for operations that make multiple changes to the value of a string.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> classe anziché la <ph id="ph2">&lt;xref:System.String&gt;</ph> classe per le operazioni che modificano più il valore di una stringa.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike instances of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class, <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</source>
          <target state="translated">A differenza delle istanze di <ph id="ph1">&lt;xref:System.String&gt;</ph> (classe), <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> gli oggetti sono modificabili, quando si concatenano, aggiungere o eliminare sottostringhe da una stringa, le operazioni vengono eseguite su una singola stringa.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you have finished modifying the value of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object, you can call its <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> method to convert it to a string.</source>
          <target state="translated">Una volta terminata la modifica del valore di un <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> dell'oggetto, è possibile chiamare il relativo <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> metodo per convertirlo in una stringa.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example replaces the <ph id="ph1">&lt;xref:System.String&gt;</ph> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
          <target state="translated">Nell'esempio seguente sostituisce il <ph id="ph1">&lt;xref:System.String&gt;</ph> utilizzato nell'esempio precedente per concatenare 1000 caratteri casuali nell'intervallo da 0x0001 a 0x052F con un <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal vs. culture-sensitive operations</source>
          <target state="translated">Numero ordinale di operazioni dipendenti dalle impostazioni cultura</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Members of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class perform either ordinal or culture-sensitive (linguistic) operations on a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">I membri del <ph id="ph1">&lt;xref:System.String&gt;</ph> classe operazioni ordinali o dipendenti dalle impostazioni cultura (linguistiche) su un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal operation acts on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Viene eseguita un'operazione ordinale al valore numerico di ogni <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive operation acts on the value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</source>
          <target state="translated">Un'operazione di distinzione delle impostazioni cultura, agisce sul valore della <ph id="ph1">&lt;xref:System.String&gt;</ph> , oggetto e maiuscole e minuscole delle impostazioni cultura specifiche accetta, ordinamento, la formattazione e le regole di analisi in considerazione.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</source>
          <target state="translated">Operazioni dipendenti dalle impostazioni cultura vengono eseguite nel contesto di una lingua dichiarata in modo esplicito o implicita impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The two kinds of operations can produce very different results when they are performed on the same string.</source>
          <target state="translated">I due tipi di operazioni possono produrre risultati molto diversi quando vengono eseguiti sulla stessa stringa.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), which is loosely based on the culture settings of the English language independent of region.</source>
          <target state="translated">.NET Framework supporta anche le operazioni di stringhe linguistico indipendente dalle impostazioni cultura usando la lingua inglese (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), che si basa fortemente alle impostazioni cultura della lingua inglese indipendente dell'area.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike other <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</source>
          <target state="translated">A differenza degli altri <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> impostazioni, le impostazioni della lingua inglese è garantite per mantenere la coerenza in un singolo computer, dal sistema al sistema e in tutte le versioni di .NET Framework.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</source>
          <target state="translated">Le impostazioni cultura invarianti possono essere considerata come un tipo di casella nera che assicura la stabilità dei confronti tra stringhe e ordinamento tra tutte le impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</source>
          <target state="translated">Se l'applicazione effettua una decisione di sicurezza su un identificatore simbolico, ad esempio un nome di file o sulla named pipe o sui dati persistenti, ad esempio i dati basati su testo in un file XML, l'operazione deve utilizzare un confronto ordinale anziché un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</source>
          <target state="translated">In questo modo un confronto con distinzione delle impostazioni cultura può restituire risultati diversi a seconda delle impostazioni cultura in effetti, mentre un confronto ordinale dipende esclusivamente dal valore binario dei caratteri confrontati.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most methods that perform string operations include an overload that has a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</source>
          <target state="translated">La maggior parte dei metodi che eseguono operazioni di stringa includono un overload che dispone di un parametro di tipo <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, che consente di specificare se il metodo esegue un'operazione ordinale o dipendenti dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In general, you should call this overload to make the intent of your method call clear.</source>
          <target state="translated">In generale, è necessario chiamare questo overload per rendere lo scopo del metodo di chiamata non crittografato.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For best practices and guidance for using ordinal and culture-sensitive operations on strings, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per procedure consigliate e indicazioni per l'utilizzo di numeri ordinali e cultura operazioni sulle stringhe, vedere <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Operations for <bpt id="p1">[</bpt>casing<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>parsing and formatting<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>comparison and sorting<ept id="p3">](#comparison)</ept>, and <bpt id="p4">[</bpt>testing for equality<ept id="p4">](#equality)</ept> can be either ordinal or culture-sensitive.</source>
          <target state="translated">Operazioni per <bpt id="p1">[</bpt>maiuscole e minuscole<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>l'analisi e formattazione<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>confronto e ordinamento<ept id="p3">](#comparison)</ept>, e <bpt id="p4">[</bpt>la verifica dell'uguaglianza<ept id="p4">](#equality)</ept> possono essere ordinali o dipendenti dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following sections discuss each category of operation.</source>
          <target state="translated">Le sezioni seguenti illustrano ogni categoria di operazione.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should always call a method overload that makes the intent of your method call clear.</source>
          <target state="translated">È sempre necessario chiamare un overload del metodo che esegue lo scopo del metodo di chiamata non crittografato.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, instead of calling the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with a value of <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> argument.</source>
          <target state="translated">Ad esempio, anziché chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> metodo per eseguire un confronto con distinzione delle impostazioni cultura di due stringhe utilizzando le convenzioni delle impostazioni cultura correnti, è necessario chiamare il <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> metodo con un valore di <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> per il <ph id="ph4">`comparisonType`</ph> argomento.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept> (Procedure consigliate per l'uso di stringhe).</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing</source>
          <target state="translated">Maiuscole e minuscole</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</source>
          <target state="translated">Le regole di maiuscole e minuscole determinano come modificare le lettere maiuscole di un carattere Unicode; ad esempio, da minuscolo a maiuscolo.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Often, a casing operation is performed before a string comparison.</source>
          <target state="translated">Spesso, prima di un confronto tra stringhe viene eseguita un'operazione di maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</source>
          <target state="translated">Una stringa, ad esempio, potrebbe essere convertita in caratteri maiuscoli in modo che può essere confrontato con un'altra stringa in caratteri maiuscoli.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can convert the characters in a string to lowercase by calling the <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method, and you can convert them to uppercase by calling the <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">È possibile convertire i caratteri in una stringa in minuscolo chiamando il <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> metodo ed è possibile eseguirne la conversione in maiuscolo chiamando il <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> method to convert a string to title case.</source>
          <target state="translated">Inoltre, è possibile utilizzare il <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> metodo per convertire una stringa in maiuscole.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</source>
          <target state="translated">Le operazioni di maiuscole e minuscole possono essere basate sulle regole di impostazioni cultura correnti, impostazioni cultura specifiche o le impostazioni cultura invarianti.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</source>
          <target state="translated">Poiché il mapping di maiuscole e può variare a seconda delle impostazioni cultura utilizzate, il risultato delle operazioni di maiuscole e minuscole può variare in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The actual differences in casing are of three kinds:</source>
          <target state="translated">Le differenze nelle maiuscole e minuscole effettivi sono tre tipi:</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</source>
          <target state="translated">Le differenze nel mapping di maiuscole dell'ALFABETO LATINO I (U + 0049), LATIN SMALL lettera I (U + 0069), LATIN CAPITAL LETTER I con punto sopra (U + 0130) e LATIN SMALL lettera punto I (U + 0131).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Tr-TR (Turco (Turchia)) e le impostazioni cultura az-Latn-AZ (Azerbaigian, alfabeto latino), tr, az e az-Latn neutre, equivalente in caratteri minuscoli dell'ALFABETO LATINO I è LATIN SMALL lettera punto I ed equivalente in caratteri maiuscoli dell'alfabeto LATINO SMALL lettera I è LATIN CAPITAL LETTER I con punto superiore.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</source>
          <target state="translated">In tutte le altre lingue, incluse le impostazioni cultura invarianti, LATIN SMALL lettera I e lettera latina a maiuscola I sono equivalenti in lettere minuscole e maiuscole.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come un confronto tra stringhe progettato per impedire l'accesso al file system può non riuscire se si basa su un confronto tra maiuscole e minuscole delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(The casing conventions of the invariant culture should have been used.)</source>
          <target state="translated">(Le convenzioni delle impostazioni cultura invarianti devono sono state utilizzate.)</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings between the invariant culture and all other cultures.</source>
          <target state="translated">Mapping di maiuscole e differenze tra le impostazioni cultura invarianti e tutte le altre impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</source>
          <target state="translated">In questi casi, usando le regole di maiuscole e minuscole delle impostazioni cultura invarianti per modificare un carattere in maiuscolo o minuscolo restituisce lo stesso carattere.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all other cultures, it returns a different character.</source>
          <target state="translated">Per tutte le altre lingue, restituisce un carattere diverso.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some of the affected characters are listed in the following table.</source>
          <target state="translated">Nella tabella seguente sono elencati alcuni dei caratteri interessati.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Character</source>
          <target state="translated">Carattere</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If changed to</source>
          <target state="translated">Se impostata su</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Returns</source>
          <target state="translated">Valore restituito</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>MICRON SIGN (U+00B5)</source>
          <target state="translated">MICRON SIGN (U+00B5)</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Maiuscole</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER MU (U+-39C)</source>
          <target state="translated">LETTERA GRECA MAIUSCOLA MU (U +-39C)</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</source>
          <target state="translated">LATINO CON PUNTO SOPRA (U + 0130)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">Minuscole</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER I (U+0069)</source>
          <target state="translated">LATINO (U + 0069)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DOTLESS I (U+0131)</source>
          <target state="translated">CARATTERE ALFABETO SI (U + 0131)</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Maiuscole</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I (U+0049)</source>
          <target state="translated">LATINO (U + 0049)</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER LONG S (U+017F)</source>
          <target state="translated">CARATTERE ALFABETO LATINO (U + 017F)</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Maiuscole</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER S (U+0053)</source>
          <target state="translated">LATIN CAPITAL LETTER S (U + 0053)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</source>
          <target state="translated">LETTERA DI CAPITALE LATINO D CON Z ALFABETO LATINO (U + 01C 5)</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">Minuscole</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DZ WITH CARON (U+01C6)</source>
          <target state="translated">CARATTERE ALFABETO LATINO LATINO (U + 01C 6)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>COMBINING GREEK YPOGEGRAMMENI (U+0345)</source>
          <target state="translated">COMBINAZIONE YPOGEGRAMMENI GRECO (U + 0345)</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Maiuscole</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER IOTA (U+0399)</source>
          <target state="translated">LETTERA GRECA MAIUSCOLA IOTA (U + 0399)</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</source>
          <target state="translated">Differenze nel mapping di maiuscole e delle coppie di due lettere minuscole nell'intervallo di caratteri ASCII.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</source>
          <target state="translated">La maggior parte delle impostazioni cultura, una coppia di due lettere maiuscole e minuscole è uguale alla coppia di caratteri maiuscola o minuscola due lettere equivalente.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</source>
          <target state="translated">Ciò non è possibile per le seguenti coppie di due lettere nelle lingue seguenti, poiché in ogni caso di confronto per un digraph:</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</source>
          <target state="translated">"lJ" e "nJ" nelle impostazioni cultura hr-HR (croato (Croazia)).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</source>
          <target state="translated">"cH" in cs-CZ (ceco (Repubblica ceca)) e le impostazioni cultura sk-SK (Slovacco (Slovacchia)).</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"aA" in the da-DK (Danish (Denmark)) culture.</source>
          <target state="translated">"aA" nelle impostazioni cultura da-DK (danese (Danimarca)).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</source>
          <target state="translated">"cS", "dZ", "dZS", "nY", "sZ", "tY" e "zS" nelle impostazioni cultura hu-HU (ungherese (Ungheria)).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</source>
          <target state="translated">"cH" e "lL" nelle impostazioni cultura es-ES tradnl (spagnolo (Spagna-ordinamento tradizionale)).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</source>
          <target state="translated">"cH", "gI", "kH", "nG" "nH", "pH", "qU", "tH" e "tR" nelle impostazioni cultura vi-VN (vietnamita (Vietnam)).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</source>
          <target state="translated">Tuttavia, è insolito che in una situazione in cui un confronto con distinzione delle impostazioni cultura di queste coppie crea problemi, perché queste coppie non sono comuni in stringhe fisse o identificatori.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</source>
          <target state="translated">L'esempio seguente illustra alcune delle differenze nelle regole di maiuscole e minuscole tra le impostazioni cultura per la conversione di stringhe in lettere maiuscole.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parsing and formatting</source>
          <target state="translated">L'analisi e formattazione</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and parsing are inverse operations.</source>
          <target state="translated">Formattazione e analisi sono operazioni inverse.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</source>
          <target state="translated">Regole di formattazione determinano come convertire un valore, ad esempio una data e ora o un numero, nella relativa rappresentazione di stringa, mentre le regole di analisi determinano come convertire una rappresentazione di stringa in un valore, ad esempio una data e ora.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both formatting and parsing rules are dependent on cultural conventions.</source>
          <target state="translated">La formattazione sia le regole di analisi sono dipendenti dalle convenzioni culturali.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</source>
          <target state="translated">Nell'esempio seguente viene illustrata l'ambiguità che può verificarsi durante l'interpretazione di una stringa di data specifici delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</source>
          <target state="translated">Senza conoscere le convenzioni delle impostazioni cultura che è stato utilizzato per produrre una stringa di data, non è possibile sapere se 01/03/2011, 03/01/2011 e 3/1/2011 rappresentano il 3 gennaio 2011 o il 1 marzo 2011.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</source>
          <target state="translated">Analogamente, come illustrato nell'esempio seguente, una singola stringa può produrre date diverse a seconda delle impostazioni cultura cui convenzioni vengono usate nell'operazione di analisi.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String comparison and sorting</source>
          <target state="translated">Confronto tra stringhe e l'ordinamento</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Conventions for comparing and sorting strings vary from culture to culture.</source>
          <target state="translated">Convenzioni per il confronto e ordinamento delle stringhe variano alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the sort order may be based on phonetics or on the visual representation of characters.</source>
          <target state="translated">Ad esempio, il tipo di ordinamento può essere basato sulla fonetica o sulla rappresentazione visiva dei caratteri.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In East Asian languages, characters are sorted by the stroke and radical of ideographs.</source>
          <target state="translated">In lingue dell'Asia orientale, i caratteri sono ordinati per il tratto e radicale di ideogrammi.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sorting also depends on the order languages and cultures use for the alphabet.</source>
          <target state="translated">Ordinamento dipende inoltre le lingue di ordine e utilizzano le impostazioni cultura per la lettera dell'alfabeto.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</source>
          <target state="translated">Nella lingua danese, ad esempio, è presente un carattere "Æ" che viene ordinato alfabeticamente dopo la lettera Z.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</source>
          <target state="translated">Inoltre, confronti possono essere tra maiuscole e minuscole o maiuscole/minuscole, e in alcuni casi le regole di maiuscole e minuscole anche differiscono dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</source>
          <target state="translated">Confronto ordinale, invece, utilizza i punti di codice Unicode dei singoli caratteri in una stringa quando il confronto e ordinamento delle stringhe.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</source>
          <target state="translated">Le regole di ordinamento determinano che l'ordine alfabetico dei caratteri Unicode e come due stringhe da confrontare a altro.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method compares two strings based on the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> metodo confronta due stringhe in base il <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the parameter value is <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, the method performs an ordinal comparison.</source>
          <target state="translated">Se il valore del parametro <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, il metodo esegue un confronto linguistico che utilizza le convenzioni delle impostazioni cultura correnti; se il valore del parametro <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, il metodo esegue un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</source>
          <target state="translated">Di conseguenza, come illustrato nell'esempio seguente, se le impostazioni cultura correnti sono US Inglese, la prima chiamata al <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> (metodo) (mediante confronto con distinzione delle impostazioni cultura) considera "a" minore di "A", ma la seconda chiamata al metodo stesso (tramite un confronto ordinale) considera "a" maggiore di "A".</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports word, string, and ordinal sort rules:</source>
          <target state="translated">.NET Framework supporta word, stringa e le regole di ordinamento:</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</source>
          <target state="translated">Un ordinamento di word esegue un confronto con distinzione delle impostazioni cultura delle stringhe in cui alcuni caratteri Unicode potrebbero essere assegnati a tali di pesi speciali.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</source>
          <target state="translated">Ad esempio, il trattino (-) potrebbe essere un peso molto piccolo assegnato in modo che "coop" e "co" vengono visualizzati uno accanto a altro in un elenco ordinato.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using word sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">Per un elenco di <ph id="ph1">&lt;xref:System.String&gt;</ph> metodi che consentono di confrontare due stringhe utilizzando le regole di ordinamento di word, vedere il <bpt id="p1">[</bpt>operazioni su stringhe in base alla categoria<ept id="p1">](#ByCategory)</ept> sezione.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string sort also performs a culture-sensitive comparison.</source>
          <target state="translated">Un ordinamento di stringa esegue inoltre un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</source>
          <target state="translated">È simile a un ordinamento di word, ad eccezione del fatto che esistono casi speciali e tutti i simboli non alfanumerici precedono a tutti i caratteri Unicode alfanumerici.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Two strings can be compared using string sort rules by calling the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> method overloads that have an <ph id="ph2">`options`</ph> parameter that is supplied a value of <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Possibile confrontare due stringhe utilizzando le regole di ordinamento di stringa chiamando il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> gli overload di metodo che hanno un <ph id="ph2">`options`</ph> parametro che viene fornito un valore di <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</source>
          <target state="translated">Si noti che questo è l'unico metodo che .NET Framework fornisce per confrontare due stringhe utilizzando le regole di ordinamento delle stringhe.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal sort compares strings based on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string.</source>
          <target state="translated">L'ordinamento ordinale confronta le stringhe in base al valore numerico di ogni <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto nella stringa.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</source>
          <target state="translated">Un confronto ordinale è automaticamente tra maiuscole e minuscole, perché le versioni maiuscole e minuscole di un carattere dispongono di punti di codice diversi.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if case is not important, you can specify an ordinal comparison that ignores case.</source>
          <target state="translated">Tuttavia, se non è importante, è possibile specificare un confronto ordinale che ignori tale distinzione.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</source>
          <target state="translated">Questo è equivalente alla conversione di una stringa in lettere maiuscole, usando la lingua inglese e quindi di eseguire un confronto ordinale al risultato.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using ordinal sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">Per un elenco di <ph id="ph1">&lt;xref:System.String&gt;</ph> metodi che consentono di confrontare due stringhe utilizzando le regole di ordinamento ordinali, vedere il <bpt id="p1">[</bpt>operazioni su stringhe in base alla categoria<ept id="p1">](#ByCategory)</ept> sezione.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object, including the invariant culture that is specified by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Un confronto con distinzione delle impostazioni cultura è qualsiasi confronto che utilizza in modo esplicito o implicito un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto, incluse le impostazioni cultura invarianti specificati tramite il <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The implicit culture is the current culture, which is specified by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Le impostazioni cultura implicite sono la lingua corrente, specificata dal <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph2">`true`</ph>) across cultures.</source>
          <target state="translated">È variare notevolmente l'ordinamento dei caratteri alfabetici (ovvero i caratteri per il quale il <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> restituisce proprietà <ph id="ph2">`true`</ph>) nelle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object to a string comparison method such as <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</source>
          <target state="translated">È possibile specificare un confronto con distinzione delle impostazioni cultura che utilizza le convenzioni delle impostazioni cultura specifiche, fornendo un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto a un metodo di confronto di stringa, ad esempio <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, or any member of the <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration other than <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> to an appropriate overload of the <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">È possibile specificare un confronto con distinzione delle impostazioni cultura che utilizza le convenzioni delle impostazioni cultura correnti fornendo <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, o qualsiasi membro del <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumerazione diverso da <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> o <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> a un overload appropriato del <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</source>
          <target state="translated">Un confronto con distinzione delle impostazioni cultura è generalmente appropriato per l'ordinamento, mentre non è un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</source>
          <target state="translated">Un confronto ordinale è generalmente appropriato per determinare se due stringhe sono uguali (ovvero, per determinare l'identità) che non è un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between culture-sensitive and ordinal comparison.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la differenza tra confronto dipendenti dalle impostazioni cultura e ordinale.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method is called).</source>
          <target state="translated">L'esempio restituisce tre stringhe "Apple", "Æble" e "AEble", utilizzando un confronto ordinale e le convenzioni delle impostazioni cultura da-DK ed en-US (ognuno dei quali è la lingua predefinita al momento il <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo viene chiamato).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</source>
          <target state="translated">Poiché la lingua danese considera il carattere "Æ" come una singola lettera e Ordina "Z" dopo la lettera dell'alfabeto, la stringa "Æble" è maggiore di "Apple".</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</source>
          <target state="translated">Tuttavia, "Æble" non è considerata equivalente a "AEble", "Æble" rappresenta anche maggiore di "AEble".</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</source>
          <target state="translated">Le impostazioni cultura en-US non includono la lettera "Æ", ma viene considerata equivalente a "AE", che spiega perché "Æble" è minore di "Apple" ma uguale a "AEble".</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</source>
          <target state="translated">Confronto ordinale, d'altra parte, considera "Apple" deve essere inferiore a "Æble" e "Æble" devono essere maggiori di "AEble".</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the following general guidelines to choose an appropriate sorting or string comparison method:</source>
          <target state="translated">Utilizzare le seguenti linee guida generali per scegliere un metodo di confronto di ordinamento o di stringa appropriato:</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</source>
          <target state="translated">Se si desidera, le stringhe devono essere ordinati in base alle impostazioni cultura dell'utente, è consigliabile ordinare in base alle convenzioni delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the user's culture changes, the order of sorted strings will also change accordingly.</source>
          <target state="translated">Se viene modificata la lingua dell'utente, l'ordine delle stringhe ordinate inoltre è in grado di modificare di conseguenza.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a thesaurus application should always sort words based on the user's culture.</source>
          <target state="translated">Ad esempio, un'applicazione del thesaurus deve sempre ordinare parole in base alle impostazioni cultura dell'utente.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to a comparison method.</source>
          <target state="translated">Se si desidera, le stringhe devono essere ordinati in base alle convenzioni delle impostazioni cultura specifiche, sarà necessario ordinare li fornendo un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto che rappresenta quelle impostazioni cultura per un metodo di confronto.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</source>
          <target state="translated">Ad esempio, in un'applicazione progettata per illustrare gli studenti che una determinata lingua, si desidera stringhe devono essere ordinati in base alle convenzioni di una delle lingue che legge di tale lingua.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</source>
          <target state="translated">Se si desidera che l'ordine delle stringhe di mantenere invariate nelle impostazioni cultura, si deve ordinarle in base alle convenzioni della lingua inglese o utilizzare un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</source>
          <target state="translated">Ad esempio, si utilizzerebbe un ordinamento ordinali per organizzare i nomi dei file, i processi, i mutex o named pipe.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Per un confronto che implica una decisione relativa alla sicurezza (ad esempio, se un nome utente è valido), è necessario eseguire sempre un ordinale nel test di uguaglianza chiamando un overload di <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</source>
          <target state="translated">Ordinamento delle impostazioni cultura e le regole di confronto tra stringhe usate di maiuscole e minuscole dipendono dalla versione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on the <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</source>
          <target state="translated">In .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> eseguono il <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> sistema operativo, ordinamento, maiuscole e minuscole, la normalizzazione e le informazioni dei caratteri Unicode conforme allo standard Unicode 6.0.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On other operating systems, it conforms to the Unicode 5.0 standard.</source>
          <target state="translated">In altri sistemi operativi, è conforme allo standard Unicode 5.0.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about word, string, and ordinal sort rules, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> topic.</source>
          <target state="translated">Per ulteriori informazioni sulle regole di ordinamento ordinali, stringa e word, vedere il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> argomento.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional recommendations on when to use each rule, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per ulteriori indicazioni su quando utilizzare ogni regola, vedere <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinarily, you don't call string comparison methods such as <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> directly to determine the sort order of strings.</source>
          <target state="translated">In genere, non chiamare stringa metodi di confronto come <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> direttamente per determinare l'ordinamento delle stringhe.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead, comparison methods are called by sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Al contrario, i metodi di confronto vengono chiamati i metodi di ordinamento, ad esempio <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</source>
          <target state="translated">Nell'esempio seguente esegue quattro diverse le operazioni di ordinamento (ordinamento word utilizzando le impostazioni cultura correnti, ordinamento word usando la lingua inglese, ordinamento ordinali e ordinamento delle stringhe utilizzando la lingua inglese) senza chiamare in modo esplicito un metodo di confronto tra stringhe, sebbene specificano il tipo di confronto da utilizzare.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that each type of sort produces a unique ordering of strings in its array.</source>
          <target state="translated">Si noti che ogni tipo di ordinamento produce un ordinamento univoco delle stringhe nella matrice.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</source>
          <target state="translated">Internamente,.NET Framework Usa chiavi di ordinamento per supportare il confronto di stringhe culturallysensitive.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</source>
          <target state="translated">Ogni carattere in una stringa viene assegnato a varie categorie di ordinamenti, inclusi i caratteri alfabetici, case e segni diacritici.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A sort key, represented by the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class, provides a repository of these weights for a particular string.</source>
          <target state="translated">Una chiave di ordinamento, rappresentato dalla <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> classe, fornisce un repository di questi fattori per una determinata stringa.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</source>
          <target state="translated">Se l'app esegue un numero elevato di ricerca o le operazioni nello stesso set di stringhe di ordinamento, è possibile migliorare le prestazioni tramite la generazione e l'archiviazione delle chiavi di ordinamento per tutte le stringhe che utilizza.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When a sort or comparison operation is required, you use the sort keys instead of the strings.</source>
          <target state="translated">Quando viene richiesta un'operazione di confronto o di ordinamento, utilizzare le chiavi di ordinamento anziché le stringhe.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class.</source>
          <target state="translated">Per altre informazioni, vedere la classe <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't specify a string comparison convention, sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> perform a culture-sensitive, case-sensitive sort on strings.</source>
          <target state="translated">Se non si specifica una convenzione di confronto di stringhe, ordinamento, ad esempio <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> eseguire un ordinamento con distinzione delle impostazioni cultura senza distinzione tra maiuscole e minuscole nelle stringhe.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates how changing the current culture affects the order of sorted strings in an array.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come modificare le impostazioni cultura correnti influisce sull'ordine di stringhe ordinate in una matrice.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates an array of three strings.</source>
          <target state="translated">Crea una matrice di tre stringhe.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>First, it sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to en-US and calls the <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Imposta innanzitutto il <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> proprietà en-US e chiamate di <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The resulting sort order is based on sorting conventions for the English (United States) culture.</source>
          <target state="translated">L'ordinamento risultante è basato su convenzioni di ordinamento per le impostazioni cultura inglese (Stati Uniti).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Next, the example sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to da-DK and calls the <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method again.</source>
          <target state="translated">Successivamente, nell'esempio viene impostato il <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> proprietà da-DK e chiamate di <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> nuovo metodo.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</source>
          <target state="translated">Si noti come l'ordinamento risultante differisce dai risultati en-US perché utilizza le convenzioni di ordinamento per il danese (Danimarca).</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your primary purpose in comparing strings is to determine whether they are equal, you should call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se lo scopo primario nel confronto tra stringhe consiste nel determinare se sono uguali, è necessario chiamare il <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, you should use <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> to perform an ordinal comparison.</source>
          <target state="translated">In genere, è consigliabile utilizzare <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> per eseguire un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method is intended primarily to sort strings.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> metodo è destinato principalmente per l'ordinamento delle stringhe.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons.</source>
          <target state="translated">Metodi di ricerca di stringhe, ad esempio <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, può inoltre effettuare confronti tra stringhe dipendenti dalle impostazioni cultura o per ordinale.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente vengono illustrate le differenze tra i confronti ordinali e delle impostazioni cultura utilizzando il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</source>
          <target state="translated">Una ricerca dipendente dalla lingua in cui le impostazioni cultura correnti sono quelle inglesi (Stati Uniti) considera la sottostringa "oe" in modo che corrisponda alla legatura "œ".</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> and finds a match at the beginning of the string.</source>
          <target state="translated">Poiché un segno meno facoltativo (U + 00AD) è un carattere a larghezza zero, la ricerca lo tratta come equivalente a <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> e trova una corrispondenza all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal search, on the other hand, does not find a match in either case.</source>
          <target state="translated">Una ricerca ordinale, d'altra parte, non viene trovata una corrispondenza in entrambi i casi.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Searching Strings</source>
          <target state="translated">Ricerca di stringhe</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</source>
          <target state="translated">Metodi di ricerca di stringhe, ad esempio <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, può inoltre effettuare distinzione delle impostazioni cultura o confronti di stringhe ordinali per determinare se un carattere o una sottostringa è presente in una stringa specificata.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The search methods in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class that search for an individual character, such as the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method, or one of a set of characters,   such as the <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, all perform an ordinal search.</source>
          <target state="translated">I metodi di ricerca nel <ph id="ph1">&lt;xref:System.String&gt;</ph> classe per l'individuazione di un singolo carattere, ad esempio il <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> , metodo o un set di caratteri, ad esempio il <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> (metodo), eseguire una ricerca ordinale.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform a culture-sensitive search for a character, you must call a <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> method such as <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura per un carattere, è necessario chiamare un <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> metodo, ad esempio <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</source>
          <target state="translated">Si noti che i risultati della ricerca di un carattere mediante il confronto ordinale e delle impostazioni cultura possono essere molto diversi.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</source>
          <target state="translated">Ad esempio, una ricerca di un carattere Unicode precomposto, ad esempio "æ" (U + 00 C 6) potrebbe corrispondere tutte le occorrenze dei relativi componenti nella sequenza corretta, ad esempio "AE" (U + 041U + 0045), a seconda delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> methods when searching for an individual character.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la differenza tra il <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> metodi per la ricerca di un singolo carattere.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</source>
          <target state="translated">Alfabeto "æ" (U + 00E6) viene trovato nella stringa "aereo" quando si utilizza le convenzioni delle impostazioni cultura en-US, ma non quando si usano le convenzioni delle impostazioni cultura da-DK o quando si esegue un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, <ph id="ph1">&lt;xref:System.String&gt;</ph> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</source>
          <target state="translated">D'altra parte, <ph id="ph1">&lt;xref:System.String&gt;</ph> metodi che eseguono la ricerca per una stringa anziché come un carattere eseguita una ricerca con distinzione delle impostazioni cultura, se le opzioni di ricerca non sono specificate in modo esplicito da un parametro di tipo della classe <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sole exception is <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, which performs an ordinal search.</source>
          <target state="translated">L'unica eccezione è <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, che esegue una ricerca ordinale.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing for equality</source>
          <target state="translated">La verifica dell'uguaglianza</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method to determine the relationship of two strings in the sort order.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> metodo per determinare la relazione tra due stringhe nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, this is a culture-sensitive operation.</source>
          <target state="translated">In genere si tratta di un'operazione con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method to test for equality.</source>
          <target state="translated">Chiamare invece il <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo per verificare l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</source>
          <target state="translated">Poiché il test di uguaglianza confronta in genere l'input dell'utente con alcune stringhe note, ad esempio un nome utente valido, una password o un percorso del file system, in genere è un'operazione ordinale.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is possible to test for equality by calling the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method and determining whether the return value is zero.</source>
          <target state="translated">È possibile verificare l'uguaglianza chiamando il <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> (metodo) e determinare se il valore restituito è zero.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, this practice is not recommended.</source>
          <target state="translated">Tuttavia, questa procedura non è consigliata.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To determine whether two strings are equal, you should call one of the overloads of the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per determinare se due stringhe sono uguali, è necessario chiamare uno degli overload di <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The preferred overload to call is either the instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method or the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, because both methods include a <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> parameter that explicitly specifies the type of comparison.</source>
          <target state="translated">L'overload preferito da chiamare è l'istanza <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> statica o metodo <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> metodo, perché entrambi i metodi includono un <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> parametro che specifichi esplicitamente il tipo di confronto.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il rischio di eseguire un confronto con distinzione delle impostazioni cultura per verificarne l'uguaglianza quando un numero ordinale deve essere utilizzato invece.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</source>
          <target state="translated">In questo caso, lo scopo del codice è impedire l'accesso al file system di URL che iniziano con "FILE://" o "file://" eseguendo un confronto senza distinzione dell'inizio di un URL con la stringa "FILE://".</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</source>
          <target state="translated">Tuttavia, se viene eseguito un confronto con distinzione delle impostazioni cultura utilizzando le impostazioni cultura Turco (Turchia) in un URL che inizia con "file://", il confronto di uguaglianza ha esito negativo, perché la lingua turca equivalente maiuscolo del carattere minuscolo "i" è "i" anziché "I".</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As a result, file system access is inadvertently permitted.</source>
          <target state="translated">Di conseguenza, è consentito inavvertitamente accesso al file system.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</source>
          <target state="translated">D'altra parte, se viene eseguito un confronto ordinale, il confronto di uguaglianza ha esito positivo e viene negato l'accesso al file system.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization</source>
          <target state="translated">Normalization</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some Unicode characters have multiple representations.</source>
          <target state="translated">Alcuni caratteri Unicode hanno più rappresentazioni.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">Uno dei punti di codice seguente, ad esempio, può rappresentare la lettera "ắ":</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+1EAF</source>
          <target state="translated">U+1EAF</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0103 U+0301</source>
          <target state="translated">U+0103 U+0301</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U+0061 U+0306 U+0301</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</source>
          <target state="translated">Più rappresentazioni di un singolo carattere complicano la ricerca, ordinamento, corrispondenza e altre operazioni sulle stringhe.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</source>
          <target state="translated">Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria di un carattere Unicode per le relative rappresentazioni binarie equivalenti.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization can use several algorithms, called normalization forms, that follow different rules.</source>
          <target state="translated">Normalizzazione è possibile utilizzare diversi algoritmi, denominati normalizzazione, che seguono regole diverse.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework supporta i formati di normalizzazione Unicode C, D, KC e KD.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">Quando le stringhe sono state normalizzate per lo stesso formato di normalizzazione, gli possono essere confrontati utilizzando il confronto ordinale.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects in each string.</source>
          <target state="translated">Un confronto ordinale è un confronto binario del valore scalare Unicode del corrispondente <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetti in ciascuna stringa.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes a number of methods that can perform an ordinal comparison, including the following:</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.String&gt;</ph> classe include una serie di metodi che è possibile eseguire un confronto ordinale, inclusi i seguenti:</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>,  <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> methods that includes a <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Un overload del <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, e <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodi che include un <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method performs an ordinal comparison if you supply a value of <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> for this parameter.</source>
          <target state="translated">Il metodo esegue un confronto ordinale, se si specifica un valore di <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> per questo parametro.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> method.</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that use ordinal comparison by default, such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Metodi che usano un confronto ordinale per impostazione predefinita, ad esempio <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that search for a <ph id="ph1">&lt;xref:System.Char&gt;</ph> value or for the elements in a <ph id="ph2">&lt;xref:System.Char&gt;</ph> array in a string instance.</source>
          <target state="translated">Metodi che cercano una <ph id="ph1">&lt;xref:System.Char&gt;</ph> valore o per gli elementi in un <ph id="ph2">&lt;xref:System.Char&gt;</ph> matrice in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such methods include <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</source>
          <target state="translated">Tali metodi includono <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> e <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can determine whether a string is normalized to normalization form C by calling the <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> method, or you can call the <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to determine whether a string is normalized to a specified normalization form.</source>
          <target state="translated">È possibile determinare se una stringa è normalizzata in formato di normalizzazione C chiamando il <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> metodo, altrimenti è possibile chiamare il <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> metodo per determinare se una stringa è normalizzata in un formato di normalizzazione specificato.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> method to convert a string to normalization form C, or you can call the <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to convert a string to a specified normalization form.</source>
          <target state="translated">È inoltre possibile chiamare il <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> metodo per convertire una stringa in formato di normalizzazione C oppure è possibile chiamare il <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> metodo per convertire una stringa in un formato di normalizzazione specificato.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For step-by-step information about normalizing and comparing strings, see the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> methods.</source>
          <target state="translated">Per informazioni dettagliate sulla normalizzazione e il confronto di stringhe, vedere il <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> e <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following simple example illustrates string normalization.</source>
          <target state="translated">L'esempio seguente viene illustrata la normalizzazione di stringa.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</source>
          <target state="translated">Definisce la lettera "ố" in tre modi diversi in tre diverse stringhe e utilizza un confronto ordinale per verificarne l'uguaglianza per determinare che ogni stringa differenze tra le due stringhe.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</source>
          <target state="translated">Converte quindi ogni stringa ai moduli supportati di normalizzazione e nuovamente esegue un confronto ordinale di ogni stringa in un formato di normalizzazione specificato.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In each case, the second test for equality shows that the strings are equal.</source>
          <target state="translated">In ogni caso, il secondo test per verificarne l'uguaglianza mostra che le stringhe sono uguali.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about normalization and normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, as well as <bpt id="p1">[</bpt>Unicode Standard Annex #15: Unicode Normalization Forms<ept id="p1">](http://unicode.org/reports/tr15/)</ept> and the <bpt id="p2">[</bpt>Normalization FAQ<ept id="p2">](http://www.unicode.org/faq/normalization.html)</ept> on the unicode.org website.</source>
          <target state="translated">Per ulteriori informazioni sulla normalizzazione e la normalizzazione, vedere <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, così come <bpt id="p1">[</bpt>Unicode Standard Annex #15: di normalizzazione Unicode<ept id="p1">](http://unicode.org/reports/tr15/)</ept> e <bpt id="p2">[</bpt>domande frequenti di normalizzazione<ept id="p2">](http://www.unicode.org/faq/normalization.html)</ept> di sito Web www.Unicode.org.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String operations by category</source>
          <target state="translated">Operazioni su stringhe per categoria</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String&gt;</ph> classe fornisce i membri per il confronto di stringhe, stringhe per verificarne l'uguaglianza di test, la ricerca di caratteri o sottostringhe in una stringa, la modifica di una stringa, l'estrazione di sottostringhe da una stringa, la combinazione di stringhe, la formattazione di valori, la copia di una stringa e normalizzazione di una stringa.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Comparing strings</source>
          <target state="translated">Confronto di stringhe</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can compare strings to determine their relative position in the sort order by using the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods:</source>
          <target state="translated">È possibile confrontare le stringhe per determinare la posizione relativa nell'ordinamento usando i seguenti <ph id="ph1">&lt;xref:System.String&gt;</ph> metodi:</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Restituisce un intero che indica la relazione tra una stringa di due stringhe nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> Restituisce un intero che indica la relazione tra una stringa in una stringa secondo basata su un confronto dei punti di codice.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Restituisce un intero che indica la relazione tra l'istanza corrente della stringa di due stringhe nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementations for the <ph id="ph4">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo fornisce il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> e <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementazioni per le <ph id="ph4">&lt;xref:System.String&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing strings for equality</source>
          <target state="translated">Test di uguaglianza delle stringhe</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method to determine whether two strings are equal.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo per determinare se due stringhe sono uguali.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> and the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</source>
          <target state="translated">L'istanza <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> e statica <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> overload consentono di specificare se il confronto è distinzione delle impostazioni cultura o per ordinale e se i case è considerato o ignorato.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</source>
          <target state="translated">La maggior parte dei test di uguaglianza sono ordinali e i confronti di uguaglianza che determinano l'accesso a una risorsa di sistema (ad esempio un oggetto file system) devono essere sempre ordinale.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Finding characters in a string</source>
          <target state="translated">Ricerca di caratteri in una stringa</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes two kinds of search methods:</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.String&gt;</ph> classe include due tipi di metodi di ricerca:</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that return a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> value to indicate whether a particular substring is present in a string instance.</source>
          <target state="translated">Metodi che restituiscono un <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> valore per indicare se una particolare sottostringa è presente in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> methods.</source>
          <target state="translated">Queste includono la <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that indicate the starting position of a substring in a string instance.</source>
          <target state="translated">Metodi che indicano la posizione iniziale di una sottostringa in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> methods.</source>
          <target state="translated">Queste includono la <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</source>
          <target state="translated">Se si desidera cercare una stringa per un modello specifico anziché una sottostringa specifica, utilizzare le espressioni regolari.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Espressioni regolari di .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Modifying a string</source>
          <target state="translated">Modifica di una stringa</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following methods that appear to modify the value of a string:</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.String&gt;</ph> classe include i metodi seguenti che vengono visualizzati per modificare il valore di una stringa:</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> inserts a string into the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> Inserisce una stringa in corrente <ph id="ph2">&lt;xref:System.String&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> inserts one or more occurrences of a specified character at the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Inserisce una o più occorrenze di un carattere specificato all'inizio di una stringa.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> inserts one or more occurrences of a specified character at the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Inserisce una o più occorrenze di un carattere specificato alla fine di una stringa.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> deletes a substring from the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> Elimina una sottostringa da corrente <ph id="ph2">&lt;xref:System.String&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> replaces a substring with another substring in the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> sostituisce una sottostringa con un'altra sottostringa nell'oggetto <ph id="ph2">&lt;xref:System.String&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> convert all the characters in a string to lowercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> convertire tutti i caratteri in una stringa in caratteri minuscoli.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> convert all the characters in a string to uppercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> convertire tutti i caratteri in una stringa in caratteri maiuscoli.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> removes all occurrences of a character from the beginning and end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> Rimuove tutte le occorrenze di un carattere di inizio e alla fine di una stringa.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> removes all occurrences of a character from the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> Rimuove tutte le occorrenze di un carattere dalla fine di una stringa.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> removes all occurrences of a character from the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Rimuove tutte le occorrenze di un carattere dall'inizio di una stringa.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All string modification methods return a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Tutti i metodi di modifica stringa restituiscono un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They don't modify the value of the current instance.</source>
          <target state="translated">Non modificare il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Extracting substrings from a string</source>
          <target state="translated">Estrazione di sottostringhe da una stringa</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method separates a single string into multiple strings.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> metodo suddivide una singola stringa in più stringhe.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</source>
          <target state="translated">Gli overload del metodo consentono di specificare più delimitatori per determinare il numero massimo di sottostringhe che il metodo estrae e per determinare se le stringhe vuote (che si verificano quando i delimitatori sono adiacenti) sono incluse tra le stringhe restituite.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Combining strings</source>
          <target state="translated">Stringhe di combinazione</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods can be used for string concatenation:</source>
          <target state="translated">Le operazioni seguenti <ph id="ph1">&lt;xref:System.String&gt;</ph> metodi possono essere utilizzati per la concatenazione di stringhe:</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> combines one or more substrings into a single string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Consente di combinare uno o più sottostringhe in una singola stringa.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> concatenates one or more substrings into a single element and adds a separator between each substring.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> Concatena una o più sottostringhe in un singolo elemento e aggiunge un separatore tra ogni sottostringa.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting values</source>
          <target state="translated">Formattazione di valori</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> metodo utilizza la funzionalità di formattazione composita per sostituire uno o più i segnaposto in una stringa con la rappresentazione di stringa di un oggetto o un valore.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is often used to do the following:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo viene spesso utilizzato per eseguire le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a numeric value in a string.</source>
          <target state="translated">Per incorporare la rappresentazione di stringa di un valore numerico in una stringa.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a date and time value in a string.</source>
          <target state="translated">Per incorporare la rappresentazione di stringa di un valore di data e ora in una stringa.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of an enumeration value in a string.</source>
          <target state="translated">Per incorporare la rappresentazione di stringa del valore di enumerazione in una stringa.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of some object that supports the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface in a string.</source>
          <target state="translated">Per incorporare la rappresentazione di stringa di un oggetto che supporta il <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interfaccia in una stringa.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To right-justify or left-justify a substring in a field within a larger string.</source>
          <target state="translated">Per giustificare a destra o giustificato a sinistra di una sottostringa in un campo all'interno di una stringa più grande.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about formatting operations and examples, see the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
          <target state="translated">Per informazioni dettagliate sulla formattazione di operazioni ed esempi, vedere il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload riepilogo.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Copying a string</source>
          <target state="translated">Copia di una stringa</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can call the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods to make a copy of a string:</source>
          <target state="translated">È possibile chiamare le operazioni seguenti <ph id="ph1">&lt;xref:System.String&gt;</ph> metodi per creare una copia di una stringa:</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> returns a reference to an existing <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> Restituisce un riferimento a un oggetto esistente <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> creates a copy of an existing string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> Crea una copia di una stringa esistente.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> copies a portion of a string to a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> copia una parte di una stringa in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalizing a string</source>
          <target state="translated">Normalizzazione di una stringa</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In Unicode, a single character can have multiple code points.</source>
          <target state="translated">In formato Unicode, un singolo carattere può avere più punti di codice.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization converts these equivalent characters into the same binary representation.</source>
          <target state="translated">Normalizzazione converte questi caratteri equivalenti in rappresentazione binaria stesso.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> method performs the normalization, and the <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> method determines whether a string is normalized.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> metodo esegue la normalizzazione e <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> metodo determina se una stringa è normalizzata.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information and an example, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section earlier in this topic.</source>
          <target state="translated">Per ulteriori informazioni e un esempio, vedere il <bpt id="p1">[</bpt>normalizzazione<ept id="p1">](#Normalization)</ept> in precedenza in questo argomento.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">Contenuto della sezione:</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Overloaded constructor syntax<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Sintassi del costruttore di overload<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Parameters<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Parametri<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Eccezioni<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Quale metodo si chiama?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Creating strings<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La creazione di stringhe<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Gestione delle stringhe ricorrenti<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Examples of instantiating strings:</source>
          <target state="translated">Esempi di stringhe di istanze:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using string assignment<ept id="p1">](#Ctor1_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzo dell'assegnazione di stringhe<ept id="p1">](#Ctor1_Example)</ept></target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a character array<ept id="p1">](#Ctor2_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzando una matrice di caratteri<ept id="p1">](#Ctor2_Example)</ept></target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a portion of a character array and repeating a single character<ept id="p1">](#Ctor3_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzando una parte di una matrice di caratteri e un singolo carattere di ripetizione<ept id="p1">](#Ctor3_Example)</ept></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a character array<ept id="p1">](#Ctor4_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzando un puntatore a una matrice di caratteri<ept id="p1">](#Ctor4_Example)</ept></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using  a pointer and a range of an array<ept id="p1">](#Ctor5_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzo di un puntatore e un intervallo di una matrice<ept id="p1">](#Ctor5_Example)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a signed byte array<ept id="p1">](#Ctor6_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzando un puntatore a una matrice di byte con segno<ept id="p1">](#Ctor6_Example)</ept></target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Version information<ept id="p1">](#Versions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Informazioni sulla versione<ept id="p1">](#Versions)</ept></target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloaded constructor syntax</source>
          <target state="translated">Sintassi del costruttore di overload</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</source>
          <target state="translated">Costruttori di stringa rientrano in due categorie: privi di parametri di puntatore, mentre quelle con i parametri di puntatore.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructors that use pointers are not CLS-compliant.</source>
          <target state="translated">I costruttori che utilizzano i puntatori non sono conformi a CLS.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</source>
          <target state="translated">Inoltre, Visual Basic non supporta l'utilizzo dei puntatori, e in c# il codice che utilizza i puntatori per eseguire in un contesto unsafe.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional guidance on choosing an overload, see <bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept></source>
          <target state="translated">Per informazioni aggiuntive sulla scelta di un overload, vedere <bpt id="p1">[</bpt>quale metodo chiamato?<ept id="p1">](#Tasks)</ept></target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters.</source>
          <target state="translated">Inizializza la nuova istanza sul valore indicato da una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This constructor copies Unicode characters(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>).</source>
          <target state="translated">Questo costruttore consente di copiare i caratteri Unicode (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor2_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">Inizializza la nuova istanza sul valore indicato da una matrice di caratteri Unicode, una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">Consente di inizializzare la nuova istanza per il valore indicata da uno specifico carattere Unicode ripetuto un numero precisato di volte (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</source>
          <target state="translated"><bpt id="p1">**</bpt>(Non conforme a CLS) <ept id="p1">**</ept> Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di caratteri Unicode che termina con un carattere null (U + 0000 o '\0').</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor4_Example)</ept>).</source>
          <target state="translated">(<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor4_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Autorizzazione: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Non conforme a CLS) <ept id="p1">**</ept> Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di caratteri Unicode, una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies the Unicode characters from <ph id="ph1">`value`</ph> starting at index <ph id="ph2">`startIndex`</ph> and ending at index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor5_Example)</ept>).</source>
          <target state="translated">Il costruttore di copia i caratteri Unicode da <ph id="ph1">`value`</ph> a partire dall'indice <ph id="ph2">`startIndex`</ph> e termina in corrispondenza dell'indice <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor5_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Autorizzazione: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Non conforme a CLS) <ept id="p1">**</ept> Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Si presuppone che la matrice rappresentano una stringa codificata utilizzando la tabella codici di sistema corrente (ovvero, la codifica specificata da <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from <ph id="ph1">`value`</ph> starting from the location specified by the pointer until a null character (0x00) is reached (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">Il costruttore elabora i caratteri <ph id="ph1">`value`</ph> a partire dalla posizione specificata dal puntatore fino a quando non viene raggiunto un carattere null (0x00) (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Autorizzazione: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Non conforme a CLS) <ept id="p1">**</ept> Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit, da una posizione inizia all'interno di tale matrice e da una lunghezza.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Si presuppone che la matrice rappresentano una stringa codificata utilizzando la tabella codici di sistema corrente (ovvero, la codifica specificata da <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from value starting at <ph id="ph1">`startIndex`</ph> and ending at <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">Il costruttore elabora i caratteri a partire valore <ph id="ph1">`startIndex`</ph> e fine <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Autorizzazione: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Non conforme a CLS) <ept id="p1">**</ept> Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit, una posizione iniziale all'interno della matrice, una lunghezza e un <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Autorizzazione: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameters</source>
          <target state="translated">Parametri</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that don't include a pointer parameter.</source>
          <target state="translated">Ecco un elenco completo dei parametri usati dalla <ph id="ph1">&lt;xref:System.String&gt;</ph> costruttori che non includono un parametro del puntatore.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Per i parametri utilizzati da ogni overload, vedere la sintassi di overload precedente.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">Parametro</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">Tipo</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An array of Unicode characters.</source>
          <target state="translated">Matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode character.</source>
          <target state="translated">Carattere Unicode.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The starting position in <ph id="ph1">`value`</ph> of the first character in the new string.</source>
          <target state="translated">La posizione iniziale nella <ph id="ph1">`value`</ph> del primo carattere nella stringa di nuovo.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">Il valore predefinito: 0</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of characters in <ph id="ph1">`value`</ph> to include in the new string.</source>
          <target state="translated">Il numero di caratteri in <ph id="ph1">`value`</ph> da includere nella nuova stringa.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Valore predefinito: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of times the character <ph id="ph1">`c`</ph> is repeated in the new string.</source>
          <target state="translated">Il numero di volte in cui il carattere <ph id="ph1">`c`</ph> viene ripetuta nella stringa di nuovo.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new object is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`count`</ph> è zero, il valore del nuovo oggetto è <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that include a pointer parameter.</source>
          <target state="translated">Ecco un elenco completo dei parametri usati dalla <ph id="ph1">&lt;xref:System.String&gt;</ph> costruttori che includono un parametro del puntatore.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Per i parametri utilizzati da ogni overload, vedere la sintassi di overload precedente.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">Parametro</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">Tipo</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</source>
          <target state="translated">Un puntatore a una matrice con terminazione null di caratteri Unicode o una matrice di interi con segno a 8 bit.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph> or an empty array, the value of the new string is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è <ph id="ph2">`null`</ph> o una matrice vuota, il valore della nuova stringa è <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The index of the array element that defines the first character in the new string.</source>
          <target state="translated">Indice dell'elemento della matrice che definisce il primo carattere nella stringa di nuovo.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">Il valore predefinito: 0</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of array elements to use to create the new string.</source>
          <target state="translated">Il numero di elementi della matrice da utilizzare per creare la nuova stringa.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If length is zero, the constructor creates a string whose value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se length è zero, il costruttore crea una stringa il cui valore è <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Valore predefinito: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An object that specifies how the <ph id="ph1">`value`</ph> array is encoded.</source>
          <target state="translated">Oggetto che specifica il modo in <ph id="ph1">`value`</ph> viene codificata.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, or the system's current ANSI code page</source>
          <target state="translated">Il valore predefinito: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, o tabella codici ANSI corrente del sistema</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exceptions</source>
          <target state="translated">Eccezioni</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that don't include pointer parameters.</source>
          <target state="translated">Di seguito è riportato un elenco delle eccezioni generate dai costruttori che non includono parametri di puntatore.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">Eccezione</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Condizione</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">Generata dal</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> è <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, or <ph id="ph3">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, o <ph id="ph3">`count`</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sum of <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> is greater than the number of elements in <ph id="ph3">`value`</ph>.</source>
          <target state="translated">la somma dei parametri <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> è maggiore del numero di elementi nel parametro <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`count`</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that include pointer parameters.</source>
          <target state="translated">Di seguito è riportato un elenco delle eccezioni generate dai costruttori che includono parametri di puntatore.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">Eccezione</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Condizione</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">Generata dal</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> specifies an array that contains an invalid Unicode character.</source>
          <target state="translated"><ph id="ph1">`value`</ph> Specifica una matrice che contiene un carattere Unicode non valido.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph> specifies an address that is less than 64K.</source>
          <target state="translated"><ph id="ph1">`value`</ph> o <ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> specifica un indirizzo minore di 64 K.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A new <ph id="ph1">&lt;xref:System.String&gt;</ph> instance could not be initialized from the <ph id="ph2">`value`</ph> byte array because <ph id="ph3">`value`</ph> does not use the default code page encoding.</source>
          <target state="translated">Un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> istanza potrebbe non essere inizializzata dal <ph id="ph2">`value`</ph> della matrice di byte perché <ph id="ph3">`value`</ph> non utilizza il codice codifica predefinita.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">Tutti i costruttori con puntatori.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is null.</source>
          <target state="translated"><ph id="ph1">`value`</ph> è null.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">Il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph> or <ph id="ph2">`length`</ph> is less than zero, <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> o <ph id="ph2">`length`</ph> è minore di zero, <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> causa un overflow del puntatore o il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The length of the new string is too large to allocate.</source>
          <target state="translated">La lunghezza della nuova stringa è troppo grande da allocare.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">Tutti i costruttori con puntatori.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph>, or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph><ph id="ph5"> + </ph><ph id="ph6">`length`</ph> – 1, specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">`value`</ph>, o <ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`length`</ph> – 1, specifica un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">Quale metodo si chiama?</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call or use</source>
          <target state="translated">Chiamata o utilizzo</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string.</source>
          <target state="translated">Creare una stringa.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Assignment from a string literal or an existing string (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor1_Example)</ept>)</source>
          <target state="translated">Assegnazione di un valore letterale stringa o una stringa esistente (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor1_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from an entire character array.</source>
          <target state="translated">Creare una stringa da un'intera matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor2_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Createa string from a portion of a character array.</source>
          <target state="translated">Crea un stringa da una parte di una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string that repeats the same character multiple times.</source>
          <target state="translated">Creare una stringa che si ripete di più volte lo stesso carattere.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>esempio<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a pointer to a Unicode or wide character array.</source>
          <target state="translated">Creare una stringa da un puntatore a una matrice di caratteri wide Unicode.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a portion of a Unicode or wide character array by using its pointer.</source>
          <target state="translated">Creare una stringa da una parte di una matrice di caratteri wide Unicode tramite il relativo puntatore.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a C++ <ph id="ph1">`char`</ph> array.</source>
          <target state="translated">Creare una stringa da C++ <ph id="ph1">`char`</ph> matrice.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from ASCII characters.</source>
          <target state="translated">Creare una stringa di caratteri ASCII.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Creating strings</source>
          <target state="translated">La creazione di stringhe</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in <bpt id="p1">[</bpt>this example<ept id="p1">](#Ctor1_Example)</ept>.</source>
          <target state="translated">Più diffuse tecnica per la creazione di stringhe a livello di codice è una semplice assegnazione, come illustrato nel <bpt id="p1">[</bpt>in questo esempio<ept id="p1">](#Ctor1_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class also includes four types of constructor overloads that let you create strings from the following values:</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.String&gt;</ph> classe include anche i quattro tipi di overload del costruttore che consentono di creare stringhe tra i valori seguenti:</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a character array (an array of UTF-16-encoded characters).</source>
          <target state="translated">Da una matrice di caratteri (una matrice di caratteri con codifica UTF-16).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from the characters in the entire array or a portion of it.</source>
          <target state="translated">È possibile creare un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto dai caratteri l'intera matrice o una parte di esso.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor copies all the characters in the array to the new string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> costruttore copia tutti i caratteri nella matrice per la nuova stringa.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor copies the characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 to the new string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttore copia i caratteri da indice <ph id="ph2">`startIndex`</ph> all'indice <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1 per la nuova stringa.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`length`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`length`</ph> è zero, il valore della nuova stringa è <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</source>
          <target state="translated">Se il codice crea ripetutamente le stringhe che presentano lo stesso valore, è possibile migliorare le prestazioni dell'applicazione utilizzando un metodo alternativo di creazione di stringhe.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>la gestione delle stringhe ricorrenti<ept id="p1">](#Repetitive)</ept>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a single character that is duplicated zero, one, or more times, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Da un singolo carattere che è duplicato zero, a una o più volte, tramite il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`count`</ph> è zero, il valore della nuova stringa è <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a null-terminated character array, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> or <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Da un puntatore a una matrice di caratteri con terminazione null, tramite il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> o <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">L'intera matrice o un intervallo specificato può essere utilizzato per inizializzare la stringa.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus <ph id="ph1">`startIndex`</ph> and continuing to the end of the array or for <ph id="ph2">`length`</ph> characters.</source>
          <target state="translated">Il costruttore di copia di una sequenza di caratteri Unicode a partire dal puntatore specificato o dal puntatore specificato più <ph id="ph1">`startIndex`</ph> e continuando fino alla fine della matrice o per <ph id="ph2">`length`</ph> caratteri.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is a null pointer or <ph id="ph2">`length`</ph> is zero, the constructor creates a string whose value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è un puntatore null o <ph id="ph2">`length`</ph> è zero, il costruttore crea una stringa il cui valore è <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</source>
          <target state="translated">Se l'operazione di copia continua alla fine della matrice e la matrice non è con terminazione null, il comportamento del costruttore è dipendente dal sistema.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such a condition might cause an access violation.</source>
          <target state="translated">Questa condizione potrebbe causare una violazione di accesso.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any embedded null characters (U+0000 or '\0') and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">Se la matrice contiene eventuali caratteri null incorporati (U + 0000 o '\0') e <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> l'overload del metodo, l'istanza di stringa contiene <ph id="ph2">`length`</ph> incorporati di caratteri, inclusi gli eventuali valori null.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente mostra cosa accade quando viene passato un puntatore a una matrice di 10 elementi che include due caratteri null per il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">Poiché l'indirizzo è l'inizio della matrice e devono essere aggiunti alla stringa di tutti gli elementi nella matrice, il costruttore crea un'istanza di una stringa con dieci caratteri, inclusi i due valori null incorporati.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">D'altra parte, se la stessa matrice viene passata la <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> costruttore, il risultato è una stringa di quattro caratteri che non include il primo carattere null.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array must contain Unicode characters.</source>
          <target state="translated">La matrice deve contenere caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In C++, this means that the character array must be defined either as the managed <ph id="ph1">&lt;xref:System.Char&gt;</ph>[] type or the unmanaged<ph id="ph2">`wchar_t`</ph>[] type.</source>
          <target state="translated">In C++, ciò significa che la matrice di caratteri deve essere definito come gestito <ph id="ph1">&lt;xref:System.Char&gt;</ph>tipo [] o non gestito<ph id="ph2">`wchar_t`</ph>tipo [].</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> overload is called and the array is not null-terminated, or if the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called and <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph>-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> l'overload del metodo e la matrice non è con terminazione null o se il <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> l'overload del metodo e <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph>-1 include un intervallo all'esterno della memoria allocata per la sequenza di caratteri, il comportamento del costruttore è dipendente dal sistema e potrebbe verificarsi una violazione di accesso.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, on the Intel Itanium processor, calls to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor may throw a <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> exception.</source>
          <target state="translated">Inoltre, sul processore Intel Itanium, le chiamate al <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttore potrebbe generare un <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> eccezione.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this occurs, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> instead.</source>
          <target state="translated">In questo caso, chiamare il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> invece.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a signed byte array.</source>
          <target state="translated">Da un puntatore a una matrice di byte con segno.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">L'intera matrice o un intervallo specificato può essere utilizzato per inizializzare la stringa.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</source>
          <target state="translated">La sequenza di byte può essere interpretata utilizzando la tabella codici predefinita di codifica, o una codifica può essere specificata nella chiamata al costruttore.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from <ph id="ph1">`value`</ph><ph id="ph2"> + </ph><ph id="ph3">`startIndex`</ph> to <ph id="ph4">`value`</ph><ph id="ph5"> + </ph><ph id="ph6">`startIndex`</ph><ph id="ph7"> + </ph><ph id="ph8">`length`</ph> -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">Se il costruttore tenta di creare un'istanza di una stringa da un'intera matrice che non è con terminazione null o se l'intervallo della matrice da <ph id="ph1">`value`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`startIndex`</ph> a <ph id="ph4">`value`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`startIndex`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`length`</ph> -1 è all'esterno della memoria allocata per la matrice, il comportamento di questo costruttore è dipendente dal sistema e potrebbe verificarsi una violazione di accesso.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ <ph id="ph1">`char`</ph> array to a string, as shown in this example:</source>
          <target state="translated">I tre costruttori che includono una matrice di byte con segno come un parametro sono progettati principalmente per convertire un C++ <ph id="ph1">`char`</ph> matrice in una stringa, come illustrato in questo esempio:</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any null characters ('\0') or bytes whose value is 0 and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">Se la matrice contiene caratteri null ('\0') o byte il cui valore è 0 e <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> l'overload del metodo, l'istanza di stringa contiene <ph id="ph2">`length`</ph> incorporati di caratteri, inclusi gli eventuali valori null.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente mostra cosa accade quando viene passato un puntatore a una matrice di 10 elementi che include due caratteri null per il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">Poiché l'indirizzo è l'inizio della matrice e devono essere aggiunti alla stringa di tutti gli elementi nella matrice, il costruttore crea un'istanza di una stringa con dieci caratteri, inclusi i due valori null incorporati.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">D'altra parte, se la stessa matrice viene passata la <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> costruttore, il risultato è una stringa di quattro caratteri che non include il primo carattere null.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructors interpret <ph id="ph3">`value`</ph> by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> e <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttori interpretano <ph id="ph3">`value`</ph> utilizzando la tabella codici ANSI predefinita, chiamare questi costruttori con matrici di byte identici possono creare le stringhe che presentano valori diversi in sistemi diversi.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Handling repetitive strings</source>
          <target state="translated">Gestione delle stringhe ricorrenti</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Apps that parse or decode streams of text often use the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to convert sequences of characters into a string.</source>
          <target state="translated">Le applicazioni che analizzano o decodificano flussi di testo spesso utilizzano il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttore o <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> metodo per convertire le sequenze di caratteri in una stringa.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</source>
          <target state="translated">Creazione di nuove stringhe più volte con lo stesso valore invece di creare e riutilizzare una stringa costituisce uno spreco di memoria.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are likely to create the same string value repeatedly by calling the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</source>
          <target state="translated">Se si è probabilmente di creare più volte lo stesso valore di stringa chiamando il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttore, anche se non si conosce anticipo quale potrebbero essere tali valori di stringa identica, è possibile usare invece una tabella di ricerca.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</source>
          <target state="translated">Si supponga, ad esempio, leggere e analizzare un flusso di caratteri da un file che contiene tag e attributi XML.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</source>
          <target state="translated">Quando si utilizza il flusso, si verifica ripetutamente determinati token (sequenze di caratteri che hanno un significato simbolico).</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</source>
          <target state="translated">Token equivalenti per le stringhe "0", "1", "true" e "false" è probabile che si verificano di frequente in un flusso XML.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead of converting each token into a new string, you can create a <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> object to hold commonly occurring strings.</source>
          <target state="translated">Anziché convertire ciascun token in una nuova stringa, è possibile creare un <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> oggetto per le stringhe che si ripetono frequentemente.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> object improves performance, because it retrieves stored strings without allocating temporary memory.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> oggetto migliora le prestazioni, poiché recupera le stringhe archiviate senza allocare memoria temporanea.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you encounter a token, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to retrieve the token from the table.</source>
          <target state="translated">Quando si verifica un token, utilizzare il <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> metodo per recuperare il token dalla tabella.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token exists, the method returns the corresponding string.</source>
          <target state="translated">Se il token esiste, il metodo restituisce la stringa corrispondente.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token does not exist, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to insert the token into the table and to get the corresponding string.</source>
          <target state="translated">Se il token non esiste, utilizzare il <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> metodo per inserire il token nella tabella e per ottenere la stringa corrispondente.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 1: Using string assignment</source>
          <target state="translated">Esempio 1: Utilizzo dell'assegnazione di stringhe</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a new string by assigning it a string literal.</source>
          <target state="translated">L'esempio seguente crea una nuova stringa mediante l'assegnazione di un valore letterale stringa.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates a second string by assigning the value of the first string to it.</source>
          <target state="translated">Crea una seconda stringa assegnandogli il valore della prima stringa.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These are the two most common ways to instantiate a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Questi sono i due modi più comuni per creare un'istanza di un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 2: Using a character array</source>
          <target state="translated">Esempio 2: Utilizzo di una matrice di caratteri</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a character array.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come creare un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto da una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 3: Using a portion of a character array and repeating a single character</source>
          <target state="translated">Esempio 3: Utilizzo di una parte di una matrice di caratteri e ripetizione di un singolo carattere</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a portion of a character array, and how to create a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains multiple occurrences of a single character.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come creare un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto da una parte di una matrice di caratteri e come creare un nuovo <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto che contiene più occorrenze di un singolo carattere.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 4: Using a pointer to a character array</source>
          <target state="translated">Esempio 4: Utilizzo di un puntatore a una matrice di caratteri</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a pointer to an array of characters.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come creare un nuovo <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto da un puntatore a una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled by using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">Nell'esempio c# debba essere compilata usando la <ph id="ph1">`/unsafe`</ph> opzione del compilatore.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 5: Instantiating a string from a pointer and a range of an array</source>
          <target state="translated">Esempio 5: Creazione di una stringa da un puntatore e un intervallo di una matrice</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example examines the elements of a character array for either a period or an exclamation point.</source>
          <target state="translated">Nell'esempio seguente vengono esaminati gli elementi di una matrice di caratteri per un punto o un punto esclamativo.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</source>
          <target state="translated">Se viene trovato uno, crea un'istanza di una stringa di caratteri nella matrice che precedono il simbolo di punteggiatura.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If not, it instantiates a string with the entire contents of the array.</source>
          <target state="translated">In caso contrario, viene creata un'istanza di una stringa con l'intero contenuto della matrice.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">Nell'esempio c# deve essere compilata usando la <ph id="ph1">`/unsafe`</ph> opzione del compilatore.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 6: Instantiating a string from a pointer to a signed byte array</source>
          <target state="translated">Esempio 6: Creazione di una stringa da un puntatore a una matrice di byte con segno</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how you can create an instance of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class with the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come è possibile creare un'istanza di <ph id="ph1">&lt;xref:System.String&gt;</ph> classe con il <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version information</source>
          <target state="translated">Informazioni sulla versione</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</source>
          <target state="translated">Tutti gli overload sono supportati in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework Client Profile</source>
          <target state="translated">.NET Framework Client Profile</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4, 3.5 SP1</source>
          <target state="translated">Tutti gli overload sono supportati in: 4, 3.5 SP1</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Portable Class Library</source>
          <target state="translated">Libreria di classi portabile</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported</source>
          <target state="translated">Tutti gli overload senza un <ph id="ph1">&lt;xref:System.SByte&gt;</ph> <ph id="ph2">`*`</ph> parametro sono supportati</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET for Windows Store apps</source>
          <target state="translated">.NET per applicazioni Windows Store</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported in: Windows 8</source>
          <target state="translated">Tutti gli overload senza un <ph id="ph1">&lt;xref:System.SByte&gt;</ph> <ph id="ph2">`*`</ph> parametro sono supportati in: Windows 8</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>A pointer to a null-terminated array of Unicode characters.</source>
          <target state="translated">Puntatore a una matrice con terminazione Null di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da uno specifico puntatore a una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">Il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifica una matrice che contiene un carattere Unicode non valido, oppure <ph id="ph2">&lt;paramref name="value" /&gt;</ph> specifica un indirizzo minore di 64000.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>An array of Unicode characters.</source>
          <target state="translated">Matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[])">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A pointer to a null-terminated array of 8-bit signed integers.</source>
          <target state="translated">Puntatore a una matrice a terminazione Null di interi con segno a 8 bit.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">I numeri interi vengono interpretati in base alla codifica della tabella codici di sistema corrente, ovvero alla codifica specificata da <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">Non è stato possibile inizializzare una nuova istanza di <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> mediante <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, supponendo che <ph id="ph3">&lt;paramref name="value" /&gt;</ph> sia codificato in ANSI.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The length of the new string to initialize, which is determined by the null termination character of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, is too large to allocate.</source>
          <target state="translated">La lunghezza della nuova stringa da inizializzare, che è determinata dal carattere a terminazione Null del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, è troppo grande da allocare.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifica un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>A Unicode character.</source>
          <target state="translated">Carattere Unicode.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept> occurs.</source>
          <target state="translated">Numero di occorrenze di <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified Unicode character repeated a specified number of times.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da uno specifico carattere Unicode ripetuto un numero precisato di volte.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>A pointer to an array of Unicode characters.</source>
          <target state="translated">Puntatore a una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione iniziale all'interno di <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Numero di caratteri in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> da usare.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da uno specifico puntatore a una matrice di caratteri Unicode, da una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è minore di zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> causa un overflow del puntatore o il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifica una matrice che contiene un carattere Unicode non valido o <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> specifica un indirizzo minore di 64000.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters.</source>
          <target state="translated">Matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione iniziale all'interno di <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Numero di caratteri in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> da usare.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da una matrice di caratteri Unicode, da una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">la somma dei parametri <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi nel parametro <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Puntatore a una matrice di interi con segno a 8 bit.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">I numeri interi vengono interpretati in base alla codifica della tabella codici di sistema corrente, ovvero alla codifica specificata da <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione iniziale all'interno di <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Numero di caratteri in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> da usare.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da uno specifico puntatore a una matrice di interi con segno a 8 bit, da una posizione iniziale all'interno di tale matrice e da una lunghezza.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated">L'indirizzo specificato da <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è troppo grande per la piattaforma corrente, ovvero il calcolo dell'indirizzo ha causato un overflow.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">La lunghezza della nuova stringa da inizializzare è troppo grande da allocare.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated">L'indirizzo specificato da <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è minore di 64 K.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">Non è stato possibile inizializzare una nuova istanza di <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> mediante <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, supponendo che <ph id="ph3">&lt;paramref name="value" /&gt;</ph> sia codificato in ANSI.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph3">&lt;paramref name="length" /&gt;</ph> specificano collettivamente un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Puntatore a una matrice di interi con segno a 8 bit.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione iniziale all'interno di <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Numero di caratteri in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> da usare.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>An object that specifies how the array referenced by <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> is encoded.</source>
          <target state="translated">Oggetto che specifica la modalità di codifica della matrice a cui fa riferimento <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ANSI encoding is assumed.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verrà usata la codifica ANSI.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> sul valore indicato da uno specifico puntatore a una matrice di interi con segno a 8 bit, da una posizione iniziale all'interno di tale matrice e da un oggetto <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Per esempi e informazioni complete sull'utilizzo per questo e altri <ph id="ph1">`String`</ph> overload del costruttore, vedere il <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> costruttore riepilogo.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated">L'indirizzo specificato da <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è troppo grande per la piattaforma corrente, ovvero il calcolo dell'indirizzo ha causato un overflow.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">La lunghezza della nuova stringa da inizializzare è troppo grande da allocare.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated">L'indirizzo specificato da <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è minore di 64 K.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded as specified by <ph id="ph4">&lt;paramref name="enc" /&gt;</ph>.</source>
          <target state="translated">non è stato possibile inizializzare una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> mediante il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, supponendo che il parametro <ph id="ph3">&lt;paramref name="value" /&gt;</ph> sia codificato secondo quanto specificato nel parametro <ph id="ph4">&lt;paramref name="enc" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph3">&lt;paramref name="length" /&gt;</ph> specificano collettivamente un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>A position in the current string.</source>
          <target state="translated">Posizione nella stringa corrente.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> object at a specified position in the current <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Ottiene l'oggetto <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> in una posizione specificata dell'oggetto <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The object at position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</source>
          <target state="translated">Oggetto in corrispondenza della posizione <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The <ph id="ph1">`index`</ph> parameter is zero-based.</source>
          <target state="translated">Il <ph id="ph1">`index`</ph> in base zero.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>This property returns the <ph id="ph1">&lt;xref:System.Char&gt;</ph> object at the position specified by the <ph id="ph2">`index`</ph> parameter.</source>
          <target state="translated">Questa proprietà restituisce il <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto in corrispondenza della posizione specificata dal <ph id="ph2">`index`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>However, a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Tuttavia, un carattere Unicode può essere rappresentato da più <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with Unicode characters instead of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> classe per funzionare con Unicode caratteri anziché <ph id="ph2">&lt;xref:System.Char&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>For more information, see the "Char Objects and Unicode Characters" section in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class overview.</source>
          <target state="translated">Per ulteriori informazioni, vedere la sezione "Char oggetti e i caratteri Unicode" il <ph id="ph1">&lt;xref:System.String&gt;</ph> Cenni preliminari sulla classe.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In C#, the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is an indexer.</source>
          <target state="translated">In c#, la <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> proprietà è un indicizzatore.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In Visual Basic, it is the default property of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">In Visual Basic la proprietà predefinita è la <ph id="ph1">&lt;xref:System.String&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string can be accessed by using code such as the following.</source>
          <target state="translated">Ogni <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto nella stringa è possibile accedere usando codice simile al seguente.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The following example demonstrates how you can use this indexer in a routine to validate a string.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come è possibile utilizzare l'indicizzatore in una routine per convalidare una stringa.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than or equal to the length of this object or less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è maggiore o uguale alla lunghezza dell'oggetto o minore di zero.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>Returns a reference to this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Restituisce un riferimento a questa istanza della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>This instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Questa istanza di <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>The return value is not an independent copy of this instance; it is simply another view of the same data.</source>
          <target state="translated">Il valore restituito non è una copia indipendente di questa istanza. è semplicemente un'altra visualizzazione degli stessi dati.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> method to create a separate <ph id="ph3">&lt;xref:System.String&gt;</ph> object with the same value as this instance.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> metodo per creare un apposito <ph id="ph3">&lt;xref:System.String&gt;</ph> oggetto con lo stesso valore di questa istanza.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> method simply returns the existing string instance, there is little reason to call it directly.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> metodo restituisce semplicemente l'istanza di stringa esistente, è necessario chiamarlo direttamente.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">Tutti gli overload del metodo <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> restituiscono un intero con segno a 32 bit che indica la relazione lessicale tra i due termini del confronto.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Value</source>
          <target state="translated">Valore</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Condizione</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Less than zero</source>
          <target state="translated">Minore di zero</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring precedes the second substring in the sort order.</source>
          <target state="translated">La prima sottostringa precede la seconda sottostringa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Zero</source>
          <target state="translated">Zero</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">`length`</ph> is zero.</source>
          <target state="translated">Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <ph id="ph1">`length`</ph> è zero.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Greater than zero</source>
          <target state="translated">Maggiore di zero</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring follows the second substring in the sort order.</source>
          <target state="translated">La prima sottostringa segue la seconda sottostringa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Whenever possible, you should call an overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Quando possibile, è necessario chiamare un overload di <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo che include un <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept> (Procedure consigliate per l'uso di stringhe).</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">Prima stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">Seconda stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> si trova nella stessa posizione di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Il confronto viene eseguito utilizzando le regole di ordinamento di word.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Quando si confrontano stringhe, è necessario chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept> (Procedure consigliate per l'uso di stringhe).</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to compare three sets of strings.</source>
          <target state="translated">L'esempio seguente chiama il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> metodo per confrontare tre set di stringhe.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>In the following example, the <ph id="ph1">`ReverseStringComparer`</ph> class demonstrates how you can evaluate two strings with the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">`ReverseStringComparer`</ph> classe illustra come è possibile valutare due stringhe con il <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Ad esempio, se il codice seguente viene eseguito il <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, un confronto con distinzione delle impostazioni cultura di "animale" con "ani posta" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamare il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> metodo e fornire un valore di <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph4">`comparisonType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The first string to compare.</source>
          <target state="translated">Prima stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The second string to compare.</source>
          <target state="translated">Seconda stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> si trova nella stessa posizione di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Il confronto viene eseguito utilizzando le regole di ordinamento di word.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Quando si confrontano stringhe, è necessario chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept> (Procedure consigliate per l'uso di stringhe).</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The following example demonstrates that the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> method is equivalent to using <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> when comparing strings.</source>
          <target state="translated">Nell'esempio seguente viene dimostrato che la <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> metodo equivale all'utilizzo <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> durante il confronto di stringhe.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Ad esempio, se il codice seguente viene eseguito il <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, un confronto con distinzione delle impostazioni cultura, distinzione tra maiuscole e di "animale" con "Ani posta" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamare il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> metodo e fornire un valore di <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The first string to compare.</source>
          <target state="translated">Prima stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The second string to compare.</source>
          <target state="translated">Seconda stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole da usare per il confronto.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati usando le regole specificate e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> si trova nella stessa posizione di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra i termini di confronto o utilizzare word (impostazioni cultura) o le regole di ordinamento (senza distinzione delle impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The following example compares three versions of the letter "I".</source>
          <target state="translated">Nell'esempio seguente vengono confrontati tre versioni della lettera "I".</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">I risultati sono interessati dalla scelta di impostazioni cultura, se è ignorare maiuscole/minuscole e se viene eseguito un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, specificare un valore di <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to compare.</source>
          <target state="translated">Prima stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to compare.</source>
          <target state="translated">Seconda stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole e usando le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> si trova nella stessa posizione di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Nel confronto viene utilizzato il <ph id="ph1">`culture`</ph> parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Il confronto viene eseguito utilizzando le regole di ordinamento di word.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example demonstrates how culture can affect a comparison.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come impostazioni cultura possono influire su un confronto.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</source>
          <target state="translated">In ceco - impostazioni cultura Repubblica ceca, "ch" è un singolo carattere che è maggiore di "d".</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</source>
          <target state="translated">Tuttavia, in inglese - impostazioni cultura di Stati Uniti, "ch" è costituito da due caratteri e "c" è minore di "d".</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</source>
          <target state="translated">Ad esempio, se il codice seguente viene eseguito nel <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, un confronto senza distinzione di "animale" con "Ani posta" (con un segno meno facoltativo o U + 00AD) utilizzando la lingua delle impostazioni cultura indica che le due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamare il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> metodo e fornire un valore di <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to compare.</source>
          <target state="translated">Prima stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to compare.</source>
          <target state="translated">Seconda stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The culture that supplies culture-specific comparison information.</source>
          <target state="translated">Impostazioni cultura che forniscono informazioni di confronto specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">Opzioni da usare durante l'esecuzione del confronto (ad esempio, per ignorare la distinzione tra maiuscole e minuscole o i simboli).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati, usando le opzioni di confronto specificate e le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che indica la relazione reciproca tra le due stringhe nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>A 32-bit signed integer that indicates the lexical relationship between <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>, as shown in the following table</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> e <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>, come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> si trova nella stessa posizione di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">Nel confronto viene utilizzato il <ph id="ph1">`culture`</ph> parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare determinate impostazioni cultura che alcune combinazioni di caratteri siano considerate come un singolo carattere, che i caratteri maiuscoli e minuscoli essere confrontati in modo specifico, o che varia a seconda dell'ordinamento di un carattere i caratteri che è preceduto o seguito.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> metodo è progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti (ovvero, quando lo scopo della chiamata al metodo consiste nel verificare la presenza di un valore restituito pari a zero).</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Per determinare se due stringhe sono equivalenti, chiamare il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration.</source>
          <target state="translated">Il confronto può essere ulteriormente specificato mediante il <ph id="ph1">`options`</ph> parametro, che è costituito da uno o più membri del <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">Tuttavia, poiché lo scopo di questo metodo è eseguire un confronto tra stringhe con distinzione delle impostazioni cultura, il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> valori non hanno alcun effetto.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, qualsiasi stringa, inclusi <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, risulta maggiore di un riferimento null e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con i caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</source>
          <target state="translated">Nell'esempio seguente vengono confrontate due stringhe in tre modi diversi: utilizzando il confronto linguistico per le impostazioni cultura en-US; tramite il confronto tra maiuscole e minuscole linguistico per le impostazioni cultura en-US; e l'utilizzo di un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It illustrates how the three methods of comparison produce three different results.</source>
          <target state="translated">Viene illustrato come i tre metodi di confronto producano tre risultati diversi.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, specificare un valore di <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Prima stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Seconda stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta le sottostringhe di due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati e restituisce un intero che indica la relativa posizione nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini del confronto.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Avviare le sottostringhe da confrontare in <ph id="ph1">`strA`</ph> in <ph id="ph2">`indexA`</ph> e <ph id="ph3">`strB`</ph> in <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">Entrambi <ph id="ph1">`indexA`</ph> e <ph id="ph2">`indexB`</ph> sono in base zero, ovvero il primo carattere in <ph id="ph3">`strA`</ph> e <ph id="ph4">`strB`</ph> alla posizione zero.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">La lunghezza della prima sottostringa è uguale alla lunghezza di <ph id="ph1">`strA`</ph> meno <ph id="ph2">`indexA`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">La lunghezza della seconda sottostringa è uguale alla lunghezza di <ph id="ph1">`strB`</ph> meno <ph id="ph2">`indexB`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Il <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, e <ph id="ph3">`length`</ph> i parametri devono essere non negativi.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Il confronto viene eseguito utilizzando le regole di ordinamento di word.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Quando si confrontano stringhe, è necessario chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept> (Procedure consigliate per l'uso di stringhe).</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The following example compares two substrings.</source>
          <target state="translated">Nell'esempio seguente confronta le sottostringhe di due.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> o <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, chiamare il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo e fornire un valore <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Prima stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Seconda stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta le sottostringhe di due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Avviare le sottostringhe da confrontare in <ph id="ph1">`strA`</ph> in <ph id="ph2">`indexA`</ph>e in <ph id="ph3">`strB`</ph> in <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">Entrambi <ph id="ph1">`indexA`</ph> e <ph id="ph2">`indexB`</ph> sono in base zero, ovvero il primo carattere in <ph id="ph3">`strA`</ph> e <ph id="ph4">`strB`</ph> alla posizione zero.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">La lunghezza della prima sottostringa è uguale alla lunghezza di <ph id="ph1">`strA`</ph> meno <ph id="ph2">`indexA`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">La lunghezza della seconda sottostringa è uguale alla lunghezza di <ph id="ph1">`strB`</ph> meno <ph id="ph2">`indexB`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Il <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, e <ph id="ph3">`length`</ph> i parametri devono essere non negativi.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Il confronto viene eseguito utilizzando le regole di ordinamento di word.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Quando si confrontano stringhe, è necessario chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept> (Procedure consigliate per l'uso di stringhe).</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The path name needs to be compared in an invariant manner.</source>
          <target state="translated">Il nome del percorso deve essere confrontato in modo invariante.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The correct code to do this is as follows.</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è come indicato di seguito.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The following example performs two comparisons of two substrings that only differ in case.</source>
          <target state="translated">Nell'esempio seguente esegue due confronti fra due sottostringhe che differiscono solo nel caso.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first comparison ignores case and the second comparison considers case.</source>
          <target state="translated">Ignora il primo confronto e il confronto secondo considera caso.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> o <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, chiamare il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo e fornire un valore <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Prima stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Seconda stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole da usare per il confronto.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta sottostringhe di due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati usando le regole specificate e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or the <ph id="ph3">&lt;paramref name="length" /&gt;</ph> parameter is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure il parametro <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follllows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue la sottostringa in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Avviare le sottostringhe da confrontare in <ph id="ph1">`strA`</ph> in <ph id="ph2">`indexA`</ph> e <ph id="ph3">`strB`</ph> in <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">Entrambi <ph id="ph1">`indexA`</ph> e <ph id="ph2">`indexB`</ph> sono in base zero, ovvero il primo carattere in <ph id="ph3">`strA`</ph> e <ph id="ph4">`strB`</ph> si trova nella posizione zero, non nella posizione uno.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">La lunghezza della prima sottostringa è uguale alla lunghezza di <ph id="ph1">`strA`</ph> meno <ph id="ph2">`indexA`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">La lunghezza della seconda sottostringa è uguale alla lunghezza di <ph id="ph1">`strB`</ph> meno <ph id="ph2">`indexB`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Il <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, e <ph id="ph3">`length`</ph> i parametri devono essere non negativi.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra i termini di confronto o utilizzare word (impostazioni cultura) o le regole di ordinamento (senza distinzione delle impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following example compares two substrings.</source>
          <target state="translated">Nell'esempio seguente confronta le sottostringhe di due.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> o <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, specificare un valore di <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Prima stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Seconda stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Confronta le sottostringhe di due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole e usando le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Avviare le sottostringhe da confrontare in <ph id="ph1">`strA`</ph> in <ph id="ph2">`indexA`</ph>e in <ph id="ph3">`strB`</ph> in <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">Entrambi <ph id="ph1">`indexA`</ph> e <ph id="ph2">`indexB`</ph> sono in base zero, ovvero il primo carattere in <ph id="ph3">`strA`</ph> e <ph id="ph4">`strB`</ph> si trova nella posizione zero, non nella posizione uno.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">La lunghezza della prima sottostringa è uguale alla lunghezza di <ph id="ph1">`strA`</ph> meno <ph id="ph2">`indexA`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">La lunghezza della seconda sottostringa è uguale alla lunghezza di <ph id="ph1">`strB`</ph> meno <ph id="ph2">`indexB`</ph> più uno.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Il <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, e <ph id="ph3">`length`</ph> i parametri devono essere non negativi.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Nel confronto viene utilizzato il <ph id="ph1">`culture`</ph> parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Il confronto viene eseguito utilizzando le regole di ordinamento di word.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Uno o entrambi i termini di confronto possono essere <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Confrontare il nome del percorso "file" mediante un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Il codice corretto per eseguire questa operazione è il seguente:</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example compares two substrings using different cultures and ignoring the case of the substrings.</source>
          <target state="translated">L'esempio seguente confronta le sottostringhe di due usando diverse impostazioni cultura e ignorare la distinzione tra delle sottostringhe.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The choice of culture affects how the letter "I" is compared.</source>
          <target state="translated">La scelta della lingua influisce sul modo in cui la lettera "I" viene confrontato.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> o <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, chiamare il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> metodo e fornire un valore <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Prima stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione iniziale della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Seconda stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Posizione iniziale della sottostringa all'interno di <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">Opzioni da usare durante l'esecuzione del confronto (ad esempio, per ignorare la distinzione tra maiuscole e minuscole o i simboli).</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</source>
          <target state="translated">Confronta le sottostringhe di due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati, usando le opzioni di confronto specificate e le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che indica la relazione reciproca tra le due sottostringhe nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</source>
          <target state="translated">Intero che indica la relazione lessicale tra le due sottostringhe, come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precede la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> segue la sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at position <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at position <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Avviare le sottostringhe da confrontare in <ph id="ph1">`strA`</ph> posizione <ph id="ph2">`indexA`</ph> e <ph id="ph3">`strB`</ph> nella posizione <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the first substring is the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph>.</source>
          <target state="translated">La lunghezza della prima sottostringa è la lunghezza di <ph id="ph1">`strA`</ph> meno <ph id="ph2">`indexA`</ph>.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the second substring is the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph>.</source>
          <target state="translated">La lunghezza della seconda sottostringa è la lunghezza di <ph id="ph1">`strB`</ph> meno <ph id="ph2">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Il <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, e <ph id="ph3">`length`</ph> i parametri devono essere non negativi.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">Nel confronto viene utilizzato il <ph id="ph1">`culture`</ph> parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Ad esempio, possibile specificare determinate impostazioni cultura che alcune combinazioni di caratteri siano considerate come un singolo carattere, che i caratteri maiuscoli e minuscoli essere confrontati in modo specifico, o che varia a seconda dell'ordinamento di un carattere i caratteri che è preceduto o seguito.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> metodo è progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se le due sottostringhe sono equivalenti (ovvero, quando lo scopo della chiamata al metodo consiste nel verificare la presenza di un valore restituito pari a zero).</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Per determinare se due stringhe sono equivalenti, chiamare il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>One or both of <ph id="ph1">`strA`</ph> and <ph id="ph2">`strB`</ph> can be <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Uno o entrambi <ph id="ph1">`strA`</ph> e <ph id="ph2">`strB`</ph> può essere <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">Per definizione, qualsiasi stringa, inclusi <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, risulta maggiore di un riferimento null e due riferimenti null risultano uguali tra loro.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Il confronto può essere ulteriormente specificato mediante il <ph id="ph1">`options`</ph> parametro, che è costituito da uno o più membri del <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">Tuttavia, poiché lo scopo di questo metodo è eseguire un confronto tra stringhe con distinzione delle impostazioni cultura, il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> valori non hanno alcun effetto.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con i caratteri rimanenti è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Il valore restituito è il risultato dell'ultimo confronto eseguito.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method to compare the last names of two people.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> metodo per confrontare i cognomi di due persone.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It then lists them in alphabetical order.</source>
          <target state="translated">Vengono quindi elencati in ordine alfabetico.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> o <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili il confronto, specificare un valore di <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> per il <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in base all'analisi dei valori numerici dei corrispondenti oggetti <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> in ciascuna stringa.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">Prima stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">Seconda stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">Confronta due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati in base all'analisi dei valori numerici dei corrispondenti oggetti <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> in ogni stringa.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> è minore di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> e <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> è maggiore di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">Questo metodo esegue un confronto tra maiuscole e minuscole usando le regole di ordinamento.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per eseguire un confronto tra maiuscole e minuscole usando le regole di ordinamento, chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> metodo con il <ph id="ph2">`comparisonType`</ph> argomento impostato su <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Poiché <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> è un metodo statico, <ph id="ph2">`strA`</ph> e <ph id="ph3">`strB`</ph> può essere <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">Se entrambi i valori sono <ph id="ph1">`null`</ph>, il metodo restituisce 0 (zero), che indica che <ph id="ph2">`strA`</ph> e <ph id="ph3">`strB`</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">Se solo uno dei valori è <ph id="ph1">`null`</ph>, il metodo considererà il valore non null devono essere maggiori.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The following example performs and ordinal comparison of two strings that only differ in case.</source>
          <target state="translated">Nell'esempio seguente viene eseguito e un confronto ordinale di due stringhe che differiscono solo per i casi.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Prima stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Indice iniziale della sottostringa di <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Seconda stringa da usare nel confronto.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Indice iniziale della sottostringa di <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each substring.</source>
          <target state="translated">Effettua il confronto fra sottostringhe di due determinati oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in base all'analisi dei valori numerici dei corrispondenti oggetti <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> in ogni sottostringa.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La lunghezza della sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> è minore della lunghezza della sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings are equal, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Le sottostringhe sono uguali o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> La lunghezza della sottostringa di <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> è maggiore della lunghezza della sottostringa di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Il <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, e <ph id="ph3">`length`</ph> i parametri devono essere non negativi.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters compared is the lesser of the length of <ph id="ph1">`strA`</ph> less <ph id="ph2">`indexA`</ph>, the length of <ph id="ph3">`strB`</ph> less <ph id="ph4">`indexB`</ph>, and <ph id="ph5">`length`</ph>.</source>
          <target state="translated">Il numero di caratteri confrontato sia il valore minore della lunghezza di <ph id="ph1">`strA`</ph> meno <ph id="ph2">`indexA`</ph>, la lunghezza di <ph id="ph3">`strB`</ph> meno <ph id="ph4">`indexB`</ph>, e <ph id="ph5">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">Questo metodo esegue un confronto tra maiuscole e minuscole usando le regole di ordinamento.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per eseguire un confronto tra maiuscole e minuscole usando le regole di ordinamento, chiamare il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> metodo con il <ph id="ph2">`comparisonType`</ph> argomento impostato su <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Poiché <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> è un metodo statico, <ph id="ph2">`strA`</ph> e <ph id="ph3">`strB`</ph> può essere <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">Se entrambi i valori sono <ph id="ph1">`null`</ph>, il metodo restituisce 0 (zero), che indica che <ph id="ph2">`strA`</ph> e <ph id="ph3">`strB`</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">Se solo uno dei valori è <ph id="ph1">`null`</ph>, il metodo considererà il valore non null devono essere maggiori.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This following example demonstrates that <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> use different sort orders.</source>
          <target state="translated">Nell'esempio seguente viene dimostrato che <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> utilizzare diversi tipi di ordinamento.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> è maggiore di <ph id="ph4">&lt;paramref name="strA" /&gt;</ph><ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> è maggiore di <ph id="ph4">&lt;paramref name="strB" /&gt;</ph><ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares this instance with a specified object or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Confronta questa istanza con <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> o un oggetto specificato e restituisce un intero che indica se questa istanza precede, segue o si trova nella stessa posizione di <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> o dell'oggetto specificato nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both overloads of the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method perform culture-sensitive and case-sensitive comparison.</source>
          <target state="translated">Entrambi gli overload di <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> metodo eseguire confronto dipendenti dalle impostazioni cultura e tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You cannot use this method to perform culture-insensitive or ordinal comparisons.</source>
          <target state="translated">È possibile utilizzare questo metodo per eseguire confronti con distinzione delle impostazioni cultura o per ordinale.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For code clarity, we recommend that you avoid the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method and call the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method instead.</source>
          <target state="translated">Per maggiore chiarezza del codice, è consigliabile evitare il <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> metodo e chiamare il <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>An object that evaluates to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Oggetto che restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Confronta questa istanza con un oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e indica se questa istanza precede, segue o si trova nella stessa posizione dell'oggetto <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> specificato all'interno dell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Intero con segno a 32 bit che indica se questa istanza precede, segue o si trova nella stessa posizione del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Questa istanza precede <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Questa istanza si trova nella stessa posizione di <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L'istanza segue <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">`value`</ph> must be a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`value`</ph> deve essere un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> metodo è stato progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Per determinare se due stringhe sono equivalenti, chiamare il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni sul comportamento di questo metodo, vedere la sezione Note del <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Because it attempts to compare a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance to a <ph id="ph2">`TestClass`</ph> object, the method throws an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Perché tenta di confrontare un <ph id="ph1">&lt;xref:System.String&gt;</ph> istanza a un <ph id="ph2">`TestClass`</ph> dell'oggetto, il metodo genera un <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Ad esempio, se il codice seguente viene eseguito il <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, un confronto tra "animale" con "ani posta" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamare il <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>The string to compare with this instance.</source>
          <target state="translated">Stringa da confrontare con questa istanza.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</source>
          <target state="translated">Confronta questa istanza con un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificato e indica se questa istanza precede, segue o si trova nella stessa posizione della stringa specificata all'interno dei criteri di ordinamento.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> parameter.</source>
          <target state="translated">Intero con segno a 32 bit che indica se questa istanza precede, segue o si trova nella stessa posizione del parametro <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condizione</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Minore di zero</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Questa istanza precede <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Questa istanza si trova nella stessa posizione di <ph id="ph3">&lt;paramref name="strB" /&gt;</ph> nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maggiore di zero</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L'istanza segue <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> metodo è stato progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Per determinare se due stringhe sono equivalenti, chiamare il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni sul comportamento di questo metodo, vedere la sezione Note del <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, because it does not have to determine whether the <ph id="ph3">`strB`</ph> argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <ph id="ph4">&lt;xref:System.Object&gt;</ph> to a <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Questo metodo implementa il <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interfaccia ed esegue leggermente migliori rispetto di <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> metodo, perché non è necessario determinare se il <ph id="ph3">`strB`</ph> argomento è un tipo di valore modificabile che deve essere di tipo boxed e non deve eseguire il cast relativo parametro da un <ph id="ph4">&lt;xref:System.Object&gt;</ph> per un <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method to compare the current string instance with another string.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> metodo per confrontare l'istanza di stringa corrente con un'altra stringa.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</source>
          <target state="translated">Nell'esempio seguente vengono illustrate le versioni generiche e non generici del metodo CompareTo per vari tipi di valore e riferimento.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> metodo non prende in considerazione tali caratteri quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Ad esempio, se il codice seguente viene eseguito il <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, un confronto tra "animale" con "ani posta" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">Per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamare il <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates one or more instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, or the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> representations of the values of one or more instances of <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Concatena una o più istanze di <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> oppure le rappresentazioni <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> dei valori di una o più istanze di <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection object that implements <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> and whose generic type argument is <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Oggetto Collection che implementa <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> e il cui argomento di tipo generico è <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Concatena i membri di una raccolta <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> costruita di tipo <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The concatenated strings in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="values" /&gt;</ph> is an empty <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph>.</source>
          <target state="translated">Stringhe concatenate in <ph id="ph1">&lt;paramref name="values" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> se <ph id="ph3">&lt;paramref name="values" /&gt;</ph> è un oggetto <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph> vuoto.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena ogni oggetto in <ph id="ph1">`values`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>To specify a delimiter between each member of <ph id="ph1">`values`</ph>, call the <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Per specificare un delimitatore tra ogni membro di <ph id="ph1">`values`</ph>, chiamare il <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null element in <ph id="ph2">`values`</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> stringa viene utilizzata al posto di qualsiasi elemento null in <ph id="ph2">`values`</ph>.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is an empty <ph id="ph2">`IEnumerable(Of String)`</ph>, the method returns <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`values`</ph> è un oggetto vuoto <ph id="ph2">`IEnumerable(Of String)`</ph>, il metodo restituisce <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">Se <ph id="ph1">`values`</ph> è <ph id="ph2">`null`</ph>, il metodo genera un <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> eccezione.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> è un metodo pratico che consente di concatenare ogni elemento in un <ph id="ph2">`IEnumerable(Of String)`</ph> insieme senza prima di convertire gli elementi in una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">È particolarmente utile con le espressioni di query Language-Integrated Query (LINQ).</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">Nell'esempio seguente viene passato un <ph id="ph1">`List(Of String)`</ph> oggetto contenente le lettere maiuscole o minuscole dell'alfabeto in un'espressione lambda che consente di selezionare lettere uguale a o maggiore di una determinata lettera (ovvero, nell'esempio, "M").</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection that is returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated">Il <ph id="ph1">`IEnumerable(Of String)`</ph> raccolta restituita dal <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> viene passato per il <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> metodo per visualizzare il risultato come stringa singola.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Assegna il risultato a un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> oggetto di tipo <ph id="ph2">&lt;xref:System.String&gt;</ph>, che passa quindi il <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The object to represent, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto da rappresentare oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>Creates the string  representation of a specified object.</source>
          <target state="translated">Crea la rappresentazione di stringa di un oggetto specificato.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The string representation of the value of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Rappresentazione di stringa del valore di <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> oppure <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> se <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> è <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> method represents <ph id="ph2">`arg0`</ph> as a string by calling its parameterless <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> metodo rappresenta <ph id="ph2">`arg0`</ph> sotto forma di stringa chiamando il relativo senza parametri <ph id="ph3">`ToString`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>An object array that contains the elements to concatenate.</source>
          <target state="translated">Matrice di oggetti contenente gli elementi da concatenare.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Concatenates the string representations of the elements in a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">Concatena le rappresentazioni di stringa degli elementi in una matrice <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>The concatenated string representations of the values of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Rappresentazioni di stringa concatenate dei valori degli elementi di <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The method concatenates each object in <ph id="ph1">`args`</ph> by calling the parameterless <ph id="ph2">`ToString`</ph> method of that object; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena ogni oggetto in <ph id="ph1">`args`</ph> chiamando il metodo senza parametri <ph id="ph2">`ToString`</ph> metodo dell'oggetto; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> viene utilizzato al posto di qualsiasi oggetto null nella matrice.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo del <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Object&gt;</ph> matrice.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Out of memory.</source>
          <target state="translated">Memoria insufficiente.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>This method is not called by C++ code.</source>
          <target state="translated">Questo metodo non viene chiamato da codice C++.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The C++ compiler resolves calls to <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> that have four or more object parameters as a call to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Il compilatore C++ risolve le chiamate a <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> con quattro o più parametri dell'oggetto come una chiamata a <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>An array of string instances.</source>
          <target state="translated">Matrice di istanze di stringa.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Concatenates the elements of a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> array.</source>
          <target state="translated">Concatena gli elementi di una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>The concatenated elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated">Elementi concatenati del parametro <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena ogni oggetto in <ph id="ph1">`values`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> stringa viene utilizzata al posto di qualsiasi oggetto null nella matrice.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with a <ph id="ph2">&lt;xref:System.String&gt;</ph> array.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo del <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.String&gt;</ph> matrice.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Out of memory.</source>
          <target state="translated">Memoria insufficiente.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Primo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Secondo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>Concatenates the string representations of two specified objects.</source>
          <target state="translated">Concatena le rappresentazioni di stringa di due oggetti specificati.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Rappresentazioni di stringa concatenate dei valori di <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> e <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph> and <ph id="ph2">`arg1`</ph> by calling the parameterless <ph id="ph3">`ToString`</ph> method of <ph id="ph4">`arg0`</ph> and <ph id="ph5">`arg1`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena <ph id="ph1">`arg0`</ph> e <ph id="ph2">`arg1`</ph> chiamando il metodo senza parametri <ph id="ph3">`ToString`</ph> metodo <ph id="ph4">`arg0`</ph> e <ph id="ph5">`arg1`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> viene utilizzato al posto di qualsiasi argomento null.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</source>
          <target state="translated">Se uno degli argomenti è un riferimento a una matrice, il metodo consente di concatenare una stringa che rappresenta la matrice, anziché i relativi membri (ad esempio, "System.String[]").</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Prima stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Seconda stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>Concatenates two specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Concatena due istanze specificate della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</source>
          <target state="translated">Concatenazione dei parametri <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> e <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph> and <ph id="ph2">`str1`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena <ph id="ph1">`str0`</ph> e <ph id="ph2">`str1`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">È inoltre possibile utilizzare operatore di concatenazione di stringhe del linguaggio, ad esempio <ph id="ph1">`+`</ph> in c# o <ph id="ph2">`&amp;`</ph> e <ph id="ph3">`+`</ph> in Visual Basic)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, per concatenare stringhe.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> stringa viene utilizzata al posto di qualsiasi argomento null.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The following example concatenates a person's first, middle, and last name.</source>
          <target state="translated">Nell'esempio seguente consente di concatenare, intermedio, nome e cognome una persona.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Primo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Secondo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">Terzo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of three specified objects.</source>
          <target state="translated">Concatena le rappresentazioni di stringa di tre oggetti specificati.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Rappresentazioni di stringa concatenate dei valori di <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph> e <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, and <ph id="ph3">`arg2`</ph> by calling the parameterless <ph id="ph4">`ToString`</ph> method of each object; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, e <ph id="ph3">`arg2`</ph> chiamando il metodo senza parametri <ph id="ph4">`ToString`</ph> metodo di ciascun oggetto; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> viene utilizzato al posto di qualsiasi argomento null.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Prima stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Seconda stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">Terza stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>Concatenates three specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Concatena tre istanze specificate della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</source>
          <target state="translated">Concatenazione dei parametri <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph> e <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, and <ph id="ph3">`str2`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, e <ph id="ph3">`str2`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">È inoltre possibile utilizzare operatore di concatenazione di stringhe del linguaggio, ad esempio <ph id="ph1">`+`</ph> in c# o <ph id="ph2">`&amp;`</ph> e <ph id="ph3">`+`</ph> in Visual Basic)</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, per concatenare stringhe.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> stringa viene utilizzata al posto di qualsiasi argomento null.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method to concatenate three strings and displays the result.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> per concatenare tre stringhe e viene visualizzato il risultato.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Primo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Secondo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">Terzo oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The fourth object to concatenate.</source>
          <target state="translated">Quarto oggetto da concatenare.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</source>
          <target state="translated">Concatena le rappresentazioni di stringa di quattro oggetti specificati e di qualsiasi oggetto specificato in un elenco di parametri di lunghezza variabile facoltativo.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The concatenated string representation of each value in the parameter list.</source>
          <target state="translated">Rappresentazione di stringa concatenata di ogni valore nell'elenco dei parametri.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Questa API non è conforme a CLS.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The CLS-compliant alternative is <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternativa conforme a CLS è <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers automatically resolve a call to this method as a call to <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">I compilatori c# e Visual Basic Risolvi automaticamente una chiamata a questo metodo come una chiamata a <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method concatenates each object in the parameter list by calling its parameterless <ph id="ph1">`ToString`</ph> method; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena ogni oggetto nell'elenco dei parametri chiamando il relativo senza parametri <ph id="ph1">`ToString`</ph> metodo; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> viene utilizzato al posto di qualsiasi argomento null.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The last parameter of the  <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method is an optional comma-delimited list of one or more additional objects to concatenate.</source>
          <target state="translated">L'ultimo parametro del <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> metodo è un elenco facoltativo delimitato da virgole di uno o più oggetti aggiuntivi da concatenare.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to concatenate a list of variable parameters.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo del <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> per concatenare un elenco di parametri variabile.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>In this case, the method is called with nine parameters.</source>
          <target state="translated">In questo caso, il metodo viene chiamato con nove parametri.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This method is marked with the <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> keyword, which means that it supports a variable number of parameters.</source>
          <target state="translated">Questo metodo è contrassegnato con il <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> (parola chiave), il che significa che supporta un numero variabile di parametri.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</source>
          <target state="translated">Il metodo può essere chiamato da Visual C++, ma non può essere chiamato dal codice c# o Visual Basic.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers resolve calls to <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> as calls to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</source>
          <target state="translated">I compilatori c# e Visual Basic risolvere le chiamate ai <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> come chiamate a <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Prima stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Seconda stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">Terza stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The fourth string to concatenate.</source>
          <target state="translated">Quarta stringa da concatenare.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>Concatenates four specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Concatena quattro istanze specificate della classe <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</source>
          <target state="translated">Concatenazione dei parametri <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph> e <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, and <ph id="ph4">`str3`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, e <ph id="ph4">`str3`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">È inoltre possibile utilizzare operatore di concatenazione di stringhe del linguaggio, ad esempio <ph id="ph1">`+`</ph> in c# o <ph id="ph2">`&amp;`</ph> e <ph id="ph3">`+`</ph> in Visual Basic)</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, per concatenare stringhe.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> stringa viene utilizzata al posto di qualsiasi oggetto null nella matrice.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</source>
          <target state="translated">Nell'esempio seguente definisce una matrice di quattro – lettera parole e archivia le singole lettere di una matrice di stringhe per decodificate.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to reassemble the scrambled words.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> metodo riassemblare le singole parole.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo dei membri di <bpt id="p1">&lt;c&gt;</bpt>valori<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>A collection object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> interface.</source>
          <target state="translated">Oggetto Collection che implementa l'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> implementation.</source>
          <target state="translated">Concatena i membri di un'implementazione di <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The concatenated members in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated">Membri concatenati in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Il metodo concatena ogni oggetto in <ph id="ph1">`values`</ph>; non vengono aggiunti i delimitatori.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> stringa viene utilizzata al posto di qualsiasi argomento null.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting the elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> è un metodo pratico che consente di concatenare ogni elemento in un <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> insieme senza prima di convertire gli elementi in stringhe.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</source>
          <target state="translated">È particolarmente utile con espressioni di query Language-Integrated Query (LINQ), come illustrato nell'esempio.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">La rappresentazione di stringa di ogni oggetto di <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> raccolta derivata mediante la chiamata di tale oggetto <ph id="ph2">`ToString`</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The following example defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">L'esempio seguente definisce un semplice <ph id="ph1">`Animal`</ph> classe che contiene il nome di un animale e l'ordine a cui appartiene.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object to contain a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">Definisce quindi un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> oggetto deve contenere un numero di <ph id="ph2">`Animal`</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> viene chiamato il metodo di estensione per estrarre il <ph id="ph2">`Animal`</ph> oggetti la cui proprietà <ph id="ph3">`Order`</ph> proprietà è uguale a "Roditori".</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method and displayed to the console.</source>
          <target state="translated">Il risultato viene passato per il <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> metodo e visualizzato nella console.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>Returns a value indicating whether a specified substring occurs within this string.</source>
          <target state="translated">Restituisce un valore che indica se una sottostringa specificata è presente all'interno della stringa.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter occurs within this string, or if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is the empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente all'interno della stringa o se il parametro <ph id="ph3">&lt;paramref name="value" /&gt;</ph> è la stringa vuota (""); in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The search begins at the first character position of this string and continues through the last character position.</source>
          <target state="translated">La ricerca inizia in corrispondenza della posizione di carattere prima di questa stringa e continua fino all'ultima posizione di carattere.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</source>
          <target state="translated">Per determinare se una stringa contiene la sottostringa specificata con un valore diverso da un confronto ordinale (ad esempio, confronto con distinzione delle impostazioni cultura o un confronto ordinale tra maiuscole e minuscole), è possibile creare un metodo personalizzato.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example illustrates one such approach.</source>
          <target state="translated">Nell'esempio seguente viene illustrato un approccio.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>It defines a <ph id="ph1">&lt;xref:System.String&gt;</ph> extension method  that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</source>
          <target state="translated">Definisce un <ph id="ph1">&lt;xref:System.String&gt;</ph> metodo di estensione che include un <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parametro e indica se una stringa contiene una sottostringa quando si usa il modulo di confronto di stringhe specificato.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example then calls the <ph id="ph1">`Contains`</ph> extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</source>
          <target state="translated">Nell'esempio seguente viene chiamato il <ph id="ph1">`Contains`</ph> metodo di estensione per determinare se una sottostringa è presente in una stringa quando si utilizza un confronto ordinale e confronto ordinale tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If you are interested in the position of the substring <ph id="ph1">`value`</ph> in the current instance, you can call the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to get the starting position of its first occurrence, or you can call the <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to get the starting position of its last occurrence.</source>
          <target state="translated">Se si è interessati nella posizione della sottostringa <ph id="ph1">`value`</ph> nell'istanza corrente, è possibile chiamare il <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo per ottenere la posizione iniziale della prima occorrenza, oppure è possibile chiamare il <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo per ottenere l'avvio di posizione del relativo ultima occorrenza.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The example includes a call to the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method if a substring is found in a string instance.</source>
          <target state="translated">L'esempio include una chiamata al <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> metodo se viene trovata una sottostringa in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example determines whether the string "fox" is a substring of a familiar quotation.</source>
          <target state="translated">Nell'esempio seguente determina se la stringa "volpe" è una sottostringa di una frase.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If "fox" is found in the string, it also displays its starting position.</source>
          <target state="translated">Se viene trovati "volpe" nella stringa, vengono inoltre visualizzate la posizione iniziale.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>The string to copy.</source>
          <target state="translated">Stringa da copiare.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>Creates a new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> with the same value as a specified <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Crea una nuova istanza dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> con lo stesso valore di un'istanza dell'oggetto <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>A new string with the same value as <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">Nuova stringa con lo stesso valore di <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that has the same value as the original string but represents a different object reference.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> metodo restituisce un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto che ha lo stesso valore di stringa originale, ma rappresenta un riferimento a un oggetto diverso.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</source>
          <target state="translated">Differisce da un'operazione di assegnazione, che assegna un riferimento di stringa esistente a una variabile oggetto aggiuntive.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The example illustrates the difference.</source>
          <target state="translated">Nell'esempio viene illustrata la differenza.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The following example creates two string objects with different values.</source>
          <target state="translated">L'esempio seguente crea due oggetti stringa con valori diversi.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>When it calls the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</source>
          <target state="translated">Quando chiama il <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> metodo a cui assegnare il primo valore per la seconda stringa, l'output indica che le stringhe rappresentano riferimenti a oggetti diversi, anche se i valori ora sono uguali.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</source>
          <target state="translated">D'altra parte, quando la prima stringa è assegnata la seconda stringa, le due stringhe hanno valori identici in quanto rappresentano il riferimento all'oggetto stesso.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character in this instance to copy.</source>
          <target state="translated">Indice del primo carattere nell'istanza da copiare.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters to which characters in this instance are copied.</source>
          <target state="translated">Matrice di caratteri Unicode in cui vengono copiati i caratteri di questa istanza.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> at which the copy operation begins.</source>
          <target state="translated">Indice in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> in corrispondenza del quale inizia l'operazione di copia.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The number of characters in this instance to copy to <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Numero di caratteri dell'istanza da copiare in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</source>
          <target state="translated">Copia un numero definito di caratteri da una posizione specificata in questa istanza in una posizione specificata in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method copies <ph id="ph1">`count`</ph> characters from the <ph id="ph2">`sourceIndex`</ph> position of this instance to the <ph id="ph3">`destinationIndex`</ph> position of <ph id="ph4">`destination`</ph> character array.</source>
          <target state="translated">Questo metodo copia <ph id="ph1">`count`</ph> caratteri dal <ph id="ph2">`sourceIndex`</ph> posizione di questa istanza con il <ph id="ph3">`destinationIndex`</ph> posizione <ph id="ph4">`destination`</ph> matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method does not resize the <ph id="ph1">`destination`</ph> character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Questo metodo non viene ridimensionato il <ph id="ph1">`destination`</ph> matrice di caratteri; deve contenere un numero sufficiente di elementi per contenere i caratteri copiati o il metodo genera un <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">`sourceIndex`</ph> and <ph id="ph2">`destinationIndex`</ph> are zero-based.</source>
          <target state="translated"><ph id="ph1">`sourceIndex`</ph> e <ph id="ph2">`destinationIndex`</ph> sono a base zero.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="count" /&gt;</ph> is negative</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> o <ph id="ph3">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> does not identify a position in the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> non identifica una posizione nell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> does not identify a valid index in the <ph id="ph2">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> non identifica un indice valido nella matrice <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the substring from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of this instance</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza della sottostringa compresa fra l'indice specificato nel parametro <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> e la fine dell'istanza.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the subarray from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of the <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza della sottomatrice compresa fra il valore del parametro <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> e la fine della matrice <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>Represents the empty string.</source>
          <target state="translated">Rappresenta la stringa vuota.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>This field is read-only.</source>
          <target state="translated">Questo campo è di sola lettura.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>The value of this field is the zero-length string, "".</source>
          <target state="translated">Il valore di questo campo è la stringa di lunghezza zero, "".</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</source>
          <target state="translated">Nel codice dell'applicazione, questo campo viene utilizzato più di frequente nelle assegnazioni per inizializzare una variabile di stringa in una stringa vuota.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>To test whether the value of a string is either <ph id="ph1">`null`</ph> or <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, use the <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">Per verificare se il valore di una stringa può essere <ph id="ph1">`null`</ph> o <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, utilizzare il <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the end of this string instance matches a specified string.</source>
          <target state="translated">Determina se la fine di questa istanza di stringa corrisponde a una stringa specificata.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Stringa da confrontare con la sottostringa alla fine di questa istanza.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>Determines whether the end of this string instance matches the specified string.</source>
          <target state="translated">Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the end of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se la fine di questa istanza corrisponde al parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the end of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">Questo metodo confronta <ph id="ph1">`value`</ph> con la sottostringa alla fine di questa istanza è uguale alla lunghezza <ph id="ph2">`value`</ph>e restituisce un'indicazione se sono uguali.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this instance.</source>
          <target state="translated">Per essere uguali, <ph id="ph1">`value`</ph> deve essere un riferimento alla stessa istanza o corrispondere alla fine di questa istanza.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example indicates whether each string in an array ends with a period (".").</source>
          <target state="translated">Nell'esempio seguente indica se ogni stringa in una matrice termina con un punto (".").</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripEndTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> method to remove HTML end tags from the end of a line.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`StripEndTags`</ph> metodo che utilizza il <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> metodo per rimuovere i tag di fine HTML dalla fine di una riga.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>Note that the  <ph id="ph1">`StripEndTags`</ph> method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</source>
          <target state="translated">Si noti che il <ph id="ph1">`StripEndTags`</ph> metodo viene chiamato in modo ricorsivo per garantire che vengano rimossi più tag di fine HTML alla fine della riga.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per determinare se una stringa termina con una particolare sottostringa utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Stringa da confrontare con la sottostringa alla fine di questa istanza.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Uno dei valori di enumerazione che determina la modalità di confronto tra questa stringa e <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante l'opzione di confronto specificata.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> corrisponde alla fine di questa stringa; in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> metodo confronta il <ph id="ph2">`value`</ph> parametro con la sottostringa alla fine di questa stringa e restituisce un valore che indica se sono uguali.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the end of this string.</source>
          <target state="translated">Per essere uguali, <ph id="ph1">`value`</ph> deve essere un riferimento a questa stessa stringa, deve essere una stringa vuota (""), o deve corrispondere alla fine di questa stringa.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">Il tipo di confronto eseguito dal <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> metodo dipende dal valore del <ph id="ph2">`comparisonType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string ends with a particular substring.</source>
          <target state="translated">Nell'esempio seguente determina se una stringa termina con una particolare sottostringa.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">I risultati sono interessati dalla scelta di impostazioni cultura, se è ignorare maiuscole/minuscole e se viene eseguito un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Stringa da confrontare con la sottostringa alla fine di questa istanza.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this instance and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Informazioni relative alle impostazioni cultura che determinano le modalità di confronto tra questa istanza e <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verranno usate le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante le impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> corrisponde alla fine di questa stringa; in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the end of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">Questo metodo consente di confrontare il <ph id="ph1">`value`</ph> parametro con la sottostringa alla fine di questa stringa che rappresenta la stessa lunghezza <ph id="ph2">`value`</ph>e restituisce un valore che indica se sono uguali.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this string.</source>
          <target state="translated">Per essere uguali, <ph id="ph1">`value`</ph> deve essere un riferimento alla stessa istanza o corrispondere alla fine di questa stringa.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a word (culture-sensitive) comparison using the specified casing and culture.</source>
          <target state="translated">Questo metodo esegue un confronto per parola (specifiche delle impostazioni cultura) usando le maiuscole e minuscole specificata e impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the end of another string.</source>
          <target state="translated">Nell'esempio seguente determina se una stringa si trova alla fine di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> metodo viene chiamato più volte con distinzione maiuscole/minuscole, maiuscole e minuscole e diverse impostazioni cultura che determinano i risultati della ricerca.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Determina se due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Stringa da confrontare con questa istanza.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>Determines whether this instance and a specified object, which must also be a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object, have the same value.</source>
          <target state="translated">Determina se questa istanza e un oggetto specificato, che deve essere anche un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> and its value is the same as this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> è un oggetto <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> e il relativo valore corrisponde a quello di questa istanza; in caso contrario <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, il metodo restituisce <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Stringa da confrontare con questa istanza.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>Determines whether this instance and another specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">Determina se questa istanza e un altro oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificato hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as the value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore del parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è lo stesso di quello di questa istanza; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, il metodo restituisce <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo. Confronta la parola titolo le maiuscole/minuscole "File" con una parola equivalente, il relativo equivalente in caratteri minuscoli, equivalente maiuscolo e una parola che contiene LATIN SMALL lettera punto I (U + 0131) anziché LATIN SMALL lettera I (U + 0069).</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> method performs an ordinal comparison, only the comparison with an identical word returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> metodo esegue un confronto ordinale, restituisce solo il confronto con una parola identico <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Prima stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Seconda stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Determina se due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore di <ph id="ph2">&lt;paramref name="a" /&gt;</ph> è uguale al valore di <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>If both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Se entrambi i parametri <ph id="ph1">&lt;paramref name="a" /&gt;</ph> e <ph id="ph2">&lt;paramref name="b" /&gt;</ph> sono <ph id="ph3">&lt;see langword="null" /&gt;</ph>, il metodo restituisce <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Stringa da confrontare con questa istanza.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies how the strings will be compared.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica la modalità di confronto delle stringhe.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Determines whether this string and a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">Determina se questa stringa e un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificato hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">Un parametro specifica le impostazioni cultura, l'eventuale distinzione fra maiuscole e minuscole e le regole di ordinamento usate per effettuare il confronto.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore del parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> corrisponde a quello di questa stringa; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra le due stringhe da confrontare o utilizzare regole di ordinamento ordinali o word.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</source>
          <target state="translated">L'esempio seguente crea una matrice di stringhe che include una "I", "i" lettera minuscola e una "ı".</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method to compare them by using each possible <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration value.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> metodo confrontarli tramite ogni possibile <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> valore di enumerazione.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">L'esempio seguente confronta i quattro set di parole con ogni membro del <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">I confronti di utilizzano le convenzioni delle impostazioni cultura Sami (Svezia superiore) e inglese (Stati Uniti).</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">Si noti che le stringhe "encyclopædia" e "Enciclopedia" sono considerati equivalenti nelle impostazioni cultura en-US, ma non nelle impostazioni cultura Sami (settentrionale Svezia).</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Prima stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Seconda stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the comparison.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di confronto.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Determina se due oggetti <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">Un parametro specifica le impostazioni cultura, l'eventuale distinzione fra maiuscole e minuscole e le regole di ordinamento usate per effettuare il confronto.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="a" /&gt;</ph> parameter is equal to the value of the <ph id="ph3">&lt;paramref name="b" /&gt;</ph> parameter; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore del parametro <ph id="ph2">&lt;paramref name="a" /&gt;</ph> è uguale al valore del parametro <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra le due stringhe da confrontare o utilizzare regole di ordinamento ordinali o word.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">L'esempio seguente confronta i quattro set di parole con ogni membro del <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">I confronti di utilizzano le convenzioni delle impostazioni cultura Sami (Svezia superiore) e inglese (Stati Uniti).</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">Si noti che le stringhe "encyclopædia" e "Enciclopedia" sono considerati equivalenti nelle impostazioni cultura en-US, ma non nelle impostazioni cultura Sami (settentrionale Svezia).</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of objects to strings based on the formats specified and inserts them into another string.</source>
          <target state="translated">Converte il valore degli oggetti in stringhe in base ai formati specificati e le inserisce in un'altra stringa.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>If you are new to the <ph id="ph1">`String.Format`</ph> method, see the <bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept> section for a quick overview.</source>
          <target state="translated">Se non si ha familiarità con il metodo <ph id="ph1">`String.Format`</ph>, vedere la sezione <bpt id="p1">[</bpt>Iniziare a utilizzare il metodo String. Format<ept id="p1">](#Starting)</ept> per una rapida panoramica.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>See the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks-top)</ept> section for general documentation for the <ph id="ph1">`String.Format`</ph> method.</source>
          <target state="translated">Vedere la sezione <bpt id="p1">[</bpt>Osservazioni<ept id="p1">](#remarks-top)</ept> per la documentazione generale per il metodo <ph id="ph1">`String.Format`</ph>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">Contenuto della sezione:</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Iniziare a utilizzare il metodo String. Format<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Quale metodo si chiama?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format method in brief<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Il metodo Format in breve<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format item<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>L'elemento di formato<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>How arguments are formatted<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La formattazione di argomenti<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Elementi di formato che hanno lo stesso indice<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Formatting and culture<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Formattazione e le impostazioni cultura<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Custom formatting operations<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Le operazioni di formattazione personalizzata<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String.Format Q &amp; A<ept id="p1">](#QA)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String.Format Q &amp; A<ept id="p1">](#QA)</ept></target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Get started with the String.Format method</source>
          <target state="translated">Iniziare a utilizzare il metodo String. Format</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> if you need to insert the value of an object, variable, or expression into another string.</source>
          <target state="translated">Utilizzare <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> se è necessario inserire il valore di un oggetto, una variabile o espressione in un'altra stringa.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you can insert the value of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value into a string to display it to the user as a single string:</source>
          <target state="translated">Ad esempio, è possibile inserire il valore di un <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valore in una stringa per visualizzarlo come una singola stringa:</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>And you can control that value's formatting:</source>
          <target state="translated">Ed è possibile controllare la formattazione di tale valore:</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Besides formatting, you can also control alignment and spacing.</source>
          <target state="translated">Oltre alla formattazione, è possibile controllare l'allineamento e spaziatura.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Inserting a string</source>
          <target state="translated">Inserimento di una stringa</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> inizia con una stringa di formato, seguita da uno o più oggetti o le espressioni che verranno convertite in stringhe e inserite in una posizione specificata nella stringa di formato.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`{0}`</ph> in the format string is a format item.</source>
          <target state="translated">Il <ph id="ph1">`{0}`</ph> nel formato di stringa è un elemento di formato.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`0`</ph> is the index of the object whose string value will be inserted at that position.</source>
          <target state="translated"><ph id="ph1">`0`</ph> è l'indice dell'oggetto il cui valore di stringa verrà inserito in tale posizione.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(Indexes start at 0.) If the object to be inserted is not a string, its <ph id="ph1">`ToString`</ph> method is called to convert it to one before inserting it in the result string.</source>
          <target state="translated">(Gli indici iniziano da 0). Se l'oggetto da inserire non è una stringa, il relativo <ph id="ph1">`ToString`</ph> metodo viene chiamato per convertire uno prima di inserirlo nella stringa di risultato.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's another example that uses two format items and two objects in the object list:</source>
          <target state="translated">Ecco un altro esempio che utilizza due elementi di formato e due oggetti nell'elenco di oggetti:</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</source>
          <target state="translated">È possibile avere un numero di elementi di formato e il numero di oggetti nell'elenco di oggetti di come si desidera, purché l'indice di ogni elemento di formato è un oggetto corrispondente nell'elenco di oggetti.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</source>
          <target state="translated">Inoltre, non è necessario sulla quale eseguire l'overload si chiama; il compilatore verrà selezionato quello più appropriato.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling formatting</source>
          <target state="translated">Il controllo della formattazione</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can follow the index in a format item with a format string to control how an object is formatted.</source>
          <target state="translated">È possibile seguire l'indice in un elemento di formato con una stringa di formato per controllare la formattazione dell'oggetto.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, <ph id="ph1">`{0:d}`</ph> applies the "d" format string to the first object in the object list.</source>
          <target state="translated">Ad esempio, <ph id="ph1">`{0:d}`</ph> si applica la stringa di formato "d" per il primo oggetto nell'elenco di oggetti.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is an example with a single object and two format items:</source>
          <target state="translated">Di seguito è riportato un esempio con un singolo oggetto e due elementi di formato:</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of types support format strings, including all numeric types (both                                          <bpt id="p1">[</bpt>standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and                                          <bpt id="p2">[</bpt>custom<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> format strings), all dates and times (both                                          <bpt id="p3">[</bpt>standard<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and                                          <bpt id="p4">[</bpt>custom<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> format strings) and time intervals (both                                          <bpt id="p5">[</bpt>standard<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and                                          <bpt id="p6">[</bpt>custom<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> format strings), all enumeration types                                          <bpt id="p7">[</bpt>enumeration types<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, and                                          <bpt id="p8">[</bpt>GUIDs<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</source>
          <target state="translated">Formato di un numero di supporto di tipi di stringhe, inclusi tutti i tipi numerici (entrambi <bpt id="p1">[</bpt>standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>personalizzato<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> stringhe di formato), tutte le date e ore (bot h <bpt id="p3">[</bpt>standard<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> e <bpt id="p4">[</bpt>personalizzato<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> stringhe di formato) e gli intervalli di tempo (entrambi <bpt id="p5">[</bpt>standard d<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> e <bpt id="p6">[</bpt>personalizzato<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> stringhe di formato), tutti i tipi di enumerazione <bpt id="p7">[</bpt>i tipi di enumerazione<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, e                                          <bpt id="p8">[</bpt>GUID<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also add support for format strings to your own types.</source>
          <target state="translated">È anche possibile aggiungere supporto per le stringhe di formato per i tipi.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling spacing</source>
          <target state="translated">Controllare la spaziatura</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can define the width of the string that is inserted into the result string by using syntax such as <ph id="ph1">`{0,12}`</ph>, which inserts a 12-character string.</source>
          <target state="translated">È possibile definire la larghezza della stringa inserita nella stringa di risultato tramite, ad esempio sintassi <ph id="ph1">`{0,12}`</ph>, che inserisce una stringa di 12 caratteri.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the string representation of the first object is right-aligned in the 12-character field.</source>
          <target state="translated">La rappresentazione di stringa del primo oggetto in questo caso, è allineato a destra del campo di 12 caratteri.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</source>
          <target state="translated">(Se la rappresentazione di stringa del primo oggetto è più di 12 caratteri, tuttavia, la larghezza preferita del campo viene ignorata e l'intera stringa viene inserita nella stringa di risultato.)</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</source>
          <target state="translated">L'esempio seguente definisce un campo di 6 caratteri per contenere la stringa "Anno" e alcune stringhe di anno, nonché un campo di 15 caratteri per contenere la stringa "Popolazione" e alcuni dati della popolazione.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the characters are right-aligned in the field.</source>
          <target state="translated">Si noti che i caratteri sono allineati a destra del campo.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling alignment</source>
          <target state="translated">Controllo dell'allineamento</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, strings are right-aligned within their field if you specify a field width.</source>
          <target state="translated">Per impostazione predefinita, le stringhe sono allineati a destra nel loro campo se si specifica una larghezza di campo.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To left-align strings in a field, you preface the field width with a negative sign, such as <ph id="ph1">`{0,-12}`</ph> to define a 12-character right-aligned field.</source>
          <target state="translated">Per allineare le stringhe in un campo a sinistra, fare precedere la larghezza del campo con un segno negativo, ad esempio <ph id="ph1">`{0,-12}`</ph> per definire un campo allineato a destra di 12 caratteri.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example is similar to the previous one, except that it left-aligns both labels and data.</source>
          <target state="translated">Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che Allinea a sinistra delle etichette e i dati.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> makes use of the composite formatting feature.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> utilizza la funzionalità di formattazione composta.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Formattazione composita<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">Quale metodo si chiama?</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call</source>
          <target state="translated">Call</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of the current culture.</source>
          <target state="translated">Formattare uno o più oggetti utilizzando le convenzioni delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Except for the overloads that include a <ph id="ph1">`provider`</ph> parameter, the remaining <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overloads include a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter followed by one or more object parameters.</source>
          <target state="translated">Ad eccezione di overload che includono un <ph id="ph1">`provider`</ph> parametro, il rimanente <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overload includono un <ph id="ph3">&lt;xref:System.String&gt;</ph> parametro seguita da uno o più parametri di oggetto.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">Per questo motivo, non è necessario determinare quale <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload si intende chiamare.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that don't have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Il compilatore di linguaggio seleziona overload appropriato tra gli overload che non hanno un <ph id="ph1">`provider`</ph> parametro, in base all'elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Ad esempio, se all'elenco di argomenti dispone di cinque argomenti, il compilatore chiama il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of a specific culture.</source>
          <target state="translated">Formattare uno o più oggetti utilizzando le convenzioni delle impostazioni cultura specifiche.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload that begins with a <ph id="ph2">`provider`</ph> parameter is followed by a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter and one or more object parameters.</source>
          <target state="translated">Ogni <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload che inizia con un <ph id="ph2">`provider`</ph> parametro è seguito da un <ph id="ph3">&lt;xref:System.String&gt;</ph> parametro e uno o più parametri dell'oggetto.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which specific <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">Per questo motivo, non è necessario determinare quali specifiche <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload si intende chiamare.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Il compilatore di linguaggio seleziona overload appropriato tra gli overload che hanno un <ph id="ph1">`provider`</ph> parametro, in base all'elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Ad esempio, se all'elenco di argomenti dispone di cinque argomenti, il compilatore chiama il <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Perform a custom formatting operation either with an <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation or an <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">Eseguire un'operazione di formattazione personalizzata con un <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementazione o <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any of the four overloads with a <ph id="ph1">`provider`</ph> parameter.</source>
          <target state="translated">Uno dei quattro overload con un <ph id="ph1">`provider`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Il compilatore seleziona overload appropriato tra gli overload che hanno un <ph id="ph1">`provider`</ph> parametro, in base all'elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Format method in brief</source>
          <target state="translated">Il metodo Format in breve</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each overload of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to include zero-based indexed placeholders, called <bpt id="p2">*</bpt>format items<ept id="p2">*</ept>, in a composite format string.</source>
          <target state="translated">Ogni overload del <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo utilizza il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> da includere in base zero segnaposto indicizzati, denominati <bpt id="p2">*</bpt>formattare gli elementi<ept id="p2">*</ept>, in una stringa di formato composita.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</source>
          <target state="translated">In fase di esecuzione, ogni elemento di formato viene sostituito con la rappresentazione di stringa dell'argomento corrispondente in un elenco di parametri.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of the argument is <ph id="ph1">`null`</ph>, the format item is replaced with <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il valore dell'argomento è <ph id="ph1">`null`</ph>, l'elemento di formato viene sostituito con <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</source>
          <target state="translated">Ad esempio, la seguente chiamata per il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> metodo include una stringa di formato con formato tre voci, {0}, \\{1 \\} e {2} e un elenco di argomenti con tre elementi.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The format item</source>
          <target state="translated">L'elemento di formato</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has this syntax:</source>
          <target state="translated">Un elemento di formato presenta questa sintassi:</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Brackets denote optional elements.</source>
          <target state="translated">Le parentesi quadre indicano elementi facoltativi.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The opening and closing braces are required.</source>
          <target state="translated">L'apertura e parentesi graffe di chiusura sono necessarie.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(To include a literal opening or closing brace in the format string, see the "Escaping Braces" section in the <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> article.)</source>
          <target state="translated">(Per includere un valore letterale di apertura o parentesi graffa chiusa nella stringa di formato, vedere la sezione "Caratteri di escape delle parentesi graffe" il <bpt id="p1">[</bpt>formattazione composita<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> articolo.)</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a format item to format a currency value might appear like this:</source>
          <target state="translated">Un elemento di formato per formattare un valore di valuta, ad esempio, può sembrare simile al seguente:</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has the following elements:</source>
          <target state="translated">Un elemento di formato include gli elementi seguenti:</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>index<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Indice<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The zero-based index of the argument whose string representation is to be included at this position in the string.</source>
          <target state="translated">L'indice in base zero dell'argomento cui rappresentazione di stringa deve essere incluso in questa posizione nella stringa.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this argument is <ph id="ph1">`null`</ph>, an empty string will be included at this position in the string.</source>
          <target state="translated">Se questo argomento è <ph id="ph1">`null`</ph>, una stringa vuota verrà inclusa in questa posizione nella stringa.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>alignment<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>alignment<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">Facoltativo.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</source>
          <target state="translated">Intero con segno che indica la lunghezza totale del campo in cui viene inserito l'argomento e se è allineato a destra (un numero intero positivo) o allineato a sinistra (un numero intero negativo).</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept>, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</source>
          <target state="translated">Se si omette <bpt id="p1">*</bpt>allineamento<ept id="p1">*</ept>, la rappresentazione di stringa dell'argomento corrispondente viene inserita in un campo senza spazi iniziali o finali.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is less than the length of the argument to be inserted, <bpt id="p2">*</bpt>alignment<ept id="p2">*</ept> is ignored and the length of the string representation of the argument is used as the field width.</source>
          <target state="translated">Se il valore di <bpt id="p1">*</bpt>allineamento<ept id="p1">*</ept> è minore della lunghezza dell'argomento deve essere inserito <bpt id="p2">*</bpt>allineamento<ept id="p2">*</ept> viene ignorato e la lunghezza della rappresentazione di stringa dell'argomento viene utilizzata come la larghezza del campo.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">Facoltativo.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that specifies the format of the corresponding argument's result string.</source>
          <target state="translated">Stringa che specifica il formato della stringa di risultato dell'argomento corrispondente.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the corresponding argument's parameterless <ph id="ph1">`ToString`</ph> method is called to produce its string representation.</source>
          <target state="translated">Se si omette <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, senza parametri dell'argomento corrispondente <ph id="ph1">`ToString`</ph> metodo viene chiamato per generare la rappresentazione di stringa.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you specify <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the argument referenced by the format item must implement the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface.</source>
          <target state="translated">Se si specifica <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, l'argomento a cui fa riferimento l'elemento di formato deve implementare il <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Types that support format strings include:</source>
          <target state="translated">I tipi che supportano le stringhe di formato includono:</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All integral and floating-point types.</source>
          <target state="translated">Tutti i tipi a virgola mobile e integrali.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>stringhe di formato numerico Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato numerico personalizzato<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> e <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>stringhe di formato di data e ora Standard<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato di data e ora personalizzato<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All enumeration types.</source>
          <target state="translated">Tutti i tipi di enumerazione.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>stringhe di formato di enumerazione<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values.</source>
          <target state="translated">valori <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>stringhe di formato TimeSpan Standard<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato TimeSpan personalizzate<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GUIDs.</source>
          <target state="translated">GUID.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See the <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method.)</source>
          <target state="translated">(Vedere il <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> metodo.)</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, note that any custom type can implement <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> or extend an existing type's <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">Tuttavia, si noti che è possibile implementare qualsiasi tipo personalizzato <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> o estendere un tipo esistente <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">`alignment`</ph> and <ph id="ph2">`formatString`</ph> arguments to produce formatted output.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">`alignment`</ph> e <ph id="ph2">`formatString`</ph> argomenti per produrre l'output formattato.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How arguments are formatted</source>
          <target state="translated">La formattazione di argomenti</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items are processed sequentially from the beginning of the string.</source>
          <target state="translated">Elementi di formato vengono elaborati in sequenza dall'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each format item has an index that corresponds to an object in the method's argument list.</source>
          <target state="translated">Ogni elemento di formato include un indice che corrisponde a un oggetto nell'elenco di argomenti del metodo.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method retrieves the argument and derives its string representation as follows:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> recupera l'argomento di metodo e deriva relativa rappresentazione di stringa, come indicato di seguito:</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument is <ph id="ph1">`null`</ph>, the method inserts <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> into the result string.</source>
          <target state="translated">Se l'argomento è <ph id="ph1">`null`</ph>, il metodo inserisce <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> nella stringa di risultato.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You don't have to be converned with handling an <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> for null arguments.</source>
          <target state="translated">Non è necessario essere converned con gestione un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> per gli argomenti null.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you call the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> overload and the <ph id="ph2">`provider`</ph> parameter implements the <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interface, the argument is passed to the <ph id="ph4">`provider`</ph> object's <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se si chiama il <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> overload e <ph id="ph2">`provider`</ph> parametro implementa la <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interfaccia, l'argomento viene passato per il <ph id="ph4">`provider`</ph> dell'oggetto <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the format item includes a <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept> argument, it is passed as the first argument to the method.</source>
          <target state="translated">Se l'elemento di formato include un <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept> argomento, viene passato come primo argomento al metodo.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation is able to provide formatting services, it returns the string representation of the argument; otherwise, it returns <ph id="ph2">`null`</ph> and the next step executes.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementazione è in grado di fornire servizi di formattazione, restituisce la rappresentazione di stringa dell'argomento; in caso contrario, restituisce <ph id="ph2">`null`</ph> ed esegue il passaggio successivo.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument implements the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface, its <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation is called.</source>
          <target state="translated">Se l'argomento implementa il <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interfaccia, il relativo <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> viene chiamata l'implementazione.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The argument's parameterless <ph id="ph1">`ToString`</ph> method, which is either overridden or inherited from the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class, is called.</source>
          <target state="translated">Senza parametri dell'argomento <ph id="ph1">`ToString`</ph> metodo, che viene sottoposto a override o ereditare il <ph id="ph2">&lt;xref:System.Object&gt;</ph> classe, viene chiamato.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that intercepts calls to the <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> method and allows you to see what information the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> method passes to a formatting method for each format item in a composite format string, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">Per un esempio che intercetta le chiamate al <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> metodo e consente di visualizzare le informazioni di <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> metodo passa a un metodo di formattazione per ogni elemento di formato in una stringa di formato composita, vedere <bpt id="p1">[</bpt>esempio: un provider di intercept e Formattatore romano<ept id="p1">](#Format7_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items that have the same index</source>
          <target state="translated">Elementi di formato che hanno lo stesso indice</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo genera un <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> eccezione se l'indice di un elemento di indice è maggiore o uguale al numero di argomenti nell'elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, <ph id="ph1">`format`</ph> can include more format items than there are arguments, as long as multiple format items have the same index.</source>
          <target state="translated">Tuttavia, <ph id="ph1">`format`</ph> può includere più elementi di formato che non vi sono argomenti, a condizione che più elementi di formato hanno lo stesso indice.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</source>
          <target state="translated">Nella chiamata al <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> nell'esempio seguente, l'elenco di argomenti metodo presenta un solo argomento, ma la stringa di formato include due elementi di formato: uno Visualizza il valore decimale di un numero e l'altro relativo valore esadecimale.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and culture</source>
          <target state="translated">Formattazione e le impostazioni cultura</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">In genere, gli oggetti nell'elenco di argomenti vengono convertiti nelle rappresentazioni di stringa usando le convenzioni delle impostazioni cultura correnti, viene restituito dal <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can control this behavior by calling one of the overloads of <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> that includes a <ph id="ph2">`provider`</ph> parameter.</source>
          <target state="translated">È possibile controllare questo comportamento chiamando uno degli overload di <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> che include un <ph id="ph2">`provider`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</source>
          <target state="translated">Il <ph id="ph1">`provider`</ph> parametro è un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementazione che fornisce informazioni di formattazione specifiche delle impostazioni cultura e personalizzate che viene utilizzate per la formattazione di moderato elaborare.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface has a single member, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, which is responsible for returning the object that provides formatting information.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interfaccia dispone di un singolo membro, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, che è responsabile di restituire l'oggetto che fornisce informazioni di formattazione.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework has three <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> implementations that provide culture-specific formatting:</source>
          <target state="translated">.NET Framework offre tre <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> implementazioni che forniscono informazioni di formattazione specifiche delle impostazioni cultura:</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns a culture-specific <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for formatting numeric values and a culture-specific <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object for formatting date and time values.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> il metodo restituisce un oggetto specifico delle impostazioni cultura <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto per la formattazione di valori numerici e impostazioni cultura specifiche <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> oggetto per la formattazione di valori di data e ora.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, which is used for culture-specific formatting of date and time values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, che viene utilizzato per la formattazione specifiche delle impostazioni cultura di valori di data e ora.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> method returns itself.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> metodo restituisce se stesso.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, which is used for culture-specific formatting of numeric values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, che viene utilizzato per la formattazione specifiche delle impostazioni cultura di valori numerici.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> property returns itself.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> proprietà restituisce se stesso.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Custom formatting operations</source>
          <target state="translated">Le operazioni di formattazione personalizzata</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the any of the overloads of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method that have a <ph id="ph2">`provider`</ph> parameter of type <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> to perform custom formatting operations.</source>
          <target state="translated">È inoltre possibile chiamare degli overload di <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo che presenta un <ph id="ph2">`provider`</ph> parametro di tipo <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> per eseguire operazioni di formattazione personalizzate.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you could format an integer as an identification number or as a telephone number.</source>
          <target state="translated">Ad esempio, è possibile formattare un numero intero come un numero di identificazione o un numero di telefono.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform custom formatting, your <ph id="ph1">`provider`</ph> argument must implement both the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> and <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interfaces.</source>
          <target state="translated">Per eseguire la formattazione personalizzata del <ph id="ph1">`provider`</ph> argomento deve implementare entrambe le <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> e <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interfacce.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is passed an <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> implementation as the <ph id="ph3">`provider`</ph> argument, the <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> method calls its   <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> implementation and requests an object of type <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> viene passato un <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> come implementazione di <ph id="ph3">`provider`</ph> argomento, il <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> chiamate al metodo relativo <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> implementazione e richiede un oggetto di tipo <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then calls the returned <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> object's <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> method to format each format item in the composite string passed to it.</source>
          <target state="translated">Chiama quindi l'oggetto restituito <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> dell'oggetto <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> per formattare ogni elemento di formato della stringa composto passato a esso.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about providing custom formatting solutions, see <bpt id="p1">[</bpt>How to: Define and Use Custom Numeric Format Providers<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> and <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni su come fornire soluzioni di formattazione personalizzate, vedere <bpt id="p1">[</bpt>procedura: definire e utilizzare provider formato numerico personalizzati<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> e <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts integers to formatted custom numbers, see <bpt id="p1">[</bpt>Example: A custom formatting operation<ept id="p1">](#Format6_Example)</ept>.</source>
          <target state="translated">Per un esempio che converte i numeri interi in formato numeri personalizzati, vedere <bpt id="p1">[</bpt>esempio: un'operazione di formattazione personalizzata<ept id="p1">](#Format6_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts unsigned bytes to Roman numerals, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">Per un esempio che converte i numeri romani byte senza segno, vedere <bpt id="p1">[</bpt>esempio: un provider intercetta e formattatore romano<ept id="p1">](#Format7_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: A custom formatting operation</source>
          <target state="translated">Esempio: Un'operazione formattazione personalizzata</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</source>
          <target state="translated">Questo esempio definisce un provider di formato che consenta di formattare un valore integer come un numero di account del cliente in formato x-xxxxx-xx.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: An intercept provider and Roman numeral formatter</source>
          <target state="translated">Esempio: Un provider di intercettare e formattatore romano</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a custom format provider that implements the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaces to do two things:</source>
          <target state="translated">In questo esempio definisce un provider di formato personalizzata che implementa il <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> e <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfacce per eseguire due operazioni:</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It displays the parameters passed to its <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Visualizza i parametri passati al relativo <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This enables us to see what parameters the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is passing to the custom formatting implementation for each object that it tries to format.</source>
          <target state="translated">Ciò consente di vedere quali parametri il <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo passa per l'implementazione di formattazione personalizzata per ogni oggetto che tenta di formattare.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This can be useful when you're debugging your application.</source>
          <target state="translated">Può essere utile quando si esegue il debug dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</source>
          <target state="translated">Se l'oggetto da formattare è un valore di byte senza segno che deve essere formattata con la stringa di formato standard "R", il formattatore personalizzato il valore numerico viene formattato come un numero romano.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String.Format Q &amp; A</source>
          <target state="translated">String. Format domande e risposte</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why do you recommend string interpolation over calls to the <ph id="ph1">`String.Format`</ph> method?</source>
          <target state="translated">Motivo per cui consigliabile interpolazione di stringhe tramite chiamate al <ph id="ph1">`String.Format`</ph> metodo?</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String interpolation is:</source>
          <target state="translated">Interpolazione di stringhe è:</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More flexible.</source>
          <target state="translated">Più flessibile.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It can be used in any string without requiring a call to a method that supports composite formatting.</source>
          <target state="translated">Può essere utilizzato qualsiasi stringa senza una chiamata a un metodo che supporta la formattazione composita.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Otherwise, you have to call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method or another method that supports composite formatting, such as <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">In caso contrario, è necessario chiamare il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo o un altro metodo che supporta la formattazione composita, ad esempio <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More readable.</source>
          <target state="translated">Più leggibile.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</source>
          <target state="translated">Poiché l'espressione da inserire in una stringa viene visualizzato nell'espressione interpolata anziché in un elenco di argomenti, sono molto più semplice per codice e per leggere stringhe interpolate.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</source>
          <target state="translated">A causa delle loro maggiore leggibilità, stringhe interpolate possono sostituire non solo le chiamate ai metodi di formattazione composta, ma possono anche essere utilizzati in operazioni di concatenazione di stringhe per produrre codice più conciso e più chiaro.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</source>
          <target state="translated">Un confronto tra le seguenti due esempi di codice viene illustrato l'eccezionale di stringhe interpolate tramite la concatenazione di stringhe e le chiamate ai metodi di formattazione composita.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</source>
          <target state="translated">L'utilizzo di più operazioni di concatenazione di stringa nell'esempio seguente genera codice dettagliato e difficile da leggere.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method in the previous example.</source>
          <target state="translated">Al contrario, l'uso di stringhe interpolate nel seguente esempio producono codice molto più semplice, più concisa rispetto l'istruzione di concatenazione di stringa e la chiamata al <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo nell'esempio precedente.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Where can I find a list of the predefined format strings that can be used with format items?</source>
          <target state="translated">Dove posso trovare un elenco delle stringhe di formato predefinito che può essere utilizzato con elementi di formato?</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all integral and floating-point types, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Per tutti i tipi a virgola mobile e integrali, vedere <bpt id="p1">[</bpt>stringhe di formato numerico Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato numerico personalizzato<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">Per i valori di data e ora, vedere <bpt id="p1">[</bpt>stringhe di formato di ora e data Standard<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato di ora e Data personalizzata<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For enumeration values, see <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</source>
          <target state="translated">Per valori di enumerazione, vedere <bpt id="p1">[</bpt>stringhe di formato di enumerazione<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values, see  <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</source>
          <target state="translated">Per <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> valori, vedere <bpt id="p1">[</bpt>stringhe di formato TimeSpan Standard<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato TimeSpan personalizzate<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.Guid&gt;</ph> values, see the Remarks section of the <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> reference page.</source>
          <target state="translated">Per <ph id="ph1">&lt;xref:System.Guid&gt;</ph> valori, vedere la sezione Note del <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> pagina di riferimento.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the alignment of the result strings that replace format items?</source>
          <target state="translated">Come controllare l'allineamento delle stringhe di risultato che sostituiscono gli elementi di formato?</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The general syntax of a format item is:</source>
          <target state="translated">La sintassi generale di un elemento di formato è:</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>where <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is a signed integer that defines the field width.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>allineamento<ept id="p1">*</ept> è un intero con segno che definisce la larghezza del campo.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this value is negative, text in the field is left-aligned.</source>
          <target state="translated">Se questo valore è negativo, nel campo di testo è allineato a sinistra.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If it is positive, text is right-aligned.</source>
          <target state="translated">In caso positivo, il testo è allineato a destra.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of digits after the decimal separator?</source>
          <target state="translated">Come controllare il numero di cifre dopo il separatore decimale</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All <bpt id="p1">[</bpt>standard numeric format strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</source>
          <target state="translated">Tutti <bpt id="p1">[</bpt>stringhe di formato numerico standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> ad eccezione di "D" (che viene utilizzato con solo numeri interi), "G", "R" e "X" Consenti un identificatore di precisione che definisce il numero di cifre decimali nella stringa di risultato.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses standard numeric format strings to control the number of decimal digits in the result string.</source>
          <target state="translated">L'esempio seguente usa le stringhe di formato numerico standard per controllare il numero di cifre decimali nella stringa di risultato.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you're using a <bpt id="p1">[</bpt>custom numeric format string<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</source>
          <target state="translated">Se si utilizza un <bpt id="p1">[</bpt>stringa di formato numerico personalizzata<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, utilizzare l'identificatore di formato "0" per controllare il numero di cifre decimali nella stringa di risultato, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of integral digits?</source>
          <target state="translated">Come controllare il numero di cifre integrali</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, formatting operations only display non-zero integral digits.</source>
          <target state="translated">Per impostazione predefinita, le operazioni di formattazione vengono visualizzati solo cifre integrali diverso da zero.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</source>
          <target state="translated">Se si desidera formattare numeri interi, è possibile utilizzare un identificatore di precisione con "D" e "X" stringhe di formato standard per controllare il numero di cifre.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" <bpt id="p1">[</bpt>custom numeric format specifier<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, as the following example shows.</source>
          <target state="translated">È possibile aggiungere un numero intero o a virgola mobile e con zeri iniziali per produrre una stringa di risultato con un numero specificato di cifre integrali con "0" <bpt id="p1">[</bpt>identificatore di formato numerico personalizzato<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How many items can I include in the format list?</source>
          <target state="translated">Il numero di elementi è possibile includere nell'elenco formato?</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is no practical limit.</source>
          <target state="translated">Non sono previsti limiti pratici.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The second parameter of the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is tagged with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, which allows you to include either a delimited list or an object array as your format list.</source>
          <target state="translated">Il secondo parametro del <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo è contrassegnato con il <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attributo, che consente di includere un elenco delimitato da virgole o una matrice di oggetti come elenco formato.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I include literal braces ("{" and "}") in the result string?</source>
          <target state="translated">Come includere valori letterali parentesi graffe ("{" e "}") nella stringa di risultato?</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, how do you prevent the following method call from throwing a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception?</source>
          <target state="translated">Ad esempio, come si impedisce la seguente chiamata al metodo generi un <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> eccezione?</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single opening or closing brace is always interpreted as the beginning or end of a format item.</source>
          <target state="translated">Un singolo apertura o la parentesi graffa di chiusura viene sempre interpretato come l'inizio o alla fine di un elemento di formato.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To be interpreted literally, it must be escaped.</source>
          <target state="translated">Per essere interpretato letteralmente, deve essere codificata.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</source>
          <target state="translated">Una parentesi graffa di escape mediante l'aggiunta di un'altra parentesi graffa ("{{" e "}}" anziché "{" e "}"), come nella chiamata al metodo seguente:</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, even escaped braces are easily misinterpreted.</source>
          <target state="translated">Tuttavia, anche con caratteri di escape delle parentesi graffe sono facilmente interpretate.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</source>
          <target state="translated">È consigliabile che comprende parentesi graffe nell'elenco formato e utilizzare gli elementi di formato per inserirli nella stringa di risultato, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why does my call to the String.Format method throw a FormatException?</source>
          <target state="translated">Perché la chiamata al metodo String. Format genera un'eccezione FormatException?</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</source>
          <target state="translated">La causa più comune dell'eccezione è che l'indice di un elemento di formato non corrisponde a un oggetto nell'elenco formato.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</source>
          <target state="translated">In genere indica che è stata misnumbered gli indici degli elementi di formato o è stata dimenticata includere un oggetto nell'elenco formato.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to include an unescaped left or right brace character also throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Tentativo di inserire una parentesi graffa di sinistra o destra senza caratteri escape di caratteri genera anche un <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</source>
          <target state="translated">In alcuni casi, l'eccezione è il risultato di un errore di digitazione; ad esempio, un errore tipico è digitata "[" (la parentesi quadra aperta) invece di "{" (la parentesi graffa sinistra).</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</source>
          <target state="translated">Se il metodo Format(System.IFormatProvider,System.String,System.Object[]) supporta matrici di parametri, perché il codice genera un'eccezione quando si utilizza una matrice?</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception:</source>
          <target state="translated">Ad esempio, il codice seguente genera un <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> eccezione:</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a problem of compiler overload resolution.</source>
          <target state="translated">Si tratta di un problema di risoluzione dell'overload del compilatore.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method.</source>
          <target state="translated">Poiché il compilatore non è possibile convertire una matrice di interi in una matrice di oggetti, e la matrice di interi considera come un solo argomento, quindi chiama il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The exception is thrown because there are four format items but only a single item in the format list.</source>
          <target state="translated">L'eccezione viene generata perché sono presenti quattro elementi di formato, ma solo un singolo elemento nell'elenco formato.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Poiché Visual Basic né in c# è possibile convertire una matrice di interi a una matrice di oggetti, è necessario eseguire la conversione prima di chiamare il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example provides one implementation.</source>
          <target state="translated">Nell'esempio seguente fornisce un'implementazione.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Numerous examples that call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method are interspersed through the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks)</ept> section of this article.</source>
          <target state="translated">Numerosi esempi che chiamano il <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> metodo vengono intercalati tramite il <bpt id="p1">[</bpt>osservazioni<ept id="p1">](#remarks)</ept> sezione di questo articolo.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also download a complete set of <ph id="ph1">`String.Format`</ph> examples, which are included a <bpt id="p1">[</bpt>.NET Core 2.0 project for C#<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> and a <bpt id="p2">[</bpt>.NET Core 2.0 project for Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, from the <bpt id="p3">[</bpt>dotnet/docs GitHub repository<ept id="p3">](https://github.com/dotnet/docs)</ept>.</source>
          <target state="translated">È inoltre possibile scaricare un set completo di <ph id="ph1">`String.Format`</ph> esempi, sono inclusi un <bpt id="p1">[</bpt>progetti .NET Core 2.0 per c#<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> e un <bpt id="p2">[</bpt>progetto .NET Core 2.0 per Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, dal <bpt id="p3">[</bpt>dotnet/docs Repository GitHub<ept id="p3">](https://github.com/dotnet/docs)</ept>.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following are some of the examples included in the article:</source>
          <target state="translated">Di seguito sono indicati alcuni degli esempi inclusi nell'articolo:</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a format string</source>
          <target state="translated">Creare una stringa di formato</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Inserting a string<ept id="p1">](#inserting-a-string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Inserimento di una stringa<ept id="p1">](#inserting-a-string)</ept></target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The format item<ept id="p1">](#the-format-item)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>L'elemento di formato<ept id="p1">](#the-format-item)</ept></target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#format-items-that-have-the-same-index)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Elementi di formato che hanno lo stesso indice<ept id="p1">](#format-items-that-have-the-same-index)</ept></target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Control formatted output</source>
          <target state="translated">Controllare l'output formattato</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling formatting<ept id="p1">](#controlling-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Il controllo della formattazione<ept id="p1">](#controlling-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling spacing<ept id="p1">](#controlling-spacing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controllare la spaziatura<ept id="p1">](#controlling-spacing)</ept></target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling alignment<ept id="p1">](#controlling-alignment)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controllo dell'allineamento<ept id="p1">](#controlling-alignment)</ept></target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of integral digits<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controllo del numero di cifre integrali<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of digits after the decimal separator<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controllo del numero di cifre dopo il separatore decimale<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Including literal braces in a result string<ept id="p1">](#braces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tra parentesi graffe letterale in una stringa di risultato<ept id="p1">](#braces)</ept></target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Make format strings culture-sensitive</source>
          <target state="translated">Verificare le stringhe di formato delle impostazioni cultura</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Culture-sensitive formatting<ept id="p1">](#culture-sensitive-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Formattazione delle impostazioni cultura<ept id="p1">](#culture-sensitive-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Customize the formatting operation</source>
          <target state="translated">Personalizzare l'operazione di formattazione</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>A custom formatting operation<ept id="p1">](#example-a-custom-formatting-operation)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Un'operazione di formattazione personalizzata<ept id="p1">](#example-a-custom-formatting-operation)</ept></target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>An intercept provider and Roman numeral formatter<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Un provider intercetta e formattatore romano<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">Oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>Replaces one or more format items in a string with the string representation of a specified object.</source>
          <target state="translated">Sostituisce uno o più elementi di formato in una stringa con la rappresentazione di stringa di un oggetto specificato.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which any format items are replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui qualsiasi elemento di formato viene sostituito dalla rappresentazione di stringa di <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire il valore di un'espressione nella relativa rappresentazione di stringa e incorporare tale rappresentazione in una stringa.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>Example: Formatting a single argument</source>
          <target state="translated">Esempio: Formattazione di un solo argomento</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method to embed an individual's age in the middle of a string.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> metodo per incorporare l'età dei singoli all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The format item in <ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated">L'elemento di formato nel parametro <ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The index of a format item is not zero.</source>
          <target state="translated">L'indice di un elemento di formato è diverso da zero.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">Matrice di oggetti che contiene zero o più oggetti da formattare.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</source>
          <target state="translated">Sostituisce l'elemento di formato presente in una stringa specificata con la rappresentazione di stringa di un oggetto corrispondente in una matrice specificata.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui gli elementi di formato sono stati sostituiti dalla rappresentazione di stringa degli oggetti corrispondenti in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire il valore di quattro o più espressioni nelle rispettive rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Since the <ph id="ph1">`args`</ph> parameter is marked with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> attribute, you can pass the objects to the method as individual arguments or as an <ph id="ph3">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">Poiché il <ph id="ph1">`args`</ph> parametro è contrassegnato con il <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> attributo, è possibile passare gli oggetti al metodo come singoli argomenti o come un <ph id="ph3">&lt;xref:System.Object&gt;</ph> matrice.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Example: Formatting more than three arguments</source>
          <target state="translated">Esempio: Formattazione di più di tre argomenti</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This example creates a string that contains data on the high and low temperature on a particular date.</source>
          <target state="translated">In questo esempio crea una stringa che contiene i dati sulla temperatura massima e minima in una determinata data.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The composite format string has five format items in the C# example and six in the Visual Basic example.</source>
          <target state="translated">Stringa di formato composita ha cinque elementi di formato di esempio di c# e sei nell'esempio di Visual Basic.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</source>
          <target state="translated">Due degli elementi di formato definire la larghezza della rappresentazione di stringa del valore corrispondente e il primo elemento di formato include anche una stringa di formato di ora e data standard.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>You can also pass the objects to be formatted as an array rather than a an argument list.</source>
          <target state="translated">È inoltre possibile passare gli oggetti da formattare come una matrice anziché da un elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> o <ph id="ph2">&lt;paramref name="args" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">L'indice di un elemento di formato è minore di zero o maggiore o uguale alla lunghezza della matrice <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">Oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>Replaces the format item or items in a specified string with the string representation of the corresponding object.</source>
          <target state="translated">Sostituisce uno o più elementi di formato presenti in una stringa specificata con la rappresentazione di stringa dell'oggetto corrispondente.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format item or items have been replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui uno o più elementi di formato vengono sostituiti dalla rappresentazione di stringa di <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire il valore di un'espressione nella relativa rappresentazione di stringa e incorporare tale rappresentazione in una stringa.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The method converts <ph id="ph1">`arg0`</ph> to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Il metodo converte <ph id="ph1">`arg0`</ph> nella relativa rappresentazione di stringa chiamando il relativo <bpt id="p1">**</bpt>ToString (IFormatProvider)<ept id="p1">**</ept> (metodo) o, se l'oggetto corrispondente elemento di formato include una stringa di formato chiamando il relativo <bpt id="p2">**</bpt>ToString ( Stringa, IFormatProvider)<ept id="p2">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Se questi metodi non esistono, viene chiamato l'oggetto senza parametri <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> o <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The index of a format item is less than zero, or greater than or equal to one.</source>
          <target state="translated">L'indice di un elemento di formato è minore di zero oppure maggiore o uguale a uno.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">Matrice di oggetti che contiene zero o più oggetti da formattare.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Replaces the format items in a string with the string representations of corresponding objects in a specified array.</source>
          <target state="translated">Sostituisce gli elementi di formato presenti in una stringa con le rappresentazioni di stringa degli oggetti corrispondenti in una matrice specificata.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui gli elementi di formato sono stati sostituiti dalla rappresentazione di stringa degli oggetti corrispondenti in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire le rappresentazioni di stringa di quattro o più espressioni e incorporare tali rappresentazioni in una stringa.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Il metodo converte ogni <ph id="ph1">&lt;xref:System.Object&gt;</ph> argomento nella relativa rappresentazione di stringa chiamando il relativo <bpt id="p1">**</bpt>ToString (IFormatProvider)<ept id="p1">**</ept> metodo o, se l'oggetto corrispondente elemento di formato include una stringa di formato, chiamando il relativo <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Se questi metodi non esistono, viene chiamato l'oggetto senza parametri <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Example: Culture-sensitive formatting</source>
          <target state="translated">Esempio: Cultura formattazione</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method to display the string representation of some date and time values and numeric values by using several different cultures.</source>
          <target state="translated">Questo esempio viene utilizzato il <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo per visualizzare la rappresentazione di stringa di alcuni valori di data e ora e i valori numerici con varie impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> o <ph id="ph2">&lt;paramref name="args" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">L'indice di un elemento di formato è minore di zero o maggiore o uguale alla lunghezza della matrice <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Primo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Secondo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">Sostituisce gli elementi di formato presenti in una stringa con la rappresentazione di stringa di due oggetti specificati.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui gli elementi di formato vengono sostituiti dalle rappresentazioni di stringa di <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> e <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire il valore di due espressioni per le rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Example: Formatting two arguments</source>
          <target state="translated">Esempio: Formattazione di due argomenti</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to display time and temperature data stored in a generic <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> object.</source>
          <target state="translated">Questo esempio viene utilizzato il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> metodo per visualizzare l'ora e temperatura dati archiviati in un oggetto generico <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Note that the format string has three format items, although there are only two objects to format.</source>
          <target state="translated">Si noti che la stringa di formato include tre elementi di formato, anche se sono presenti solo due oggetti da formattare.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</source>
          <target state="translated">Poiché il primo oggetto nell'elenco (un valore data e ora) viene utilizzato da due elementi di formato: il primo formato elemento sia indicato l'ora e il secondo Visualizza la data.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The index of a format item is not zero or one.</source>
          <target state="translated">L'indice di un elemento di formato è diverso da zero o uno.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Primo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Secondo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">Sostituisce gli elementi di formato presenti in una stringa con la rappresentazione di stringa di due oggetti specificati.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui gli elementi di formato vengono sostituiti dalle rappresentazioni di stringa di <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> e <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire le rappresentazioni di stringa di due espressioni e incorporare tali rappresentazioni in una stringa.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Il metodo converte ogni <ph id="ph1">&lt;xref:System.Object&gt;</ph> argomento nella relativa rappresentazione di stringa chiamando il relativo <bpt id="p1">**</bpt>ToString (IFormatProvider)<ept id="p1">**</ept> metodo o, se l'oggetto corrispondente elemento di formato include una stringa di formato, chiamando il relativo <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Se questi metodi non esistono, viene chiamato l'oggetto senza parametri <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> o <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> è <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than or equal to two.</source>
          <target state="translated">L'indice di un elemento di formato è minore di zero oppure maggiore o uguale a due.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Primo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Secondo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">Terzo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">Sostituisce gli elementi di formato in una stringa con le rappresentazioni di stringa di tre oggetti specificati.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui gli elementi di formato sono stati sostituiti dalle rappresentazioni di stringa di <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> e <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire il valore di tre espressioni nelle rispettive rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Example: Formatting three arguments</source>
          <target state="translated">Esempio: Formattazione di tre argomenti</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to create a string that illustrates the result of a Boolean <ph id="ph2">`And`</ph> operation with two integer values.</source>
          <target state="translated">Questo esempio viene utilizzato il <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> metodo per creare una stringa che illustra il risultato di un valore booleano <ph id="ph2">`And`</ph> operazione con due valori integer.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</source>
          <target state="translated">Si noti che la stringa di formato include sei elementi di formato, ma il metodo ha solo tre elementi nell'elenco dei parametri, perché ogni elemento è formattato in due modi diversi.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than two.</source>
          <target state="translated">L'indice di un elemento di formato è minore di zero oppure maggiore di due.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Stringa in formato composito<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Primo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Secondo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">Terzo oggetto da formattare.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">Sostituisce gli elementi di formato in una stringa con le rappresentazioni di stringa di tre oggetti specificati.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An parameter supplies culture-specific formatting information.</source>
          <target state="translated">Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Copia di <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in cui gli elementi di formato sono stati sostituiti dalle rappresentazioni di stringa di <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> e <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Questo metodo Usa il <bpt id="p1">[</bpt>funzionalità di formattazione composta<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> per convertire le rappresentazioni di stringa di tre espressioni e incorporare tali rappresentazioni in una stringa.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Il metodo converte ogni <ph id="ph1">&lt;xref:System.Object&gt;</ph> argomento nella relativa rappresentazione di stringa chiamando il relativo <bpt id="p1">**</bpt>ToString (IFormatProvider)<ept id="p1">**</ept> metodo o, se l'oggetto corrispondente elemento di formato include una stringa di formato, chiamando il relativo <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Se questi metodi non esistono, viene chiamato l'oggetto senza parametri <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> metodo.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> o <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than or equal to three.</source>
          <target state="translated">L'indice di un elemento di formato è minore di zero oppure maggiore o uguale a tre.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>Retrieves an object that can iterate through the individual characters in this string.</source>
          <target state="translated">Recupera un oggetto che può eseguire l'iterazione fra i singoli caratteri di questa stringa.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>An enumerator object.</source>
          <target state="translated">Oggetto enumeratore.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>Rather than calling the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</source>
          <target state="translated">Anziché chiamare il metodo di <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> metodo per recuperare un <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> dell'oggetto che è quindi possibile utilizzare l'enumerazione di una stringa, è necessario utilizzare il costrutto di iterazione del linguaggio (in c#, in C + + CLR e in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in C#,                  <bpt id="p2">[</bpt>for each<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C++/CLR, and                  <bpt id="p3">[</bpt>For Each<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</source>
          <target state="translated"><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in c#, <bpt id="p2">[</bpt>per ogni<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C + + CLR, e <bpt id="p3">[</bpt>per ogni<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>This method enables you to iterate the individual characters in a string.</source>
          <target state="translated">Questo metodo consente di scorrere i singoli caratteri in una stringa.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>For example, the Visual Basic <ph id="ph1">`For Each`</ph> and C# <ph id="ph2">`foreach`</ph> statements invoke this method to return a <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> object that can provide read-only access to the characters in this string instance.</source>
          <target state="translated">Ad esempio, Visual Basic <ph id="ph1">`For Each`</ph> e c# <ph id="ph2">`foreach`</ph> istruzioni richiamano questo metodo per restituire un <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> oggetto che può fornire accesso in sola lettura ai caratteri di questa istanza di stringa.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>The following example iterates the characters in several strings and displays information about their individual characters.</source>
          <target state="translated">Nell'esempio seguente scorre i caratteri in diverse stringhe e visualizza le informazioni sui relativi caratteri singoli.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>It uses the language iteration construct rather than a call to the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">Viene utilizzato il costrutto dell'iterazione di linguaggio anziché come una chiamata al <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>Returns the hash code for this string.</source>
          <target state="translated">Restituisce il codice hash di questa stringa.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Codice hash di un intero con segno a 32 bit.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The behavior of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> is dependent on its implementation, which might change from one version of the common language runtime to another.</source>
          <target state="translated">Il comportamento di <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> dipende dalla relativa implementazione, che potrebbe cambiare da una versione di common language runtime.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>A reason why this might happen is to improve the performance of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">È un motivo per cui questa situazione può verificarsi per migliorare le prestazioni di <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>If two string objects are equal, the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method returns identical values.</source>
          <target state="translated">Se due oggetti string specificati sono uguali, il <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> metodo restituisce valori identici.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, there is not a unique hash code value for each unique string value.</source>
          <target state="translated">Tuttavia, non c'è un valore del codice hash univoco per ogni valore di stringa univoco.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Different strings can return the same hash code.</source>
          <target state="translated">Stringhe diverse possono restituire lo stesso codice hash.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The hash code itself is not guaranteed to be stable.</source>
          <target state="translated">Non è necessariamente che il codice hash stabile.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</source>
          <target state="translated">Codice hash per stringhe identiche possono variare tra le versioni di .NET Framework e su più piattaforme (ad esempio 32 bit e 64 bit) per una singola versione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In some cases, they can even differ by application domain.</source>
          <target state="translated">In alcuni casi, possono anche differire dal dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This implies two subsequent runs of the same program may return different hash codes.</source>
          <target state="translated">Ciò implica due esecuzioni successive dello stesso programma possono restituire i codici hash diverso.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</source>
          <target state="translated">Di conseguenza, hash codici non devono mai essere utilizzati di fuori del dominio applicazione in cui sono stati creati, non deve mai essere utilizzati come campi chiave in una raccolta e non deve essere mantenute.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">Infine, non utilizzare il codice hash anziché un valore restituito da una funzione hash di crittografia, se è necessario un hash crittografico.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Per gli hash di crittografia, utilizzare una classe derivata dal <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For more information about hash codes, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sui codici hash, vedere <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In desktop apps, you can use the             <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">Nelle App desktop, è possibile utilizzare il <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt; elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> per generare codice hash univoco in una base di un dominio di applicazione.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">Questo può ridurre il numero di conflitti e migliorare le prestazioni complessive di inserimenti e le ricerche che utilizzano le tabelle hash.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the                <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt; elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a  to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">Definisce un per generare codice hash univoco in una base di un dominio di applicazione.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">Questo può ridurre il numero di conflitti e migliorare le prestazioni complessive di inserimenti e le ricerche che utilizzano le tabelle hash.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the .</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a <ph id="ph1">`DisplayString`</ph> class that includes a private string constant, <ph id="ph2">`s`</ph>, whose value is "This is a string."</source>
          <target state="translated">Definisce un <ph id="ph1">`DisplayString`</ph> classe che include una costante di stringa privata, <ph id="ph2">`s`</ph>, il cui valore è "This is a una stringa".</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also includes a <ph id="ph1">`ShowStringHashCode`</ph> method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</source>
          <target state="translated">Viene inoltre incluso un metodo <ph id="ph1">`ShowStringHashCode`</ph> tramite cui vengono visualizzati il valore stringa e il codice hash con il nome del dominio applicazione in cui il metodo è in esecuzione.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When you run the example without supplying a configuration file, it displays output similar to the following.</source>
          <target state="translated">Quando si esegue l'esempio senza fornire un file di configurazione, restituisce un output analogo al seguente.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Note that the hash codes for the string are identical in the two application domains.</source>
          <target state="translated">Si noti che i codici hash per la stringa sono identici nei due domini applicazione.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</source>
          <target state="translated">Tuttavia, se si aggiunge il file di configurazione seguente alla directory di esempio e, successivamente, si esegue l'esempio, i codici hash per la stessa stringa risulteranno diversi dal dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When the configuration file is present, the example displays the following output:</source>
          <target state="translated">Quando il file di configurazione è presente, l'esempio visualizza il seguente output:</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</source>
          <target state="translated">I codici hash vengono utilizzati per inserire e recuperare gli oggetti con chiavi da tabelle hash in modo efficiente.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, hash codes don't uniquely identify strings.</source>
          <target state="translated">Tuttavia, i codici hash non identificano in modo univoco le stringhe.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</source>
          <target state="translated">Stringhe identiche hanno i codici hash uguali, ma common language runtime può inoltre assegnare lo stesso codice hash di stringhe diverse.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</source>
          <target state="translated">Inoltre, i codici hash possono variare da una versione di .NET Framework, dalla piattaforma all'interno di un'unica versione e dal dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</source>
          <target state="translated">Per questo motivo, è consigliabile non serializzare o mantenere i valori di codice hash, né utilizzare le chiavi in una tabella hash o un dizionario.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For additional information about the use of hash codes and the <ph id="ph1">`GetHashCode`</ph> method, see <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sull'utilizzo dei codici hash e <ph id="ph1">`GetHashCode`</ph> metodo, vedere <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method using various input strings.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> metodo utilizzando diverse stringhe di input.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The value returned by <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> is platform-dependent.</source>
          <target state="translated">Il valore restituito da <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> dipende dalla piattaforma.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It differs on the 32-bit and 64-bit versions of the .NET Framework.</source>
          <target state="translated">La differenza nelle versioni a 32 e 64 bit di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also can differ between versions of the .NET Framework.</source>
          <target state="translated">È anche possibile diverso tra le versioni di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> for class <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Restituisce l'oggetto <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> per la classe <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>The enumerated constant, <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</source>
          <target state="translated">Costante enumerata <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetTypeCode">
          <source>The following example displays the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumerated constant for the <ph id="ph2">&lt;xref:System.String&gt;</ph> type.</source>
          <target state="translated">L'esempio seguente mostra il <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> costante enumerata per il <ph id="ph2">&lt;xref:System.String&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza di un carattere Unicode specificato o di una stringa all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">Il metodo restituisce -1 se la stringa o il carattere non viene trovato nell'istanza.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Carattere Unicode da cercare.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza del carattere Unicode specificato in questa stringa.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se viene trovato il carattere; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>The following example demonstrates how you can search a <ph id="ph1">&lt;xref:System.String&gt;</ph> for a character using the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come cercare un <ph id="ph1">&lt;xref:System.String&gt;</ph> di un carattere utilizzando il <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se viene trovata la stringa; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è 0.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The search begins at the first character position of this instance and continues until the last character position.</source>
          <target state="translated">La ricerca inizia in corrispondenza della posizione del primo carattere contenuto di questa istanza e continua fino all'ultima posizione.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura, se <ph id="ph1">`value`</ph> contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> metodo restituisce sempre 0 (zero) per indicare che è stata trovata la corrispondenza all'inizio dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Solo una delle stringhe contiene un segno meno facoltativo.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, in ogni caso, poiché il segno meno facoltativo è un carattere ignorabile, il risultato è lo stesso come se il segno meno non era state incluse <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</source>
          <target state="translated">Quando si cerca solo un segno, il metodo restituisce 0 (zero) per indicare che ha trovato una corrispondenza all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example searches for the "n" in "animal".</source>
          <target state="translated">Nell'esempio seguente viene eseguita la ricerca di "n" in "animale".</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Because string indexes begin at zero rather than one, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method indicates that the "n" is at position 1.</source>
          <target state="translated">Poiché gli indici di stringa iniziano da zero, anziché uno, il <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> metodo indica che "n" è nella posizione 1.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to determine the starting position of an animal name in a sentence.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo per determinare la posizione iniziale di un nome di polizia di una frase.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>It then uses this position to insert an adjective that describes the animal into the sentence.</source>
          <target state="translated">Questa posizione viene quindi utilizzato per inserire un aggettivo che descrive l'animale nella frase.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Per trovare il primo indice di una sottostringa all'interno di un'istanza di stringa usando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">`comparisonType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Carattere Unicode da cercare.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza del carattere Unicode specificato in questa stringa.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">La ricerca ha inizio alla posizione del carattere specificata.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dall'inizio della stringa se viene trovato il carattere oppure -1 in caso contrario.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Numerazione dell'indice inizia da 0.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Il parametro <ph id="ph1">`startIndex`</ph> può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">La ricerca ha inizio dal <ph id="ph1">`startIndex`</ph> alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of the string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è minore di 0 (zero) o maggiore della lunghezza della stringa.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">La ricerca ha inizio alla posizione del carattere specificata.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Numerazione dell'indice inizia da 0.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Il parametro <ph id="ph1">`startIndex`</ph> può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and continues until the last character position.</source>
          <target state="translated">La ricerca inizia in corrispondenza di <ph id="ph1">`startIndex`</ph> posizione di questa istanza di carattere e continua fino all'ultima posizione.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura, se <ph id="ph1">`value`</ph> contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> metodo restituisce sempre <ph id="ph3">`startIndex`</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" in due stringhe.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</source>
          <target state="translated">Se si esegue l'esempio <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The following example searches for all occurrences of a specified string within a target string.</source>
          <target state="translated">Nell'esempio seguente viene eseguita la ricerca di tutte le occorrenze di una stringa specificata all'interno di una stringa di destinazione.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è minore di 0 (zero) o maggiore della lunghezza di questa stringa.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Per trovare il primo indice di una sottostringa che si verifica dopo una particolare posizione di carattere utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">`comparisonType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di ricerca.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">Un parametro specifica il tipo di ricerca da usare per la stringa specificata.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale stringa viene trovata; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è 0.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro consente di ricercare il <ph id="ph2">`value`</ph> parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Il seguente exampledemonstrates tre overload del <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo che trova la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore valido di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura (ovvero se <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), se <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> metodo restituisce sempre 0 (zero) per indicare che è stata trovata la corrispondenza all'inizio dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Solo una delle stringhe contiene un segno meno facoltativo.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, poiché il segno meno facoltativo è un carattere ignorabile, una ricerca con distinzione delle impostazioni cultura restituisce lo stesso valore che verrebbe restituito se il segno meno non incluse nella stringa di ricerca.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">Una ricerca ordinale, tuttavia, consente di trovare il segno meno facoltativo in una stringa e segnala che è assente correttamente dalla seconda stringa.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Carattere Unicode da cercare.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified character in this instance.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza del carattere specificato in questa istanza.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dall'inizio della stringa se viene trovato il carattere oppure -1 in caso contrario.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">La ricerca inizia in corrispondenza <ph id="ph1">`startIndex`</ph> e continua a <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Il carattere alla <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> non è incluso nella ricerca.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Numerazione dell'indice inizia da 0 (zero).</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Il parametro <ph id="ph1">`startIndex`</ph> può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> o <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è maggiore della lunghezza di questa stringa.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza di questa stringa meno <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Numerazione dell'indice inizia da 0 (zero).</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Il parametro <ph id="ph1">`startIndex`</ph> può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">La ricerca inizia in corrispondenza <ph id="ph1">`startIndex`</ph> e continua a <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Il carattere alla <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> non è incluso nella ricerca.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura, se <ph id="ph1">`value`</ph> contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> metodo restituisce sempre <ph id="ph3">`startIndex`</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dal terzo sesto posizioni dei caratteri in due stringhe.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of the string "he" within a substring of another string.</source>
          <target state="translated">Nell'esempio seguente trova l'indice di tutte le occorrenze della stringa "he" all'interno di una sottostringa di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that the number of characters to be searched must be recalculated for each search iteration.</source>
          <target state="translated">Si noti che per ogni iterazione di ricerca è necessario ricalcolare il numero di caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> o <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è maggiore della lunghezza di questa stringa.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza di questa stringa meno <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>To use the comparison rules of the current culture to perform this operation, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Per utilizzare le regole di confronto della lingua corrente per eseguire questa operazione, chiamare il <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">`comparisonType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di ricerca.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string and the type of search to use for the specified string.</source>
          <target state="translated">I parametri specificano la posizione iniziale della ricerca nella stringa corrente e il tipo di ricerca da usare per la stringa specificata.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Numerazione dell'indice inizia da 0.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Il parametro <ph id="ph1">`startIndex`</ph> può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro consente di ricercare il <ph id="ph2">`value`</ph> parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Il seguente exampledemonstrates tre overload del <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo che trova la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è minore di 0 (zero) o maggiore della lunghezza di questa stringa.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore valido di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura (ovvero se <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), se <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> metodo restituisce sempre <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dalla posizione del carattere terzo in due stringhe.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Il metodo restituisce l'indice del segno meno facoltativo nella prima stringa solo quando esegue un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di ricerca.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</source>
          <target state="translated">I parametri specificano la posizione di ricerca iniziale nella stringa corrente, il numero di caratteri nella stringa corrente in cui eseguire la ricerca e il tipo di ricerca da usare per la stringa specificata.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Numerazione dell'indice inizia da 0 (zero).</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Il parametro <ph id="ph1">`startIndex`</ph> può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">La ricerca inizia in corrispondenza <ph id="ph1">`startIndex`</ph> e continua a <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Il carattere alla <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> non è incluso nella ricerca.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro consente di ricercare il <ph id="ph2">`value`</ph> parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Il seguente exampledemonstrates tre overload del <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo che trova la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> o <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è maggiore della lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza di questa stringa meno <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore valido di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura (ovvero se <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), se <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo restituisce sempre <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dal terzo sesto posizioni dei caratteri in due stringhe.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">Quando esegue un confronto ordinale, tuttavia, trova la sottostringa solo nella prima stringa.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno, ma l'indice di "m" quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Il metodo restituisce l'indice del segno meno facoltativo nella prima stringa solo quando esegue un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Restituisce l'indice della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">Il metodo restituisce -1 se i caratteri nella matrice non vengono trovati nell'istanza.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph>; -1 se non è stato trovato alcun carattere in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">La ricerca di <ph id="ph1">`anyOf`</ph> tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>If <ph id="ph1">`anyOf`</ph> is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</source>
          <target state="translated">Se <ph id="ph1">`anyOf`</ph> è una matrice vuota, il metodo trova una corrispondenza all'inizio della stringa (ovvero, in corrispondenza dell'indice zero).</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The following example finds the first vowel in a string.</source>
          <target state="translated">Nell'esempio seguente vengono vocale prima in una stringa.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">La ricerca ha inizio alla posizione del carattere specificata.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph>; -1 se non è stato trovato alcun carattere in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated">Il <ph id="ph1">`startIndex`</ph> parametro possibile compreso tra 0 e minore della lunghezza dell'istanza di stringa di uno.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">La ricerca ha inizio dal <ph id="ph1">`startIndex`</ph> alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">La ricerca di <ph id="ph1">`anyOf`</ph> tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i rispettivi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</source>
          <target state="translated">Nell'esempio seguente consente di trovare l'indice dell'occorrenza di qualsiasi carattere della stringa "is" all'interno di una sottostringa di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated">il parametro <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è maggiore del numero di caratteri presenti in questa istanza.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph>; -1 se non è stato trovato alcun carattere in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">La ricerca inizia in corrispondenza <ph id="ph1">`startIndex`</ph> e continua a <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Il carattere alla <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> non è incluso nella ricerca.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated">Il <ph id="ph1">`startIndex`</ph> parametro possibile compreso tra 0 e minore della lunghezza dell'istanza di stringa di uno.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">La ricerca di <ph id="ph1">`anyOf`</ph> tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i rispettivi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</source>
          <target state="translated">Nell'esempio seguente viene trovato l'indice dell'occorrenza di qualsiasi carattere della stringa "aid" all'interno di una sottostringa di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> o <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è maggiore del numero di caratteri in questa istanza.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The zero-based index position of the insertion.</source>
          <target state="translated">La posizione dell'indice in base zero dell'inserimento.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The string to insert.</source>
          <target state="translated">Stringa da inserire.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Returns a new string in which a specified string is inserted at a specified index position in this instance.</source>
          <target state="translated">Restituisce una nuova stringa in cui una stringa specificata viene inserita in una posizione di indice specificata in questa istanza.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>A new string that is equivalent to this instance, but with <ph id="ph1">&lt;paramref name="value" /&gt;</ph> inserted at position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Nuova stringa equivalente a questa istanza, ma con <ph id="ph1">&lt;paramref name="value" /&gt;</ph> inserito in corrispondenza della posizione <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to the length of this instance, <ph id="ph2">`value`</ph> is appended to the end of this instance.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale alla lunghezza di questa istanza, <ph id="ph2">`value`</ph> viene aggiunto alla fine di questa istanza.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Instead, it returns a new string in which <ph id="ph1">`value`</ph> is inserted into the current instance.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui <ph id="ph1">`value`</ph> viene inserito nell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>For example, the return value of <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> is "abXYZc".</source>
          <target state="translated">Ad esempio, il valore restituito di <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> è "abXYZc".</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following example inserts a space character in the fourth character position (the character at index 3) of a string.</source>
          <target state="translated">L'esempio seguente inserisce un carattere di spazio nella posizione del quarto carattere (il carattere in corrispondenza dell'indice 3) di una stringa.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following console application prompts the users to enter one or more adjectives to describe two animals.</source>
          <target state="translated">La seguente applicazione console richiede agli utenti di immettere uno o più degli aggettivi per descrivere due animali.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> method to insert the text entered by the user into a string.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> per inserire il testo immesso dall'utente in una stringa.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative or greater than the length of this instance.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è negativo o maggiore della lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>A string to search for in the intern pool.</source>
          <target state="translated">Stringa da cercare nel pool di centralizzazione.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>Retrieves the system's reference to the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Recupera il riferimento del sistema all'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificato.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>The system's reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, if it is interned; otherwise, a new reference to a string with the value of <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">Riferimento del sistema a <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, se è centralizzato; in caso contrario, nuovo riferimento a una stringa con il valore di <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</source>
          <target state="translated">Common language runtime gestisce l'archiviazione delle stringhe mediante una tabella, denominata pool interno, che contiene un solo riferimento a ogni valore letterale stringa univoca dichiarata o creata a livello di codice nel programma.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Consequently, an instance of a literal string with a particular value only exists once in the system.</source>
          <target state="translated">Di conseguenza, un'istanza di una stringa letterale con un valore specifico è presente una sola volta nel sistema.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</source>
          <target state="translated">Ad esempio, se si assegna la stessa stringa letterale a più variabili, il runtime recupera lo stesso riferimento per la stringa letterale dal pool di centralizzazione e assegna a ogni variabile.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method uses the intern pool to search for a string equal to the value of <ph id="ph2">`str`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> metodo utilizza il pool interno per cercare una stringa uguale al valore di <ph id="ph2">`str`</ph>.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If such a string exists, its reference in the intern pool is returned.</source>
          <target state="translated">Se tale stringa esiste, viene restituito il relativo riferimento nel pool di centralizzazione.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If the string does not exist, a reference to <ph id="ph1">`str`</ph> is added to the intern pool, then that reference is returned.</source>
          <target state="translated">Se la stringa non esiste, un riferimento a <ph id="ph1">`str`</ph> viene aggiunto al pool interno, che quindi viene restituito.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</source>
          <target state="translated">Nell'esempio seguente, la stringa s1, che ha un valore "MyTest", è già inserita perché è un valore letterale nel programma.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> class generates a new string object that has the same value as s1.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> classe genera un nuovo oggetto stringa con lo stesso valore di s1.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>A reference to that string is assigned to s2.</source>
          <target state="translated">Un riferimento a tale stringa viene assegnato a s2.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method searches for a string that has the same value as s2.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> metodo cerca una stringa che contiene lo stesso valore di s2.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Because such a string exists, the method returns the same reference that is assigned to s1.</source>
          <target state="translated">Poiché tale stringa esiste, il metodo restituisce lo stesso riferimento assegnato a s1.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>That reference is then assigned to s3.</source>
          <target state="translated">Tale riferimento viene quindi assegnato a s3.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</source>
          <target state="translated">I riferimenti s1 e S2 risultano diversi perché fanno riferimento a oggetti diversi. i riferimenti s1 e s3 risultano uguali perché fanno riferimento alla stessa stringa.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo per confrontare il <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Version Considerations</source>
          <target state="translated">Considerazioni sulla versione</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> metodo verrà ripristinato il comportamento in .NET Framework 1.0 e 1.1 relativamente all'inserimento di una stringa vuota.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the variable <ph id="ph1">`str1`</ph> is assigned a reference to <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, and the variable <ph id="ph3">`str2`</ph> is assigned the reference to <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> that is returned by calling the <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> method after converting a <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> object whose value is <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> to a string.</source>
          <target state="translated">Nell'esempio seguente, la variabile <ph id="ph1">`str1`</ph> viene assegnato un riferimento a <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, mentre la variabile <ph id="ph3">`str2`</ph> è assegnato il riferimento a <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> restituito chiamando il <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> metodo dopo aver convertito un <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>oggetto il cui valore è <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> in una stringa.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Then the references contained in <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph> are compared for equality.</source>
          <target state="translated">Quindi, i riferimenti contenuti <ph id="ph1">`str1`</ph> e <ph id="ph2">`str2`</ph> vengono confrontati per verificarne l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> and <ph id="ph5">`str2`</ph> are equal.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, e <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> e <ph id="ph5">`str2`</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> are not equal.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> e <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> e <ph id="ph4">`str2`</ph> non sono uguali.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Performance Considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</source>
          <target state="translated">Se si sta tentando di ridurre la quantità totale di memoria allocata dall'applicazione, tenere presente che l'inserimento di una stringa ha due effetti collaterali indesiderati.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>First, the memory allocated for interned <ph id="ph1">&lt;xref:System.String&gt;</ph> objects is not likely be released until the common language runtime (CLR) terminates.</source>
          <target state="translated">In primo luogo, la memoria allocata per centralizzati <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetti non viene probabilmente essere rilasciata finché non termina con common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The reason is that the CLR's reference to the interned <ph id="ph1">&lt;xref:System.String&gt;</ph> object can persist after your application, or even your application domain, terminates.</source>
          <target state="translated">Il motivo è che il riferimento del CLR per inserito <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto può persistere anche dopo l'applicazione o persino del dominio applicazione, viene terminato.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Second, to intern a string, you must first create the string.</source>
          <target state="translated">In secondo luogo, per collaterale di una stringa, è innanzitutto necessario creare la stringa.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The memory used by the <ph id="ph1">&lt;xref:System.String&gt;</ph> object must still be allocated, even though the memory will eventually be garbage collected.</source>
          <target state="translated">La memoria utilizzata dal <ph id="ph1">&lt;xref:System.String&gt;</ph> oggetto deve essere comunque allocato, anche se la memoria verrà infine sottoposte a garbage collection.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The .NET Framework version 2.0 introduces the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> enumeration member.</source>
          <target state="translated">.NET Framework versione 2.0 introduce il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> membro di enumerazione.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> member marks an assembly as not requiring string-literal interning.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> membro contrassegna un assembly che non richiedono stringhe letterali.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>You can apply <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> to an assembly using the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> attribute.</source>
          <target state="translated">È possibile applicare <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> a un assembly utilizzando il <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Also, when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to compile an assembly in advance of run time, strings are not interned across modules.</source>
          <target state="translated">Inoltre, quando si utilizza il <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> per compilare un assembly prima della fase di esecuzione, le stringhe non sono inserite in tutti i moduli.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</source>
          <target state="translated">L'esempio seguente usa tre stringhe hanno lo stesso valore per determinare se una stringa appena creata e una stringa inserita sono uguali.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>The string to search for in the intern pool.</source>
          <target state="translated">Stringa da cercare nel pool di centralizzazione.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>Retrieves a reference to a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Recupera un riferimento a un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificato.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>A reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph> if it is in the common language runtime intern pool; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Riferimento a <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, se è presente nel pool di centralizzazione di Common Language Runtime; in caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <ph id="ph1">&lt;xref:System.String&gt;</ph> you add programmatically by calling the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Common language runtime gestisce automaticamente una tabella, denominata pool interno, che contiene una singola istanza di ogni costante di stringa letterale univoca dichiarata in un programma, nonché qualsiasi istanza univoca di <ph id="ph1">&lt;xref:System.String&gt;</ph> per aggiungere a livello di programmazione, chiamare il <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The intern pool conserves string storage.</source>
          <target state="translated">Nel pool di archiviazione di stringhe.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <ph id="ph1">&lt;xref:System.String&gt;</ph> that have identical values.</source>
          <target state="translated">Se si assegna una costante di valore letterale stringa a più variabili, ogni variabile è impostata per fare riferimento alla stessa costante nel pool di centralizzazione invece che fanno riferimento a diverse istanze di <ph id="ph1">&lt;xref:System.String&gt;</ph> che hanno valori identici.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method looks up <ph id="ph1">`str`</ph> in the intern pool.</source>
          <target state="translated">Questo metodo cerca <ph id="ph1">`str`</ph> nel pool di centralizzazione.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been interned, a reference to that instance is returned; otherwise, <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Se <ph id="ph1">`str`</ph> è già stato inserito, un riferimento a tale istanza sia restituito; in caso contrario, <ph id="ph2">`null`</ph> viene restituito.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo per confrontare il <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method does not return a Boolean value.</source>
          <target state="translated">Questo metodo non restituisce un valore booleano.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</source>
          <target state="translated">Se si chiama il metodo perché si vuole che un valore booleano che indica se una determinata stringa è stata inserita, è possibile utilizzare codice analogo al seguente.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to install an assembly to the native image cache on a local computer.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, è possibile eseguire l'override del pool interno quando si utilizza il <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> per installare un assembly nella cache delle immagini native in un computer locale.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>For more information, see Performance Considerations in the Remarks section for the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> property.</source>
          <target state="translated">Per ulteriori informazioni, vedere Considerazioni sulle prestazioni nella sezione Osservazioni per il <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The following example demonstrates that literal strings are interned automatically by the compiler.</source>
          <target state="translated">Nell'esempio seguente viene illustrato che le stringhe letterali vengono inserite automaticamente dal compilatore.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Indicates whether this string is in a particular Unicode normalization form.</source>
          <target state="translated">Specifica se la stringa è in un particolare formato di normalizzazione Unicode.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>Indicates whether this string is in Unicode normalization form C.</source>
          <target state="translated">Specifica se la stringa è nel formato di normalizzazione Unicode C.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in normalization form C; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se la stringa è in formato di normalizzazione C; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework supporta attualmente i formati di normalizzazione C, D, KC e KD.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per una descrizione dei formati di normalizzazione Unicode, vedere <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The following example determines whether a string is successfully normalized to various normalization forms.</source>
          <target state="translated">Nell'esempio seguente determina se una stringa è normalizzata correttamente in varie forme di normalizzazione.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">L'istanza corrente contiene caratteri Unicode non validi.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph> non appena viene rilevato il primo carattere non normalizzato in una stringa.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> metodo genererà un' <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Sebbene <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Formato di normalizzazione Unicode.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Indicates whether this string is in the specified Unicode normalization form.</source>
          <target state="translated">Specifica se la stringa è nel formato di normalizzazione Unicode indicato.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in the normalization form specified by the <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph> parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se la stringa è nel formato di normalizzazione specificato dal parametro <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework supporta attualmente i formati di normalizzazione C, D, KC e KD.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per una descrizione dei formati di normalizzazione Unicode, vedere <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">L'istanza corrente contiene caratteri Unicode non validi.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph> non appena viene rilevato il primo carattere non normalizzato in una stringa.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> metodo genererà un' <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Sebbene <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The string to test.</source>
          <target state="translated">Stringa da testare.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Indicates whether the specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> string.</source>
          <target state="translated">Indica se la stringa specificata è <ph id="ph1">&lt;see langword="null" /&gt;</ph> o una stringa <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una stringa vuota (""); in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> is a convenience method that enables you to simultaneously test whether a <ph id="ph2">&lt;xref:System.String&gt;</ph> is <ph id="ph3">`null`</ph> or its value is <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> è un metodo pratico che consente di testare simultaneamente se un <ph id="ph2">&lt;xref:System.String&gt;</ph> è <ph id="ph3">`null`</ph> o il relativo valore è <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">È equivalente al codice seguente:</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method to test whether a string is <ph id="ph2">`null`</ph>, its value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>,  or it consists only of white-space characters.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> metodo per verificare se è una stringa <ph id="ph2">`null`</ph>, il relativo valore è <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, o è costituito solo da spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is a null string?</source>
          <target state="translated">Che cos'è una stringa null?</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is <ph id="ph1">`null`</ph> if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of <ph id="ph2">`null`</ph>.</source>
          <target state="translated">È una stringa <ph id="ph1">`null`</ph> se non è stato assegnato un valore (in C++ e Visual Basic) o in modo esplicito è stato assegnato un valore di <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Although the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">Sebbene il <bpt id="p1">[</bpt>formattazione composita<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> funzionalità è possibile gestire correttamente una stringa null, come illustrato nell'esempio seguente, il tentativo di chiamare uno se i relativi membri genera un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is an empty string?</source>
          <target state="translated">Che cos'è una stringa vuota?</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is empty if it  is explicitly assigned an empty string ("") or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Una stringa è vuota se è stato assegnato in modo esplicito una stringa vuota ("") o <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>An empty string has a <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> of 0.</source>
          <target state="translated">Una stringa vuota è un <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> pari a 0.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example creates an empty string and displays its value and its length.</source>
          <target state="translated">Nell'esempio seguente crea una stringa vuota e visualizza il relativo valore e la relativa lunghezza.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example examines three strings and determines whether each string has a value, is an empty string, or is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Nell'esempio seguente vengono esaminati tre stringhe e determina se ogni stringa è un valore, è una stringa vuota o è <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The string to test.</source>
          <target state="translated">Stringa da testare.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>Indicates whether a specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, empty, or consists only of white-space characters.</source>
          <target state="translated">Indica se una stringa specificata è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, vuota o è composta solo da spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="value" /&gt;</ph> consists exclusively of white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph> oppure se <ph id="ph5">&lt;paramref name="value" /&gt;</ph> è composto solo da spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> is a convenience method that is similar to the following  code, except that it offers superior performance:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> è un metodo pratico che è simile al codice seguente, ad eccezione del fatto che offre prestazioni migliori:</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method interprets any character that returns a value of <ph id="ph2">`true`</ph> when it is passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method as a white-space character.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> metodo interpreta qualsiasi carattere che restituisce un valore di <ph id="ph2">`true`</ph> quando viene passato per il <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo come un carattere di spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The following example creates a string array, and then passes each element of the array to the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente crea una matrice di stringhe e quindi passa ogni elemento della matrice di <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</source>
          <target state="translated">Concatena gli elementi di una matrice specificata o i membri di una raccolta, usando tra gli elementi o i membri il separatore specificato.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">Stringa da usare come separatore. <bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> è incluso nella stringa restituita solo se <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> ha più di un elemento.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection that contains the strings to concatenate.</source>
          <target state="translated">Raccolta che contiene le stringhe da concatenare.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>, using the specified separator between each member.</source>
          <target state="translated">Concatena i membri di una raccolta <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> costruita di tipo <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>, usando tra i membri il separatore specificato.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Stringa costituita dai membri di <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimitati dalla stringa <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="values" /&gt;</ph> non dispone di membri, il metodo restituisce <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Se <ph id="ph1">`separator`</ph> è <ph id="ph2">`null`</ph>, una stringa vuota (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) viene invece utilizzato.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Se qualsiasi membro del <ph id="ph1">`values`</ph> è <ph id="ph2">`null`</ph>, invece, viene utilizzata una stringa vuota.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> è un metodo pratico che consente di concatenare ogni elemento in un <ph id="ph2">`IEnumerable(Of String)`</ph> insieme senza prima di convertire gli elementi in una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">È particolarmente utile con le espressioni di query Language-Integrated Query (LINQ).</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">Nell'esempio seguente viene passato un <ph id="ph1">`List(Of String)`</ph> oggetto contenente le lettere maiuscole o minuscole dell'alfabeto in un'espressione lambda che consente di selezionare lettere uguale a o maggiore di una determinata lettera (ovvero, nell'esempio, "M").</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated">Il <ph id="ph1">`IEnumerable(Of String)`</ph> raccolta restituita dal <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> viene passato per il <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> metodo per visualizzare il risultato come stringa singola.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Assegna il risultato a un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> oggetto di tipo <ph id="ph2">&lt;xref:System.String&gt;</ph>, che passa quindi il <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string to use as a separator.</source>
          <target state="translated">Stringa da usare come separatore.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> è incluso nella stringa restituita solo se <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> ha più di un elemento.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Matrice contenente gli elementi da concatenare.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>Concatenates the elements of an object array, using the specified separator between each element.</source>
          <target state="translated">Concatena gli elementi di una matrice di oggetti, usando tra gli elementi il separatore specificato.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A string that consists of the elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Stringa costituita dagli elementi di <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimitati dalla stringa <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="values" /&gt;</ph> è una matrice vuota, il metodo restituisce <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph> or if any element of <ph id="ph3">`values`</ph> other than the first element is <ph id="ph4">`null`</ph>, an empty string (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Se <ph id="ph1">`separator`</ph> è <ph id="ph2">`null`</ph> o se qualsiasi elemento di <ph id="ph3">`values`</ph> è superiore al primo elemento <ph id="ph4">`null`</ph>, una stringa vuota (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) viene invece utilizzato.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>See the Notes for Callers section if the first element of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vedere la sezione Note per i chiamanti se il primo elemento della <ph id="ph1">`values`</ph> è <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> è un metodo pratico che consente di concatenare ogni elemento in una matrice di oggetti senza conversione in modo esplicito gli elementi in stringhe.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string representation of each object in the array is derived by calling that object's <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">La rappresentazione di stringa di ogni oggetto nella matrice è derivata mediante la chiamata di tale oggetto <ph id="ph1">`ToString`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>It assigns the result to a integer array, which it then passes to the <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Assegna il risultato a una matrice di interi, passa quindi il <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If the first element of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> method does not concatenate the elements in <ph id="ph4">&lt;paramref name="values" /&gt;</ph> but instead returns <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se il primo elemento della <ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> metodo concatenare gli elementi in <ph id="ph4">&lt;paramref name="values" /&gt;</ph> ma restituisce <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A number of workarounds for this issue are available.</source>
          <target state="translated">Un numero di possibili soluzioni al problema è disponibile.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The easiest is to assign a value of <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> to the first element of the array, as the following example shows.</source>
          <target state="translated">Il metodo più semplice consiste nell'assegnare un valore di <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> al primo elemento della matrice, come nell'esempio seguente viene illustrato.</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>The string to use as a separator.</source>
          <target state="translated">Stringa da usare come separatore.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> è incluso nella stringa restituita solo se <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> ha più di un elemento.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Matrice contenente gli elementi da concatenare.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>Concatenates all the elements of a string array, using the specified separator between each element.</source>
          <target state="translated">Concatena tutti gli elementi di una matrice di stringhe, usando tra gli elementi il separatore specificato.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>A string that consists of the elements in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Stringa costituita dagli elementi di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimitati dalla stringa <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è una matrice vuota, il metodo restituisce <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value)`</ph> returns "apple, orange, grape, pear".</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`separator`</ph> è "," e gli elementi di <ph id="ph2">`value`</ph> sono "apple", "arancione", "uva" e "pera", <ph id="ph3">`Join(separator, value)`</ph> restituisce "apple, arancione, uva, pera".</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Se <ph id="ph1">`separator`</ph> è <ph id="ph2">`null`</ph>, una stringa vuota (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) viene invece utilizzato.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Se qualsiasi elemento in <ph id="ph1">`value`</ph> è <ph id="ph2">`null`</ph>, invece, viene utilizzata una stringa vuota.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The string to use as a separator.</source>
          <target state="translated">Stringa da usare come separatore.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> è incluso nella stringa restituita solo se <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> ha più di un elemento.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Matrice contenente gli elementi da concatenare.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The first element in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Primo elemento di <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> da usare.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The number of elements of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Numero di elementi di <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> da usare.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Concatenates the specified elements of a string array, using the specified separator between each element.</source>
          <target state="translated">Concatena gli elementi specificati di una matrice di stringhe, usando tra gli elementi il separatore specificato.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>A string that consists of the strings in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Stringa costituita dalle stringhe di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimitate dalla stringa <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> has no elements, or <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> and all the elements of <ph id="ph5">&lt;paramref name="value" /&gt;</ph> are <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> se <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è zero, se <ph id="ph3">&lt;paramref name="value" /&gt;</ph> non ha elementi o se <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> e tutti gli elementi di <ph id="ph5">&lt;paramref name="value" /&gt;</ph> sono <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> returns "orange, grape".</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`separator`</ph> è "," e gli elementi di <ph id="ph2">`value`</ph> sono "apple", "arancione", "uva" e "pera", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> restituisce "arancione, uva".</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Se <ph id="ph1">`separator`</ph> è <ph id="ph2">`null`</ph>, una stringa vuota (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) viene invece utilizzato.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Se qualsiasi elemento in <ph id="ph1">`value`</ph> è <ph id="ph2">`null`</ph>, invece, viene utilizzata una stringa vuota.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The following example concatenates two elements from an array of names of fruit.</source>
          <target state="translated">Nell'esempio seguente consente di concatenare due elementi da una matrice di nomi di frutta.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">La somma di <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è maggiore del numero di elementi in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Out of memory.</source>
          <target state="translated">Memoria insufficiente.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo dei membri di <bpt id="p1">&lt;c&gt;</bpt>valori<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">Stringa da usare come separatore. <bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> è incluso nella stringa restituita solo se <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> ha più di un elemento.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A collection that contains the objects to concatenate.</source>
          <target state="translated">Raccolta che contiene gli oggetti da concatenare.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of a collection, using the specified separator between each member.</source>
          <target state="translated">Concatena i membri di una raccolta, usando tra i membri il separatore specificato.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Stringa costituita dai membri di <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimitati dalla stringa <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="values" /&gt;</ph> non dispone di membri, il metodo restituisce <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Se <ph id="ph1">`separator`</ph> è <ph id="ph2">`null`</ph>, una stringa vuota (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) viene invece utilizzato.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Se qualsiasi membro del <ph id="ph1">`values`</ph> è <ph id="ph2">`null`</ph>, invece, viene utilizzata una stringa vuota.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each member of an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting them to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> è un metodo pratico che consente di concatenare ogni membro di un <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> insieme senza prima convertirli in stringhe.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">La rappresentazione di stringa di ogni oggetto di <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> raccolta derivata mediante la chiamata di tale oggetto <ph id="ph2">`ToString`</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>This method is particular useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Questo metodo è determinato utile con le espressioni di query Language-Integrated Query (LINQ).</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>For example, the following code defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">Ad esempio, il codice seguente definisce un semplice <ph id="ph1">`Animal`</ph> classe che contiene il nome di un animale e l'ordine a cui appartiene.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object that contains a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">Definisce quindi un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> oggetto che contiene un numero di <ph id="ph2">`Animal`</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> viene chiamato il metodo di estensione per estrarre il <ph id="ph2">`Animal`</ph> oggetti la cui proprietà <ph id="ph3">`Order`</ph> proprietà è uguale a "Roditori".</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">Il risultato viene passato per il <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type integer, which it then passes to the <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">Assegna il risultato a un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> oggetto di tipo integer, che passa quindi il <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato o di una stringa all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">Il metodo restituisce -1 se la stringa o il carattere non viene trovato nell'istanza.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Carattere Unicode da cercare.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se viene trovato il carattere; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Questo metodo inizia la ricerca dalla posizione dell'ultimo carattere di questa istanza e continua all'indietro verso l'inizio fino a quando non <ph id="ph1">`value`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The search is case-sensitive.</source>
          <target state="translated">La ricerca prevede la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The following example defines an <ph id="ph1">`ExtractFilename`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> method to find the last directory separator character in a string and to extract the string's file name.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`ExtractFilename`</ph> metodo che utilizza il <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> metodo per trovare l'ultimo carattere separatore di directory in una stringa e per estrarre il nome del file della stringa.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>If the file exists, the method returns the file name without its path.</source>
          <target state="translated">Se il file esiste, il metodo restituisce il nome del file senza il relativo percorso.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione iniziale nell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se viene trovata la stringa; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è l'ultima posizione dell'indice in questa istanza.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">La ricerca inizia in corrispondenza di questa istanza l'ultima posizione di carattere e continua all'indietro verso l'inizio fino a quando non <ph id="ph1">`value`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura, se <ph id="ph1">`value`</ph> contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method always returns <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> metodo restituisce sempre <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, che rappresenta l'ultima posizione di indice nell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Solo una delle stringhe contiene un segno meno facoltativo.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, in ogni caso, poiché il segno meno facoltativo è un carattere ignorabile, il risultato è lo stesso come se il segno meno non era state incluse <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 6 and 5.</source>
          <target state="translated">Quando si cerca solo un segno, il metodo restituisce 6 e 5.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>These values correspond to the index of the last character in the two strings.</source>
          <target state="translated">Questi valori corrispondono all'indice dell'ultimo carattere nelle due stringhe.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</source>
          <target state="translated">Nell'esempio seguente rimuove i tag HTML da una stringa, se i tag di iniziano e fine della stringa.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If a string ends with a closing bracket character ("&gt;"), the example uses the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to locate the start of the end tag.</source>
          <target state="translated">Se una stringa termina con una chiusura parentesi ("&gt;"), nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo per individuare l'inizio del tag di fine.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per trovare l'ultimo indice di una sottostringa all'interno di un'istanza di stringa usando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Carattere Unicode da cercare.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale carattere viene trovato oppure –1 se non viene trovato o se l'istanza corrente è uguale a <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.This method begins searching at the <ph id="ph2">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning of the current instance until either <ph id="ph3">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> -1. questo metodo inizia la ricerca di <ph id="ph2">`startIndex`</ph> posizione di questa istanza e procede a ritroso verso l'inizio dell'istanza corrente fino al carattere <ph id="ph3">`value`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`startIndex`</ph> è <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, il metodo esegue ricerche in ogni carattere dall'ultimo carattere della stringa all'inizio.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">La ricerca prevede la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</source>
          <target state="translated">Nell'esempio seguente trova l'indice di tutte le occorrenze di un carattere in una stringa, a partire dalla fine della stringa all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è minore di zero oppure maggiore o uguale alla lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice iniziale in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito sarà il più piccolo tra <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e l'ultima posizione dell'indice in questa istanza.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">La ricerca inizia in corrispondenza di <ph id="ph1">`startIndex`</ph> posizione di questa istanza e procede a ritroso verso l'inizio fino al carattere <ph id="ph2">`value`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`startIndex`</ph> è <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, il metodo esegue ricerche in ogni carattere dall'ultimo carattere della stringa all'inizio.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura, se <ph id="ph1">`value`</ph> contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> metodo restituisce sempre <ph id="ph3">`startIndex`</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> metodo viene utilizzato per trovare una sottostringa che include un segno meno facoltativo (U + 00AD) e che precede o che include la "m" finale in una stringa.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versione successiva, perché viene ignorato il segno meno facoltativo nella stringa di ricerca, la chiamata al metodo per trovare una sottostringa che include il segno meno facoltativo e "m" restituisce la posizione di "m" nella stringa, mentre questo viene chiamato per trovare un substrin g che include il segno meno facoltativo e "n" restituisce la posizione di "n".</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Quando la stringa di ricerca contiene solo il segno, il metodo restituisce l'indice di "m", che rappresenta il valore di <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</source>
          <target state="translated">Nell'esempio seguente trova l'indice di tutte le occorrenze di una stringa nella stringa di destinazione, a partire dalla fine della stringa di destinazione fino all'inizio della stringa di destinazione.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è minore di zero oppure maggiore della lunghezza dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">L'istanza corrente equivale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è minore di -1 o maggiore di zero.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per trovare l'indice di una sottostringa che precede una particolare posizione di carattere utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di ricerca.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce l'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">Un parametro specifica il tipo di ricerca da usare per la stringa specificata.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">Posizione iniziale dell'indice in base zero del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale stringa viene trovata; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito è l'ultima posizione dell'indice in questa istanza.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro consente di ricercare il <ph id="ph2">`value`</ph> parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">La ricerca inizia in corrispondenza di questa istanza l'ultima posizione di carattere e continua all'indietro verso l'inizio fino a quando non <ph id="ph1">`value`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Il seguente exampledemonstrates tre overload del <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore valido di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura (ovvero se <ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), se <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> metodo restituisce sempre <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, che rappresenta l'ultima posizione di indice nell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Solo una delle stringhe contiene un segno meno facoltativo.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o versioni successive, poiché il segno meno facoltativo è un carattere ignorabile, una ricerca con distinzione delle impostazioni cultura restituisce lo stesso valore che verrebbe restituito se il segno meno non incluse nella stringa di ricerca.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">Una ricerca ordinale, tuttavia, consente di trovare il segno meno facoltativo in una stringa e segnala che è assente correttamente dalla seconda stringa.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Carattere Unicode da cercare.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza del carattere Unicode specificato in una sottostringa all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale carattere viene trovato oppure –1 se non viene trovato o se l'istanza corrente è uguale a <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward toward the beginning of this instance until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Questo metodo inizia la ricerca di <ph id="ph1">`startIndex`</ph> i caratteri di posizione e procede a ritroso verso l'inizio di questa istanza fino a quando non <ph id="ph2">`value`</ph> viene trovato o <ph id="ph3">`count`</ph> sono state esaminate le posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`startIndex`</ph> è <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, il metodo esegue la ricerca all'indietro <ph id="ph3">`count`</ph> l'ultimo carattere nella stringa di caratteri.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">La ricerca prevede la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i rispettivi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">Nell'esempio seguente trova l'indice di tutte le occorrenze di un carattere in una sottostringa, a partire dalla fine della sottostringa all'inizio della sottostringa.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è minore di zero oppure maggiore o uguale alla lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 è minore di zero.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice iniziale in base zero di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito sarà il più piccolo tra <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e l'ultima posizione dell'indice in questa istanza.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">La ricerca inizia in corrispondenza di <ph id="ph1">`startIndex`</ph> posizione di questa istanza e procede a ritroso verso l'inizio fino al carattere <ph id="ph2">`value`</ph> viene trovato o <ph id="ph3">`count`</ph> sono state esaminate le posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`startIndex`</ph> è <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, il metodo esegue la ricerca all'indietro <ph id="ph3">`count`</ph> l'ultimo carattere nella stringa di caratteri.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura, se <ph id="ph1">`value`</ph> contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo restituisce sempre <ph id="ph3">`startIndex`</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) nei due caratteri che precedono l'elemento finale "m" di due stringhe.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">Nell'esempio seguente trova l'indice di tutte le occorrenze di una stringa in una sottostringa, a partire dalla fine della sottostringa all'inizio della sottostringa.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è maggiore della lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 specifies a position that is not within this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 specifica una posizione non inclusa in questa istanza.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">L'istanza corrente equivale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="start" /&gt;</ph> è minore di -1 o maggiore di zero.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">L'istanza corrente equivale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è maggiore di 1.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>To perform this operation by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per eseguire questa operazione utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di ricerca.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce l'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">Un parametro specifica il tipo di confronto da effettuare durante la ricerca della stringa specificata.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice iniziale in base zero del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito sarà il più piccolo tra <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e l'ultima posizione dell'indice in questa istanza.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">La ricerca inizia in corrispondenza di <ph id="ph1">`startIndex`</ph> i caratteri di posizione e procede a ritroso fino a quando non <ph id="ph2">`value`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`startIndex`</ph> è <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, il metodo esegue ricerche in ogni carattere dall'ultimo carattere della stringa all'inizio.</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro consente di ricercare il <ph id="ph2">`value`</ph> parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Il seguente exampledemonstrates tre overload del <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è minore di zero oppure maggiore della lunghezza dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">L'istanza corrente equivale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è minore di -1 o maggiore di zero.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore valido di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura (ovvero se <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), se <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> metodo restituisce sempre <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m", a partire da "m" finale in due stringhe.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Il metodo restituisce l'indice del segno meno facoltativo nella prima stringa solo quando esegue un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Stringa da cercare.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica le regole di ricerca.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</source>
          <target state="translated">La ricerca inizia in una posizione del carattere specificata e continua all'indietro verso l'inizio della stringa per il numero di posizioni dei caratteri indicato.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">Un parametro specifica il tipo di confronto da effettuare durante la ricerca della stringa specificata.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice iniziale in base zero del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, il valore restituito sarà il più piccolo tra <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e l'ultima posizione dell'indice in questa istanza.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">La ricerca inizia in corrispondenza di <ph id="ph1">`startIndex`</ph> i caratteri di posizione e procede a ritroso fino a quando non <ph id="ph2">`value`</ph> viene trovato o <ph id="ph3">`count`</ph> sono state esaminate le posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`startIndex`</ph> è <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, il metodo esegue la ricerca all'indietro <ph id="ph3">`count`</ph> l'ultimo carattere nella stringa di caratteri.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Il <ph id="ph1">`comparisonType`</ph> parametro consente di ricercare il <ph id="ph2">`value`</ph> parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Il seguente exampledemonstrates tre overload del <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> metodo trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> è maggiore della lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e il risultato di <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> specifica una posizione non inclusa in questa istanza.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">L'istanza corrente equivale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="start" /&gt;</ph> è minore di -1 o maggiore di zero.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">L'istanza corrente equivale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è maggiore di 1.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore valido di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">In una ricerca dipendente dalle impostazioni cultura (ovvero se <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), se <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è composta solo da uno o più caratteri ignorabili, il <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo restituisce sempre <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</source>
          <target state="translated">Nell'esempio seguente, il <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguito da una "m" in tutti, ma la posizione del primo carattere prima di "m" finale in due stringhe.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Solo una delle stringhe contiene la sottostringa richiesta.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Se viene eseguito l'esempio di <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">Quando esegue un confronto ordinale, tuttavia, trova la sottostringa solo nella prima stringa.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno, ma l'indice di "m" quando si esegue un confronto con distinzione delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Il metodo restituisce l'indice del segno meno facoltativo nella prima stringa solo quando esegue un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">Il metodo restituisce -1 se i caratteri nella matrice non vengono trovati nell'istanza.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph>; -1 se non è stato trovato alcun carattere in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph1">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Questo metodo inizia la ricerca dalla posizione dell'ultimo carattere di questa istanza e continua all'indietro verso l'inizio fino a un carattere nel <ph id="ph1">`anyOf`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The search is case-sensitive.</source>
          <target state="translated">La ricerca prevede la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within another string.</source>
          <target state="translated">Nell'esempio seguente consente di trovare l'indice dell'ultima occorrenza di qualsiasi carattere nella stringa "is" all'interno di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph>; -1 se non è stato trovato alcun carattere in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> oppure se l'istanza corrente è uguale a <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Questo metodo inizia la ricerca di <ph id="ph1">`startIndex`</ph> posizione di questa istanza e procede a ritroso verso l'inizio fino a un carattere nel carattere <ph id="ph2">`anyOf`</ph> viene trovato o viene esaminata la posizione del primo carattere.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">La ricerca prevede la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</source>
          <target state="translated">Nell'esempio seguente consente di trovare l'indice dell'ultima occorrenza di qualsiasi carattere nella stringa "is" all'interno di una sottostringa di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> specifica una posizione non inclusa in questa istanza.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Posizione iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">La ricerca procede da <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> verso l'inizio dell'istanza.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Numero di posizioni dei caratteri da esaminare.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph>; -1 se non è stato trovato alcun carattere in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> oppure se l'istanza corrente è uguale a <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Numerazione dell'indice inizia da zero.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Questo metodo inizia la ricerca di <ph id="ph1">`startIndex`</ph> posizione di questa istanza e procede a ritroso verso l'inizio fino a un carattere nel carattere <ph id="ph2">`anyOf`</ph> viene trovato o <ph id="ph3">`count`</ph> sono state esaminate le posizioni dei caratteri.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">La ricerca prevede la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</source>
          <target state="translated">Nell'esempio seguente viene trovato l'indice dell'ultima occorrenza di qualsiasi carattere della stringa "Aid" all'interno di una sottostringa di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> or <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> o <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> minus <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">L'istanza corrente non è uguale a <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> e il risultato dell'operazione <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> meno <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 è minore di zero.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="P:System.String.Length">
          <source>Gets the number of characters in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Ottiene il numero di caratteri nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The number of characters in the current string.</source>
          <target state="translated">Numero di caratteri nella stringa corrente.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in this instance, not the number of Unicode characters.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> proprietà restituisce il numero di <ph id="ph2">&lt;xref:System.Char&gt;</ph> oggetti in questa istanza, non il numero di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The reason is that a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Il motivo è che un carattere Unicode può essere rappresentato da più <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with each Unicode character instead of each <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> classe per funzionare con ogni carattere Unicode anziché ogni <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In some languages, such as C and C++, a null character indicates the end of a string.</source>
          <target state="translated">In alcune lingue, ad esempio C e C++, un carattere null indica la fine di una stringa.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In the .NET Framework, a null character can be embedded in a string.</source>
          <target state="translated">In .NET Framework, un carattere null possono essere incorporato in una stringa.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>When a string includes one or more null characters, they are included in the length of the total string.</source>
          <target state="translated">Quando una stringa include uno o più caratteri null, queste vengono incluse nella lunghezza della stringa totale.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>For example, in the following string, the substrings "abc" and "def" are separated by a null character.</source>
          <target state="translated">Ad esempio, nella stringa di seguito, le sottostringhe "abc" e "def" sono separati da un carattere null.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> proprietà restituisce 7, a indicare che include i sei caratteri alfabetici, nonché il carattere null.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string whose binary representation is in a particular Unicode normalization form.</source>
          <target state="translated">Restituisce una nuova stringa la cui rappresentazione binaria è in un formato di normalizzazione Unicode specifico.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</source>
          <target state="translated">Restituisce una nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode C.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</source>
          <target state="translated">Nuova stringa normalizzata il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode C.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">Uno dei punti di codice seguente, ad esempio, può rappresentare la lettera "ắ":</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+1EAF</source>
          <target state="translated">U+1EAF</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0103 U+0301</source>
          <target state="translated">U+0103 U+0301</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U+0061 U+0306 U+0301</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</source>
          <target state="translated">.NET Framework supporta quattro forme di normalizzazione (C, D, KC e KD) che sono definite dallo standard Unicode. Quando due stringhe sono rappresentate nello stesso formato di normalizzazione, theycan essere confrontati utilizzando il confronto ordinale.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">Per normalizzare e confrontare due stringhe, eseguire le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">Ottenere le stringhe da confrontare da un'origine di input, ad esempio un file o un dispositivo di input dell'utente.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> method to normalize the strings to normalization form C.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> metodo normalizzare le stringhe di formato di normalizzazione Unicode C.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">Per confrontare due stringhe, chiamare un metodo che supporta il confronto ordinale tra stringhe, ad esempio il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> (metodo), quindi specificare un valore di <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> come il <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argomento.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ordinare una matrice di stringhe normalizzate, passare un <ph id="ph1">`comparer`</ph> valore <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> a un overload appropriato del <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">Generare le stringhe nell'output ordinato in base all'ordine indicato nel passaggio precedente.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per una descrizione dei formati di normalizzazione Unicode, vedere <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">Nell'esempio seguente una stringa in ognuno dei quattro normalizzazione Normalizza, conferma che la stringa di formato di normalizzazione specificato e quindi vengono elencati i punti di codice nella stringa normalizzata.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">L'istanza corrente contiene caratteri Unicode non validi.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph> non appena viene rilevato il primo carattere non normalizzato in una stringa.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> metodo genererà un' <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Sebbene <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Formato di normalizzazione Unicode.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</source>
          <target state="translated">Restituisce una nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode specificato.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph> parameter.</source>
          <target state="translated">Nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione specificato nel parametro <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">.NET Framework supporta quattro forme di normalizzazione (C, D, KC e KD) che sono definite dallo standard Unicode. Quando due stringhe sono rappresentate nel formato di normalizzazione stesso, gli possono essere confrontati utilizzando il confronto ordinale.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">Per normalizzare e confrontare due stringhe, eseguire le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">Ottenere le stringhe da confrontare da un'origine di input, ad esempio un file o un dispositivo di input dell'utente.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> method to normalize the strings to a specified normalization form.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> metodo normalizzare le stringhe in un formato di normalizzazione specificato.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">Per confrontare due stringhe, chiamare un metodo che supporta il confronto ordinale tra stringhe, ad esempio il <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> (metodo), quindi specificare un valore di <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> come il <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argomento.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ordinare una matrice di stringhe normalizzate, passare un <ph id="ph1">`comparer`</ph> valore <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> a un overload appropriato del <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">Generare le stringhe nell'output ordinato in base all'ordine indicato nel passaggio precedente.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per una descrizione dei formati di normalizzazione Unicode, vedere <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">Nell'esempio seguente una stringa in ognuno dei quattro normalizzazione Normalizza, conferma che la stringa di formato di normalizzazione specificato e quindi vengono elencati i punti di codice nella stringa normalizzata.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">L'istanza corrente contiene caratteri Unicode non validi.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Il <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph> non appena viene rilevato il primo carattere non normalizzato in una stringa.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method may throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> metodo potrebbe generare un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Sebbene <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Prima stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Seconda stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Determines whether two specified strings have the same value.</source>
          <target state="translated">Determina se due stringhe specificate hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore di <ph id="ph2">&lt;paramref name="a" /&gt;</ph> è uguale al valore di <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> metodo definisce il funzionamento dell'operatore di uguaglianza per il <ph id="ph2">&lt;xref:System.String&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>It enables code such as that shown in the Example section.</source>
          <target state="translated">Consente di codice, ad esempio illustrato nella sezione esempio.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The operator, in turn, calls the static <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">L'operatore, chiama a sua volta, il metodo statico <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> metodo, che esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the equality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method.</source>
          <target state="translated">Il compilatore Visual Basic non risolve l'operatore di uguaglianza come una chiamata al <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Instead, the equality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'operatore di uguaglianza esegue invece il wrapping di una chiamata al <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The following example demonstrates the equality operator.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'operatore di uguaglianza.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Prima stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Seconda stringa da confrontare o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Determines whether two specified strings have different values.</source>
          <target state="translated">Determina se due stringhe specificate hanno valori diversi.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is different from the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore del parametro <ph id="ph2">&lt;paramref name="a" /&gt;</ph> è diverso dal valore del parametro <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> metodo definisce il funzionamento dell'operatore di disuguaglianza per la <ph id="ph2">&lt;xref:System.String&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>It enables code such as that shown in the Examples section.</source>
          <target state="translated">Consente di codice, ad esempio illustrato nella sezione esempi.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> operator in turn calls the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> operatore a sua volta chiama il metodo statico <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> metodo, che esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the inequality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method.</source>
          <target state="translated">Il compilatore Visual Basic non risolve l'operatore di disuguaglianza come una chiamata al <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Instead, the inequality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'operatore di disuguaglianza esegue invece il wrapping di una chiamata al <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The following example demonstrates the inequality operator.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'operatore di disuguaglianza.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">Restituisce una nuova stringa di lunghezza specificata in cui la parte iniziale della stringa corrente viene riempita con spazi o con un carattere Unicode specificato.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</source>
          <target state="translated">Restituisce una nuova stringa che allinea a destra i caratteri in questa istanza mediante l'aggiunta a sinistra di un numero di spazi tale da ottenere la lunghezza totale specificata.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Nuova stringa equivalente a questa istanza, ma allineata a destra mediante l'aggiunta a sinistra di un numero di spazi tale da ottenere la lunghezza <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Tuttavia, se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Spazio Unicode è definito come 0x0020 esadecimale.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> metodo riempie l'inizio della stringa restituita.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte destra della stringa.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>Instead, it returns a new string that is padded with leading white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa che viene riempita con spazi vuoti iniziali in modo che la lunghezza totale è <ph id="ph1">`totalWidth`</ph> caratteri.</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Carattere di riempimento Unicode.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</source>
          <target state="translated">Restituisce una nuova stringa che allinea a destra i caratteri in questa istanza mediante l'aggiunta a sinistra di una sequenza di elementi pari al carattere Unicode specificato, in modo da ottenere la lunghezza totale specificata.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Nuova stringa equivalente a questa istanza, ma allineata a destra mediante l'aggiunta a sinistra di un numero di caratteri <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> tale da ottenere la lunghezza <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Tuttavia, se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> metodo riempie l'inizio della stringa restituita.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte destra della stringa.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with leading <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa che viene riempita con iniziali <ph id="ph1">`paddingChar`</ph> caratteri in modo che la lunghezza totale è <ph id="ph2">`totalWidth`</ph> caratteri.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">Restituisce una nuova stringa di lunghezza specificata in cui la parte finale della stringa corrente è riempita con spazi o con una sequenza di elementi pari a un carattere Unicode specificato.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</source>
          <target state="translated">Restituisce una nuova stringa che allinea a sinistra i caratteri in questa stringa mediante l'aggiunta a destra di un numero di spazi tale da ottenere la lunghezza totale specificata.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Nuova stringa equivalente a questa istanza, ma allineata a sinistra mediante l'aggiunta a destra di un numero di spazi tale da ottenere la lunghezza <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Tuttavia, se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Spazio Unicode è definito come 0x0020 esadecimale.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> metodo riempie la fine della stringa restituita.</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte sinistra della stringa.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>Instead, it returns a new string that is padded with trailing white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa che viene riempita con spazi vuoti finali in modo che la lunghezza totale è <ph id="ph1">`totalWidth`</ph> caratteri.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Carattere di riempimento Unicode.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</source>
          <target state="translated">Restituisce una nuova stringa che allinea a sinistra i caratteri in questa stringa mediante l'aggiunta a destra di un carattere Unicode specificato, in modo da ottenere la lunghezza totale specificata.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Nuova stringa equivalente a questa istanza, ma allineata a sinistra mediante l'aggiunta a destra di un numero di caratteri <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> tale da ottenere la lunghezza <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Tuttavia, se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> metodo riempie la fine della stringa restituita.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte sinistra della stringa.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with trailing <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa che viene riempita con finali <ph id="ph1">`paddingChar`</ph> caratteri in modo che la lunghezza totale è <ph id="ph2">`totalWidth`</ph> caratteri.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which a specified number of characters from the current string are deleted.</source>
          <target state="translated">Restituisce una nuova stringa in cui dalla stringa corrente viene eliminato un numero specificato di caratteri.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">Posizione in base zero da cui iniziare l'eliminazione dei caratteri.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</source>
          <target state="translated">Restituisce una nuova stringa in cui sono stati eliminati tutti i caratteri dell'istanza corrente a partire da una posizione specificata fino all'ultima posizione.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>A new string that is equivalent to this string except for the removed characters.</source>
          <target state="translated">Nuova stringa equivalente a questa stringa tranne che per i caratteri eliminati.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, le stringhe sono in base zero.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">Il valore di <ph id="ph1">`startIndex`</ph> parametro può essere compreso tra zero e uno minore della lunghezza dell'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>Instead, it returns a new string in which all characters from position <ph id="ph1">`startIndex`</ph> to the end of the original string have been removed.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa nella quale tutti i caratteri dalla posizione <ph id="ph1">`startIndex`</ph> alla fine della stringa originale sono stati rimossi.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The next-to-last case removes all text starting from the specified index through the end of the string.</source>
          <target state="translated">Nel caso di penultimo rimuove tutto il testo a partire dall'indice specificato fino alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The last case removes three characters starting from the specified index.</source>
          <target state="translated">Nell'ultimo caso rimuove tre caratteri a partire dall'indice specificato.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> specifica una posizione non all'interno di questa stringa.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">Posizione in base zero da cui iniziare l'eliminazione dei caratteri.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The number of characters to delete.</source>
          <target state="translated">Numero di caratteri da eliminare.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</source>
          <target state="translated">Restituisce una nuova stringa in cui è stato eliminato un numero specificato di caratteri nell'istanza corrente a partire da una posizione specificata.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>A new string that is equivalent to this instance except for the removed characters.</source>
          <target state="translated">Nuova stringa equivalente a questa istanza tranne che per i caratteri eliminati.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, le stringhe sono in base zero.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">Il valore di <ph id="ph1">`startIndex`</ph> parametro può essere compreso tra zero e uno minore della lunghezza dell'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Instead, it returns a new string in which the number of characters specified by the <ph id="ph1">`count`</ph> parameter have been removed.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui il numero di caratteri specificato da di <ph id="ph1">`count`</ph> parametro sono state rimosse.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The characters are removed at the position specified by <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">La rimozione di caratteri in corrispondenza della posizione specificata da <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The following example demonstrates how you can remove the middle name from a complete name.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come è possibile rimuovere il secondo nome da un nome completo.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> specify a position outside this instance.</source>
          <target state="translated">la somma dei parametri <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> specifica una posizione non all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all occurrences of a specified Unicode character or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in the current string are replaced with another specified Unicode character or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Restituisce una nuova stringa in cui tutte le occorrenze di un carattere Unicode o di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> specificati presenti nella stringa corrente vengono sostituite con un altro carattere Unicode o oggetto <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> specificati.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to be replaced.</source>
          <target state="translated">Carattere Unicode da sostituire.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Carattere Unicode con cui sostituire tutte le occorrenze di <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</source>
          <target state="translated">Restituisce una nuova stringa in cui tutte le occorrenze di un carattere Unicode specificato presenti in questa istanza vengono sostituite con un altro carattere Unicode specificato.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>A string that is equivalent to this instance except that all instances of <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>.</source>
          <target state="translated">Stringa equivalente a questa istanza, salvo per il fatto che tutte le istanze di <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> vengono sostituite con <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> non viene trovato nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldChar`</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura) per trovare <ph id="ph1">`oldChar`</ph>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldChar`</ph> are replaced by <ph id="ph2">`newChar`</ph>.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutte le occorrenze di <ph id="ph1">`oldChar`</ph> vengono sostituiti da <ph id="ph2">`newChar`</ph>.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">Poiché questo metodo restituisce la stringa modificata, è possibile concatenare le chiamate successive al <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> metodo per eseguire più sostituzioni sulla stringa originale.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">Chiamate al metodo vengono eseguite da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Nell'esempio seguente viene illustrato questo concetto.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</source>
          <target state="translated">L'esempio seguente crea un elenco di valori separati da virgole, sostituendo con virgole per gli spazi vuoti tra una serie di numeri.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to be replaced.</source>
          <target state="translated">Stringa da sostituire.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Stringa con cui sostituire tutte le occorrenze di <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</source>
          <target state="translated">Restituisce una nuova stringa in cui tutte le occorrenze di una stringa specificata nell'istanza corrente vengono sostituite con un'altra stringa specificata.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>A string that is equivalent to the current string except that all instances of <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>.</source>
          <target state="translated">Stringa equivalente alla stringa corrente, salvo per il fatto che tutte le istanze di <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> vengono sostituite con <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> non viene trovato nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">`newValue`</ph> is <ph id="ph2">`null`</ph>, all occurrences of <ph id="ph3">`oldValue`</ph> are removed.</source>
          <target state="translated">Se <ph id="ph1">`newValue`</ph> è <ph id="ph2">`null`</ph>, tutte le occorrenze di <ph id="ph3">`oldValue`</ph> vengono rimossi.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldValue`</ph> are replaced by <ph id="ph2">`newValue`</ph>.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutte le occorrenze di <ph id="ph1">`oldValue`</ph> vengono sostituiti da <ph id="ph2">`newValue`</ph>.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldValue`</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura) per trovare <ph id="ph1">`oldValue`</ph>.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">Poiché questo metodo restituisce la stringa modificata, è possibile concatenare le chiamate successive al <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> metodo per eseguire più sostituzioni sulla stringa originale.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">Chiamate al metodo vengono eseguite da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Nell'esempio seguente viene illustrato questo concetto.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to correct a spelling error.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> metodo per correggere un errore di ortografia.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> è la stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</source>
          <target state="translated">Restituisce una matrice di stringhe contenente le sottostringhe di questa istanza delimitate dagli elementi di una stringa o matrice di caratteri Unicode specificata.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> is used to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> viene utilizzato per suddividere una stringa delimitata in sottostringhe.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use either a character array to specify zero, one, or multiple delimiting characters (the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</source>
          <target state="translated">È possibile utilizzare una matrice di caratteri per specificare nessuno, uno o più caratteri di delimitazione (il <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> metodo), oppure è possibile utilizzare una matrice di caratteri per specificare zero, uno o più stringhe di delimitazione.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method allow you to limit the number of substrings returned by the method (the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> method), to determine whether empty strings are included in the returned substrings (the <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> methods, or to do both (the <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> methods).</source>
          <target state="translated">Gli overload del <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo consente di limitare il numero di sottostringhe restituito dal metodo (il <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> (metodo)), per determinare se le stringhe vuote vengono inclusi nelle sottostringhe restituite (il <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> e <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> metodi, o entrambe le opzioni (il <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> e <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> metodi).</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more detailed information on the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method, as well as for examples that call each overload, see the documentation for the individual overloads of <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sul <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> (metodo), come anche per esempi che chiamano ogni overload, vedere la documentazione per i singoli overload del <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo non è sempre il modo migliore per suddividere una stringa delimitata in sottostringhe.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">Se non si desidera estrarre le sottostringhe di una stringa delimitata, o se si desidera analizzare una stringa in base a un criterio anziché un set di caratteri di delimitazione, considerare le seguenti alternative.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Regular expressions</source>
          <target state="translated">Espressioni regolari</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">Se le stringhe conforme a un modello predefinito, è possibile utilizzare un'espressione regolare per estrarre e gestire i relativi elementi.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">Ad esempio, se le stringhe di assumono la forma "<bpt id="p1">*</bpt>numero<ept id="p1">*</ept> <bpt id="p2">*</bpt>operando<ept id="p2">*</ept> <bpt id="p3">*</bpt>numero<ept id="p3">*</ept>" è possibile utilizzare un <bpt id="p4">[</bpt>espressione regolare<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> per estrarre e gestire il elementi della stringa.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's an example:</source>
          <target state="translated">Di seguito è riportato un esempio:</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">Criterio di espressione regolare <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> è definito come segue:</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Trova la corrispondenza con una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Corrisponde a uno o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">Corrisponde a un segno di operatori aritmetici (+, -, *, o /).</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the second capturing group.</source>
          <target state="translated">Equivale al secondo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Corrisponde a uno o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Trova la corrispondenza con una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the third capturing group.</source>
          <target state="translated">Equivale al terzo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">È inoltre possibile utilizzare un'espressione regolare per estrarre le sottostringhe da una stringa basata su un modello, anziché un set fisso di caratteri.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">Si tratta di uno scenario comune quando una di queste condizioni si verifica:</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">Uno o più i caratteri di delimitazione non sempre essere utilizzato come un delimitatore di <ph id="ph1">&lt;xref:System.String&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">La sequenza e il numero di caratteri di delimitazione è sconosciuto o variabile.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo non può essere utilizzato per suddividere la stringa seguente, perché il numero di <ph id="ph2">`\n`</ph> (in c#) o <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) di caratteri è variabile, e vengono sempre non utilizzati come delimitatori.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">Un'espressione regolare è possibile suddividere la stringa semplice, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">Criterio di espressione regolare <ph id="ph1">`\[([^\[\]]+)\]`</ph> è definito come segue:</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an opening bracket.</source>
          <target state="translated">Corrisponde a una parentesi di apertura.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">Corrisponde a qualsiasi carattere che non è una parentesi o una parentesi di chiusura una o più volte.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a closing bracket.</source>
          <target state="translated">Corrisponde a una parentesi di chiusura.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> è pressoché identico al metodo <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, ad eccezione del fatto che suddivide una stringa in base a un criterio di espressione regolare invece di un set di caratteri predefinito.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">Ad esempio, l'esempio seguente usa il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> metodo per suddividere una stringa contenente le sottostringhe delimitate da varie combinazioni di trattini e altri caratteri.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">Criterio di espressione regolare <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> è definito come segue:</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">Corrisponde a uno spazio vuoto seguito da un trattino.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Trova la corrispondenza zero o uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">Corrisponde a zero o una occorrenza di uno il + o * carattere.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Trova la corrispondenza zero o uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">Corrisponde a un trattino seguito da uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Search methods and the Substring method</source>
          <target state="translated">Metodi di ricerca e il metodo Substring</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">Se non si è interessati in tutte le sottostringhe in una stringa, è preferibile usare uno dei metodi di confronto tra stringhe che restituisce l'indice in corrispondenza del quale inizia la corrispondenza.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">È quindi possibile chiamare il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> metodo per estrarre la sottostringa che si desidera.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string comparison methods include:</source>
          <target state="translated">I metodi di confronto di stringhe includono:</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, che restituisce l'indice in base zero della prima occorrenza di un carattere o una stringa in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, che restituisce l'indice in base zero nell'istanza della stringa corrente della prima occorrenza di qualsiasi carattere presente in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, che restituisce l'indice in base zero dell'ultima occorrenza di un carattere o una stringa in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, che restituisce un indice in base zero nell'istanza corrente di stringa dell'ultima occorrenza di qualsiasi carattere presente in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo per individuare i periodi in una stringa.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> per restituire frasi intere.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>Splits a string into substrings that are based on the characters in an array.</source>
          <target state="translated">Suddivide una stringa in sottostringhe basate sui caratteri in una matrice.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>An array whose elements contain the substrings from this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Matrice i cui elementi contengono le sottostringhe da questa istanza delimitate da uno o più caratteri in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione Osservazioni.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>When a string is delimited by a known set of characters, you can use the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">Quando una stringa è delimitata da un set di caratteri noto, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> metodo per separarlo in sottostringhe.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For other ways to extract substrings from a string, see the <bpt id="p1">[</bpt>Alternatives to String.Split<ept id="p1">](#Alternatives)</ept> section.</source>
          <target state="translated">Per altri modi per estrarre le sottostringhe da una stringa, vedere il <bpt id="p1">[</bpt>alternative a String. Split<ept id="p1">](#Alternatives)</ept> sezione.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Return value details</source>
          <target state="translated">Dettagli sul valore restituito</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Caratteri di delimitazione non sono inclusi gli elementi della matrice restituita.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Ad esempio, se la matrice separatore include il carattere "-" e il valore dell'istanza della stringa corrente è "aa-bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Se questa istanza non contiene i caratteri in <ph id="ph1">`separator`</ph>, la matrice restituita è costituito da un unico elemento che contiene questa istanza.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`separator`</ph> definisce un carattere di delimitazione separato.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Se due delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente nella matrice restituita contiene <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here are some examples:</source>
          <target state="translated">Ecco alcuni esempi:</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String value</source>
          <target state="translated">Valore stringa</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Separator</source>
          <target state="translated">Separatore</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Returned array</source>
          <target state="translated">Matrice restituita</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">nuovo Char [] {',', ' '} (c#)</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {","c, " "c}) (Visual Basic)</source>
          <target state="translated">Char () = {"," c "" c}) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">nuovo Char [] {'. '}</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char () = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Banana"</source>
          <target state="translated">"Banana"</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">nuovo Char [] {'. '}</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char () = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Banana"}</source>
          <target state="translated">{"Banana"}</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {} (C#)</source>
          <target state="translated">nuovo Char [] {} (c#)</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {} (Visual Basic)</source>
          <target state="translated">Char () = {} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>null (C#)</source>
          <target state="translated">null (C#)</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Nothing (Visual Basic)</source>
          <target state="translated">Nothing (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The separator array</source>
          <target state="translated">La matrice separatore</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of separator defines a separate delimiter that consists of a single character.</source>
          <target state="translated">Ogni elemento del separatore definisce un delimitatore separato costituito da un singolo carattere.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If the <ph id="ph1">`separator`</ph> argument is <ph id="ph2">`null`</ph> or contains no characters, the method treats white-space characters as the delimiters.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> argomento <ph id="ph2">`null`</ph> o non contiene caratteri, il metodo considera gli spazi vuoti come delimitatori.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>White-space characters are defined by the Unicode standard; they return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli spazi vuoti sono definiti da Unicode standard; restituiscono <ph id="ph1">`true`</ph> se vengono passati il <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String.Split(Char[]) and compiler overload resolution</source>
          <target state="translated">Risoluzione dell'overload String.Split(Char[]) e compilatore</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Although the single parameter for this overload of <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> is a character array, you can call it with a single character, as the following example shows.</source>
          <target state="translated">Anche se il singolo parametro per questo overload di <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> è una matrice di caratteri, è possibile chiamare con un singolo carattere, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Because the <ph id="ph1">`separator`</ph> parameter is decorated  with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, compilers will interpret a single character as a single-element character array.</source>
          <target state="translated">Poiché il <ph id="ph1">`separator`</ph> parametro è decorato con il <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attributo, compilatori interpreterà un singolo carattere come una matrice di caratteri a singolo elemento.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is not the case for other <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> overloads that include a <ph id="ph2">`separator`</ph> parameter; you must explicitly pass these overloads a character array as the <ph id="ph3">`separator`</ph> argument.</source>
          <target state="translated">Questo non avviene per altri <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> overload che includono un <ph id="ph2">`separator`</ph> parametro; è necessario passare in modo esplicito questi overload una matrice di caratteri come il <ph id="ph3">`separator`</ph> argomento.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Comparison details</source>
          <target state="translated">Dettagli di confronto</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> array, and returns those substrings as elements of an array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> metodo estrae le sottostringhe di questa stringa delimitate da uno o più dei caratteri di <ph id="ph2">`separator`</ph> di matrice e restituisce tali sottostringhe come elementi di una matrice.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Alternatives to String.Split</source>
          <target state="translated">Alternative a String. Split</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo non è sempre il modo migliore per suddividere una stringa delimitata in sottostringhe.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">Se non si desidera estrarre le sottostringhe di una stringa delimitata, o se si desidera analizzare una stringa in base a un criterio anziché un set di caratteri di delimitazione, considerare le seguenti alternative.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Regular expressions</source>
          <target state="translated">Espressioni regolari</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">Se le stringhe conforme a un modello predefinito, è possibile utilizzare un'espressione regolare per estrarre e gestire i relativi elementi.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">Ad esempio, se le stringhe di assumono la forma "<bpt id="p1">*</bpt>numero<ept id="p1">*</ept> <bpt id="p2">*</bpt>operando<ept id="p2">*</ept> <bpt id="p3">*</bpt>numero<ept id="p3">*</ept>" è possibile utilizzare un <bpt id="p4">[</bpt>espressione regolare<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> per estrarre e gestire il elementi della stringa.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here's an example:</source>
          <target state="translated">Di seguito è riportato un esempio:</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">Criterio di espressione regolare <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> è definito come segue:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Trova la corrispondenza con una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Corrisponde a uno o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">Corrisponde a un segno di operatori aritmetici (+, -, *, o /).</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the second capturing group.</source>
          <target state="translated">Equivale al secondo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Corrisponde a uno o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Trova la corrispondenza con una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the third capturing group.</source>
          <target state="translated">Equivale al terzo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">È inoltre possibile utilizzare un'espressione regolare per estrarre le sottostringhe da una stringa basata su un modello, anziché un set fisso di caratteri.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">Si tratta di uno scenario comune quando una di queste condizioni si verifica:</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">Uno o più i caratteri di delimitazione non sempre essere utilizzato come un delimitatore di <ph id="ph1">&lt;xref:System.String&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">La sequenza e il numero di caratteri di delimitazione è sconosciuto o variabile.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo non può essere utilizzato per suddividere la stringa seguente, perché il numero di <ph id="ph2">`\n`</ph> (in c#) o <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) di caratteri è variabile, e vengono sempre non utilizzati come delimitatori.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">Un'espressione regolare è possibile suddividere la stringa semplice, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">Criterio di espressione regolare <ph id="ph1">`\[([^\[\]]+)\]`</ph> è definito come segue:</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an opening bracket.</source>
          <target state="translated">Corrisponde a una parentesi di apertura.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">Corrisponde a qualsiasi carattere che non è una parentesi o una parentesi di chiusura una o più volte.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a closing bracket.</source>
          <target state="translated">Corrisponde a una parentesi di chiusura.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> è pressoché identico al metodo <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, ad eccezione del fatto che suddivide una stringa in base a un criterio di espressione regolare invece di un set di caratteri predefinito.</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">Ad esempio, l'esempio seguente usa il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> metodo per suddividere una stringa contenente le sottostringhe delimitate da varie combinazioni di trattini e altri caratteri.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">Criterio di espressione regolare <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> è definito come segue:</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">Corrisponde a uno spazio vuoto seguito da un trattino.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Trova la corrispondenza zero o uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">Corrisponde a zero o una occorrenza di uno il + o * carattere.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Trova la corrispondenza zero o uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">Corrisponde a un trattino seguito da uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Search methods and the Substring method</source>
          <target state="translated">Metodi di ricerca e il metodo Substring</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">Se non si è interessati in tutte le sottostringhe in una stringa, è preferibile usare uno dei metodi di confronto tra stringhe che restituisce l'indice in corrispondenza del quale inizia la corrispondenza.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">È quindi possibile chiamare il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> metodo per estrarre la sottostringa che si desidera.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The string comparison methods include:</source>
          <target state="translated">I metodi di confronto di stringhe includono:</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, che restituisce l'indice in base zero della prima occorrenza di un carattere o una stringa in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, che restituisce l'indice in base zero nell'istanza della stringa corrente della prima occorrenza di qualsiasi carattere presente in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, che restituisce l'indice in base zero dell'ultima occorrenza di un carattere o una stringa in un'istanza di stringa.</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, che restituisce un indice in base zero nell'istanza corrente di stringa dell'ultima occorrenza di qualsiasi carattere presente in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo per individuare i periodi in una stringa.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> per restituire frasi intere.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Performance Considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodi allocano memoria per l'oggetto matrice restituito e un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni elemento della matrice.</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method.</source>
          <target state="translated">Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You also have the option of using the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to locate a substring within a string.</source>
          <target state="translated">È inoltre la possibilità di usare il <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per individuare una sottostringa all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Per suddividere una stringa in un carattere separatore, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare un carattere di separazione della stringa.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Per suddividere una stringa in una stringa di separazione, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare il primo carattere della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Utilizzare quindi la <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come estrarre singole parole da un blocco di testo trattando spazi e segni di punteggiatura come delimitatori.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The character array passed to the <ph id="ph1">`separator`</ph> parameter of the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method consists of a space character and a tab character, together with some common punctuation symbols.</source>
          <target state="translated">Passata la matrice di caratteri di <ph id="ph1">`separator`</ph> parametro del <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> metodo è costituito da uno spazio e un carattere di tabulazione, con alcuni simboli di punteggiatura comuni.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> e versioni precedenti, se il <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> viene passato un <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> ovvero <ph id="ph4">&lt;see langword="null" /&gt;</ph> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere la stringa che il <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> non metodo in tagliare la stringa.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, entrambi i metodi utilizzano un set identico di caratteri spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Numero massimo di sottostringhe da restituire.</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">Suddivide una stringa in un numero massimo di sottostringhe in base ai caratteri in una matrice.</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>You also specify the maximum number of substrings to return.</source>
          <target state="translated">Numero massimo di sottostringhe da restituire.</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Matrice i cui elementi contengono le sottostringhe in questa istanza delimitate da uno o più caratteri in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione Osservazioni.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Caratteri di delimitazione non sono inclusi gli elementi della matrice restituita.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Se questa istanza non contiene i caratteri in <ph id="ph1">`separator`</ph>, la matrice restituita è costituito da un unico elemento che contiene questa istanza.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is zero, an empty array is returned.</source>
          <target state="translated">Se <ph id="ph1">`count`</ph> è zero, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro <ph id="ph2">`null`</ph> o non contiene caratteri, spazi vuoti vengono considerati come delimitatori.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode e restituito <ph id="ph1">`true`</ph> se vengono passati il <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`separator`</ph> definisce un carattere di delimitazione separato.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Se due delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">Se sono presenti più di <ph id="ph1">`count`</ph> sottostringhe di questa istanza, il primo <ph id="ph2">`count`</ph> -1 sottostringhe vengono restituiti nel primo <ph id="ph3">`count`</ph> -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Se <ph id="ph1">`count`</ph> è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibili e viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following table provides examples.</source>
          <target state="translated">Nella tabella seguente vengono forniti esempi.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>String value</source>
          <target state="translated">Valore stringa</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Separator</source>
          <target state="translated">Separatore</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Count</source>
          <target state="translated">Conteggio</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Returned array</source>
          <target state="translated">Matrice restituita</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">nuovo Char [] {',', ' '} (c#)</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {","c, " "c} (Visual Basic)</source>
          <target state="translated">Char () = {"," c "" c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", " 12, 19"}</source>
          <target state="translated">{"42", " 12, 19"}</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">nuovo Char [] {'. '}</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char () = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", "", "12", ".19"}</source>
          <target state="translated">{"42", "", "12", ".19"}</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Banana"</source>
          <target state="translated">"Banana"</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">nuovo Char [] {'. '}</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char () = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Banana"}</source>
          <target state="translated">{"Banana"}</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {} (C#)</source>
          <target state="translated">nuovo Char [] {} (c#)</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {} (Visual Basic)</source>
          <target state="translated">Char () = {} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb\nSmarba"} (C#)</source>
          <target state="translated">{"Darb\nSmarba"} (C#)</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">nuovo Char [] null (c#)</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char () = Nothing</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">nuovo Char [] null (c#)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char () = Nothing</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>100</source>
          <target state="translated">100</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Performance Considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodi allocano memoria per l'oggetto matrice restituito e un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni elemento della matrice.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> (metodo) e facoltativamente la <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> metodo, per individuare una sottostringa all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Se si divide una stringa in un carattere separatore, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare un carattere di separazione della stringa.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Se si divide una stringa in una stringa di separazione, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare il primo carattere della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Utilizzare quindi la <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following example demonstrates how <ph id="ph1">`count`</ph> affects the number of strings returned by <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come <ph id="ph1">`count`</ph> influisce sul numero di stringhe restituito dal <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> e versioni precedenti, se il <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> viene passato un <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> ovvero <ph id="ph4">&lt;see langword="null" /&gt;</ph> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere la stringa che il <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> non metodo in tagliare la stringa.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, entrambi i metodi utilizzano un set identico di caratteri spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> per omettere gli elementi di matrice vuoti dalla matrice restituita; <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> per includere tali elementi.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the characters in an array.</source>
          <target state="translated">Suddivide una stringa in sottostringhe in base ai caratteri in una matrice.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">È possibile specificare se le sottostringhe includono elementi della matrice vuota.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da uno o più caratteri in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione Osservazioni.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Dettagli sul valore restituito</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Delimiter characters (the characters in the <ph id="ph1">`separator`</ph> array) are not included in the elements of the returned array.</source>
          <target state="translated">Caratteri di delimitazione (i caratteri di <ph id="ph1">`separator`</ph> matrice) non sono inclusi gli elementi della matrice restituita.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Ad esempio, se il <ph id="ph1">`separator`</ph> matrice include il carattere "-" e il valore dell'istanza della stringa corrente è "aa-bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Se questa istanza non contiene i caratteri in <ph id="ph1">`separator`</ph>, la matrice restituita è costituito da un unico elemento che contiene questa istanza.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">Se il <ph id="ph1">`options`</ph> parametro <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> e la lunghezza di questa istanza è uguale a zero, il metodo restituisce una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of a single character.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`separator`</ph> definisce un delimitatore separato costituito da un singolo carattere.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il <ph id="ph1">`options`</ph> argomento <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "<ph id="ph2">\_</ph>", the value of the string instance is "-<ph id="ph3">\_</ph>aa-<ph id="ph4">\_</ph>", and the value of   the <ph id="ph5">`options`</ph> argument is <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a string array with the following five elements:</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`separator`</ph> include due elementi, "-" e "<ph id="ph2">\_</ph>", il valore dell'istanza di stringa è "-<ph id="ph3">\_</ph>aa -<ph id="ph4">\_</ph>" e il valore della <ph id="ph5">`options`</ph> argomento è <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, il metodo restituisce una matrice di stringhe i seguenti cinque elementi:</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" character at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta una stringa vuota che precede il "-" carattere in corrispondenza dell'indice 0.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta la stringa vuota tra il "-" carattere in corrispondenza dell'indice 0 e il carattere "_" in corrispondenza dell'indice 1.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">"aa",</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" character at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta la stringa vuota che segue il carattere "_" in corrispondenza dell'indice 4.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" character at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta la stringa vuota che segue il "-" carattere in corrispondenza dell'indice 5.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">La matrice separatore</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro <ph id="ph2">`null`</ph> o non contiene caratteri, spazi vuoti vengono considerati come delimitatori.</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode e restituito <ph id="ph1">`true`</ph> se vengono passati il <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro nella chiamata a questo overload del metodo è <ph id="ph2">`null`</ph>, la risoluzione dell'overload del compilatore non riesce.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Dettagli di confronto</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo estrae le sottostringhe di questa stringa delimitate da uno o più dei caratteri di <ph id="ph2">`separator`</ph> parametro e restituisce le sottostringhe come elementi di una matrice.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodi allocano memoria per l'oggetto matrice restituito e un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni elemento della matrice.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> (metodo) e facoltativamente la <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> metodo, per individuare una sottostringa all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Se si divide una stringa in un carattere separatore, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare un carattere di separazione della stringa.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Se si divide una stringa in una stringa di separazione, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare il primo carattere della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Utilizzare quindi la <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumerazione per includere o escludere le sottostringhe generate dal <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è uno dei valori di <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> e versioni precedenti, se il <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> viene passato un <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> ovvero <ph id="ph4">&lt;see langword="null" /&gt;</ph> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere la stringa che il <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> non metodo in tagliare la stringa.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, entrambi i metodi utilizzano un set identico di caratteri spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di stringhe che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> per omettere gli elementi di matrice vuoti dalla matrice restituita; <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> per includere tali elementi.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the strings in an array.</source>
          <target state="translated">Suddivide una stringa in sottostringhe in base alle stringhe in una matrice.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">È possibile specificare se le sottostringhe includono elementi della matrice vuota.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da una o più stringhe indicate in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione Osservazioni.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>When a string is delimited by a known set of strings, you can use the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">Quando una stringa è delimitata da un set noto di stringhe, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo per separarlo in sottostringhe.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Dettagli sul valore restituito</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">Le stringhe di delimitazione non sono inclusi gli elementi della matrice restituita.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Ad esempio, se il <ph id="ph1">`separator`</ph> matrice include la stringa "-" e il valore dell'istanza della stringa corrente è "aa - bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Se questa istanza non contiene una delle stringhe in <ph id="ph1">`separator`</ph>, la matrice restituita è costituito da un unico elemento che contiene questa istanza.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">Se il <ph id="ph1">`options`</ph> parametro <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> e la lunghezza di questa istanza è uguale a zero, il metodo restituisce una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`separator`</ph> definisce un delimitatore separato costituito da uno o più caratteri.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il <ph id="ph1">`options`</ph> argomento <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "_", the value of the string instance is "-_aa-<ph id="ph2">\_</ph>", and the value of   the <ph id="ph3">`options`</ph> argument is <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a sting array with the following five elements:</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`separator`</ph> include due elementi, "-" e "_", il valore dell'istanza di stringa è "- _aa -<ph id="ph2">\_</ph>" e il valore della <ph id="ph3">`options`</ph> argomento <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, il metodo restituisce una matrice di stringa con i seguenti cinque elementi:</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" substring at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta una stringa vuota che precede il "-" sottostringa in corrispondenza dell'indice 0.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta la stringa vuota tra il "-" sottostringa in corrispondenza dell'indice 0 e la sottostringa "_" in corrispondenza dell'indice 1.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">"aa",</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" substring at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta la stringa vuota che segue la sottostringa "_" in corrispondenza dell'indice 4.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" substring at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, che rappresenta la stringa vuota che segue il "-" sottostringa in corrispondenza dell'indice 5.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">La matrice separatore</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">Se uno degli elementi in <ph id="ph1">`separator`</ph> costituito da più caratteri, la sottostringa intera viene considerata un delimitatore.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">Ad esempio, se uno degli elementi in <ph id="ph1">`separator`</ph> è "10", il tentativo di suddividere la stringa "This10is10a10string".</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>returns the following four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">Restituisce la matrice di quattro elementi seguente: {"This", "is", "a", "string".</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro <ph id="ph2">`null`</ph> o non contiene caratteri, spazi vuoti vengono considerati come delimitatori.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode e restituito <ph id="ph1">`true`</ph> se vengono passati il <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro nella chiamata a questo overload del metodo è <ph id="ph2">`null`</ph>, la risoluzione dell'overload del compilatore non riesce.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Dettagli di confronto</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo estrae le sottostringhe di questa stringa delimitate da uno o più delle stringhe di <ph id="ph2">`separator`</ph> parametro e restituisce le sottostringhe come elementi di una matrice.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo ignora qualsiasi elemento di <ph id="ph2">`separator`</ph> il cui valore è <ph id="ph3">`null`</ph> o una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">Per evitare risultati ambigui quando le stringhe nel <ph id="ph1">`separator`</ph> hanno in comune, i caratteri di <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> operazione procede dall'inizio alla fine del valore dell'istanza e corrisponde al primo elemento <ph id="ph3">`separator`</ph> che è uguale a un delimitatore nel istanza.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">L'ordine in cui le sottostringhe sono rilevate nell'istanza ha la precedenza sull'ordine degli elementi in <ph id="ph1">`separator`</ph>.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">Si consideri ad esempio un'istanza il cui valore è "abcdef".</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</source>
          <target state="translated">Se il primo elemento in <ph id="ph1">`separator`</ph> è "ef" e il secondo elemento è stato "bcde", il risultato dell'operazione di divisione sarà una matrice di stringhe che contiene due elementi, "a" e "f".</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">In questo modo la sottostringa nell'istanza, "bcde", viene rilevata e corrisponde a un elemento in <ph id="ph1">`separator`</ph> prima che venga rilevata la sottostringa "f".</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</source>
          <target state="translated">Tuttavia, se il primo elemento della <ph id="ph1">`separator`</ph> è "bcd" e il secondo elemento è "bc", il risultato dell'operazione di divisione sarà una matrice di stringhe che contiene due elementi, "a" e "ef".</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">Perché "bcd" è il primo delimitatore del <ph id="ph1">`separator`</ph> che corrisponde a un delimitatore nell'istanza.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</source>
          <target state="translated">Se il primo elemento è "bc" è stato annullato. l'ordine dei separatori e il secondo elemento è stato "bcd", il risultato sarebbe una matrice di stringhe che contiene due elementi, "a" e "def".</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodi allocano memoria per l'oggetto matrice restituito e un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni elemento della matrice.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> (metodo) e facoltativamente la <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> metodo, per individuare una sottostringa all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Se si divide una stringa in un carattere separatore, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare un carattere di separazione della stringa.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Se si divide una stringa in una stringa di separazione, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare il primo carattere della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Utilizzare quindi la <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example illustrates the difference in the arrays returned by calling a string's <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> method with its <ph id="ph2">`options`</ph> parameter equal to <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la differenza matrici restituite chiamando una stringa <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> metodo con il relativo <ph id="ph2">`options`</ph> uguale al parametro <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> e <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example defines an array of separators that include punctuation and white-space characters.</source>
          <target state="translated">L'esempio seguente definisce una matrice di separatori che includono la punteggiatura e caratteri di spazio vuoto.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Passing this array along with a value of <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> to the <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> method returns an array that consists of the individual words from the string.</source>
          <target state="translated">Il passaggio di questa matrice insieme a un valore di <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> per il <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> metodo restituisce una matrice costituita da singole parole dalla stringa.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Note that the method is called with the <ph id="ph1">`options`</ph> argument set to <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si noti che il metodo viene chiamato con il <ph id="ph1">`options`</ph> argomento impostato su <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This prevents the returned array from including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> values that represent empty substring matches between punctuation marks and white-space characters.</source>
          <target state="translated">Ciò impedisce la matrice restituita inclusi <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> valori che rappresentano le corrispondenze tra segni di punteggiatura e caratteri di spazio vuoto sottostringa.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è uno dei valori di <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> e versioni precedenti, se il <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> viene passato un <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> ovvero <ph id="ph4">&lt;see langword="null" /&gt;</ph> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere la stringa che il <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> non metodo in tagliare la stringa.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, entrambi i metodi utilizzano un set identico di caratteri spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Numero massimo di sottostringhe da restituire.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> per omettere gli elementi di matrice vuoti dalla matrice restituita; <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> per includere tali elementi.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">Suddivide una stringa in un numero massimo di sottostringhe in base ai caratteri in una matrice.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da uno o più caratteri in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione Osservazioni.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Caratteri di delimitazione non sono inclusi gli elementi della matrice restituita.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Se questa istanza non contiene i caratteri in <ph id="ph1">`separator`</ph>, o <ph id="ph2">`count`</ph> parametro è 1, la matrice restituita è costituita da un unico elemento che contiene questa istanza.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro <ph id="ph2">`null`</ph> o non contiene caratteri, spazi vuoti vengono considerati come delimitatori.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode e restituito <ph id="ph1">`true`</ph> se vengono passati il <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Tuttavia, se il <ph id="ph1">`separator`</ph> parametro nella chiamata a questo overload del metodo è <ph id="ph2">`null`</ph>, la risoluzione dell'overload del compilatore non riesce.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the null.</source>
          <target state="translated">Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di null.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">Se il <ph id="ph1">`count`</ph> parametro è uguale a zero, o <ph id="ph2">`options`</ph> parametro <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> e la lunghezza di questa istanza è uguale a zero, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`separator`</ph> definisce un carattere di delimitazione separato.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Se il <ph id="ph1">`options`</ph> parametro <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">Se sono presenti più di <ph id="ph1">`count`</ph> sottostringhe di questa istanza, il primo <ph id="ph2">`count`</ph> -1 sottostringhe vengono restituiti nel primo <ph id="ph3">`count`</ph> -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Se <ph id="ph1">`count`</ph> è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibili e viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodi allocano memoria per l'oggetto matrice restituito e un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni elemento della matrice.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> (metodo) e facoltativamente la <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> metodo, per individuare una sottostringa all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Se si divide una stringa in un carattere separatore, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare un carattere di separazione della stringa.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Se si divide una stringa in una stringa di separazione, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare il primo carattere della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Utilizzare quindi la <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumerazione per includere o escludere le sottostringhe generate dal <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è uno dei valori di <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> e versioni precedenti, se il <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> viene passato un <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> ovvero <ph id="ph4">&lt;see langword="null" /&gt;</ph> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere la stringa che il <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> non metodo in tagliare la stringa.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, entrambi i metodi utilizzano un set identico di caratteri spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di stringhe che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Numero massimo di sottostringhe da restituire.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> per omettere gli elementi di matrice vuoti dalla matrice restituita; <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> per includere tali elementi.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the strings in an array.</source>
          <target state="translated">Suddivide una stringa in un numero massimo di sottostringhe in base alle stringe in una matrice.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">È possibile specificare se le sottostringhe includono elementi della matrice vuota.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da una o più stringhe indicate in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione Osservazioni.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Dettagli sul valore restituito</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">Le stringhe di delimitazione non sono inclusi gli elementi della matrice restituita.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Se questa istanza non contiene una delle stringhe in <ph id="ph1">`separator`</ph>, o <ph id="ph2">`count`</ph> parametro è 1, la matrice restituita è costituita da un unico elemento che contiene questa istanza.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Se il <ph id="ph1">`separator`</ph> parametro <ph id="ph2">`null`</ph> o non contiene caratteri, spazi vuoti vengono considerati come delimitatori.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode e restituito <ph id="ph1">`true`</ph> se vengono passati il <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Tuttavia, se il <ph id="ph1">`separator`</ph> parametro nella chiamata a questo overload del metodo è <ph id="ph2">`null`</ph>, la risoluzione dell'overload del compilatore non riesce.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">Se il <ph id="ph1">`count`</ph> parametro è uguale a zero, o <ph id="ph2">`options`</ph> parametro <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> e la lunghezza di questa istanza è uguale a zero, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`separator`</ph> definisce un delimitatore separato costituito da uno o più caratteri.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Se il <ph id="ph1">`options`</ph> parametro <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">Se sono presenti più di <ph id="ph1">`count`</ph> sottostringhe di questa istanza, il primo <ph id="ph2">`count`</ph> -1 sottostringhe vengono restituiti nel primo <ph id="ph3">`count`</ph> -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Se <ph id="ph1">`count`</ph> è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibili e viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">La matrice separatore</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">Se uno degli elementi in <ph id="ph1">`separator`</ph> costituito da più caratteri, la sottostringa intera viene considerata un delimitatore.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">Ad esempio, se uno degli elementi in <ph id="ph1">`separator`</ph> è "10", il tentativo di suddividere la stringa "This10is10a10string".</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>returns this four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">Restituisce la matrice di quattro elementi: {"This", "is", "a", "string".</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Dettagli di confronto</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo estrae le sottostringhe di questa stringa delimitate da uno o più delle stringhe di <ph id="ph2">`separator`</ph> parametro e restituisce le sottostringhe come elementi di una matrice.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodo ignora qualsiasi elemento di <ph id="ph2">`separator`</ph> il cui valore è <ph id="ph3">`null`</ph> o una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">Per evitare risultati ambigui quando le stringhe nel <ph id="ph1">`separator`</ph> hanno in comune, i caratteri di <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> procede dall'inizio alla fine del valore dell'istanza del metodo e corrisponde al primo elemento <ph id="ph3">`separator`</ph> che è uguale a un delimitatore nel istanza.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">L'ordine in cui le sottostringhe sono rilevate nell'istanza ha la precedenza sull'ordine degli elementi in <ph id="ph1">`separator`</ph>.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">Si consideri ad esempio un'istanza il cui valore è "abcdef".</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</source>
          <target state="translated">Se il primo elemento in <ph id="ph1">`separator`</ph> è "ef" e il secondo elemento è stato "bcde", il risultato dell'operazione di divisione sarà "a" e "f".</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">In questo modo la sottostringa nell'istanza, "bcde", viene rilevata e corrisponde a un elemento in <ph id="ph1">`separator`</ph> prima che venga rilevata la sottostringa "f".</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</source>
          <target state="translated">Tuttavia, se il primo elemento della <ph id="ph1">`separator`</ph> è "bcd" e il secondo elemento è "bc", il risultato dell'operazione di divisione sarà "a" e "ef".</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">Perché "bcd" è il primo delimitatore del <ph id="ph1">`separator`</ph> che corrisponde a un delimitatore nell'istanza.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</source>
          <target state="translated">Se il primo elemento è "bc" è stato annullato. l'ordine dei separatori e il secondo elemento è stato "bcd", il risultato sarebbe "a" e "def".</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">Considerazioni sulle prestazioni</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> metodi allocano memoria per l'oggetto matrice restituito e un <ph id="ph2">&lt;xref:System.String&gt;</ph> oggetto per ogni elemento della matrice.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> (metodo) e facoltativamente la <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> metodo, per individuare una sottostringa all'interno di una stringa.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Se si divide una stringa in un carattere separatore, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare un carattere di separazione della stringa.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Se si divide una stringa in una stringa di separazione, utilizzare il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> metodo per individuare il primo carattere della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Utilizzare quindi la <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumerazione per includere o escludere le sottostringhe generate dal <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> non è uno dei valori di <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> e versioni precedenti, se il <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> viene passato un <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> ovvero <ph id="ph4">&lt;see langword="null" /&gt;</ph> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere la stringa che il <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> non metodo in tagliare la stringa.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, entrambi i metodi utilizzano un set identico di caratteri spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the beginning of this string instance matches a specified string.</source>
          <target state="translated">Determina se l'inizio di questa istanza di stringa corrisponde a una stringa specificata.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>The string to compare.</source>
          <target state="translated">Stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>Determines whether the beginning of this string instance matches the specified string.</source>
          <target state="translated">Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'inizio di questa stringa corrisponde al parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the beginning of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">Questo metodo confronta <ph id="ph1">`value`</ph> con la sottostringa all'inizio di questa istanza è uguale alla lunghezza <ph id="ph2">`value`</ph>e restituisce un'indicazione se sono uguali.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">Per essere uguali, <ph id="ph1">`value`</ph> deve essere una stringa vuota (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), deve essere un riferimento alla stessa istanza o deve corrispondere all'inizio di questa istanza.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripStartTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> method to remove HTML start tags from the beginning of a string.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`StripStartTags`</ph> metodo che utilizza il <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> tag di inizio del metodo per rimuovere HTML dall'inizio di una stringa.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>Note that the <ph id="ph1">`StripStartTags`</ph> method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</source>
          <target state="translated">Si noti che il <ph id="ph1">`StripStartTags`</ph> metodo viene chiamato in modo ricorsivo per garantire che vengano rimossi più tag di inizio HTML all'inizio della riga.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The example does not remove HTML tags embedded in a string.</source>
          <target state="translated">L'esempio non rimuove i tag HTML incorporati in una stringa.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Per determinare se una stringa inizia con una particolare sottostringa utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The string to compare.</source>
          <target state="translated">Stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Uno dei valori di enumerazione che determina la modalità di confronto tra questa stringa e <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata se confrontata usando l'opzione di confronto specificata.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this instance begins with <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'istanza inizia con <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> metodo confronta il <ph id="ph2">`value`</ph> parametro con la sottostringa all'inizio di questa stringa e restituisce un valore che indica se sono uguali.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</source>
          <target state="translated">Per essere uguali, <ph id="ph1">`value`</ph> deve essere un riferimento a questa stessa stringa, deve essere una stringa vuota (""), o deve corrispondere all'inizio di questa stringa.</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">Il tipo di confronto eseguito dal <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> metodo dipende dal valore del <ph id="ph2">`comparisonType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can use the conventions of the current culture (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) or the invariant culture (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), or it can consist of a character-by-character comparison of code points (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Il confronto è possibile utilizzare le convenzioni delle impostazioni cultura correnti (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) o le impostazioni cultura invarianti (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> e <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), o può essere costituito da un confronto carattere per carattere dei punti di codice (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> o <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can also be case-sensitive (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), or it can ignore case (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Il confronto può anche essere distinzione maiuscole/minuscole (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), o ignorarla (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</source>
          <target state="translated">Nell'esempio seguente viene cercata la stringa "the" all'inizio di una stringa più lunga che inizia con la parola "The".</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>As the output from the example shows, a call to the <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</source>
          <target state="translated">Come illustrato nell'esempio, una chiamata a dall'output di <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> metodo che esegue un confronto tra maiuscole e minuscole, ma indipendenti dalle impostazioni cultura non riesce a trovare la stringa, mentre una chiamata che esegue un confronto delle impostazioni cultura e case insensitive corrisponde alla stringa.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string starts with a particular substring.</source>
          <target state="translated">Nell'esempio seguente determina se una stringa inizia con una particolare sottostringa.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>It initializes a two-dimensional string array.</source>
          <target state="translated">Inizializza una matrice di stringhe bidimensionale.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</source>
          <target state="translated">Il primo elemento della seconda dimensione contiene una stringa e il secondo elemento contiene la stringa di ricerca all'inizio della prima stringa.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">I risultati sono interessati dalla scelta di impostazioni cultura, se è ignorare maiuscole/minuscole e se viene eseguito un confronto ordinale.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</source>
          <target state="translated">Si noti che quando l'istanza di stringa contiene un alfabeto, i confronti dipendenti dalle impostazioni cultura con relativi caratteri consecutivi corrispondano correttamente.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> non è un valore di <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare.</source>
          <target state="translated">Stringa da confrontare.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Informazioni relative alle impostazioni cultura che determinano le modalità di confronto tra questa stringa e <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verranno usate le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante le impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> corrisponde all'inizio di questa stringa; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the beginning of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">Questo metodo consente di confrontare il <ph id="ph1">`value`</ph> parametro con la sottostringa all'inizio di questa stringa che rappresenta la stessa lunghezza <ph id="ph2">`value`</ph>e restituisce un valore che indica se sono uguali.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">Per essere uguali, <ph id="ph1">`value`</ph> deve essere una stringa vuota (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), deve essere un riferimento alla stessa istanza o deve corrispondere all'inizio di questa istanza.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a comparison using the specified casing and culture.</source>
          <target state="translated">Questo metodo esegue un confronto usando le maiuscole e minuscole specificata e le impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the beginning of another string.</source>
          <target state="translated">Nell'esempio seguente determina se una stringa si verifica all'inizio di un'altra stringa.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> metodo viene chiamato più volte con distinzione maiuscole/minuscole, maiuscole e minuscole e diverse impostazioni cultura che determinano i risultati della ricerca.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Recupera una sottostringa da questa istanza.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>This member is overloaded.</source>
          <target state="translated">Si tratta di un membro di overload.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</source>
          <target state="translated">Per informazioni complete su questo membro, inclusi la sintassi, l'uso e gli esempi, fare clic su un nome nell'elenco degli overload.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">Posizione iniziale in base zero del carattere di una sottostringa in questa istanza.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Recupera una sottostringa da questa istanza.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The substring starts at a specified character position and continues to the end of the string.</source>
          <target state="translated">La sottostringa inizia in corrispondenza di un carattere specificato e continua fino alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>A string that is equivalent to the substring that begins at <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance.</source>
          <target state="translated">Stringa equivalente alla sottostringa che inizia in corrispondenza di <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> in questa istanza oppure <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> se <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> è uguale alla lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> metodo per estrarre una sottostringa da una stringa che inizia alla posizione del carattere specificato e termina alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">La posizione iniziale del carattere è un'in base zero. in altre parole, il primo carattere nella stringa è in corrispondenza dell'indice 0, non di indice 1.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins at a specified character position and ends before to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method.</source>
          <target state="translated">Per estrarre una sottostringa che inizia alla posizione del carattere specificato e termina prima alla fine della stringa, chiamare il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>Instead, it returns a new string that begins at the <ph id="ph1">`startIndex`</ph> position in the current string.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa che inizia in corrispondenza di <ph id="ph1">`startIndex`</ph> posizione nella stringa corrente.</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">Per estrarre una sottostringa che inizia con un determinato carattere o sequenza di caratteri, chiamare un metodo, ad esempio <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> per ottenere il valore di <ph id="ph3">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</source>
          <target state="translated">Il secondo esempio viene illustrato questo oggetto. estrae un valore di chiave che inizia una posizione di carattere dopo il carattere "=".</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero, the method returns the original string unchanged.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale a zero, il metodo restituisce la stringa originale invariata.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example demonstrates obtaining a substring from a string.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come ottenere una sottostringa da una stringa.</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> (metodo) per separare le coppie chiave/valore delimitate da è uguale a un carattere ("=").</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo viene utilizzato per ottenere la posizione del carattere di uguale nella stringa di...</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">La chiamata al <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> metodo estrae la chiave name., che inizia dal primo carattere nella stringa di e si estende per il numero di caratteri restituiti dalla chiamata al metodo di <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">La chiamata al <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> metodo quindi estrae il valore assegnato alla chiave.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">Una posizione di carattere oltre il carattere di uguale e alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> è minore di zero o maggiore della lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">Posizione iniziale in base zero del carattere di una sottostringa in questa istanza.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The number of characters in the substring.</source>
          <target state="translated">Numero di caratteri nella sottostringa.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Recupera una sottostringa da questa istanza.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The substring starts at a specified character position and has a specified length.</source>
          <target state="translated">La sottostringa inizia in corrispondenza della posizione del carattere specificata e ha la lunghezza specificata.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>A string that is equivalent to the substring of length <ph id="ph1">&lt;paramref name="length" /&gt;</ph> that begins at <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance and <ph id="ph5">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated">Stringa equivalente alla sottostringa di lunghezza <ph id="ph1">&lt;paramref name="length" /&gt;</ph> che inizia in corrispondenza di <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> in questa istanza oppure <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> se <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> è uguale alla lunghezza di questa istanza e <ph id="ph5">&lt;paramref name="length" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> metodo per estrarre una sottostringa da una stringa che inizia alla posizione del carattere specificato e termina prima della fine della stringa.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">La posizione iniziale del carattere è un'in base zero. in altre parole, il primo carattere nella stringa è in corrispondenza dell'indice 0, non di indice 1.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins at a specified character position and continues to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method.</source>
          <target state="translated">Per estrarre una sottostringa che inizia alla posizione del carattere specificata e continua fino alla fine della stringa, chiamare il <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Instead, it returns a new string with <ph id="ph1">`length`</ph> characters starting from the <ph id="ph2">`startIndex`</ph> position in the current string.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa con <ph id="ph1">`length`</ph> caratteri a partire dal <ph id="ph2">`startIndex`</ph> posizione nella stringa corrente.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`length`</ph> parameter represents the total number of characters to extract from the current string instance.</source>
          <target state="translated">Il <ph id="ph1">`length`</ph> parametro rappresenta il numero totale di caratteri da estrarre dall'istanza di stringa corrente.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This includes the starting character found at index  <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Ciò include il carattere iniziale nell'indice <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In other words, the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method attempts to extract characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> - 1.</source>
          <target state="translated">In altre parole, il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> metodo tenta di estrarre i caratteri dall'indice <ph id="ph2">`startIndex`</ph> all'indice <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> - 1.</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">Per estrarre una sottostringa che inizia con un determinato carattere o sequenza di caratteri, chiamare un metodo, ad esempio <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> per ottenere il valore di <ph id="ph3">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the substring extends from <ph id="ph1">`startIndex`</ph> to a specified character sequence, you can call a method such as  <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the index of the ending character or character sequence.</source>
          <target state="translated">Se si estende la sottostringa da <ph id="ph1">`startIndex`</ph> una sequenza di caratteri specificato, è possibile chiamare un metodo, ad esempio <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> per ottenere l'indice del carattere finale o sequenza di caratteri.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You can then convert that value to an index position in the string as follows:</source>
          <target state="translated">È possibile convertire tale valore in una posizione di indice nella stringa come indicato di seguito:</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for a single character that is to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph> + 1, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Se è cercato un singolo carattere che deve contrassegnare la fine della sottostringa, il <ph id="ph1">`length`</ph> parametro è uguale a <ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph> + 1, dove <ph id="ph5">`endIndex`</ph> è il valore restituito del <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a continuous block of "b" characters from a string.</source>
          <target state="translated">Nell'esempio seguente estrae un blocco continuo di caratteri "b" da una stringa.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for multiple characters that are to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`endMatchLength`</ph><ph id="ph5"> - </ph><ph id="ph6">`startIndex`</ph>, where <ph id="ph7">`endIndex`</ph> is the return value of the <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> method., and <ph id="ph10">`endMatchLength`</ph> is the length of the character sequence that marks the end of the substring.</source>
          <target state="translated">Se è cercato di più caratteri per contrassegnare la fine della sottostringa, il <ph id="ph1">`length`</ph> parametro è uguale a <ph id="ph2">`endIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`endMatchLength`</ph> <ph id="ph5"> - </ph> <ph id="ph6">`startIndex`</ph>, dove <ph id="ph7">`endIndex`</ph> è il valore restituito di <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo. e <ph id="ph10">`endMatchLength`</ph> è la lunghezza della sequenza di caratteri che contrassegna la fine della sottostringa.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a block of text that contains an XML <ph id="ph1">`&lt;definition&gt;`</ph> element.</source>
          <target state="translated">L'esempio seguente estrae un blocco di testo che contiene un file XML <ph id="ph1">`&lt;definition&gt;`</ph> elemento.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the character or character sequence is not included in the end of the substring, the <ph id="ph1">`length`</ph> parameter equals <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph>, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Se non è incluso il carattere o sequenza di caratteri alla fine della sottostringa, il <ph id="ph1">`length`</ph> parametro è uguale a <ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph>, dove <ph id="ph5">`endIndex`</ph> è il valore restituito del <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> o <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale a zero e uguale la lunghezza della stringa corrente, il metodo restituisce la stringa originale senza modificata.</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example illustrates a simple call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</source>
          <target state="translated">Nell'esempio seguente viene illustrata una semplice chiamata al <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> metodo che estrae i due caratteri da una stringa a partire dalla sesta posizione di carattere (ovvero, in corrispondenza dell'indice 5).</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method in the following three cases to isolate substrings within a string.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> metodo nei tre casi seguenti per isolare le sottostringhe in una stringa.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</source>
          <target state="translated">Nei due casi vengono utilizzate le sottostringhe nei confronti e nel terzo caso viene generata un'eccezione perché sono stati specificati parametri non validi.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</source>
          <target state="translated">Estrae il singolo carattere e la terza posizione nella stringa (corrispondenza dell'indice 2) e lo confronta con "c".</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This comparison returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Questo confronto restituisce <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">Estrae zero caratteri a partire dalla posizione del quarto presenti nella stringa (in corrispondenza dell'indice 3) e lo passa al <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This returns true because the call to the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Restituisce true perché la chiamata al <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> restituisce <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It attempts to extract one character starting at the fourth position in the string.</source>
          <target state="translated">Tenta di estrarre un carattere a partire dalla posizione nella stringa di quarto.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Because there is no character at that position, the method call throws an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception.</source>
          <target state="translated">Poiché non è presente alcun carattere in tale posizione, la chiamata al metodo genera un <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> eccezione.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> (metodo) per separare le coppie chiave/valore delimitate da è uguale a un carattere ("=").</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo viene utilizzato per ottenere la posizione del carattere di uguale nella stringa di...</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">La chiamata al <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> metodo estrae la chiave name., che inizia dal primo carattere nella stringa di e si estende per il numero di caratteri restituiti dalla chiamata al metodo di <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">La chiamata al <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> metodo quindi estrae il valore assegnato alla chiave.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">Una posizione di carattere oltre il carattere di uguale e alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> indicates a position not within this instance.</source>
          <target state="translated">La somma di <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> indica una posizione non all'interno di questa istanza.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce un enumeratore che esegue l'iterazione dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>A strongly-typed enumerator that can be used to iterate through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Enumeratore fortemente tipizzato che può essere usato per eseguire l'iterazione nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface object.</source>
          <target state="translated">E può essere utilizzato solo quando il <ph id="ph1">&lt;xref:System.String&gt;</ph> esegue il cast dell'istanza di un <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> oggetto di interfaccia.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Restituisce un enumeratore che esegue l'iterazione dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator that can be used to iterate through the current string.</source>
          <target state="translated">Enumeratore utilizzabile per eseguire l'iterazione degli elementi della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Questo parametro viene ignorato.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the current string is <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the value of the current string is <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore della stringa corrente è <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>; <ph id="ph3">&lt;see langword="false" /&gt;</ph> se il valore della stringa corrente è <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The value of the current string is not <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated">Il valore della stringa corrente non è <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> o <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero maggiore di <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> o minore di <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The character at index 0 in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Carattere in corrispondenza dell'indice 0 nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> or than <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph> greater.</source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero minore di <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> o maggiore di <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero minore di <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> o maggiore di <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero maggiore di <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> o minore di <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero maggiore di <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> o minore di <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The type of the returned object.</source>
          <target state="translated">Tipo dell'oggetto restituito.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be converted to the type specified by the <ph id="ph2">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Non è possibile convertire il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente nel tipo specificato dal parametro <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero maggiore di <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> o minore di <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Non è possibile analizzare il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph></source>
          <target state="translated">Il valore dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente è un numero maggiore di  <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> o minore di <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Valore convertito dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.String&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L'alternativa consigliata consiste nel chiamare il <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">Copia i caratteri di questa istanza in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">Copia i caratteri di questa istanza in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>A Unicode character array whose elements are the individual characters of this instance.</source>
          <target state="translated">Matrice di caratteri Unicode i cui elementi sono i singoli caratteri di questa istanza.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>If this instance is an empty string, the returned array is empty and has a zero length.</source>
          <target state="translated">Se l'istanza è una stringa vuota, la matrice restituita sarà vuota e di lunghezza zero.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>This method copies each character (that is, each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object) in a string to a character array.</source>
          <target state="translated">Questo metodo copia ogni carattere (ovvero, ogni <ph id="ph1">&lt;xref:System.Char&gt;</ph> oggetto) in una stringa in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The first character copied is at index zero of the returned character array; the last character copied is at index <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</source>
          <target state="translated">È il primo carattere copiato in corrispondenza dell'indice zero della matrice di caratteri restituiti; è l'ultimo carattere copiato in corrispondenza dell'indice <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a string from the characters in a character array, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">Per creare una stringa di caratteri in una matrice di caratteri, chiamare il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a byte array that contains the encoded characters in a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per creare una matrice di byte che contiene i caratteri codificati in una stringa, creare un'istanza appropriata <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> oggetto e chiamare il relativo <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">Alcune delle codifiche standard disponibili in .NET Framework includono quanto segue:</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Encoding</source>
          <target state="translated">Codifica</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>ASCII</source>
          <target state="translated">non</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>codifica dei caratteri in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to extract the characters in a string to a character array.</source>
          <target state="translated">L'esempio seguente chiama il <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> metodo per estrarre i caratteri in una stringa in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then displays the original string and the elements in the array.</source>
          <target state="translated">Visualizza quindi la stringa originale e gli elementi nella matrice.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example defines a string containing the characters that serve as delimiters in a delimited string.</source>
          <target state="translated">L'esempio seguente definisce una stringa contenente i caratteri utilizzati come delimitatori di una stringa delimitata.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to create a character array that can be passed to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate the delimited string into its individual substrings.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> metodo per creare una matrice di caratteri che può essere passata al <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> metodo per suddividere la stringa delimitata in relative sottostringhe singoli.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The starting position of a substring in this instance.</source>
          <target state="translated">Posizione iniziale di una sottostringa in questa istanza.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The length of the substring in this instance.</source>
          <target state="translated">Lunghezza della sottostringa in questa istanza.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Copies the characters in a specified substring in this instance to a Unicode character array.</source>
          <target state="translated">Copia i caratteri di una determinata sottostringa di questa istanza in una matrice di caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>A Unicode character array whose elements are the <ph id="ph1">&lt;paramref name="length" /&gt;</ph> number of characters in this instance starting from character position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri Unicode i cui elementi sono il numero <ph id="ph1">&lt;paramref name="length" /&gt;</ph> di caratteri di questa istanza a partire dalla posizione <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> del carattere.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>This method copies the characters in a portion of a string to a character array.</source>
          <target state="translated">Questo metodo copia i caratteri in una parte di una stringa in una matrice di caratteri.</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a string from a range of characters in a character array, call the  <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Per creare una stringa di un intervallo di caratteri in una matrice di caratteri, chiamare il <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter is zero-based.</source>
          <target state="translated">Il <ph id="ph1">`startIndex`</ph> in base zero.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>That is, the index of the first character in the string instance is zero.</source>
          <target state="translated">Ovvero, l'indice del primo carattere nell'istanza della stringa è zero.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`length`</ph> is zero, the returned array is empty and has a zero length.</source>
          <target state="translated">Se <ph id="ph1">`length`</ph> è zero, la matrice restituita è vuota e ha una lunghezza zero.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If this instance is <ph id="ph1">`null`</ph> or an empty string (""), the returned array is empty and has a zero length.</source>
          <target state="translated">Se questa istanza è <ph id="ph1">`null`</ph> o una stringa vuota (""), la matrice restituita è vuota e ha una lunghezza zero.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Per creare una matrice di byte che contiene i caratteri codificati in una parte di una stringa, creare un'istanza appropriata <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> oggetto e chiamare il relativo <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">Alcune delle codifiche standard disponibili in .NET Framework includono quanto segue:</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Encoding</source>
          <target state="translated">Codifica</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>ASCII</source>
          <target state="translated">non</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>codifica dei caratteri in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</source>
          <target state="translated">Nell'esempio seguente converte una sottostringa all'interno di una stringa in una matrice di caratteri, quindi enumera e visualizza gli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">la somma dei parametri <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è maggiore della lunghezza di questa istanza.</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">Restituisce una copia di questa stringa convertita in caratteri minuscoli.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">Restituisce una copia di questa stringa convertita in caratteri minuscoli.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>A string in lowercase.</source>
          <target state="translated">Stringa di caratteri minuscoli.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method takes into account the casing rules of the current culture.</source>
          <target state="translated">Questo metodo prende in considerazione le regole di maiuscole e minuscole delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in minuscolo.</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Security Considerations</source>
          <target state="translated">Considerazioni sulla sicurezza</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">L'operazione di maiuscole e minuscole risultante dalla chiamata di <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> metodo considerando le convenzioni delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">Ciò produce lo stesso risultato in tutte le impostazioni cultura (a differenza di <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> metodo) ed esegue in modo più efficiente.</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The following example converts several mixed case strings to lowercase.</source>
          <target state="translated">Nell'esempio seguente converte misti di alcune stringhe in caratteri minuscoli.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, si consiglia di evitare di chiamare metodi di maiuscole e minuscole delle stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>To convert a character to lowercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">Per convertire un carattere in minuscolo utilizzando le convenzioni delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</source>
          <target state="translated">Restituisce una copia di questa stringa convertita in caratteri minuscoli, usando le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">Equivalente in caratteri minuscoli della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of the string is changed.</source>
          <target state="translated">Le regole di maiuscole e minuscole delle impostazioni cultura specificate per il <ph id="ph1">`culture`</ph> parametro determinano la modalità di formattazione della stringa verrà modificata.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in minuscolo.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">Considerazioni sulla sicurezza</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">Se si passa il <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> metodo un <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto diverso da <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, l'operazione di maiuscole e minuscole per considerare le regole specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">Questo produce lo stesso risultato in tutte le impostazioni cultura e lo esegue in modo più efficiente.</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</source>
          <target state="translated">Nell'esempio seguente converte le due stringhe di caratteri maiuscoli in caratteri minuscoli utilizzando le impostazioni cultura italiano e turco (Turchia), quindi confronta le stringhe di caratteri minuscole.</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Le stringhe in maiuscolo sono identiche ad eccezione del fatto che per ogni occorrenza del Unicode LATIN CAPITAL LETTER I in una stringa, l'altra stringa contiene LATIN CAPITAL LETTER I con punto sopra.</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to lowercase using the casing rules of the invariant culture.</source>
          <target state="translated">Restituisce una copia dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> convertito in caratteri minuscoli mediante le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura invariabili.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">Equivalente in caratteri minuscoli della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">La lingua inglese rappresenta impostazioni cultura che sono indipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">È associato con la lingua inglese, ma non con un paese o area.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per altre informazioni, vedere la proprietà <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Se l'applicazione dipende da nel caso di una stringa che cambia in modo prevedibile che è indipendente dalle impostazioni cultura correnti, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> metodo è equivalente a <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">Il metodo è consigliato per una raccolta di stringhe deve trovarsi in un ordine prestabilito in un controllo dell'interfaccia utente.</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in minuscolo.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Security Considerations</source>
          <target state="translated">Considerazioni sulla sicurezza</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">L'esempio seguente definisce una matrice di stringhe che contiene una singola parola in un numero di lingue.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> metodo viene utilizzato per compilare gli elementi di una matrice parallela con la versione di ogni parola tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> metodo viene utilizzato per ordinare la matrice di distinzione maiuscole/minuscole in base all'ordine di elementi nella matrice di caratteri minuscolo per garantire che gli elementi vengono visualizzati nello stesso ordine indipendentemente dal linguaggio.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of this instance to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Converte il valore di questa istanza in un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">Restituisce questa istanza di <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>. Non viene eseguita alcuna conversione effettiva.</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>The current string.</source>
          <target state="translated">Stringa corrente.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">Poiché questo metodo restituisce semplicemente la stringa corrente invariata, non è necessario chiamarlo direttamente.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>It is usually called implicitly in a composite formatting operation, as the example shows.</source>
          <target state="translated">Viene in genere chiamato in modo implicito in un'operazione, come illustrato nell'esempio di formattazione composita.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> method.Note that the example does not explicitly call the <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> metodo. Si noti che nell'esempio viene chiamato in modo esplicito il <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Instead, the method is called implicitly by the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature.</source>
          <target state="translated">Al contrario, il metodo viene chiamato in modo implicito dal <bpt id="p1">[</bpt>formattazione composita<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> funzionalità.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>(Reserved) An object that supplies culture-specific formatting information.</source>
          <target state="translated">(Riservato) Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">Restituisce questa istanza di <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>. Non viene eseguita alcuna conversione effettiva.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>The current string.</source>
          <target state="translated">Stringa corrente.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source><ph id="ph1">`provider`</ph> is reserved, and does not currently participate in this operation.</source>
          <target state="translated"><ph id="ph1">`provider`</ph> è riservato e attualmente non fa parte di questa operazione.</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">Poiché questo metodo restituisce semplicemente la stringa corrente invariata, non è necessario chiamarlo direttamente.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">Restituisce una copia di questa stringa convertita in caratteri maiuscoli.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">Restituisce una copia di questa stringa convertita in caratteri maiuscoli.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Equivalente in caratteri maiuscoli della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</source>
          <target state="translated">Questo metodo utilizza le regole di maiuscole e minuscole delle impostazioni cultura correnti per convertire ogni carattere nell'istanza corrente nell'equivalente maiuscolo.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</source>
          <target state="translated">Se un carattere non ha un equivalente maiuscolo, viene incluso invariato nella stringa restituita.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in maiuscolo.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> metodo viene spesso utilizzato per convertire una stringa in lettere maiuscole, in modo che può essere utilizzato in un confronto tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>A better method to perform case-insensitive comparison is to call a string comparison method that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter whose value you set to <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> for a culture-sensitive, case-insensitive comparison.</source>
          <target state="translated">Un metodo migliore per eseguire un confronto tra maiuscole e minuscole consiste nel chiamare un metodo di confronto tra stringhe con un <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parametro il cui valore è impostato su <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> per un confronto con distinzione delle impostazioni cultura senza distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Security Considerations</source>
          <target state="translated">Considerazioni sulla sicurezza</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">L'operazione di maiuscole e minuscole risultante dalla chiamata di <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> metodo considerando le convenzioni delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">Ciò produce lo stesso risultato in tutte le impostazioni cultura (a differenza di <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> metodo) ed esegue in modo più efficiente.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</source>
          <target state="translated">L'esempio seguente chiama il <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> metodo per convertire una serie di stringhe di un carattere che contengono ogni carattere nei set di caratteri esteso latino di base, Supplemento latino 1 e latina.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>It then displays each string whose uppercase character is different from its lowercase character.</source>
          <target state="translated">Visualizza quindi ogni stringa i cui caratteri maiuscoli in caratteri è diverso dal carattere minuscolo.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Come spiegato in <bpt id="p1">[</bpt>procedure consigliate per l'uso di stringhe<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, si consiglia di evitare di chiamare metodi di maiuscole e minuscole delle stringhe che sostituiscono i valori predefiniti e di chiamano invece i metodi che richiedono parametri per specificare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>To convert a string to uppercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">Per convertire una stringa in lettere maiuscole utilizzando le convenzioni delle impostazioni cultura correnti, chiamare il <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> overload del metodo con un valore di <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> per relativo <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</source>
          <target state="translated">Restituisce una copia di questa stringa convertita in caratteri maiuscoli, usando le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Equivalente in caratteri maiuscoli della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of a string is changed.</source>
          <target state="translated">Le regole di maiuscole e minuscole delle impostazioni cultura specificate per il <ph id="ph1">`culture`</ph> parametro determinano il modo nel caso di una stringa vengono modificati.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in maiuscolo.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">Considerazioni sulla sicurezza</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">Se si passa il <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> metodo un <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto diverso da <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, l'operazione di maiuscole e minuscole per considerare le regole specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">Questo produce lo stesso risultato in tutte le impostazioni cultura e lo esegue in modo più efficiente.</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</source>
          <target state="translated">Nell'esempio seguente converte una stringa di caratteri minuscoli in due stringhe di caratteri maiuscoli utilizzando le impostazioni cultura italiano e turco (Turchia), quindi confronta le stringhe in maiuscolo.</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Le stringhe in maiuscolo sono identiche ad eccezione del fatto che per ogni occorrenza del Unicode LATIN CAPITAL LETTER I in una stringa, l'altra stringa contiene LATIN CAPITAL LETTER I con punto sopra.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to uppercase using the casing rules of the invariant culture.</source>
          <target state="translated">Restituisce una copia dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> convertito in caratteri maiuscoli mediante le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura invariabili.</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Equivalente in caratteri maiuscoli della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">La lingua inglese rappresenta impostazioni cultura che sono indipendente dalle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">È associato con la lingua inglese, ma non con un paese o area.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per altre informazioni, vedere la proprietà <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Se l'applicazione dipende da nel caso di una stringa che cambia in modo prevedibile che è indipendente dalle impostazioni cultura correnti, utilizzare il <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo è equivalente a <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">Il metodo è consigliato per una raccolta di stringhe deve trovarsi in un ordine prestabilito in un controllo dell'interfaccia utente.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in maiuscolo.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Security Considerations</source>
          <target state="translated">Considerazioni sulla sicurezza</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">L'esempio seguente definisce una matrice di stringhe che contiene una singola parola in un numero di lingue.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> metodo viene utilizzato per compilare gli elementi di una matrice parallela con la versione di ogni parola tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> metodo viene utilizzato per ordinare la matrice di distinzione maiuscole/minuscole in base all'ordine di elementi nella matrice in maiuscolo per assicurarsi che gli elementi vengono visualizzati nello stesso ordine indipendentemente dal linguaggio.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object are removed.</source>
          <target state="translated">Restituisce una nuova stringa in cui vengono rimosse tutte le occorrenze iniziali e finali di un set di caratteri specificati contenuti nell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>Removes all leading and trailing white-space characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Rimuove tutti gli spazi vuoti iniziali e finali dall'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>The string that remains after all white-space characters are removed from the start and end of the current string.</source>
          <target state="translated">Stringa risultante dopo che tutti gli spazi vuoti sono stati rimossi dall'inizio e dalla fine della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing white-space characters.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> metodo rimuove dalla stringa corrente tutti i caratteri spazi vuoti iniziali e finali.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Each leading and trailing trim operation stops when a non-white-space character is encountered.</source>
          <target state="translated">Ogni operazione di taglio iniziali e finali si interrompe quando viene rilevato uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>For example, if the current string is "   abc   xyz   ", the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc   xyz".</source>
          <target state="translated">Se la stringa corrente è "abc xyz", ad esempio il <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> metodo restituisce "abc xyz".</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>To remove white-space characters between words in a string, use a <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Per rimuovere i caratteri di spazio tra le parole in una stringa, utilizzare un <bpt id="p1">[</bpt>espressioni regolari di .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui vengono rimossi tutti i caratteri spazi vuoti iniziali e finali trovati nell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of white-space characters, the method returns <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Se la stringa corrente è uguale a <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> o tutti i caratteri nell'istanza corrente è costituito da spazi vuoti, il metodo restituisce <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">Gli spazi vuoti sono definiti dallo standard Unicode.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> method removes any leading and trailing characters that produce a return value of <ph id="ph2">`true`</ph> when they are passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> metodo rimuove qualsiasi carattere iniziali e finali che producono un valore restituito di <ph id="ph2">`true`</ph> quando vengono passati al <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> method to remove any extra white space from strings entered by the user before concatenating them.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> per rimuovere qualsiasi spazio vuoto aggiuntivo da immessi dall'utente prima della concatenazione di stringhe.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintain an internal list of white-space characters that this method trims.</source>
          <target state="translated">Il <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti viene mantenuto un elenco interno di spazi vuoti rimossi da questo metodo.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph2">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <ph id="ph2">&lt;see langword="true" /&gt;</ph> valore restituito quando vengono passati al <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> (metodo)).</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">Grazie a questa modifica, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo nel <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>e versioni successive non non rimuovere.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Inoltre, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti non trim spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), "narrow" senza interruzione spazio (U + 202F) e media matematica spazio (U + 205F).</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri Unicode da rimuovere oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Rimuove dall'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente tutte le occorrenze iniziali e finali di un set di caratteri specificati in una matrice.</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start and end of the current string.</source>
          <target state="translated">Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> sono state rimosse dall'inizio e dalla fine della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una matrice vuota, verranno rimossi invece gli spazi vuoti.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> metodo rimuove dalla stringa corrente tutti i caratteri iniziali e finali presenti il <ph id="ph2">`trimChars`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Each leading and trailing trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">Ogni iniziali e finali trim operazione si arresta un carattere che non si trova in <ph id="ph1">`trimChars`</ph> viene rilevato.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc456xyz".</source>
          <target state="translated">Ad esempio, se la stringa corrente è "123abc456xyz789" e <ph id="ph1">`trimChars`</ph> contiene le cifre da "1" e "9", il <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> metodo restituisce "abc456xyz".</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Instead, it returns a new string in which all leading and trailing <ph id="ph1">`trimChars`</ph> characters found in the current instance are removed.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui tutte le iniziali e finali <ph id="ph1">`trimChars`</ph> caratteri trovati nell'istanza corrente vengono rimossi.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of characters in the <ph id="ph2">`trimChars`</ph> array, the method returns <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Se la stringa corrente è uguale a <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> o tutti i caratteri nell'istanza corrente è costituito da caratteri di <ph id="ph2">`trimChars`</ph> matrice, il metodo restituisce <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">`trimChars`</ph> is <ph id="ph2">`null`</ph> or an empty array, this method removes any leading or trailing characters that result in the method returning <ph id="ph3">`true`</ph> when they are passed to the <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method,</source>
          <target state="translated">Se <ph id="ph1">`trimChars`</ph> è <ph id="ph2">`null`</ph> o una matrice vuota, questo metodo rimuove qualsiasi carattere iniziali o finali che comporta la restituzione del metodo <ph id="ph3">`true`</ph> quando vengono passati al <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> , metodo</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method to remove space, asterisk (*), and apostrophe (') characters from a string.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> metodo per rimuovere i caratteri apostrofo ('), asterisco (*) e lo spazio da una stringa.</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated">Il <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti mantiene un elenco interno di spazi vuoti rimossi da questo metodo se <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, se <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <ph id="ph4">&lt;see langword="true" /&gt;</ph> valore restituito quando vengono passati al <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> (metodo)).</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">Grazie a questa modifica, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo nel <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>e versioni successive non non rimuovere.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Inoltre, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti non trim spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), "narrow" senza interruzione spazio (U + 202F) e media matematica spazio (U + 205F).</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri Unicode da rimuovere oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Removes all trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Rimuove dall'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente tutte le occorrenze finali di un set di caratteri specificati in una matrice.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the end of the current string.</source>
          <target state="translated">Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> sono state rimosse dalla fine della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, Unicode white-space characters are removed instead.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o se è una matrice vuota, verranno rimossi invece gli spazi vuoti Unicode.</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes from the current string all trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> metodo rimuove dalla stringa corrente tutti i caratteri finali presenti il <ph id="ph2">`trimChars`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The trim operation stops when the first character that is not in <ph id="ph1">`trimChars`</ph> is encountered at the end of the string.</source>
          <target state="translated">L'operazione di taglio si interrompe quando il primo carattere che non è in <ph id="ph1">`trimChars`</ph> viene rilevato alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method returns "123abc456xyz".</source>
          <target state="translated">Ad esempio, se la stringa corrente è "123abc456xyz789" e <ph id="ph1">`trimChars`</ph> contiene le cifre da "1" e "9", il <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> metodo restituirà "123abc456xyz".</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Instead, it returns a new string in which all trailing characters found in <ph id="ph1">`trimChars`</ph> are removed from the current string.</source>
          <target state="translated">Restituisce invece una nuova stringa in cui tutti i caratteri finali trovati <ph id="ph1">`trimChars`</ph> vengono rimosse dalla stringa corrente.</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> method to trim white space or punctuation marks from the end of a string.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> metodo per eliminare gli spazi o segni di punteggiatura dalla fine di una stringa.</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated">Il <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti mantiene un elenco interno di spazi vuoti rimossi da questo metodo se <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, se <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <ph id="ph4">&lt;see langword="true" /&gt;</ph> valore restituito quando vengono passati al <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> (metodo)).</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">Grazie a questa modifica, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo nel <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> e versioni successive non non rimuovere.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Inoltre, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti non trim spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), "narrow" senza interruzione spazio (U + 202F) e media matematica spazio (U + 205F).</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Matrice di caratteri Unicode da rimuovere oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>Removes all leading occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Rimuove dall'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> corrente tutte le occorrenze iniziali di un set di caratteri specificati in una matrice.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>The string that remains after all occurrences of characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start of the current string.</source>
          <target state="translated">Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> sono state rimosse dall'inizio della stringa corrente.</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una matrice vuota, verranno rimossi invece gli spazi vuoti.</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes from the current string all leading characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> metodo rimuove dalla stringa corrente in tutti i caratteri iniziali di <ph id="ph2">`trimChars`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">L'operazione di taglio si arresta quando un carattere che non si trova in <ph id="ph1">`trimChars`</ph> viene rilevato.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> method returns "abc456xyz789".</source>
          <target state="translated">Ad esempio, se la stringa corrente è "123abc456xyz789" e <ph id="ph1">`trimChars`</ph> contiene le cifre da "1" e "9", il <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> metodo restituisce "abc456xyz789".</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</source>
          <target state="translated">Al contrario, restituisce una nuova stringa in cui vengono rimossi tutti i caratteri spazi vuoti iniziali trovati nell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method to trim white space and comment characters from lines of source code.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> metodo per rimuovere gli spazi vuoti e caratteri di commento dalle righe del codice sorgente.</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">`StripComments`</ph> method wraps a call to <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</source>
          <target state="translated">Il <ph id="ph1">`StripComments`</ph> metodo esegue il wrapping di una chiamata a <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> e passa una matrice di caratteri che contiene uno spazio e il carattere di commento, ovvero un apostrofo (') in Visual Basic e una barra (/) in c#.</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method is also called to remove leading white space when evaluating whether a string is a comment.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> metodo viene chiamato anche per rimuovere gli spazi vuoti iniziali quando si valuta se una stringa è un commento.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example then illustrates a call to the <ph id="ph1">`StripComments`</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrata una chiamata al metodo <ph id="ph1">`StripComments`</ph>.</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated">Il <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti mantiene un elenco interno di spazi vuoti rimossi da questo metodo se <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una matrice vuota.</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, se <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <ph id="ph4">&lt;see langword="true" /&gt;</ph> valore restituito quando vengono passati al <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> (metodo)).</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">Grazie a questa modifica, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo nel <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> e versioni successive non non rimuovere.</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Inoltre, il <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> metodo il <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> e versioni precedenti non trim spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), "narrow" senza interruzione spazio (U + 202F) e media matematica spazio (U + 205F).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>