<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bca6cb70cbbc34b4d8170b379576027df0dbb65e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37731852" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta il testo come sequenza di unità di codice UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Una stringa è una raccolta sequenziale di caratteri utilizzato per rappresentare del testo. Oggetto <xref:System.String> oggetto è una raccolta sequenziale di <xref:System.Char?displayProperty=nameWithType> gli oggetti che rappresentano una stringa; un <xref:System.Char?displayProperty=nameWithType> oggetto corrisponde a un'unità di codice UTF-16. Il valore della <xref:System.String> oggetto è il contenuto della raccolta sequenza di <xref:System.Char?displayProperty=nameWithType> oggetti e che il valore è non modificabile (vale a dire è sola lettura). Per altre informazioni sull'immutabilità delle stringhe, vedere la [immutabilità e della classe StringBuilder](#Immutability) sezione più avanti in questo argomento. Le dimensioni massime di un <xref:System.String> oggetto in memoria è 2 GB o caratteri di circa 1 miliardo.  
  
 Contenuto della sezione:  
  
 [Creare un'istanza di un oggetto stringa](#Instantiation)   
 [Gli oggetti char e i caratteri Unicode](#Characters)   
 [Le stringhe e Standard Unicode](#Unicode)   
 [Le stringhe e caratteri null incorporati](#EmbeddedNulls)   
 [Le stringhe e gli indici](#Indexes)   
 [Stringhe null e stringhe vuote](#Nulls)   
 [Non modificabilità e la classe StringBuilder](#Immutability)   
 [Valore ordinale e operazioni con distinzione delle impostazioni cultura](#CultureSensitive)   
 [Normalizzazione](#Normalization)   
 [Operazioni sulle stringhe in base alla categoria](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Creare un'istanza di un oggetto stringa  
 È possibile creare un'istanza di un <xref:System.String> oggetto nei modi seguenti:  
  
-   Assegnando una valore letterale stringa a un <xref:System.String> variabile. Questo è il metodo più comunemente usato per la creazione di una stringa. Nell'esempio seguente usa l'assegnazione per creare più stringhe. Si noti che in c#, perché la barra rovesciata (\\) è un carattere di escape, deve utilizzare caratteri di escape barra rovesciata letterale in una stringa o l'intera stringa deve essere @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Chiamando un <xref:System.String> costruttore della classe. Nell'esempio seguente crea un'istanza di stringhe tramite una chiamata diversi costruttori di classe. Si noti che alcuni costruttori includere puntatori a matrici di caratteri o matrici di byte con segno come parametri. Visual Basic non supporta le chiamate a questi costruttori. Per informazioni dettagliate sui <xref:System.String> costruttori, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Usando l'operatore di concatenazione di stringhe (+ in c# e & o + in Visual Basic) per creare una singola stringa da qualsiasi combinazione di <xref:System.String> istanze e i valori letterali stringa. Nell'esempio seguente viene illustrato l'utilizzo dell'operatore di concatenazione di stringa.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Recupero di una proprietà o chiamando un metodo che restituisce una stringa. L'esempio seguente usa i metodi del <xref:System.String> classe per estrarre una sottostringa da una stringa più grande.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Chiamando un metodo di formattazione per convertire un valore o un oggetto nella relativa rappresentazione di stringa. L'esempio seguente usa il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità per incorporare la rappresentazione di stringa di due oggetti in una stringa.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Gli oggetti char e i caratteri Unicode  
 Ogni carattere in una stringa è definito da un valore scalare Unicode, detti anche un punto di codice Unicode o il valore ordinale (numerico) del carattere Unicode. Ogni punto di codice è codificato con codifica UTF-16 e il valore numerico di ogni elemento della codifica è rappresentato da un <xref:System.Char> oggetto.  
  
> [!NOTE]
>  Si noti che, poiché un <xref:System.String> istanza è costituita da una raccolta sequenziale di unità di codice UTF-16, è possibile creare un <xref:System.String> oggetto che non è una stringa Unicode in formato corretto. Ad esempio, è possibile creare una stringa che contiene un carattere surrogato basso senza un surrogato alto corrispondente. Anche se alcuni metodi, ad esempio i metodi di codifica e decodifica gli oggetti di <xref:System.Text> dello spazio dei nomi, potrebbe esegue i controlli per garantire che le stringhe siano in formato corretto, <xref:System.String> membri della classe non garantiscono che una stringa è ben formata.  
  
 Un unico <xref:System.Char> oggetto rappresenta in genere un singolo punto di codice, vale a dire il valore numerico del <xref:System.Char> è uguale al punto di codice. Ad esempio, il punto di codice "per il carattere a" è 0061 U +. Tuttavia, un punto di codice potrebbe richiedere più di un elemento con codificato (più <xref:System.Char> oggetto). Lo standard Unicode definisce due tipi di caratteri che corrispondono a più <xref:System.Char> oggetti: grafema e punti di codice supplementari Unicode che corrispondono ai caratteri nei piani supplementari Unicode.  
  
-   Un grafemi sono rappresentato da un carattere di base seguito da uno o più caratteri di combinazione. Ad esempio, il carattere ä è rappresentato dall'oggetto <xref:System.Char> il cui punto di codice è U+10000 0061 seguito da un oggetto <xref:System.Char> oggetto il cui punto di codice è 0308 U +. Questo carattere può anche essere definito da un singolo <xref:System.Char> oggetto con un punto di codice di U + 00E4. Come illustrato nell'esempio seguente, un confronto con distinzione delle impostazioni cultura per verificarne l'uguaglianza indica che questi due rappresentazioni sono uguali, anche se non lo fa un confronto ordinale comune. Tuttavia, se le due stringhe vengono normalizzate, un confronto ordinale anche indica che essi siano uguali. (Per altre informazioni sulla normalizzazione di stringhe, vedere la [normalizzazione](#Normalization) sezione.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode punto di codice supplementare (una coppia di surrogati) è rappresentato da un <xref:System.Char> oggetto il cui punto di codice è un surrogato alto seguito da un <xref:System.Char> oggetto il cui punto di codice è un surrogato basso. Le unità di codice di surrogati alti compreso tra U+D800 e U + DBFF. Le unità di codice di surrogati bassi compreso tra U+DC00 e U + DFFF. Coppie di surrogati vengono utilizzate per rappresentare i caratteri nei piani supplementari Unicode 16. Nell'esempio seguente crea un carattere surrogato e lo passa al <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> metodo per determinare se si tratta di una coppia di surrogati.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Le stringhe e Standard Unicode  
 In una stringa di caratteri sono rappresentati dalle unità di codice codificata UTF-16, che corrispondono a <xref:System.Char> valori.  
  
 Ogni carattere in una stringa è una categoria di carattere Unicode associata, che è rappresentata in .NET Framework per il <xref:System.Globalization.UnicodeCategory> enumerazione. La categoria di un carattere o una coppia di surrogati può essere determinata chiamando il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> (metodo).  
  
 .NET gestisce la propria tabella di caratteri e le relative categorie corrispondenti, che assicura che una versione specifica di un'implementazione di .NET in esecuzione su piattaforme diverse restituisce le informazioni sulle categorie di caratteri identiche. Nella tabella seguente elenca le versioni di .NET e le versioni dello Unicode Standard su cui si basano le categorie di caratteri.  
  
|Versione di .NET Framework|Versione dello Standard Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Lo Standard Unicode, versione 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[Lo Standard Unicode, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|  
|.NET core (tutte le versioni)|[Lo Standard Unicode, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 Inoltre, .NET Framework supporta il confronto di stringa e l'ordinamento basato sullo standard Unicode. Nelle versioni di .NET Framework tramite la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework gestisce la propria tabella di dati stringa. Questo vale anche delle versioni di .NET Framework a partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)] in esecuzione su Windows 7. A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i delegati di runtime in esecuzione in Windows 8 e versioni successive del sistema operativo Windows, stringa di confronto e ordinamento di operazioni al sistema operativo. Nella tabella seguente elenca le versioni di .NET Framework e le versioni dello Unicode Standard nella quale carattere si basano confronto e ordinamento.  
  
|Versione di .NET Framework|Versione dello Standard Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Lo Standard Unicode, versione 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive in Windows 7|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive in Windows 8 e versioni successive i sistemi operativi Windows|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  

In .NET Core, le operazioni di ordinamento e confronto sono basate sulla [Version 8.0.0 dello Unicode Standard](https://www.unicode.org/versions/Unicode8.0.0/).

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Le stringhe e caratteri null incorporati  
 In .NET Framework, un <xref:System.String> l'oggetto può includere caratteri null incorporati, conteggiate come parte della lunghezza della stringa. Tuttavia, in alcuni linguaggi, ad esempio C e C++, un carattere null indica la fine di una stringa, ma non viene considerata una parte della stringa e non conteggiato come parte della lunghezza della stringa. Ciò significa che i presupposti comuni seguenti che ai programmatori di C e C++ o librerie scritte in C o C++ potrebbero risultare sulle stringhe non sono necessariamente validi quando applicato a <xref:System.String> oggetti:  
  
-   Il valore restituito dal `strlen` oppure `wcslen` le funzioni non è necessariamente uguale <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   La stringa creata dal `strcpy_s` oppure `wcscpy_s` funzioni non è necessariamente identico alla stringa creata dal <xref:System.String.Copy%2A?displayProperty=nameWithType> (metodo).  
  
 È necessario assicurarsi che codice nativo C e C++ che crea un'istanza <xref:System.String> oggetti e il codice che viene passato <xref:System.String> oggetti tramite platform invoke, non dare per scontato che un carattere null incorporato contrassegna la fine della stringa.  
  
 Caratteri null incorporati in una stringa vengono inoltre considerati in modo diverso quando una stringa viene ordinata (o rispetto) e quando viene eseguita la ricerca di una stringa. Caratteri null vengono ignorati quando si eseguono confronti dipendenti dalle impostazioni cultura tra due stringhe, inclusi i confronti usando la lingua inglese. Questi sono considerati solo per i confronti ordinali ordinale o tra maiuscole e minuscole. D'altra parte, caratteri null incorporati vengono sempre considerati durante la ricerca di una stringa con i metodi, ad esempio <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, e <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Le stringhe e gli indici  
 Un indice è la posizione di un <xref:System.Char> oggetto (non un carattere Unicode) in un <xref:System.String>. Un indice è un numero non negativo in base zero che inizia dalla prima posizione nella stringa, ovvero la posizione di indice da zero. Un numero di metodi di ricerca, ad esempio <xref:System.String.IndexOf%2A> e <xref:System.String.LastIndexOf%2A>, restituire l'indice di un carattere o tra sottostringhe nell'istanza della stringa.  
  
 Il <xref:System.String.Chars%2A> proprietà consente di accedere a singoli <xref:System.Char> gli oggetti in base alla posizione dell'indice nella stringa. Poiché il <xref:System.String.Chars%2A> proprietà è la proprietà predefinita (in Visual Basic) o l'indicizzatore (in c#), è possibile accedere ai singoli <xref:System.Char> gli oggetti in una stringa usando codice simile al seguente. Questo codice cerca gli spazi vuoti o caratteri di punteggiatura di una stringa per determinare la stringa contiene il numero di parole.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Perché il <xref:System.String> classe implementa le <xref:System.Collections.IEnumerable> interfaccia, è anche possibile scorrere il <xref:System.Char> oggetti in una stringa usando un `foreach` costrutto, come illustrato nell'esempio seguente.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 I valori di indice consecutive potrebbero non corrispondere a consecutivi caratteri Unicode, perché un carattere Unicode può essere codificato in più di un <xref:System.Char> oggetto. In particolare, una stringa può contenere più caratteri unità di testo costituiti da un carattere di base seguito da uno o più caratteri di combinazione o da coppie di surrogati. Per lavorare con i caratteri Unicode anziché <xref:System.Char> oggetti, usare il <xref:System.Globalization.StringInfo?displayProperty=nameWithType> e <xref:System.Globalization.TextElementEnumerator> classi. Nell'esempio seguente viene illustrata la differenza tra il codice che funziona con <xref:System.Char> oggetti e il codice che funziona con i caratteri Unicode. Confronta il numero di caratteri o elementi di testo di ogni parola di una frase. La stringa include due sequenze di un carattere di base seguito da un carattere di combinazione.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 In questo esempio funziona con gli elementi di testo utilizzando il <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> metodo e il <xref:System.Globalization.TextElementEnumerator> classe per enumerare tutti gli elementi di testo in una stringa. È anche possibile recuperare una matrice che contiene l'indice iniziale di ogni elemento di testo chiamando il <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> (metodo).  
  
 Per altre informazioni sull'uso di unità di testo anziché singoli <xref:System.Char> valori, vedere il <xref:System.Globalization.StringInfo> classe.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Stringhe null e stringhe vuote  
 È una stringa che è stata dichiarata ma non è stata assegnata un valore `null`. Tentativo di chiamare metodi su tale stringa genera un <xref:System.NullReferenceException>. Una stringa null è diversa da una stringa vuota, che è una stringa il cui valore è "" o <xref:System.String.Empty?displayProperty=nameWithType>. In alcuni casi, passando una stringa null o una stringa vuota come argomento in una chiamata al metodo genera un'eccezione. Ad esempio, passando una stringa null per il <xref:System.Int32.Parse%2A?displayProperty=nameWithType> metodo genera un' <xref:System.ArgumentNullException>e passando una stringa vuota genera un <xref:System.FormatException>. In altri casi, un argomento del metodo può essere una stringa null o una stringa vuota. Ad esempio, se si specifica un <xref:System.IFormattable> implementazione per una classe, che si desidera equivalgono sia una stringa null e una stringa vuota con l'identificatore di formato generale ("G").  
  
 Il <xref:System.String> classe include i seguenti due metodi pratici che consentono di verificare se è una stringa `null` o vuoto:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, che indica se una stringa è uno `null` o è uguale a <xref:System.String.Empty?displayProperty=nameWithType>. Questo metodo elimina la necessità di usare codice simile al seguente:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, che indica se è una stringa `null`, è uguale a <xref:System.String.Empty?displayProperty=nameWithType>, o è costituito esclusivamente da spazi vuoti. Questo metodo elimina la necessità di usare codice simile al seguente:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 L'esempio seguente usa il <xref:System.String.IsNullOrEmpty%2A> metodo nella <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementazione di un oggetto personalizzato `Temperature` classe. Il metodo supporta le stringhe di formato "G", "C", "F" e "K". Se una stringa di formato vuoto o un formato stringa il cui valore è `null` viene passato al metodo, il relativo valore viene modificato per la stringa di formato "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Non modificabilità e la classe StringBuilder  
 Oggetto <xref:System.String> oggetto viene chiamato non modificabile (sola lettura), perché il relativo valore non può essere modificato dopo che è stato creato. I metodi che sembrano modificare una <xref:System.String> oggetti in realtà restituiscono un nuovo <xref:System.String> oggetto che contiene la modifica.  
  
 Poiché le stringhe sono modificabili, routine di modifica di stringhe che eseguono ripetuto aggiunte o le eliminazioni a quello che sembra essere che una stringa singola può esatte una riduzione significativa delle prestazioni. Ad esempio, il codice seguente usa un generatore di numeri casuali per creare una stringa con caratteri di 1000 0x0001 a 0x052F compreso nell'intervallo. Anche se il codice sembra utilizzare la concatenazione di stringhe da aggiungere un nuovo carattere nella stringa esistente denominato `str`, crea un nuovo <xref:System.String> oggetto per ogni operazione di concatenazione.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 È possibile usare la <xref:System.Text.StringBuilder> classe anziché il <xref:System.String> classe per le operazioni che rendono più modifiche al valore di una stringa. A differenza delle istanze del <xref:System.String> classe <xref:System.Text.StringBuilder> gli oggetti sono modificabili; quando si concatenare, aggiungere o eliminare sottostringhe da una stringa, le operazioni vengono eseguite in un'unica stringa. Dopo aver finito modificando il valore di una <xref:System.Text.StringBuilder> dell'oggetto, è possibile chiamare relativo <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodo per convertirlo in una stringa. Nell'esempio seguente sostituisce la <xref:System.String> usato nell'esempio precedente per concatenare i 1000 caratteri casuale nell'intervallo da 0x0001 a 0x052F con un <xref:System.Text.StringBuilder> oggetto.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Valore ordinale e operazioni con distinzione delle impostazioni cultura  
 I membri del <xref:System.String> classe operazioni ordinali o dipendenti dalle impostazioni cultura (linguistica) su un <xref:System.String> oggetto. Viene eseguita un'operazione ordinale del valore numerico della ognuno <xref:System.Char> oggetto. Un'operazione di distinzione delle impostazioni cultura agisce sul valore della <xref:System.String> oggetto e maiuscole e minuscole delle impostazioni cultura specifiche accetta, l'ordinamento, la formattazione e le regole di analisi in considerazione. Operazioni con distinzione delle impostazioni cultura vengono eseguite nel contesto di una cultura dichiarata in modo esplicito o implicita impostazioni cultura correnti. I due tipi di operazioni possono produrre risultati molto diversi quando vengono eseguiti sulla stessa stringa.  
  
 .NET Framework supporta anche operazioni linguistici della stringa indipendente dalle impostazioni cultura usando le impostazioni cultura invarianti (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), che si basa regime di controllo libero alle impostazioni cultura della lingua inglese indipendente dell'area. A differenza di altri <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> impostazioni, le impostazioni della cultura invariabile rimangono coerenti in un singolo computer, dal sistema al sistema e in tutte le versioni di .NET Framework. La lingua inglese può essere considerata come una sorta di casella nera che garantisce la stabilità dei confronti di stringhe e ordinamento tra tutte le impostazioni cultura.  
  
> [!IMPORTANT]
>  Se l'applicazione prende una decisione di sicurezza su un identificatore simbolico, ad esempio un nome di file o sulla named pipe o sui dati persistenti, ad esempio i dati basati su testo in un file XML, l'operazione deve usare un confronto ordinale anziché un confronto con distinzione delle impostazioni cultura. Infatti un confronto con distinzione delle impostazioni cultura può restituire risultati diversi a seconda delle impostazioni cultura in effetti, mentre un confronto ordinale dipende esclusivamente dal valore binario dei caratteri confrontati.  
  
> [!IMPORTANT]
>  La maggior parte dei metodi che eseguono operazioni sulle stringhe includono un overload che dispone di un parametro di tipo <xref:System.StringComparison>, che consente di specificare se il metodo esegue un'operazione ordinale o distinzione delle impostazioni cultura. In generale, è necessario chiamare questo overload per rendere lo scopo del metodo di chiamata non crittografato. Per le procedure consigliate e linee guida per l'uso di numeri ordinali e cultura operazioni sulle stringhe, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operazioni per [maiuscole e minuscole](#casing), [analisi e formattazione](#parsing), [confronto e ordinamento](#comparison), e [test dell'uguaglianza](#equality) possono essere entrambi numero ordinale o distinzione delle impostazioni cultura. Le sezioni seguenti illustrano ogni categoria dell'operazione.  
  
> [!TIP]
>  È sempre necessario chiamare un overload del metodo che effettua lo scopo del metodo di chiamata non crittografato. Ad esempio, invece di chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%29> metodo per eseguire un confronto con distinzione delle impostazioni cultura di due stringhe usando le convenzioni delle impostazioni cultura correnti, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo con un valore di <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> per il `comparisonType` argomento. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
<a name="casing"></a>   
### <a name="casing"></a>Maiuscole/minuscole  
 Le regole di distinzione tra maiuscole e determinano come modificare l'uso delle maiuscole per un carattere Unicode. ad esempio, da minuscolo a maiuscolo. Spesso, prima di un confronto tra stringhe viene eseguita un'operazione di maiuscole e minuscole. Una stringa, ad esempio, potrebbe essere convertita in caratteri maiuscoli in modo che può essere confrontato con un'altra stringa in caratteri maiuscoli. È possibile convertire i caratteri in una stringa in lettere minuscole chiamando il <xref:System.String.ToLower%2A> oppure <xref:System.String.ToLowerInvariant%2A> metodo ed è possibile eseguirne la conversione in maiuscolo, chiamare il <xref:System.String.ToUpper%2A> o <xref:System.String.ToUpperInvariant%2A> (metodo). Inoltre, è possibile usare il <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> metodo per convertire una stringa in maiuscolo.  
  
 Operazioni di maiuscole e minuscole possono basarsi sulle regole di impostazioni cultura correnti, impostazioni cultura specifiche o le impostazioni cultura invarianti. Poiché il mapping di maiuscole può variare a seconda delle impostazioni cultura usate, il risultato delle operazioni di maiuscole e minuscole può variare a seconda delle impostazioni cultura. Le differenze tra maiuscole e minuscole effettive sono di tre tipi:  
  
-   Differenze nel mapping di maiuscole dell'ALFABETO LATINO I (u+0049), alfabeto LATINO piccole lettera I (u+0069), alfabeto LATINO lettera maiuscola I con punto precedente (U + 0130) e LATINO piccole lettera punto I (U + 0131). Tr-TR (Turco (Turchia)) e le impostazioni cultura Latn-zone di disponibilità (Azerbaigian, alfabeto latino) e nel tr, az delle impostazioni cultura non associate di az-Latn, equivalente minuscolo di ALFABETO LATINO I LATINO piccole lettera punto I ed è l'equivalente maiuscolo del LATINO piccole lettera I LATINO LATINO. In tutte le altre lingue, tra cui le impostazioni cultura invarianti, alfabeto LATINO piccole lettera ricerca per categorie e lettera latina a maiuscola sono equivalenti in lettere minuscole e maiuscole.  
  
     Nell'esempio seguente viene illustrato come un confronto tra stringhe progettato per impedire l'accesso al file system può non riuscire se si basa su un confronto tra maiuscole e minuscole dipendenti dalle impostazioni cultura. (Le convenzioni delle impostazioni cultura invarianti devono sono state utilizzate.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Differenze nei mapping di maiuscole e tutte le altre impostazioni cultura e le impostazioni cultura invarianti. In questi casi, usando le regole di maiuscole e minuscole delle impostazioni cultura invarianti per modificare un carattere maiuscolo o minuscolo restituisce lo stesso carattere. Per tutte le altre lingue, restituisce un carattere diverso. Nella tabella seguente sono elencati alcuni dei caratteri interessati.  
  
    |Carattere|Se modificato in|Valore restituito|  
    |---------------|-------------------|-------------|  
    |MICRON SIGN (U + 00B5)|Maiuscole|MICROSOFT UPDATE ALFABETO GRECO (U +-39C)|  
    |LATINO CON PUNTO PRECEDENTE (U + 0130)|Minuscole|LATINO (U+0069)|  
    |CARATTERE ALFABETO SI (U + 0131)|Maiuscole|LATINO (U+0049)|  
    |LATINO LATINO (U + 017F)|Maiuscole|LATIN CAPITAL LETTER S (U + 0053)|  
    |ALFABETO LATINO 1!D CON Z ALFABETO LATINO (U + 01C 5)|Minuscole|CARATTERE ALFABETO LATINO LATINO (U + 01C 6)|  
    |COMBINAZIONE YPOGEGRAMMENI GRECO (U + 0345)|Maiuscole|IOTA ALFABETO GRECO (U + 0399)|  
  
-   Differenze nei mapping maiuscole di due lettere minuscole coppie nell'intervallo di caratteri ASCII. La maggior parte delle impostazioni cultura, una coppia di due lettere maiuscole e minuscole è uguale alla coppia di caratteri maiuscola o minuscola due lettere equivalente. Ciò non vale per le seguenti coppie di due lettere nelle lingue seguenti, perché in ogni caso rispetto a un digraph:  
  
    -   "lJ" e "nJ" nelle impostazioni cultura hr-HR (croato (Croazia)).  
  
    -   "cH" in cs-CZ (ceco (Repubblica ceca)) e le impostazioni cultura sk-SK (Slovacco (Slovacchia)).  
  
    -   "aA" nelle impostazioni cultura da-DK (danese (Danimarca)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" e "zS" nelle impostazioni cultura hu-HU (ungherese (Ungheria)).  
  
    -   "cH" e "lL" nelle impostazioni cultura es-ES tradnl (spagnolo (Spagna, ordinamento tradizionale)).  
  
    -   "cH", "gI", "kH", "nG" "hub di notifica", "pH", "qU", "tH" e "tR" nelle impostazioni cultura vi-VN (vietnamita (Vietnam)).  
  
     Tuttavia, è insolito riscontrare una situazione in cui un confronto con distinzione delle impostazioni cultura di queste coppie crea problemi, poiché queste coppie non sono comuni in stringhe fisse o gli identificatori.  
  
 L'esempio seguente illustra alcune delle differenze nelle regole di maiuscole e minuscole tra le impostazioni cultura durante la conversione di stringhe in lettere maiuscole.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Analisi e formattazione  
 Formattazione e analisi sono operazioni inverse. Regole di formattazione determinano come convertire un valore, ad esempio una data e ora o un numero, alla relativa rappresentazione di stringa, mentre le regole di analisi determinano come convertire una rappresentazione di stringa su un valore, ad esempio una data e ora. Formattazione sia le regole di analisi dipendono le convenzioni culturali. L'esempio seguente illustra l'ambiguità che può verificarsi durante l'interpretazione di una stringa di data specifiche delle impostazioni cultura. Senza conoscere le convenzioni delle impostazioni cultura usato per produrre una stringa di data, non è possibile sapere se 03/01/2011 e 3/1/2011 03/01/2011 rappresentano 3 gennaio 2011 o 1 marzo 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Analogamente, come illustrato nell'esempio seguente, una singola stringa può produrre date diverse a seconda le impostazioni cultura le cui convenzioni vengono usate nell'operazione di analisi.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Confronto tra stringhe e ordinamento  
 Convenzioni per il confronto e ordinamento delle stringhe variano alle impostazioni cultura. Ad esempio, l'ordinamento può essere basato sulla fonetica o sulla rappresentazione visiva dei caratteri. Nelle lingue asiatiche orientali, i caratteri sono ordinati per il tratto e radicali di ideogrammi. L'ordinamento dipende anche le lingue di ordine e usano le impostazioni cultura per l'alfabeto. Nella lingua danese, ad esempio, è presente un carattere "Æ" che viene ordinato alfabeticamente dopo la lettera Z. Inoltre, i confronti possono essere distinzione maiuscole/minuscole o maiuscole e minuscole, e in alcuni casi le regole di maiuscole e minuscole inoltre differiscano dalle impostazioni cultura. Confronto ordinale, d'altra parte, Usa i punti di codice Unicode dei singoli caratteri in una stringa durante il confronto e ordinamento delle stringhe.  
  
 Le regole di ordinamento determinano che l'ordine alfabetico dei caratteri Unicode e come due stringhe confrontano tra loro. Ad esempio, il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metodo confronta due stringhe in base il <xref:System.StringComparison> parametro. Se il valore del parametro <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, il metodo esegue un confronto linguistico che usa le convenzioni delle impostazioni cultura correnti; se il valore del parametro è <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, il metodo esegue un confronto ordinale. Di conseguenza, come illustrato nell'esempio seguente, se le impostazioni cultura correnti sono stati uniti Inglese, la prima chiamata al <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (metodo) (mediante confronto con distinzione delle impostazioni cultura) considera "a" minore di "A", ma la seconda chiamata al metodo di stesso (tramite un confronto ordinale) vengono considerati "a" maggiore di "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET Framework supporta word, stringa e le regole di ordinamento per ordinale:  
  
-   Un ordinamento di word esegue un confronto con distinzione delle impostazioni cultura delle stringhe in cui alcuni caratteri Unicode non alfanumerici potrebbero essere assegnati a tali pesi speciali. Ad esempio, il trattino (-) potrebbe avere una valenza ridotta a esso in modo che "co-op" e "coop" vengono visualizzati uno accanto a altro in un elenco ordinato. Per un elenco del <xref:System.String> metodi che consentono di confrontare due stringhe usando le regole di ordinamento di word, vedere la [operazioni di stringa in base alla categoria](#ByCategory) sezione.  
  
-   Un ordinamento per stringhe esegue inoltre un confronto con distinzione delle impostazioni cultura. È simile a un ordinamento di word, ad eccezione del fatto che esistono casi speciali e tutti i simboli non alfanumerici precedono a tutti i caratteri Unicode alfanumerici. Possono confrontare due stringhe usando le regole di ordinamento di stringa chiamando il <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> overload del metodo con un `options` parametro che viene fornito un valore di <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Si noti che questo è l'unico metodo che .NET Framework fornisce per confrontare due stringhe usando le regole di ordinamento di stringa.  
  
-   Un ordinamento per ordinale confronta le stringhe in base al valore numerico della ognuno <xref:System.Char> oggetto nella stringa. Un confronto ordinale è automaticamente distinzione maiuscole/minuscole perché le versioni maiuscole e minuscole di un carattere dispongono di punti di codice diverse. Tuttavia, se i casi non sono importanti, è possibile specificare un confronto ordinale che ignora i casi. Ciò equivale alla conversione della stringa in lettere maiuscole usando le impostazioni cultura invarianti ed eseguendo un confronto ordinale sul risultato. Per un elenco del <xref:System.String> metodi che consentono di confrontare due stringhe usando le regole di ordinamento per ordinale, vedere la [operazioni di stringa in base alla categoria](#ByCategory) sezione.  
  
 Un confronto con distinzione delle impostazioni cultura è qualsiasi confronto che in modo esplicito o implicito utilizza una <xref:System.Globalization.CultureInfo> oggetto, incluse le impostazioni cultura invarianti specificato da di <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> proprietà. Le impostazioni di cultura implicite sono le impostazioni cultura correnti, specificato mediante il <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> proprietà. È presente una notevole variazione nell'ordine dei caratteri alfabetici (ovvero i caratteri per il quale il <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> restituisce proprietà `true`) nelle impostazioni cultura. È possibile specificare un confronto con distinzione delle impostazioni cultura che usa le convenzioni delle impostazioni cultura specifiche, fornendo una <xref:System.Globalization.CultureInfo> dell'oggetto, ad esempio a un metodo di confronto tra stringhe <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. È possibile specificare un confronto con distinzione delle impostazioni cultura che usa le convenzioni delle impostazioni cultura correnti, fornendo <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, o qualsiasi membro del <xref:System.Globalization.CompareOptions> enumerazione diverso <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> o <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> al relativo eseguire l'overload del <xref:System.String.Compare%2A> (metodo). Un confronto con distinzione delle impostazioni cultura viene in genere adatto per l'ordinamento mentre non è un confronto ordinale. Un confronto ordinale è in genere adatto per determinare se due stringhe sono uguali (ovvero, per determinare l'identità) mentre non è un confronto con distinzione delle impostazioni cultura.  
  
 Nell'esempio seguente viene illustrata la differenza tra il confronto ordinale e distinzione delle impostazioni cultura. L'esempio restituisce tre stringhe, "Apple", "Æble" e "AEble", utilizzando un confronto ordinale e le convenzioni delle impostazioni cultura en-US e da-DK (ognuno dei quali è la lingua predefinita al momento il <xref:System.String.Compare%2A> viene chiamato). Poiché la lingua danese considera il carattere "" come una singola lettera e ordina nell'alfabeto "Z", la stringa "Æble" è maggiore di "Apple". Tuttavia, "Æble" non è considerata equivalente a "AEble", in modo "Æble" è anche maggiore di "AEble". Le impostazioni cultura en-US non includono la lettera "" ma viene considerata equivalente a quello "AE", che spiega il motivo per cui "Æble" è minore di "Apple" ma uguale a "AEble". Confronto ordinale, d'altra parte, considera "Apple" deve essere inferiore rispetto a "Æble" e "Æble" può essere maggiore di "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Usare le linee guida generali seguenti per scegliere un metodo di confronto di ordinamento o stringa appropriato:  
  
-   Se si desidera, le stringhe devono essere ordinati in base alle impostazioni cultura dell'utente, è necessario ordinare le convenzioni delle impostazioni cultura correnti in base. Se viene modificata la lingua dell'utente, l'ordine di stringhe ordinate anche cambiano di conseguenza. Ad esempio, un'applicazione del thesaurus deve sempre l'ordinamento di parole in base alla lingua dell'utente.  
  
-   Se si desidera, le stringhe devono essere ordinati in base alle convenzioni delle impostazioni cultura specifiche, è necessario ordinarle fornendo un <xref:System.Globalization.CultureInfo> oggetto che rappresenta quelle impostazioni cultura per un metodo di confronto. Ad esempio, in un'applicazione progettata per illustrare agli studenti un determinato linguaggio, si desidera stringhe devono essere ordinati basato sulle convenzioni di una delle impostazioni cultura che legge tale lingua.  
  
-   Se si desidera che l'ordine delle stringhe di rimanere invariato nelle impostazioni cultura, è necessario ordinarle in base alle convenzioni della lingua inglese o usano un confronto ordinale. Ad esempio, si utilizzerebbe un ordinamento per ordinale per organizzare i nomi dei file, processi, i mutex o named pipes.  
  
-   Per un confronto che coinvolge una decisione relativa alla sicurezza (ad esempio, se un nome utente è valido), è necessario eseguire sempre un ordinale test di uguaglianza chiamando un overload del <xref:System.String.Equals%2A> (metodo).  
  
> [!NOTE]
>  L'ordinamento dipendenti dalle impostazioni cultura e maiuscole e minuscole utilizzate nel confronto tra stringhe con regole dipendono dalla versione di .NET Framework. In .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] eseguono il [!INCLUDE[win8](~/includes/win8-md.md)] operativo di sistema, l'ordinamento, le maiuscole e minuscole, della normalizzazione e informazioni di carattere Unicode è conforme allo standard Unicode 6.0. In altri sistemi operativi, sia conforme allo standard Unicode 5.0.  
  
 Per altre informazioni sui word, stringa e le regole di ordinamento per ordinale, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> argomento. Per altre indicazioni su quando usare ogni regola, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 In genere, non chiamare stringa metodi di confronto, ad esempio <xref:System.String.Compare%2A> direttamente per determinare l'ordinamento delle stringhe. Al contrario, i metodi di confronto vengono chiamati i metodi di ordinamento, ad esempio <xref:System.Array.Sort%2A?displayProperty=nameWithType> o <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. L'esempio seguente esegue quattro diverse le operazioni di ordinamento (ordinamento di word usando le impostazioni cultura correnti, l'ordinamento per parola utilizzando le impostazioni cultura invarianti, ordinamento per ordinale e ordinamento delle stringhe utilizzando la lingua inglese) senza chiamare in modo esplicito un metodo di confronto di stringhe, anche se essi specifica il tipo di confronto da utilizzare. Si noti che ogni tipo di ordinamento produce un ordinamento univoco delle stringhe nella matrice.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Internamente,.NET Framework Usa chiavi di ordinamento per supportare il confronto di stringhe culturallysensitive. Ogni carattere nella stringa verrà attribuite varie categorie di ordinamenti, tra cui alfabetico case e segni diacritici. Una chiave di ordinamento, rappresentato dal <xref:System.Globalization.SortKey> classe, fornisce un archivio di tali pesi per una determinata stringa. Se l'app esegue un numero elevato di una ricerca o operazioni sullo stesso set di stringhe di ordinamento, è possibile migliorare le prestazioni generano e memorizzano chiavi di ordinamento per tutte le stringhe che usa. Quando viene richiesta un'operazione di ordinamento o confronto, si usano le chiavi di ordinamento anziché le stringhe. Per altre informazioni, vedere la classe <xref:System.Globalization.SortKey>.  
  
 Se non si specifica una convenzione di confronto di stringa, i metodi di ordinamento, ad esempio <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> eseguire un ordinamento dipendenti dalle impostazioni cultura, distinzione maiuscole/minuscole nelle stringhe. Nell'esempio seguente viene illustrato come modificare le impostazioni cultura correnti influisce sull'ordine di stringhe ordinate in una matrice. Crea una matrice di tre stringhe. In primo luogo, imposta la `System.Threading.Thread.CurrentThread.CurrentCulture` proprietà en-US e chiama il <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> (metodo). L'ordinamento risultante è basato su convenzioni di ordinamento per le impostazioni cultura inglese (Stati Uniti). Successivamente, nell'esempio viene impostato il `System.Threading.Thread.CurrentThread.CurrentCulture` proprietà da-DK e chiama il <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodo nuovamente. Si noti come l'ordinamento risultante è diverso dai risultati en-US, perché Usa le convenzioni di ordinamento per il danese (Danimarca).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Se lo scopo primario nel confronto di stringhe consiste nel determinare se sono uguali, è necessario chiamare il <xref:System.String.Equals%2A?displayProperty=nameWithType> (metodo). In genere, è consigliabile usare <xref:System.String.Equals%2A> per eseguire un confronto ordinale. Il <xref:System.String.Compare%2A?displayProperty=nameWithType> metodo è destinato principalmente a ordinamento delle stringhe.  
  
 I metodi di ricerca, stringhe, ad esempio <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, può anche eseguire confronti tra stringhe dipendenti dalle impostazioni cultura o per ordinale. Nell'esempio seguente vengono illustrate le differenze tra i confronti ordinali e con distinzione delle impostazioni cultura usando le <xref:System.String.IndexOf%2A> (metodo). Una ricerca dipendente dalle impostazioni cultura in cui le impostazioni cultura correnti sono inglese (Stati Uniti) prende in considerazione la sottostringa "oe" in modo che corrisponda il legatura "œ". Poiché un segno meno facoltativo (U + 00AD) è un carattere a larghezza zero, la ricerca considera il segno meno facoltativo come equivalente a <xref:System.String.Empty> e trova una corrispondenza all'inizio della stringa. Una ricerca ordinale, d'altra parte, non viene trovata una corrispondenza in entrambi i casi.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Ricerca di stringhe  
 I metodi di ricerca, stringhe, ad esempio <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, può anche eseguire distinzione delle impostazioni cultura o i confronti di stringhe ordinali per determinare se una sottostringa o un carattere viene trovato in una stringa specificata.  
  
 I metodi di ricerca nel <xref:System.String> classe per l'individuazione di un singolo carattere, ad esempio il <xref:System.String.IndexOf%2A> metodo, o parte di un set di caratteri, ad esempio il <xref:System.String.IndexOfAny%2A> (metodo), eseguire una ricerca ordinale. Per eseguire una ricerca dipendente dalle impostazioni cultura per un carattere, è necessario chiamare una <xref:System.Globalization.CompareInfo> metodo come <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> o <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Si noti che i risultati della ricerca di un carattere utilizzando il confronto ordinale e con distinzione delle impostazioni cultura possono essere molto diversi. Ad esempio, una ricerca di un carattere Unicode precomposto, ad esempio la legatura "" (U + 00 C 6) potrebbe corrispondere tutte le occorrenze dei relativi componenti nella sequenza corretta, ad esempio quello "AE" (U + 041U + 0045), a seconda delle impostazioni cultura. Nell'esempio seguente viene illustrata la differenza tra il <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> e <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> metodi durante la ricerca di un singolo carattere. L'alfabeto "" (U + 00E6) viene trovato nella stringa "aereo" quando si usa le convenzioni delle impostazioni cultura en-US, ma non quando si usa le convenzioni delle impostazioni cultura da-DK o quando si esegue un confronto ordinale.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 D'altra parte, <xref:System.String> metodi che eseguono la ricerca per una stringa anziché un carattere di eseguita una ricerca dipendente dalle impostazioni cultura se le opzioni di ricerca non vengono specificate in modo esplicito da un parametro di tipo della classe <xref:System.StringComparison>. L'unica eccezione è <xref:System.String.Contains%2A>, che consente di eseguire una ricerca ordinale.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Test dell'uguaglianza  
 Usare il <xref:System.String.Compare%2A?displayProperty=nameWithType> metodo per stabilire la relazione tra due stringhe nell'ordinamento. In genere, si tratta di un'operazione di distinzione delle impostazioni cultura. Al contrario, chiamare il <xref:System.String.Equals%2A?displayProperty=nameWithType> metodo per verificare l'uguaglianza. Poiché il test di uguaglianza confronta in genere l'input dell'utente con alcune stringhe note, ad esempio un nome utente valido, una password o un percorso del file system, in genere è un'operazione ordinale.  
  
> [!WARNING]
>  È possibile verificare l'uguaglianza chiamando il <xref:System.String.Compare%2A?displayProperty=nameWithType> metodo e determinare se il valore restituito è zero. Tuttavia, questa pratica non è consigliabile. Per determinare se due stringhe sono uguali, è necessario chiamare uno degli overload del <xref:System.String.Equals%2A?displayProperty=nameWithType> (metodo). L'overload preferita da chiamare è l'istanza <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metodo o il metodo statico <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo, perché entrambi i metodi includono un <xref:System.StringComparison?displayProperty=nameWithType> parametro che specifichi esplicitamente il tipo di confronto.  
  
 Nell'esempio seguente viene illustrato il rischio di eseguire un confronto con distinzione delle impostazioni cultura per verificarne l'uguaglianza quando un numero ordinale uno deve essere usato invece. In questo caso, lo scopo del codice è per impedire l'accesso al file system da URL che iniziano con "FILE://" o "file://" eseguendo un confronto tra maiuscole e minuscole tra l'inizio di un URL con la stringa "FILE://". Tuttavia, se viene eseguito un confronto di distinzione delle impostazioni cultura usando le impostazioni cultura Turco (Turchia) in un URL che inizia con "file://", il confronto di uguaglianza ha esito negativo, poiché la lingua turca equivalente maiuscolo di "i" minuscola è "i" anziché "I". Di conseguenza, accesso al file system inavvertitamente è consentito. D'altra parte, se viene eseguito un confronto ordinale, il confronto di uguaglianza ha esito positivo e viene negato l'accesso al file system.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalization  
 Alcuni caratteri Unicode disporre di più rappresentazioni. Uno dei punti di codice seguente, ad esempio, può rappresentare la lettera "ắ":  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Più rappresentazioni di un singolo carattere complicano la ricerca, l'ordinamento, ricerca e altre operazioni sulle stringhe.  
  
 Lo standard Unicode definisce un processo denominato di normalizzazione che restituisce una rappresentazione binaria di un carattere Unicode per una delle relative rappresentazioni binarie equivalente. Normalizzazione è possibile usare diversi algoritmi, denominati formati di normalizzazione che seguono regole diverse. .NET Framework supporta i formati di normalizzazione Unicode C, D, KC e KD. Quando le stringhe sono state normalizzate per lo stesso formato di normalizzazione, possono essere confrontate utilizzando un confronto ordinale.  
  
 Un confronto ordinale è un confronto binario del valore scalare Unicode del corrispondente <xref:System.Char> gli oggetti in ciascuna stringa. Il <xref:System.String> classe include una serie di metodi che è possibile eseguire un confronto ordinale, inclusi i seguenti:  
  
-   Un overload del <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, e <xref:System.String.LastIndexOf%2A> metodi che include un <xref:System.StringComparison> parametro. Il metodo esegue un confronto ordinale, se si specifica un valore pari <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase> per questo parametro.  
  
-   Gli overload del <xref:System.String.CompareOrdinal%2A> (metodo).  
  
-   I metodi che usano un confronto ordinale per impostazione predefinita, quali <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, e <xref:System.String.Split%2A>.  
  
-   I metodi che eseguono la ricerca per un <xref:System.Char> valore o per gli elementi in un <xref:System.Char> matrice in un'istanza di stringa. Tali metodi includono <xref:System.String.IndexOf%28System.Char%29> e <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 È possibile determinare se una stringa è normalizzata in formato di normalizzazione C chiamando il <xref:System.String.IsNormalized?displayProperty=nameWithType> metodo, altrimenti è possibile chiamare il <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodo per determinare se una stringa è normalizzata in un formato di normalizzazione specificato. È inoltre possibile chiamare il <xref:System.String.Normalize?displayProperty=nameWithType> metodo per convertire una stringa in formato di normalizzazione C, oppure è possibile chiamare il <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodo per convertire una stringa in un formato di normalizzazione specificato. Per informazioni dettagliate sulla normalizzazione e il confronto di stringhe, vedere la <xref:System.String.Normalize> e <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metodi.  
  
 L'esempio seguente viene illustrato normalizzazione delle stringhe. Definisce la lettera "ố" in tre modi diversi in tre diverse stringhe e utilizza un confronto ordinale per verificarne l'uguaglianza per determinare che ogni stringa è diversa dalle altre due stringhe. Quindi converte ogni stringa per il form di normalizzazione supportate e anche in questo caso esegue un confronto ordinale di ogni stringa in un formato di normalizzazione specificato. In ogni caso, il secondo test per verificarne l'uguaglianza mostra che le stringhe sono uguali.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Per altre informazioni sulla normalizzazione e la normalizzazione dei moduli, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, nonché [Unicode Standard Annex #15: di normalizzazione Unicode](https://unicode.org/reports/tr15/) e il [domande frequenti sulla normalizzazione](https://www.unicode.org/faq/normalization.html) di sito Web www.Unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operazioni sulle stringhe in base alla categoria  
 Il <xref:System.String> classe fornisce membri per il confronto di stringhe, test delle stringhe per verificarne l'uguaglianza, ricerca di sottostringhe in una stringa, la modifica di una stringa, l'estrazione di sottostringhe da una stringa, la combinazione di stringhe, valori, copia di una stringa di formattazione o caratteri e normalizzazione di una stringa.  
  
### <a name="comparing-strings"></a>Confronto di stringhe  
 È possibile confrontare le stringhe per determinare la posizione relativa nell'ordinamento usando i seguenti <xref:System.String> metodi:  
  
-   <xref:System.String.Compare%2A> Restituisce un intero che indica la relazione di una stringa in una seconda stringa nella sequenza di ordinamento.  
  
-   <xref:System.String.CompareOrdinal%2A> Restituisce un intero che indica la relazione di una stringa in una seconda stringa basata su un confronto dei punti di codice.  
  
-   <xref:System.String.CompareTo%2A> Restituisce un intero che indica la relazione tra l'istanza della stringa corrente in una seconda stringa nella sequenza di ordinamento. Il <xref:System.String.CompareTo%28System.String%29> metodo offre il <xref:System.IComparable> e <xref:System.IComparable%601> implementazioni per le <xref:System.String> classe.  
  
### <a name="testing-strings-for-equality"></a>Test di uguaglianza delle stringhe  
 Si chiama il <xref:System.String.Equals%2A> metodo per determinare se due stringhe sono uguali. L'istanza <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> e il metodo statico <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overload consentono di specificare se il confronto è distinzione delle impostazioni cultura o per ordinale e se case considerate o ignorate. La maggior parte dei test per verificarne l'uguaglianza sono ordinali e i confronti di uguaglianza che regolano l'accesso a una risorsa di sistema (ad esempio, un oggetto file system) devono essere sempre ordinale.  
  
### <a name="finding-characters-in-a-string"></a>Ricerca di caratteri in una stringa  
 Il <xref:System.String> classe include due tipi di metodi di ricerca:  
  
-   I metodi che restituiscono un <xref:System.Boolean> valore per indicare se una particolare sottostringa è presente in un'istanza di stringa. Sono inclusi i <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, e <xref:System.String.StartsWith%2A> metodi.  
  
-   Metodi che indicano la posizione iniziale di una sottostringa in un'istanza di stringa. Sono inclusi i <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, e <xref:System.String.LastIndexOfAny%2A> metodi.  
  
> [!WARNING]
>  Se si desidera cercare una stringa per un determinato modello anziché una sottostringa specifica, è consigliabile usare espressioni regolari. Per altre informazioni, vedere [Espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modifica di una stringa  
 Il <xref:System.String> classe include i metodi seguenti che sembrano modificare il valore di una stringa:  
  
-   <xref:System.String.Insert%2A> Inserisce una stringa in corrente <xref:System.String> istanza.  
  
-   <xref:System.String.PadLeft%2A> Inserisce una o più occorrenze di un carattere specificato all'inizio di una stringa.  
  
-   <xref:System.String.PadRight%2A> Inserisce una o più occorrenze di un carattere specificato alla fine di una stringa.  
  
-   <xref:System.String.Remove%2A> Elimina una sottostringa da corrente <xref:System.String> istanza.  
  
-   <xref:System.String.Replace%2A> sostituisce una sottostringa con un'altra sottostringa nell'attuale <xref:System.String> istanza.  
  
-   <xref:System.String.ToLower%2A> e <xref:System.String.ToLowerInvariant%2A> convertire tutti i caratteri in una stringa in caratteri minuscoli.  
  
-   <xref:System.String.ToUpper%2A> e <xref:System.String.ToUpperInvariant%2A> convertire tutti i caratteri in una stringa in lettere maiuscole.  
  
-   <xref:System.String.Trim%2A> Rimuove tutte le occorrenze di un carattere dall'inizio e alla fine di una stringa.  
  
-   <xref:System.String.TrimEnd%2A> Rimuove tutte le occorrenze di un carattere dalla fine della stringa.  
  
-   <xref:System.String.TrimStart%2A> Rimuove tutte le occorrenze di un carattere dall'inizio di una stringa.  
  
> [!IMPORTANT]
>  Tutti i metodi di modifica di stringhe restituiscono un nuovo <xref:System.String> oggetto. Essi non modificano il valore dell'istanza corrente.  
  
### <a name="extracting-substrings-from-a-string"></a>L'estrazione di sottostringhe da una stringa  
 Il <xref:System.String.Split%2A?displayProperty=nameWithType> metodo suddivide una singola stringa in più stringhe. Gli overload del metodo consentono di specificare più delimitatori, per determinare il numero massimo di sottostringhe che il metodo estrae e per determinare se le stringhe vuote (che si verificano quando i delimitatori sono adiacenti) sono incluse tra le stringhe restituite.  
  
### <a name="combining-strings"></a>Stringhe di combinazione  
 Nell'esempio <xref:System.String> metodi possono essere utilizzati per la concatenazione di stringhe:  
  
-   <xref:System.String.Concat%2A> Combina le sottostringhe di una o più in un'unica stringa.  
  
-   <xref:System.String.Join%2A> Concatena una o più sottostringhe in un singolo elemento e aggiunge un separatore tra ogni sottostringa.  
  
### <a name="formatting-values"></a>Formattazione di valori  
 Il <xref:System.String.Format%2A?displayProperty=nameWithType> metodo Usa la funzionalità di formattazione composita per sostituire uno o più segnaposto in una stringa con la rappresentazione di stringa di un oggetto o valore. Il <xref:System.String.Format%2A> metodo viene spesso utilizzato per eseguire le operazioni seguenti:  
  
-   Per incorporare la rappresentazione di stringa di un valore numerico in una stringa.  
  
-   Per incorporare la rappresentazione di stringa di un valore di data e ora in una stringa.  
  
-   Per incorporare la rappresentazione di stringa del valore di enumerazione in una stringa.  
  
-   Per incorporare la rappresentazione di stringa di un oggetto che supporta il <xref:System.IFormattable> interfaccia in una stringa.  
  
-   Per giustificare a destra o giustificato a sinistra di una sottostringa in un campo all'interno di una stringa più grande.  
  
 Per informazioni dettagliate sulle operazioni e gli esempi di formattazione, vedere il <xref:System.String.Format%2A> eseguire l'overload di riepilogo.  
  
### <a name="copying-a-string"></a>Copia di una stringa  
 È possibile chiamare il comando seguente <xref:System.String> metodi per creare una copia di una stringa:  
  
-   <xref:System.String.Clone%2A> Restituisce un riferimento a un oggetto esistente <xref:System.String> oggetto.  
  
-   <xref:System.String.Copy%2A> Crea una copia di una stringa esistente.  
  
-   <xref:System.String.CopyTo%2A> copia una parte di una stringa in una matrice di caratteri.  
  
### <a name="normalizing-a-string"></a>Normalizzazione di una stringa  
 In Unicode, un singolo carattere può avere più punti di codice. Normalizzazione converte la stessa rappresentazione binaria di questi caratteri equivalenti. Il <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodo esegue la normalizzazione e il <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> metodo determina se una stringa è normalizzata.  
  
 Per altre informazioni e un esempio, vedere la [normalizzazione](#Normalization) in precedenza in questo argomento.  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contenuto della sezione:  
  
 [Sintassi del costruttore di overload](#Syntax)   
 [Parametri](#Params)   
 [Eccezioni](#Exceptions)   
 [Quale metodo viene chiamato?](#Tasks)   
 [Creazione di stringhe](#Creating_Strings)   
 [Gestione delle stringhe ricorrenti](#Repetitive)   
 Esempi di creazione di un'istanza di stringhe:   
 [Utilizzo dell'assegnazione di stringhe](#Ctor1_Example)  
 [Usando una matrice di caratteri](#Ctor2_Example)  
 [Utilizzo di una parte di una matrice di caratteri e la ripetizione di un singolo carattere](#Ctor3_Example)  
 [Usando un puntatore a una matrice di caratteri](#Ctor4_Example)  
 [Usando un puntatore e un intervallo di una matrice](#Ctor5_Example)  
 [Usando un puntatore a una matrice di byte con segno](#Ctor6_Example)  
[Informazioni sulla versione](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Sintassi del costruttore di overload  
 Costruttori di stringhe possono essere suddivise in due categorie: quelli senza parametri dei puntatori e quelli con i parametri di puntatore. I costruttori che utilizzano i puntatori non sono conformi a CLS. Inoltre, Visual Basic non supporta l'utilizzo dei puntatori e c# richiede codice che usa puntatori per l'esecuzione in un contesto unsafe. Per altre informazioni, vedere [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Per altro materiale sussidiario sulla scelta di un overload, vedere [quale metodo viene chiamato?](#Tasks)  
  
 `String(Char[] value)`  
 Inizializza la nuova istanza sul valore indicato da una matrice di caratteri Unicode. Questo costruttore copia i caratteri Unicode ([esempio](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inizializza la nuova istanza sul valore indicato da una matrice di caratteri Unicode, una posizione di carattere iniziale all'interno di tale matrice e una lunghezza ([esempio](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Consente di inizializzare la nuova istanza per il valore indicata da uno specifico carattere Unicode ripetuto un numero precisato di volte in cui ([esempio](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di caratteri Unicode che termina con un carattere null (u+0000 o '\0'). ([esempio](#Ctor4_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di caratteri Unicode, da una posizione di carattere iniziale all'interno di tale matrice e una lunghezza. Il costruttore di copia i caratteri Unicode compresi `value` iniziando dall'indice `startIndex` e termina in corrispondenza dell'indice `startIndex`  +  `length` -1 ([esempio](#Ctor5_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(SByte* value)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit. Si presuppone che la matrice rappresentano una stringa codificata utilizzando la tabella codici del sistema corrente (vale a dire, la codifica specificata da <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Il costruttore elabora i caratteri `value` a partire dalla posizione specificata dal puntatore fino a quando non viene raggiunto un carattere null (0x00) ([esempio](#Ctor6_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit, una posizione iniziale all'interno di tale matrice e una lunghezza.  Si presuppone che la matrice rappresentano una stringa codificata utilizzando la tabella codici del sistema corrente (vale a dire, la codifica specificata da <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Il costruttore elabora i caratteri dal valore partire `startIndex` a `startIndex`  +  `length` – 1 ([esempio](#Ctor6_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit, una posizione iniziale all'interno della matrice, una lunghezza e un <xref:System.Text.Encoding> oggetto.  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parametri  
 Ecco un elenco completo dei parametri usati dalla <xref:System.String> costruttori che non includono un parametro del puntatore. Per i parametri usati da ogni overload, vedere la sintassi di overload precedente.  
  
|Parametro|Tipo|Descrizione|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Matrice di caratteri Unicode.|  
|`c`|<xref:System.Char>|Carattere Unicode.|  
|`startIndex`|<xref:System.Int32>|Posizione iniziale in `value` del primo carattere nella stringa di nuovo.<br /><br /> Il valore predefinito: 0|  
|`length`|<xref:System.Int32>|Il numero di caratteri in `value` da includere nella nuova stringa.<br /><br /> Valore predefinito: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Numero di occorrenze del carattere `c` viene ripetuta nella stringa di nuovo. Se `count` è uguale a zero, il valore del nuovo oggetto è <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Ecco un elenco completo dei parametri usati dalla <xref:System.String> costruttori che includono un parametro del puntatore. Per i parametri usati da ogni overload, vedere la sintassi di overload precedente.  
  
|Parametro|Tipo|Descrizione|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> oppure<br /><br /> <xref:System.SByte>\*|Puntatore a una matrice con terminazione null di caratteri Unicode o una matrice di interi con segno a 8 bit. Se `value` viene `null` o una matrice vuota, il valore della nuova stringa è <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|L'indice dell'elemento della matrice che definisce il primo carattere nella stringa di nuovo.<br /><br /> Il valore predefinito: 0|  
|`length`|<xref:System.Int32>|Il numero di elementi della matrice da usare per creare la nuova stringa. Se la lunghezza è zero, il costruttore crea una stringa il cui valore è <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valore predefinito: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Oggetto che specifica come il `value` matrice viene codificata.<br /><br /> Il valore predefinito: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, o tabella codici ANSI corrente del sistema|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Eccezioni  
 Ecco un elenco delle eccezioni generate dai costruttori che non includono i parametri di puntatore.  
  
|Eccezione|Condizione|Generata da|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` è `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, o `count` è minore di zero.<br /><br /> oppure<br /><br /> la somma dei parametri `startIndex` e `length` è maggiore del numero di elementi nel parametro `value`.<br /><br /> oppure<br /><br /> `count` è minore di zero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Ecco un elenco delle eccezioni generate dai costruttori che includono parametri di puntatore.  
  
|Eccezione|Condizione|Generata da|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Specifica una matrice che contiene un carattere Unicode non valido.<br /><br /> oppure<br /><br /> `value` oppure `value`  +  `startIndex` specifica un indirizzo minore di 64 K.<br /><br /> oppure<br /><br /> Una nuova <xref:System.String> istanza nelze inicializovat dal `value` della matrice di byte perché `value` non usa l'impostazione predefinita codifica della tabella codici.|Tutti i costruttori con i puntatori.|  
|<xref:System.ArgumentNullException>|`value` è null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Il processo corrente non ha accesso in lettura a tutti i caratteri considerati.<br /><br /> oppure<br /><br /> `startIndex` o `length` è minore di zero, `value` + `startIndex` causa un overflow del puntatore o il processo corrente non ha accesso in lettura a tutti i caratteri considerati.<br /><br /> oppure<br /><br /> La lunghezza della nuova stringa è troppo grande da allocare.|Tutti i costruttori con i puntatori.|  
|<xref:System.AccessViolationException>|`value`, oppure `value`  +  `startIndex`  +  `length` – 1, specifica un indirizzo non valido.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Quale metodo viene chiamato?  
  
|A|Chiamata o utilizzo|  
|--------|-----------------|  
|Creare una stringa.|Assegnazione di un valore letterale stringa o una stringa esistente ([esempio](#Ctor1_Example))|  
|Creare una stringa da un'intera matrice di caratteri.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([esempio](#Ctor2_Example))|  
|Crea un stringa da una parte di una matrice di caratteri.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([esempio](#Ctor3_Example))|  
|Creare una stringa che ripete più volte lo stesso carattere.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([esempio](#Ctor3_Example))|  
|Creare una stringa da un puntatore a una matrice di caratteri "wide" o Unicode.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Creare una stringa da una parte di una matrice di caratteri "wide" o Unicode usando il relativo puntatore.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Creare una stringa da C++ `char` matrice.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> oppure<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Creare una stringa di caratteri ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Creazione di stringhe  
 Uso più comune tecnica per la creazione di stringhe a livello di codice è semplice assegnazione, come illustrato nella [in questo esempio](#Ctor1_Example). Il <xref:System.String> classe include anche i quattro tipi di overload del costruttore che consentono di creare stringhe tra i valori seguenti:  
  
-   Da una matrice di caratteri (una matrice di caratteri con codifica UTF-16). È possibile creare un nuovo <xref:System.String> oggetto verso i caratteri nell'intera matrice o una parte di esso. Il <xref:System.String.%23ctor%28System.Char%5B%5D%29> costruttore copia tutti i caratteri nella matrice per la nuova stringa. Il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore di copia i caratteri da indice `startIndex` all'indice `startIndex`  +  `length` – 1 per la nuova stringa. Se `length` è uguale a zero, il valore della nuova stringa è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Se il codice ripetutamente crea un'istanza di stringhe con lo stesso valore, è possibile migliorare le prestazioni dell'applicazione usando un metodo alternativo di creazione di stringhe. Per altre informazioni, vedere [gestione delle stringhe ripetitive](#Repetitive).  
  
-   Da un singolo carattere che è duplicato uguale a zero, uno, o più volte, usando il <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> costruttore. Se `count` è uguale a zero, il valore della nuova stringa è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Da un puntatore a una matrice di caratteri con terminazione null, tramite il <xref:System.String.%23ctor%28System.Char%2A%29> o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> costruttore. L'intera matrice o un intervallo specificato è utilizzabile per inizializzare la stringa. Il costruttore di copia una sequenza di caratteri Unicode a partire dal puntatore specificato o dal puntatore sul segno più `startIndex` e proseguire fino alla fine della matrice o per `length` caratteri. Se `value` è un puntatore null o `length` è uguale a zero, il costruttore crea una stringa il cui valore è <xref:System.String.Empty?displayProperty=nameWithType>. Se l'operazione di copia continua alla fine della matrice e la matrice non è con terminazione null, il comportamento del costruttore è dipendente dal sistema. Tale condizione potrebbe causare una violazione di accesso.  
  
     Se la matrice contiene eventuali caratteri null incorporati (u+0000 o '\0') e il <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> viene chiamato l'overload, l'istanza di stringa contiene `length` caratteri inclusi quelli incorporati i valori null. L'esempio seguente mostra cosa accade quando viene passato un puntatore a una matrice di 10 elementi che include due caratteri null per il <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> (metodo). Poiché l'indirizzo è l'inizio della matrice e tutti gli elementi nella matrice devono essere aggiunti alla stringa, il costruttore crea un'istanza di una stringa con dieci caratteri, inclusi due valori null incorporati. D'altra parte, se la stessa matrice viene passata per il <xref:System.String.%23ctor%28System.Char%2A%29> costruttore, il risultato è una stringa di quattro caratteri che non include al primo carattere null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     La matrice deve contenere caratteri Unicode. In C++, ciò significa che la matrice di caratteri deve essere definito come managed <xref:System.Char>tipo [] o non gestito`wchar_t`tipo [].  
  
     Se il <xref:System.String.%23ctor%28System.Char%2A%29> l'overload del metodo e la matrice non è con terminazione null, o se il <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> l'overload del metodo e `startIndex`  +  `length`-1 include un intervallo all'esterno della memoria allocata per la sequenza di caratteri, il comportamento del costruttore è dipendente dal sistema e potrebbe verificarsi una violazione di accesso. Inoltre, sul processore Intel Itanium, le chiamate al <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> costruttore può generare un <xref:System.DataMisalignedException> eccezione. Se in questo caso, chiamare il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> invece.  
  
-   Da un puntatore a una matrice di byte con segno. L'intera matrice o un intervallo specificato è utilizzabile per inizializzare la stringa. La sequenza di byte può essere interpretata con la tabella codici predefinita di codifica o una codifica può essere specificata nella chiamata al costruttore. Se il costruttore tenta di creare un'istanza di una stringa da un'intera matrice che non è con terminazione null oppure se l'intervallo della matrice da `value`  +  `startIndex` al `value`  +  `startIndex`  +  `length` -1 è all'esterno della memoria allocata per l'array, il comportamento di questo costruttore è dipendente dal sistema e potrebbe verificarsi una violazione di accesso.  
  
     I tre costruttori che includono una matrice di byte con segno come parametro sono progettati principalmente per convertire un C++ `char` della matrice in una stringa, come illustrato in questo esempio:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Se la matrice contiene i caratteri null ('\0') o byte il cui valore è 0 e il <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> viene chiamato l'overload, l'istanza di stringa contiene `length` caratteri inclusi quelli incorporati i valori null. L'esempio seguente mostra cosa accade quando viene passato un puntatore a una matrice di 10 elementi che include due caratteri null per il <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> (metodo). Poiché l'indirizzo è l'inizio della matrice e tutti gli elementi nella matrice devono essere aggiunti alla stringa, il costruttore crea un'istanza di una stringa con dieci caratteri, inclusi due valori null incorporati. D'altra parte, se la stessa matrice viene passata per il <xref:System.String.%23ctor%28System.SByte%2A%29> costruttore, il risultato è una stringa di quattro caratteri che non include al primo carattere null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Poiché il <xref:System.String.%23ctor%28System.SByte%2A%29> e <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> costruttori interpretano `value` usando la tabella codici ANSI predefinita, la chiamata di questi costruttori con matrici di byte identici può creare stringhe con valori diversi a seconda del sistema.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Gestione delle stringhe ricorrenti  
 Le app che analizzano o decodificano i flussi di testo spesso usano il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore o <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per convertire le sequenze di caratteri in una stringa. Creazione di nuove stringhe a più volte con lo stesso valore anziché creando e riutilizzando una sola stringa comporta uno spreco di memoria. Se è probabile che creare più volte lo stesso valore di stringa chiamando il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore, anche se non si conosce anticipo quali potrebbero essere tali valori di stringa identica, è possibile usare invece una tabella di ricerca.  
  
 Si supponga, ad esempio, leggere e analizzare il flusso di caratteri da un file che contiene tag e attributi XML. Quando si analizza il flusso, si verifica più volte alcuni token (vale a dire, sequenze di caratteri che hanno un significato simbolico). Token equivalenti per le stringhe "0", "1", "true" e "false" è probabile che si verificano di frequente in un flusso XML.  
  
 Anziché convertire ogni token in una nuova stringa, è possibile creare un <xref:System.Xml.NameTable?displayProperty=nameWithType> oggetto per contenere le stringhe che si verificano comunemente. Il <xref:System.Xml.NameTable> oggetto migliora le prestazioni, poiché recupera stringhe archiviate senza allocare memoria temporanea. Quando si verifica un token, usare il <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per recuperare il token dalla tabella. Se il token non esiste, il metodo restituisce la stringa corrispondente. Se il token non esiste, usare il <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per inserire il token nella tabella e per ottenere la stringa corrispondente.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Esempio 1: Uso dell'assegnazione di stringhe  
 L'esempio seguente crea una nuova stringa assegnandole un valore letterale stringa. Viene creata una seconda stringa assegnando il valore della prima stringa a esso. Questi sono i due modi più comuni per creare un'istanza di un nuovo <xref:System.String> oggetto.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Esempio 2: Uso di una matrice di caratteri  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.String> oggetto da una matrice di caratteri.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Esempio 3: Utilizzo di una parte di una matrice di caratteri e ripetizione di un singolo carattere  
 Nell'esempio seguente viene illustrato come creare una nuova <xref:System.String> da una parte di una matrice di caratteri e su come creare un nuovo oggetto <xref:System.String> oggetto che contiene più occorrenze di un singolo carattere.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Esempio 4: Utilizzo di un puntatore a una matrice di caratteri  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.String> oggetto da un puntatore a una matrice di caratteri. Nell'esempio c# debba essere compilata usando la `/unsafe` opzione del compilatore.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Esempio 5: Creare un'istanza di una stringa da un puntatore e un intervallo di una matrice  
 Nell'esempio seguente esamina gli elementi di una matrice di caratteri per un punto o un punto esclamativo. Se viene trovata, crea un'istanza di una stringa di caratteri nella matrice che precedono il simbolo di punteggiatura. In caso contrario, viene creata un'istanza di una stringa con l'intero contenuto della matrice. Nell'esempio c# deve essere compilata usando la `/unsafe` opzione del compilatore.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Esempio 6: Creare un'istanza di una stringa da un puntatore a una matrice di byte con segno  
 Nell'esempio seguente viene illustrato come è possibile creare un'istanza di <xref:System.String> classe con il <xref:System.String.%23ctor%28System.SByte%2A%29> costruttore.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informazioni sulla versione  
 .NET Framework  
 Tutti gli overload sono supportati in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Tutti gli overload sono supportati in: 4, 3.5 SP1  
  
 Libreria di classi portabile  
 Tutti gli overload senza un <xref:System.SByte> `*` parametro sono supportati  
  
 .NET per applicazioni Windows Store  
 Tutti gli overload senza un <xref:System.SByte> `*` parametro sono supportati in: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice con terminazione Null di caratteri Unicode.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di caratteri Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> specifica una matrice che contiene un carattere Unicode non valido, oppure <paramref name="value" /> specifica un indirizzo minore di 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di caratteri Unicode.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da una matrice di caratteri Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice a terminazione Null di interi con segno a 8 bit. I numeri interi vengono interpretati in base alla codifica della tabella codici di sistema corrente, ovvero alla codifica specificata da <see cref="P:System.Text.Encoding.Default" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Non è stato possibile inizializzare una nuova istanza di <see cref="T:System.String" /> mediante <paramref name="value" />, supponendo che <paramref name="value" /> sia codificato in ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della nuova stringa da inizializzare, che è determinata dal carattere a terminazione Null del parametro <paramref name="value" />, è troppo grande da allocare.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> specifica un indirizzo non valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode.</param>
        <param name="count">Numero di occorrenze di <c>c</c>.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico carattere Unicode ripetuto un numero precisato di volte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di caratteri Unicode.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di caratteri Unicode, da una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero, <paramref name="value" /> + <paramref name="startIndex" /> causa un overflow del puntatore o il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> specifica una matrice che contiene un carattere Unicode non valido o <paramref name="value" /> + <paramref name="startIndex" /> specifica un indirizzo minore di 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di caratteri Unicode.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da una matrice di caratteri Unicode, da una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="length" /> è maggiore del numero di elementi in <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di interi con segno a 8 bit. I numeri interi vengono interpretati in base alla codifica della tabella codici di sistema corrente, ovvero alla codifica specificata da <see cref="P:System.Text.Encoding.Default" />.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di interi con segno a 8 bit, da una posizione iniziale all'interno di tale matrice e da una lunghezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è troppo grande per la piattaforma corrente, ovvero il calcolo dell'indirizzo ha causato un overflow.  oppure  La lunghezza della nuova stringa da inizializzare è troppo grande da allocare.</exception>
        <exception cref="T:System.ArgumentException">L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è minore di 64 K.  oppure  Non è stato possibile inizializzare una nuova istanza di <see cref="T:System.String" /> tramite <paramref name="value" />, supponendo che <paramref name="value" /> sia codificato in ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> specificano collettivamente un indirizzo non valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di interi con segno a 8 bit.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <param name="enc">Oggetto che specifica la modalità di codifica della matrice a cui fa riferimento <c>value</c>. Se <c>enc</c> è <see langword="null" />, verrà usata la codifica ANSI.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di interi con segno a 8 bit, da una posizione iniziale all'interno di tale matrice e da un oggetto <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni sull'utilizzo complete su questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è troppo grande per la piattaforma corrente, ovvero il calcolo dell'indirizzo ha causato un overflow.  oppure  La lunghezza della nuova stringa da inizializzare è troppo grande da allocare.</exception>
        <exception cref="T:System.ArgumentException">L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è minore di 64 K.  oppure  Non è stato possibile inizializzare una nuova istanza di <see cref="T:System.String" /> tramite <paramref name="value" />, supponendo che <paramref name="value" /> sia stato codificato secondo quanto specificato da <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> specificano collettivamente un indirizzo non valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione nella stringa corrente.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Char" /> in una posizione specificata dell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <value>Oggetto in corrispondenza della posizione <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `index` in base zero.  
  
 Questa proprietà restituisce il <xref:System.Char> oggetto in corrispondenza della posizione specificata dal `index` parametro. Tuttavia, un carattere Unicode può essere rappresentato da più di un <xref:System.Char>. Usare la <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe per funzionare con Unicode caratteri anziché <xref:System.Char> oggetti. Per altre informazioni, vedere la sezione "Char gli oggetti e dei caratteri Unicode" nel <xref:System.String> Cenni preliminari sulla classe.  
  
 In c# il <xref:System.String.Chars%2A> proprietà è un indicizzatore. In Visual Basic, è la proprietà predefinita di <xref:System.String> classe. Ogni <xref:System.Char> oggetto nella stringa sono accessibili usando codice simile al seguente.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come è possibile utilizzare l'indicizzatore in una routine per convalidare una stringa.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è maggiore o uguale alla lunghezza dell'oggetto o minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un riferimento a questa istanza della classe <see cref="T:System.String" />.</summary>
        <returns>Questa istanza di <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito non è una copia indipendente di questa istanza. è semplicemente un'altra visualizzazione degli stessi dati. Usare la <xref:System.String.Copy%2A> oppure <xref:System.String.CopyTo%2A> metodo per creare un oggetto separato <xref:System.String> oggetto con lo stesso valore di questa istanza.  
  
 Poiché il <xref:System.String.Clone%2A> metodo restituisce semplicemente l'istanza esistente di stringa, non si ha lo chiamino direttamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli overload del metodo <xref:System.String.Compare%2A> restituiscono un intero con segno a 32 bit che indica la relazione lessicale tra i due termini del confronto.  
  
|Valore|Condizione|  
|-----------|---------------|  
|Minore di zero|La prima sottostringa precede la sottostringa secondo nell'ordinamento.|  
|Zero|Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure `length` è zero.|  
|Maggiore di zero|La prima sottostringa segue la sottostringa secondo nell'ordinamento.|  
  
> [!WARNING]
>  Quando possibile, è necessario chiamare un overload del <xref:System.String.Compare%2A> metodo che includa un <xref:System.StringComparison> parametro. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il confronto utilizza le impostazioni cultura correnti per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, possibile specificare le impostazioni cultura che determinate combinazioni di caratteri di essere considerato come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo particolare o che l'ordinamento di un carattere dipende i caratteri che precedono o lo seguono.  
  
 Il confronto viene eseguito usando le regole di ordinamento di word. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo, che è necessario specificare in modo esplicito il tipo di confronto di stringhe che usa il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.String.Compare%28System.String%2CSystem.String%29> metodo per confrontare i tre set di stringhe.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Nell'esempio seguente, il `ReverseStringComparer` classe illustra come eseguire la valutazione due stringhe con la <xref:System.String.Compare%2A> (metodo).  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Ad esempio, se il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto con distinzione delle impostazioni cultura di "animali" con "ani elettronica" (tramite un segno meno facoltativo o 00AD U +) indica che le due stringhe sono equivalenti.  [! codice csharp [System.String.Compare#21] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare21.cs#21)] [! codice vb [System.String.Compare#21] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare21.vb#21)] per riconoscere caratteri ignorabili in un confronto tra stringhe, chiamata di <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodo e fornire un valore di <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il confronto utilizza le impostazioni cultura correnti per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, possibile specificare le impostazioni cultura che determinate combinazioni di caratteri di essere considerato come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo particolare o che l'ordinamento di un carattere dipende i caratteri che precedono o lo seguono.  
  
 Il confronto viene eseguito usando le regole di ordinamento di word. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo, che è necessario specificare in modo esplicito il tipo di confronto di stringhe che usa il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Nell'esempio seguente viene dimostrato che la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> metodo equivale all'uso <xref:System.String.ToUpper%2A> o <xref:System.String.ToLower%2A> durante il confronto di stringhe.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Ad esempio, se il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto tra maiuscole e minuscole, distinzione delle impostazioni cultura di "animali" con "Ani elettronica" (tramite un segno meno facoltativo o 00AD U +) indica che le due stringhe sono equivalenti.  [! codice csharp [System.String.Compare#22] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare22.cs#22)] [! codice vb [System.String.Compare#22] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare22.vb#22)] per riconoscere caratteri ignorabili in un confronto tra stringhe, chiamata il <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodo e fornire un valore di <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oppure <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole da usare per il confronto.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati usando le regole specificate e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invariante, rispettano o ignorare la distinzione tra i termini di confronto o usare word (dipendenti dalle impostazioni cultura) o regole di ordinamento ordinali (senza distinzione delle impostazioni cultura).  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 L'esempio seguente confronta le tre versioni della lettera "I". I risultati sono interessati dalla scelta di impostazioni cultura, se verrà ignorato caso e se viene eseguito un confronto ordinale.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> non è supportato.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Per poter riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.StringComparison.Ordinal" /> oppure <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole e usando le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, possibile specificare le impostazioni cultura che determinate combinazioni di caratteri di essere considerato come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo particolare o che l'ordinamento di un carattere dipende i caratteri che precedono o lo seguono.  
  
 Il confronto viene eseguito usando le regole di ordinamento di word. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostazioni cultura può influire su un confronto. In ceco - impostazioni cultura Repubblica ceca, "ch" è un singolo carattere che è maggiore di "d". Tuttavia, in inglese - impostazioni cultura di Stati Uniti, "ch" è costituito da due caratteri e "c" è minore di "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Ad esempio, se il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto tra maiuscole e minuscole di "animali" con "Ani elettronica" (tramite un segno meno facoltativo o U+10000 00AD) usando l'invariante delle impostazioni cultura indica che le due stringhe sono equivalenti.  [! codice csharp [System.String.Compare#23] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare23.cs#23)] [! codice vb [System.String.Compare#23] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare23.vb#23)] per riconoscere caratteri ignorabili in un confronto tra stringhe, chiamata il <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo e fornire un valore di <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oppure <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="culture">Impostazioni cultura che forniscono informazioni di confronto specifiche delle impostazioni cultura.</param>
        <param name="options">Opzioni da usare durante l'esecuzione del confronto (ad esempio, per ignorare la distinzione tra maiuscole e minuscole o i simboli).</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati, usando le opzioni di confronto specificate e le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che indica la relazione reciproca tra le due stringhe nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra <paramref name="strA" /> e <paramref name="strB" />, come illustrato nella tabella seguente  <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, una specifica impostazione cultura è stato possibile specificare che alcune combinazioni di caratteri siano considerate come un singolo carattere che caratteri maiuscoli e minuscoli da confrontare in modo particolare, o che l'ordinamento di un carattere dipende i caratteri che è preceduto o seguito.  
  
> [!CAUTION]
>  Il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodo è progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere usato durante lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti (ovvero, quando lo scopo della chiamata al metodo è di test per un valore restituito pari a zero). Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> (metodo).  
  
 Il confronto può essere ulteriormente specificato mediante il `options` parametro, che è costituito da uno o più membri del <xref:System.Globalization.CompareOptions> enumerazione. Tuttavia, poiché lo scopo di questo metodo è eseguire un confronto tra stringhe con distinzione delle impostazioni cultura, il <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valori non hanno alcun effetto.  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui <xref:System.String.Empty?displayProperty=nameWithType>, risulta maggiore di un riferimento null e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con i caratteri rimanenti è considerata maggiore.  
  
   
  
## Examples  
 L'esempio seguente vengono confrontate due stringhe in tre modi diversi: usando il confronto linguistico per le impostazioni cultura en-US; mediante il confronto tra maiuscole e minuscole linguistico per le impostazioni cultura en-US; e l'utilizzo di un confronto ordinale. Viene illustrato come i tre metodi di confronto di producano risultati diversi a tre.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è un valore di <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. Il <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Per poter riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oppure <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati e restituisce un intero che indica la relativa posizione nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini del confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare nel `strA` alla `indexA` e nella `strB` in `indexB`. Entrambe `indexA` e `indexB` sono in base zero, vale a dire il primo carattere `strA` e `strB` è nella posizione zero. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 È il minore della lunghezza delle sottostringhe di due, il numero di caratteri da confrontare e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Il confronto utilizza le impostazioni cultura correnti per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, possibile specificare le impostazioni cultura che determinate combinazioni di caratteri di essere considerato come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo particolare o che l'ordinamento di un carattere dipende i caratteri che precedono o lo seguono.  
  
 Il confronto viene eseguito usando le regole di ordinamento di word. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodo, che è necessario specificare in modo esplicito il tipo di confronto di stringhe che usa il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le sottostringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Nell'esempio seguente confronta le sottostringhe di due.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="indexA" /> o <paramref name="indexB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua. Per riconoscere caratteri ignorabili il confronto, chiamare il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo e fornire il valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare nel `strA` alla `indexA`e nella `strB` in `indexB`. Entrambe `indexA` e `indexB` sono in base zero, vale a dire il primo carattere `strA` e `strB` è nella posizione zero. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 È il minore della lunghezza delle sottostringhe di due, il numero di caratteri da confrontare e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Il confronto utilizza le impostazioni cultura correnti per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, possibile specificare le impostazioni cultura che determinate combinazioni di caratteri di essere considerato come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo particolare o che l'ordinamento di un carattere dipende i caratteri che precedono o lo seguono.  
  
 Il confronto viene eseguito usando le regole di ordinamento di word. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodo, che è necessario specificare in modo esplicito il tipo di confronto di stringhe che usa il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le sottostringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Il nome del percorso deve essere confrontato in modo invariante. Il codice corretto per eseguire questa operazione è come indicato di seguito.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Nell'esempio seguente esegue due confronti delle sottostringhe di due che differiscono solo nel caso. Ignora maiuscole e minuscole del primo confronto e il confronto secondo prende in considerazione i casi.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="indexA" /> o <paramref name="indexB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua. Per riconoscere caratteri ignorabili il confronto, chiamare il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo e fornire il valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole da usare per il confronto.</param>
        <summary>Confronta sottostringhe di due oggetti <see cref="T:System.String" /> specificati usando le regole specificate e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure il parametro <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare nel `strA` alla `indexA` e nella `strB` in `indexB`. Entrambe `indexA` e `indexB` sono in base zero, vale a dire il primo carattere `strA` e `strB` si trova nella posizione zero, non nella posizione uno. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 È il minore della lunghezza delle sottostringhe di due, il numero di caratteri da confrontare e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invariante, rispettano o ignorare la distinzione tra i termini di confronto o usare word (dipendenti dalle impostazioni cultura) o regole di ordinamento ordinali (senza distinzione delle impostazioni cultura).  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le sottostringhe sono state confrontate. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Nell'esempio seguente confronta le sottostringhe di due.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="indexA" /> o <paramref name="indexB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua. Per poter riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.StringComparison.Ordinal" /> oppure <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole e usando le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare nel `strA` alla `indexA`e nella `strB` in `indexB`. Entrambe `indexA` e `indexB` sono in base zero, vale a dire il primo carattere `strA` e `strB` si trova nella posizione zero, non nella posizione uno. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 È il minore della lunghezza delle sottostringhe di due, il numero di caratteri da confrontare e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, possibile specificare le impostazioni cultura che determinate combinazioni di caratteri di essere considerato come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo particolare o che l'ordinamento di un carattere dipende i caratteri che precedono o lo seguono.  
  
 Il confronto viene eseguito usando le regole di ordinamento di word. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Può essere uno o entrambi i termini di confronto `null`. Per definizione, una stringa qualsiasi, tra cui una stringa vuota (""), maggiore di un riferimento null; viene confrontato e risultano uguali tra loro due riferimenti null.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le sottostringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Possono verificarsi risultati imprevisti quando i confronti vengono applicati le regole di maiuscole e minuscole delle impostazioni cultura specifiche. In lingua turca, ad esempio, l'esempio seguente restituirà un risultato errato perché il file system in turco non usa le regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Confrontare il nome del percorso in "file" tramite un confronto ordinale. Il codice corretto per eseguire questa operazione è come segue:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Nell'esempio seguente confronta le sottostringhe di due usando diverse impostazioni cultura e ignorare la distinzione tra le sottostringhe. La scelta della lingua influisce sul "modo in cui la lettera I" è confrontato.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="strA" /> o <paramref name="strB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua. Per riconoscere caratteri ignorabili il confronto, chiamare il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo e fornire il valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione iniziale della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione iniziale della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="culture">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</param>
        <param name="options">Opzioni da usare durante l'esecuzione del confronto (ad esempio, per ignorare la distinzione tra maiuscole e minuscole o i simboli).</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati, usando le opzioni di confronto specificate e le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che indica la relazione reciproca tra le due sottostringhe nell'ordinamento.</summary>
        <returns>Intero che indica la relazione lessicale tra le due sottostringhe, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare nel `strA` nella posizione `indexA` e nella `strB` posizione `indexB`. La lunghezza della sottostringa prima è la lunghezza di `strA` meno `indexA`. La lunghezza della sottostringa secondo è la lunghezza di `strB` meno `indexB`.  
  
 È il minore della lunghezza delle sottostringhe di due, il numero di caratteri da confrontare e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei caratteri singoli. Ad esempio, una specifica impostazione cultura è stato possibile specificare che alcune combinazioni di caratteri siano considerate come un singolo carattere che caratteri maiuscoli e minuscoli da confrontare in modo particolare, o che l'ordinamento di un carattere dipende i caratteri che è preceduto o seguito.  
  
> [!CAUTION]
>  Il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodo è progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere usato durante lo scopo principale della chiamata al metodo consiste nel determinare se le due sottostringhe sono equivalenti (ovvero, quando lo scopo della chiamata al metodo è di test per un valore restituito pari a zero). Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> (metodo).  
  
 Una o entrambe `strA` e `strB` può essere `null`. Per definizione, una stringa qualsiasi, tra cui <xref:System.String.Empty?displayProperty=nameWithType>, risulta maggiore di un riferimento null e due riferimenti null risultano uguali tra loro.  
  
 Il confronto può essere ulteriormente specificato mediante il `options` parametro, che è costituito da uno o più membri del <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione. Tuttavia, poiché lo scopo di questo metodo è eseguire un confronto tra stringhe con distinzione delle impostazioni cultura, il <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valori non hanno alcun effetto.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le sottostringhe sono state confrontate. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con i caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodo per confrontare i cognomi dei due persone. Vengono quindi elencati in ordine alfabetico.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è un valore di <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see langword=".Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" /><see langword=".Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="strA" /> o <paramref name="strB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo non prende in considerazione tali caratteri quando si esegue un confronto linguistico o dipendente dalla lingua. Per poter riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oppure <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta due oggetti <see cref="T:System.String" /> in base all'analisi dei valori numerici dei corrispondenti oggetti <see cref="T:System.Char" /> in ciascuna stringa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati in base all'analisi dei valori numerici dei corrispondenti oggetti <see cref="T:System.Char" /> in ogni stringa.</summary>
        <returns>Intero che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> è minore di <paramref name="strB" />.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> e <paramref name="strB" /> sono uguali.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> è maggiore di <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto tra maiuscole e minuscole usando le regole di ordinamento per ordinale. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Per eseguire un confronto tra maiuscole e minuscole usando le regole di ordinamento per ordinale, chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo con il `comparisonType` argomento impostato su <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 In quanto <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> è un metodo statico `strA` e `strB` può essere `null`. Se entrambi i valori sono `null`, il metodo restituisce 0 (zero), che indica che `strA` e `strB` sono uguali. Se solo uno dei valori è `null`, il metodo prende in considerazione il valore non null a essere superiore.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguito e un confronto ordinale di due stringhe che differiscono solo nei case.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Indice iniziale della sottostringa di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Indice iniziale della sottostringa di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <summary>Effettua il confronto fra sottostringhe di due determinati oggetti <see cref="T:System.String" /> in base all'analisi dei valori numerici dei corrispondenti oggetti <see cref="T:System.Char" /> in ogni sottostringa.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> è minore della sottostringa in <paramref name="strB" />.  </description></item><item><term> Zero  </term><description> Le sottostringhe sono uguali o <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> è maggiore della sottostringa in <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Il numero di caratteri confrontato è il minore della lunghezza di `strA` minore `indexA`, la lunghezza di `strB` less `indexB`, e `length`.  
  
 Questo metodo esegue un confronto tra maiuscole e minuscole usando le regole di ordinamento per ordinale. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Per eseguire un confronto tra maiuscole e minuscole usando le regole di ordinamento per ordinale, chiamare il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodo con il `comparisonType` argomento impostato su <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 In quanto <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> è un metodo statico `strA` e `strB` può essere `null`. Se entrambi i valori sono `null`, il metodo restituisce 0 (zero), che indica che `strA` e `strB` sono uguali. Se solo uno dei valori è `null`, il metodo prende in considerazione il valore non null a essere superiore.  
  
   
  
## Examples  
 Nell'esempio seguente viene dimostrato che <xref:System.String.CompareOrdinal%2A> e <xref:System.String.Compare%2A> usare diversi tipi di ordinamento.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> non è <see langword="null" /> e <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="strB" /> non è <see langword="null" /> e <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta questa istanza con <see cref="T:System.String" /> o un oggetto specificato e restituisce un intero che indica se questa istanza precede, segue o si trova nella stessa posizione di <see cref="T:System.String" /> o dell'oggetto specificato nell'ordinamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entrambi gli overload del <xref:System.String.CompareTo%2A> metodo esegue il confronto di distinzione delle impostazioni cultura e tra maiuscole e minuscole. È possibile utilizzare questo metodo per eseguire confronti con distinzione delle impostazioni cultura o per ordinali. Per maggiore chiarezza del codice, è consigliabile evitare il <xref:System.String.CompareTo%2A> metodo e chiamare il <xref:System.String.Compare%2A> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto che restituisce un oggetto <see cref="T:System.String" />.</param>
        <summary>Confronta questa istanza con un oggetto <see cref="T:System.Object" /> specificato e indica se questa istanza precede, segue o si trova nella stessa posizione dell'oggetto <see cref="T:System.Object" /> specificato all'interno dell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica se questa istanza precede, segue o si trova nella stessa posizione del parametro <paramref name="value" /> nell'ordinamento.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> L'istanza precede <paramref name="value" />.  </description></item><item><term> Zero  </term><description> L'istanza si trova nella stessa posizione di <paramref name="value" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description> L'istanza segue <paramref name="value" />. .  oppure  <paramref name="value" /> è <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` deve essere un <xref:System.String> oggetto.  
  
> [!CAUTION]
>  Il <xref:System.String.CompareTo%2A> metodo è stato progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere usato durante lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti. Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> (metodo).  
  
 Questo metodo esegue un confronto di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Per altre informazioni sul comportamento di questo metodo, vedere la sezione Osservazioni del <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.CompareTo%2A> metodo con un <xref:System.Object>. Perché tenta di confrontare una <xref:System.String> dell'istanza per un `TestClass` dell'oggetto, il metodo genera un <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un oggetto <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.CompareTo(System.Object)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Ad esempio, se il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto tra "animali" con "ani elettronica" (tramite un segno meno facoltativo o 00AD U +) indica che le due stringhe sono equivalenti.  [! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  Per poter riconoscere caratteri ignorabili in un confronto tra stringhe, chiamare il <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Stringa da confrontare con questa istanza.</param>
        <summary>Confronta questa istanza con un oggetto <see cref="T:System.String" /> specificato e indica se questa istanza precede, segue o si trova nella stessa posizione della stringa specificata all'interno dei criteri di ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica se questa istanza precede, segue o si trova nella stessa posizione del parametro <paramref name="strB" /> nell'ordinamento.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> L'istanza precede <paramref name="strB" />.  </description></item><item><term> Zero  </term><description> L'istanza si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description> L'istanza segue <paramref name="strB" />. .  oppure  <paramref name="strB" /> è <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Il <xref:System.String.CompareTo%2A> metodo è stato progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere usato durante lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti. Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> (metodo).  
  
 Per altre informazioni sul comportamento di questo metodo, vedere la sezione Osservazioni del <xref:System.String.Compare%28System.String%2CSystem.String%29> (metodo).  
  
 Questo metodo implementa il <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto al <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> metodo, perché non è necessario determinare se il `strB` argomento è un tipo valore modificabile che deve essere sottoposto a boxing e che è necessario eseguire il cast relativo parametro da un <xref:System.Object> a un <xref:System.String>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.CompareTo%2A> metodo per il confronto di istanza della stringa corrente con un'altra stringa.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 L'esempio seguente illustra le versioni generiche e non generici del metodo CompareTo per diversi tipi di riferimento e valore.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.CompareTo(System.String)" /> metodo non prende in considerazione tali caratteri quando esegue un confronto con distinzione delle impostazioni cultura. Ad esempio, se il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto tra "animali" con "ani elettronica" (tramite un segno meno facoltativo o 00AD U +) indica che le due stringhe sono equivalenti.  [! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  Per poter riconoscere caratteri ignorabili in un confronto tra stringhe, chiamare il <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena una o più istanze di <see cref="T:System.String" /> oppure le rappresentazioni <see cref="T:System.String" /> dei valori di una o più istanze di <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Oggetto Collection che implementa <see cref="T:System.Collections.Generic.IEnumerable`1" /> e il cui argomento di tipo generico è <see cref="T:System.String" />.</param>
        <summary>Concatena i membri di una raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> costruita di tipo <see cref="T:System.String" />.</summary>
        <returns>Stringhe concatenate in <paramref name="values" /> o <see cref="F:System.String.Empty" /> se <paramref name="values" /> è un oggetto <see langword="IEnumerable(Of String)" /> vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto `values`; non vengono aggiunti i delimitatori. Per specificare un delimitatore tra ogni membro del `values`, chiamare il <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (metodo).  
  
 Un' <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi elemento null in `values`.  
  
 Se `values` è una classe vuota `IEnumerable(Of String)`, il metodo restituisce <xref:System.String.Empty?displayProperty=nameWithType>. Se `values` viene `null`, il metodo genera un <xref:System.ArgumentNullException> eccezione.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> è un metodo pratico che consente di concatenare ogni elemento in un `IEnumerable(Of String)` raccolta senza prima convertire gli elementi in una matrice di stringhe. È particolarmente utile con espressioni di query Language-Integrated Query (LINQ). L'esempio seguente passa un `List(Of String)` oggetto contenente le lettere maiuscole o minuscole dell'alfabeto a un'espressione lambda che consente di selezionare lettere che si trovano uguale o maggiore di una determinata lettera (ovvero, nell'esempio, "M"). Il `IEnumerable(Of String)` raccolta restituito dal <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene passato per il <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodo per visualizzare il risultato come stringa singola.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a un <xref:System.Collections.Generic.List%601> oggetto di tipo <xref:System.String>, che viene quindi passata al <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (metodo).  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Oggetto da rappresentare oppure <see langword="null" />.</param>
        <summary>Crea la rappresentazione di stringa di un oggetto specificato.</summary>
        <returns>Rappresentazione di stringa del valore di <paramref name="arg0" /> oppure <see cref="F:System.String.Empty" /> se <paramref name="arg0" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Concat%28System.Object%29> metodo rappresenta `arg0` sotto forma di stringa chiamando il relativo senza parametri `ToString` (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Concat%2A> (metodo).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Matrice di oggetti contenente gli elementi da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa degli elementi in una matrice <see cref="T:System.Object" /> specificata.</summary>
        <returns>Rappresentazioni di stringa concatenate dei valori degli elementi di <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto nella `args` mediante la chiamata senza parametri `ToString` metodo dell'oggetto; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene usato al posto di qualsiasi oggetto null nella matrice.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.String.Concat%2A> metodo con un <xref:System.Object> matrice.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo non viene chiamato da codice C++. Il compilatore C++ risolve le chiamate a <see cref="Overload:System.String.Concat" /> che dispone di quattro o più parametri dell'oggetto come una chiamata a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Matrice di istanze di stringa.</param>
        <summary>Concatena gli elementi di una matrice di oggetti <see cref="T:System.String" /> specificati.</summary>
        <returns>Elementi concatenati del parametro <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto `values`; non vengono aggiunti i delimitatori.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi oggetto null nella matrice.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.String.Concat%2A> metodo con un <xref:System.String> matrice.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primo oggetto da concatenare.</param>
        <param name="arg1">Secondo oggetto da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa di due oggetti specificati.</summary>
        <returns>Rappresentazioni di stringa concatenate dei valori di <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consente di concatenare il metodo `arg0` e `arg1` mediante la chiamata senza parametri `ToString` metodo `arg0` e `arg1`; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene usato al posto di qualsiasi argomento null.  
  
 Se uno degli argomenti è un riferimento a una matrice, il metodo consente di concatenare una stringa che rappresenta la matrice, anziché i relativi membri (ad esempio, "System.String[]").  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Concat%2A> (metodo).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Prima stringa da concatenare.</param>
        <param name="str1">Seconda stringa da concatenare.</param>
        <summary>Concatena due istanze specificate della classe <see cref="T:System.String" />.</summary>
        <returns>Concatenazione dei parametri <paramref name="str0" /> e <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `str0` e `str1`; non vengono aggiunti i delimitatori.  
  
> [!NOTE]
>  Operatore di concatenazione di stringhe del linguaggio, è possibile anche usare, ad esempio `+` in c# o `&` e `+` in Visual Basic)  
>   
>  , per concatenare le stringhe.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi argomento null.  
  
   
  
## Examples  
 Nell'esempio seguente consente di concatenare, intermedio, nome e cognome una persona.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primo oggetto da concatenare.</param>
        <param name="arg1">Secondo oggetto da concatenare.</param>
        <param name="arg2">Terzo oggetto da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa di tre oggetti specificati.</summary>
        <returns>Rappresentazioni di stringa concatenate dei valori di <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consente di concatenare `arg0`, `arg1`, e `arg2` mediante la chiamata senza parametri `ToString` metodo per ogni oggetto; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene usato al posto di qualsiasi argomento null.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Concat%2A> (metodo).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Prima stringa da concatenare.</param>
        <param name="str1">Seconda stringa da concatenare.</param>
        <param name="str2">Terza stringa da concatenare.</param>
        <summary>Concatena tre istanze specificate della classe <see cref="T:System.String" />.</summary>
        <returns>Concatenazione dei parametri <paramref name="str0" />, <paramref name="str1" /> e <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `str0`, `str1`, e `str2`; non vengono aggiunti i delimitatori.  
  
> [!NOTE]
>  Operatore di concatenazione di stringhe del linguaggio, è possibile anche usare, ad esempio `+` in c# o `&` e `+` in Visual Basic)  
>   
>  , per concatenare le stringhe.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi argomento null.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Concat%2A> metodo per concatenare tre stringhe e viene visualizzato il risultato.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primo oggetto da concatenare.</param>
        <param name="arg1">Secondo oggetto da concatenare.</param>
        <param name="arg2">Terzo oggetto da concatenare.</param>
        <param name="arg3">Quarto oggetto da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa di quattro oggetti specificati e di qualsiasi oggetto specificato in un elenco di parametri di lunghezza variabile facoltativo.</summary>
        <returns>Rappresentazione di stringa concatenata di ogni valore nell'elenco dei parametri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questa API non è conforme a CLS. L'alternativa conforme a CLS è <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. I compilatori c# e Visual Basic Risolvi automaticamente una chiamata al metodo come una chiamata a <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Il metodo concatena ogni oggetto nell'elenco dei parametri chiamando relativo senza parametri `ToString` metodo; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene usato al posto di qualsiasi argomento null.  
  
> [!NOTE]
>  L'ultimo parametro del <xref:System.String.Concat%2A> metodo è un elenco facoltativo delimitato da virgole di uno o più oggetti aggiuntivi da concatenare.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodo per concatenare un elenco di parametri variabile. In questo caso, il metodo viene chiamato con nove parametri.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo metodo è contrassegnato con il <see langword="vararg" /> (parola chiave), il che significa che supporta un numero variabile di parametri. Il metodo può essere chiamato da Visual C++, ma non può essere chiamato dal codice c# o Visual Basic. I compilatori c# e Visual Basic risolvere le chiamate ai <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> come chiamate a <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Prima stringa da concatenare.</param>
        <param name="str1">Seconda stringa da concatenare.</param>
        <param name="str2">Terza stringa da concatenare.</param>
        <param name="str3">Quarta stringa da concatenare.</param>
        <summary>Concatena quattro istanze specificate della classe <see cref="T:System.String" />.</summary>
        <returns>Concatenazione dei parametri <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> e <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `str0`, `str1`, `str2`, e `str3`; non vengono aggiunti i delimitatori.  
  
> [!NOTE]
>  Operatore di concatenazione di stringhe del linguaggio, è possibile anche usare, ad esempio `+` in c# o `&` e `+` in Visual Basic)  
>   
>  , per concatenare le stringhe.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi oggetto null nella matrice.  
  
   
  
## Examples  
 Nell'esempio seguente definisce una matrice di parole di quattro – lettere e archivia le singole lettere in una matrice di stringhe per decodificate. Chiama quindi il <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metodo per riassemblare le singole parole.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Il tipo dei membri del <c>valori</c>.</typeparam>
        <param name="values">Oggetto Collection che implementa l'interfaccia <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatena i membri di un'implementazione di <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Membri concatenati in <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto `values`; non vengono aggiunti i delimitatori.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi argomento null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> è un metodo pratico che consente di concatenare ogni elemento in un <xref:System.Collections.Generic.IEnumerable%601> raccolta senza prima convertire gli elementi in stringhe. È particolarmente utile con espressioni di query Language-Integrated Query (LINQ), come illustrato nell'esempio. La rappresentazione di stringa di ogni oggetto nella <xref:System.Collections.Generic.IEnumerable%601> è derivata tramite la chiamata dell'oggetto raccolta `ToString` (metodo).  
  
   
  
## Examples  
 L'esempio seguente definisce una semplice `Animal` classe che contiene il nome di un animale e l'ordine a cui appartiene. Definisce quindi una <xref:System.Collections.Generic.List%601> oggetto per contenere un numero di `Animal` oggetti. Il <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene chiamato il metodo di estensione per estrarre le `Animal` oggetti la cui proprietà `Order` proprietà è uguale a "Roditore". Il risultato viene passato per il <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodo e visualizzati nella console.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <summary>Restituisce un valore che indica se una sottostringa specificata è presente all'interno della stringa.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è presente all'interno della stringa o se il parametro <paramref name="value" /> è la stringa vuota (""); in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura). La ricerca inizia nella posizione del primo carattere della stringa e continui fino alla posizione dell'ultimo carattere.  
  
 Per determinare se una stringa contiene una sottostringa specificata con un valore diverso da un confronto ordinale (ad esempio, confronto con distinzione delle impostazioni cultura, o un confronto ordinale tra maiuscole e minuscole), è possibile creare un metodo personalizzato. L'esempio seguente illustra un approccio di questo tipo. Definisce un <xref:System.String> metodo di estensione che include un <xref:System.StringComparison> parametro e indica se una stringa contiene una sottostringa quando si usa il modulo specificato sul confronto tra stringhe.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 L'esempio seguente chiama quindi il `Contains` metodo di estensione per stabilire se una sottostringa si trova in una stringa quando si usa un confronto ordinale e un confronto ordinale tra maiuscole e minuscole.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Se si è interessati nella posizione della sottostringa `value` nell'istanza corrente, è possibile chiamare il <xref:System.String.IndexOf%2A> metodo per ottenere la posizione iniziale della prima occorrenza, oppure è possibile chiamare il <xref:System.String.LastIndexOf%2A> metodo per ottenere a partire dalla posizione del relativo ultima occorrenza. L'esempio include una chiamata al <xref:System.String.IndexOf%28System.String%29> metodo se in un'istanza di stringa viene trovata una sottostringa.  
  
   
  
## Examples  
 Nell'esempio seguente determina se la stringa "volpe" è una sottostringa di una frase. Se viene trovati "parole volpe" nella stringa, visualizza anche la posizione iniziale.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da copiare.</param>
        <summary>Crea una nuova istanza dell'oggetto <see cref="T:System.String" /> con lo stesso valore di un'istanza dell'oggetto <see cref="T:System.String" /> specificata.</summary>
        <returns>Nuova stringa con lo stesso valore di <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Copy%2A> metodo restituisce un <xref:System.String> oggetto che ha lo stesso valore di stringa originale, ma rappresenta un riferimento di un oggetto diverso. Differisce da un'operazione di assegnazione, che assegna un riferimento di stringa esistente a una variabile oggetto aggiuntive. Nell'esempio viene illustrata la differenza.  
  
   
  
## Examples  
 L'esempio seguente crea due oggetti stringa con valori diversi. Quando chiama il <xref:System.String.Copy%2A> metodo a cui assegnare il primo valore per la seconda stringa, l'output indica che le stringhe rappresentano i riferimenti a oggetti diversi anche se i relativi valori sono uguali a questo punto. D'altra parte, quando la prima stringa è assegnata alla stringa del secondo, le due stringhe hanno valori identici poiché rappresentano il riferimento all'oggetto stesso.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Indice del primo carattere nell'istanza da copiare.</param>
        <param name="destination">Matrice di caratteri Unicode in cui vengono copiati i caratteri di questa istanza.</param>
        <param name="destinationIndex">Indice in <c>destination</c> in corrispondenza del quale inizia l'operazione di copia.</param>
        <param name="count">Numero di caratteri dell'istanza da copiare in <c>destination</c>.</param>
        <summary>Copia un numero definito di caratteri da una posizione specificata in questa istanza in una posizione specificata in una matrice di caratteri Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia `count` caratteri dal `sourceIndex` posizione di questa istanza con il `destinationIndex` posizionare di `destination` matrice di caratteri. Questo metodo non si ridimensiona il `destination` matrice di caratteri; deve avere un numero sufficiente di elementi da contenere i caratteri copiati o il metodo genera un <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` e `destinationIndex` sono a base zero.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.CopyTo%2A> (metodo).  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> o <paramref name="count" /> è negativo  oppure  <paramref name="sourceIndex" /> non identifica una posizione nell'istanza corrente.  oppure  <paramref name="destinationIndex" /> non identifica un indice valido nella matrice <paramref name="destination" />.  oppure  <paramref name="count" /> è maggiore della lunghezza della sottostringa in <paramref name="sourceIndex" /> alla fine dell'istanza  oppure  <paramref name="count" /> è maggiore della lunghezza della matrice secondaria in <paramref name="destinationIndex" /> alla fine della matrice <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta la stringa vuota. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questo campo è la stringa di lunghezza zero, "".  
  
 Nel codice dell'applicazione, questo campo viene usato più di frequente nelle assegnazioni per inizializzare una variabile di stringa in una stringa vuota. Per verificare se il valore di una stringa può essere `null` oppure <xref:System.String.Empty?displayProperty=nameWithType>, usare il <xref:System.String.IsNullOrEmpty%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se la fine di questa istanza di stringa corrisponde a una stringa specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con la sottostringa alla fine di questa istanza.</param>
        <summary>Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata.</summary>
        <returns>
          <see langword="true" /> se la fine di questa istanza corrisponde al parametro <paramref name="value" />; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo confronta `value` con la sottostringa alla fine di questa istanza è uguale alla lunghezza `value`e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento alla stessa istanza o corrisponde alla fine di questa istanza.  
  
 Questo metodo esegue un confronto di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
   
  
## Examples  
 Nell'esempio seguente indica se ogni stringa in una matrice termina con un punto (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 L'esempio seguente definisce una `StripEndTags` metodo che usa il <xref:System.String.EndsWith%28System.String%29> metodo per rimuovere i tag di fine HTML dalla fine di una riga. Si noti che il `StripEndTags` viene chiamato in modo ricorsivo per garantire che vengano rimossi più tag di fine HTML alla fine della riga.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per determinare se una stringa termina con una particolare sottostringa tramite le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per la relativa <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con la sottostringa alla fine di questa istanza.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che determina la modalità di confronto tra questa stringa e <c>value</c>.</param>
        <summary>Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante l'opzione di confronto specificata.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> corrisponde alla fine di questa stringa; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.EndsWith%2A> metodo confronta la `value` parametro con la sottostringa alla fine di questa stringa e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento a questa stessa stringa, deve essere una stringa vuota (""), oppure deve corrispondere alla fine di questa stringa. Il tipo di confronto eseguito dal <xref:System.String.EndsWith%2A> metodo dipende dal valore della `comparisonType` parametro.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa termina con una particolare sottostringa. I risultati sono interessati dalla scelta di impostazioni cultura, se verrà ignorato caso e se viene eseguito un confronto ordinale.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con la sottostringa alla fine di questa istanza.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Informazioni relative alle impostazioni cultura che determinano le modalità di confronto tra questa istanza e <c>value</c>. Se <c>culture</c> è <see langword="null" />, verranno usate le impostazioni cultura correnti.</param>
        <summary>Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante le impostazioni cultura specificate.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> corrisponde alla fine di questa stringa; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo confronta la `value` parametro per la sottostringa alla fine di questa stringa che rappresenta la stessa lunghezza `value`e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento alla stessa istanza oppure corrispondere alla fine di questa stringa.  
  
 Questo metodo esegue un confronto (dipendenti dalle impostazioni cultura) di word usando le maiuscole e minuscole specificata e le impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa si verifica alla fine di un'altra stringa. Il <xref:System.String.EndsWith%2A> metodo viene chiamato più volte con distinzione maiuscole/minuscole e maiuscole/minuscole diverse impostazioni cultura che determinano i risultati della ricerca.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se due oggetti <see cref="T:System.String" /> hanno lo stesso valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Stringa da confrontare con questa istanza.</param>
        <summary>Determina se questa istanza e un oggetto specificato, che deve essere anche un oggetto <see cref="T:System.String" />, hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="obj" /> è un oggetto <see cref="T:System.String" /> e il relativo valore corrisponde a quello di questa istanza; in caso contrario <see langword="false" />.  Se <paramref name="obj" /> è <see langword="null" />, il metodo restituisce <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Equals%2A> (metodo).  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con questa istanza.</param>
        <summary>Determina se questa istanza e un altro oggetto <see cref="T:System.String" /> specificato hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="value" /> è lo stesso di quello di questa istanza; in caso contrario, <see langword="false" />. Se <paramref name="value" /> è <see langword="null" />, il metodo restituisce <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Equals%2A> (metodo). Confronta la parola con titolo "File" con una parola equivalente, l'equivalente minuscolo, equivalente maiuscolo e una parola che contiene LATIN piccole lettera punto ricerca per categorie (U + 0131) anziché LATIN piccole lettera ricerca per categorie (u+0069). Poiché il <xref:System.String.Equals%28System.String%29> metodo esegue un confronto ordinale, restituisce solo il confronto con una parola identico `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <summary>Determina se due oggetti <see cref="T:System.String" /> specificati hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il valore di <paramref name="a" /> è uguale al valore di <paramref name="b" />; in caso contrario, <see langword="false" />. Se entrambi i parametri <paramref name="a" /> e <paramref name="b" /> sono <see langword="null" />, il metodo restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Equals%2A> (metodo).  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con questa istanza.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica la modalità di confronto delle stringhe.</param>
        <summary>Determina se questa stringa e un oggetto <see cref="T:System.String" /> specificato hanno lo stesso valore. Un parametro specifica le impostazioni cultura, l'eventuale distinzione fra maiuscole e minuscole e le regole di ordinamento usate per effettuare il confronto.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="value" /> corrisponde a quello di questa stringa; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invariante, rispettano o ignorare la distinzione tra le due stringhe da confrontare o usare parole o le regole di ordinamento per ordinale.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di stringhe costituito da una maiuscola "I", una "i" minuscola e una "ı". Chiama poi il <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metodo confrontarli con ogni possibile <xref:System.StringComparison> valore di enumerazione.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 L'esempio seguente confronta i quattro set di parole con ogni membro del <xref:System.StringComparison> enumerazione.  I confronti di usano le convenzioni della lingua inglese (Stati Uniti) e le lingue Sami (Svezia superiore). Si noti che le stringhe "encyclopædia" e "Enciclopedia" sono considerati equivalenti nelle impostazioni cultura en-US, ma non nelle impostazioni cultura Sami (settentrionale Svezia).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di confronto.</param>
        <summary>Determina se due oggetti <see cref="T:System.String" /> specificati hanno lo stesso valore. Un parametro specifica le impostazioni cultura, l'eventuale distinzione fra maiuscole e minuscole e le regole di ordinamento usate per effettuare il confronto.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="a" /> è uguale al valore del parametro <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invariante, rispettano o ignorare la distinzione tra le due stringhe da confrontare o usare parole o le regole di ordinamento per ordinale.  
  
   
  
## Examples  
 L'esempio seguente confronta i quattro set di parole con ogni membro del <xref:System.StringComparison> enumerazione.  I confronti di usano le convenzioni della lingua inglese (Stati Uniti) e le lingue Sami (Svezia superiore). Si noti che le stringhe "encyclopædia" e "Enciclopedia" sono considerati equivalenti nelle impostazioni cultura en-US, ma non nelle impostazioni cultura Sami (settentrionale Svezia).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore degli oggetti in stringhe in base ai formati specificati e le inserisce in un'altra stringa.  Se non si ha familiarità con il metodo "String.Format", vedere la sezione [Introduzione al metodo String. Format](#Starting) per una rapida panoramica.  Vedere la sezione Osservazioni per la documentazione generale per il metodo "String.Format".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Contenuto della sezione:  
  
 [Iniziare con il metodo String. Format](#Starting)   
 [Quale metodo viene chiamato?](#FTaskList)   
 [Il metodo di formato in breve](#Format_Brief)   
 [L'elemento di formato](#FormatItem)   
 [La formattazione di argomenti](#HowFormatted)   
 [Elementi di formato che hanno lo stesso indice](#SameIndex)   
 [Formattazione e le impostazioni cultura](#Format_Culture)   
 [Operazioni di formattazione personalizzata](#Format_Custom)   
 [String. Format domande e risposte](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Iniziare con il metodo String. Format  
 Usare <xref:System.String.Format%2A?displayProperty=nameWithType> se è necessario inserire il valore di un oggetto, una variabile o espressione in un'altra stringa. Ad esempio, è possibile inserire il valore di un <xref:System.Decimal> valore in una stringa per visualizzarlo all'utente sotto forma di stringa singolo:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Ed è possibile controllare la formattazione del valore:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Oltre a formattazione, è anche possibile controllare l'allineamento e spaziatura.  
  
 ### <a name="inserting-a-string"></a>Inserimento di una stringa  

 <xref:System.String.Format%2A?displayProperty=nameWithType> inizia con una stringa di formato, seguita da uno o più oggetti o le espressioni che verranno convertite in stringhe e inserite in una posizione specificata nella stringa di formato. Ad esempio:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Il `{0}` nel formato di stringa è un elemento di formato. `0` è l'indice dell'oggetto il cui valore di stringa verrà inserito in tale posizione. (Gli indici iniziano da 0). Se l'oggetto da inserire non è una stringa, relativo `ToString` viene chiamato per convertire i dati a una prima di inserirlo nella stringa di risultato.  
  
 Ecco un altro esempio che usa due elementi di formato e due oggetti nell'elenco di oggetti:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 È possibile avere un numero di elementi di formato e il numero di oggetti nell'elenco di oggetti come si desidera, fino a quando l'indice di ogni elemento di formato è un oggetto corrispondente nell'elenco di oggetti. Inoltre non devi preoccuparti sulla quale eseguire l'overload si chiama; il compilatore seleziona quello appropriato per l'utente.  
  
 ### <a name="controlling-formatting"></a>Controllare la formattazione  
 È possibile seguire l'indice in un elemento di formato con una stringa di formato per controllare come viene formattato un oggetto. Ad esempio, `{0:d}` si applica la stringa di formato "d" per il primo oggetto nell'elenco di oggetti. Di seguito è riportato un esempio con un singolo oggetto e due elementi di formato:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Un numero di supporto di tipi di formattare le stringhe, inclusi tutti i tipi numerici (entrambe [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [personalizzati](~/docs/standard/base-types/custom-numeric-format-strings.md) stringhe di formato), tutte le date e ore (entrambi [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e[personalizzati](~/docs/standard/base-types/custom-date-and-time-format-strings.md) stringhe di formato) e gli intervalli di tempo (entrambi [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) e [personalizzato](~/docs/standard/base-types/custom-timespan-format-strings.md) stringhe di formato), tutti i tipi di enumerazione [i tipi di enumerazione ](~/docs/standard/base-types/enumeration-format-strings.md), e [GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). È anche possibile aggiungere il supporto per le stringhe di formato per i tipi personalizzati.  
  
 ### <a name="controlling-spacing"></a>Controllare la spaziatura  
 È possibile definire la larghezza della stringa inserita nella stringa di risultato tramite, ad esempio sintassi `{0,12}`, che inserisce una stringa di 12 caratteri. La rappresentazione di stringa del primo oggetto in questo caso, viene allineato a destra nel campo di 12 caratteri.  (Se la rappresentazione di stringa del primo oggetto è di più di 12 caratteri, tuttavia, la larghezza preferita del campo viene ignorata e l'intera stringa viene inserita nella stringa di risultato.)  
  
 L'esempio seguente definisce un campo di 6 caratteri per memorizzare la stringa "Year" e alcune stringhe anno, nonché un campo di 15 caratteri per contenere la stringa "Popolamento" e alcuni dati della popolazione. Si noti che i caratteri sono allineati a destra del campo.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Controllo dell'allineamento  
 Per impostazione predefinita, le stringhe sono allineati a destra nel proprio campo se si specifica una lunghezza di campo. Per allineare a sinistra le stringhe in un campo, ad esempio si anteporre la larghezza del campo con un segno negativo, `{0,-12}` per definire un campo allineato a destra di 12 caratteri.  
  
 Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che Allinea a sinistra di etichette e dati.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> Usa la funzionalità di formattazione composita. Per altre informazioni, vedere [Formattazione composita](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Quale metodo viene chiamato?  
  
|A|Call|  
|--------|----------|  
|Formattare uno o più oggetti usando le convenzioni delle impostazioni cultura correnti.|Fatta eccezione per gli overload che includono un `provider` parametro, i rimanenti <xref:System.String.Format%2A> overload includono un <xref:System.String> parametro seguita da uno o più parametri dell'oggetto. Per questo motivo, non è necessario determinare quale <xref:System.String.Format%2A> overload si intende chiamare. Il compilatore di linguaggio consente di selezionare l'overload appropriato tra gli overload che non hanno un `provider` parametro, in base all'elenco di argomenti. Ad esempio, se all'elenco di argomenti dispone di cinque argomenti, il compilatore chiama il <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> (metodo).|  
|Formattare uno o più oggetti usando le convenzioni delle impostazioni cultura specifiche.|Ciascuna <xref:System.String.Format%2A> overload che inizia con un `provider` parametro è seguito da un <xref:System.String> parametro e uno o più parametri dell'oggetto. Per questo motivo, non è necessario determinare specifico a cui <xref:System.String.Format%2A> overload si intende chiamare. Il compilatore di linguaggio consente di selezionare l'overload appropriato tra gli overload che includono un `provider` parametro, in base all'elenco di argomenti. Ad esempio, se all'elenco di argomenti dispone di cinque argomenti, il compilatore chiama il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> (metodo).|  
|Eseguire un'operazione di formattazione personalizzata con un <xref:System.ICustomFormatter> implementazione o <xref:System.IFormattable> implementazione.|Uno qualsiasi dei quattro overload con un `provider` parametro. Il compilatore consente di selezionare l'overload appropriato tra gli overload che includono un `provider` parametro, in base all'elenco di argomenti.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Il metodo di formato in breve 

 Ogni overload del <xref:System.String.Format%2A> metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) includere segnaposto indicizzati in base zero, denominati *formattare gli elementi*, in una stringa di formato composito. In fase di esecuzione, ogni elemento di formato viene sostituito con la rappresentazione di stringa dell'argomento corrispondente in un elenco di parametri. Se il valore dell'argomento `null`, l'elemento di formato viene sostituito con <xref:System.String.Empty?displayProperty=nameWithType>. Ad esempio, la chiamata seguente al <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodo include una stringa di formato con tre elementi di formato, {0}, {1}, e {2}e un elenco di argomenti con tre elementi.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>L'elemento di formato  
 Questa sintassi è un elemento di formato:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Parentesi quadre indicano elementi facoltativi. Le parentesi e parentesi graffe di chiusura sono obbligatori. (Per includere una valore letterale apertura o chiusura di parentesi graffa nella stringa di formato, vedere la [escape delle parentesi graffe](~/docs/standard/base-types/composite-formatting.md#escaping-braces) sezione il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) articolo.)  
  
 Ad esempio, un elemento di formato per formattare un valore di valuta potrebbe essere simile al seguente:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Un elemento di formato include gli elementi seguenti:  
  
 *index*  
 Indice a base zero dell'argomento la cui rappresentazione di stringa deve essere incluso nella posizione specificata nella stringa. Se questo argomento è `null`, una stringa vuota verrà inclusa nella posizione specificata nella stringa.  
  
 *allineamento*  
 Facoltativo. Un intero con segno che indica la lunghezza totale del campo in cui viene inserito l'argomento e se viene allineato a destra (un numero intero positivo) o allineato a sinistra (un numero intero negativo). Se si omette *allineamento*, la rappresentazione di stringa dell'argomento corrispondente viene inserita in un campo senza spazi iniziali o finali.  
  
 Se il valore di *allineamento* è minore della lunghezza dell'argomento deve essere inserito *allineamento* viene ignorato e la lunghezza della rappresentazione di stringa dell'argomento viene usata come larghezza del campo.  
  
 *formatString*  
 Facoltativo. Stringa che specifica il formato della stringa di risultato dell'argomento corrispondente. Se si omette *formatString*, l'argomento corrispondente senza parametri del `ToString` metodo viene chiamato per generare la rappresentazione di stringa. Se si specifica *formatString*, l'argomento fa riferimento l'elemento di formato deve implementare il <xref:System.IFormattable> interfaccia. I tipi che supportano le stringhe di formato includono:  
  
-   Tutti i tipi a virgola mobile e integrali. (Vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzate](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> e <xref:System.DateTimeOffset>. (Vedere [stringhe di formato di data e ora Standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [stringhe di formato di data e ora personalizzato](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Tutti i tipi di enumerazione. (Vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   valori <xref:System.TimeSpan>. (Vedere [stringhe di formato TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) e [stringhe di formato TimeSpan personalizzate](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID. (Vedere il <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> (metodo).)  
  
 Si noti tuttavia che è possibile implementare qualsiasi tipo personalizzato <xref:System.IFormattable> o estendere un tipo esistente <xref:System.IFormattable> implementazione.  
  
 L'esempio seguente usa il `alignment` e `formatString` argomenti per produrre l'output formattato.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>La formattazione di argomenti  
 Gli elementi di formato vengono elaborati in modo sequenziale dall'inizio della stringa. Ogni elemento di formato include un indice che corrisponde a un oggetto nell'elenco di argomenti del metodo. Il <xref:System.String.Format%2A> metodo recupera l'argomento e deriva relativa rappresentazione di stringa come indicato di seguito:  
  
-   Se l'argomento `null`, il metodo inserisce <xref:System.String.Empty?displayProperty=nameWithType> nella stringa di risultato. Non è necessario prestare attenzione con la gestione una <xref:System.NullReferenceException> per gli argomenti null. 
  
-   Se si chiama il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> rapporto di overload e il `provider` dell'oggetto <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementazione restituisce un valore non null <xref:System.ICustomFormatter> implementazione, l'argomento viene passato al relativo <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo). Se l'elemento di formato include un *formatString* argomento, viene passato come primo argomento al metodo. Se il <xref:System.ICustomFormatter> implementazione è disponibile e produce una stringa non null, che viene restituita come rappresentazione di stringa dell'argomento di stringa; in caso contrario, viene eseguito il passaggio successivo.  
  
-   Se l'argomento implementa il <xref:System.IFormattable> interfaccia relativo <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> viene chiamata l'implementazione.  
  
-   L'argomento va senza parametri `ToString` , che esegue l'override o eredita da un'implementazione della classe base, viene chiamato.  
  
 Per un esempio che intercetta le chiamate al <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> metodo e consente di visualizzare le informazioni che il <xref:System.String.Format%2A> metodo passa a un metodo di formattazione per ogni elemento di formato in una stringa di formato composita, vedere [esempio: un provider di intercettazione e Formattatore numerale romano](#Format7_Example).  

 Per altre informazioni, vedere la [nell'ordine di elaborazione](~/docs/standard/base-types/composite-formatting.md##processing-order) sezione il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) articolo.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Elementi di formato che hanno lo stesso indice  
 Il <xref:System.String.Format%2A> metodo genera un <xref:System.FormatException> eccezione se l'indice di un elemento di indice è maggiore o uguale al numero di argomenti nell'elenco di argomenti. Tuttavia, `format` può includere più elementi di formato, quanti sono presenti argomenti, purché più elementi di formato hanno lo stesso indice. Nella chiamata al <xref:System.String.Format%28System.String%2CSystem.Object%29> metodo nell'esempio seguente, l'elenco di argomenti contiene un solo argomento, ma la stringa di formato include due elementi di formato: uno viene visualizzato il valore decimale di un numero e l'altra consente di visualizzare il relativo valore esadecimale.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formattazione e le impostazioni cultura  
 In generale, gli oggetti nell'elenco di argomenti vengono convertiti nelle rispettive rappresentazioni di stringa usando le convenzioni delle impostazioni cultura correnti, che viene restituito dal <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> proprietà. È possibile controllare questo comportamento chiamando uno degli overload del <xref:System.String.Format%2A> che include un `provider` parametro. Il `provider` parametro è un <xref:System.IFormatProvider> elaborare implementazione che fornisce informazioni di formattazione specifiche delle impostazioni cultura e personalizzate che consente di moderato la formattazione.  
  
 Il <xref:System.IFormatProvider> interfaccia dispone di un singolo membro, <xref:System.IFormatProvider.GetFormat%2A>, che è responsabile della restituzione dell'oggetto che fornisce informazioni di formattazione. .NET Framework ha tre <xref:System.IFormatProvider> implementazioni che forniscono informazioni di formattazione specifiche delle impostazioni cultura:  
  
-   <xref:System.Globalization.CultureInfo>. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> metodo viene restituito un oggetto specifico delle impostazioni cultura <xref:System.Globalization.NumberFormatInfo> oggetto per la formattazione di valori numerici e una cultura <xref:System.Globalization.DateTimeFormatInfo> oggetto per la formattazione di valori data e ora.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, che viene usato per la formattazione specifiche delle impostazioni cultura di valori data e ora. Relativo <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> metodo restituisce se stesso.  
  
-   <xref:System.Globalization.NumberFormatInfo>, che viene usato per la formattazione specifica delle impostazioni cultura di valori numerici. Relativo <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> proprietà restituisce se stesso. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Operazioni di formattazione personalizzata  
 È inoltre possibile chiamare uno degli overload del <xref:System.String.Format%2A> metodo con un `provider` parametru typu <xref:System.IFormatProvider> per eseguire operazioni di formattazione personalizzate. È ad esempio, è stato possibile formattare un integer come un numero di identificazione o un numero di telefono. Per eseguire la formattazione personalizzata, il `provider` argomento deve implementare sia il <xref:System.IFormatProvider> e <xref:System.ICustomFormatter> interfacce. Quando la <xref:System.String.Format%2A> viene passato un <xref:System.ICustomFormatter> implementazione come il `provider` argomento, il <xref:System.String.Format%2A> chiamate al metodo relativo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementazione e richiede un oggetto di tipo <xref:System.ICustomFormatter>. Chiama quindi l'oggetto restituito <xref:System.ICustomFormatter> dell'oggetto <xref:System.ICustomFormatter.Format%2A> metodo per formattare ogni elemento di formato della stringa composita passato ad esso.  
  
 Per altre informazioni su come fornire soluzioni di formattazione personalizzate, vedere [procedura: definire e usare provider formato numerico personalizzati](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) e <xref:System.ICustomFormatter>. Per un esempio che converte i numeri interi in numeri formattati personalizzati, vedere [esempio: un'operazione di formattazione personalizzata](#Format6_Example). Per un esempio che converte i byte senza segno in numeri romani, vedere [esempio: un provider di intercettazione e il formattatore numerale romano](#Format7_Example).  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>Esempio: Un'operazione formattazione personalizzata  
 Questo esempio definisce un provider di formato che formatta un valore integer come un numero di account dei clienti nel formato x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Esempio: Un provider di intercettazione e formattatore numerale romano  
 Questo esempio viene definito un provider di formato personalizzata che implementa il <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfacce eseguire due operazioni:  
  
-   Visualizza i parametri passati al relativo <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementazione. Ciò consente di vedere quali parametri il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo passa all'implementazione di formattazione personalizzata per ogni oggetto che tenta di formattare. Ciò può essere utile quando si esegue il debug dell'applicazione.  
  
-   Se l'oggetto da formattare è un valore byte senza segno che deve essere formattato usando la stringa di formato standard "R", il formattatore personalizzato il valore numerico viene formattato come un numerale romano.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String. Format domande e risposte  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Il motivo per cui è preferibile l'interpolazione di stringhe tramite chiamate al `String.Format` metodo?

Interpolazione di stringhe è:

- Più flessibile. Può essere utilizzato in qualsiasi stringa senza richiedere una chiamata a un metodo che supporta la formattazione composita. In caso contrario, è necessario chiamare il <xref:System.String.Format%2A> metodo o un altro metodo che supporta la formattazione composita, ad esempio <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Più leggibile. Poiché nell'espressione interpolata è presente l'espressione da inserire in una stringa anziché in un elenco di argomenti, le stringhe interpolate sono molto più semplice di codice e di leggere. A causa delle loro maggiore leggibilità, le stringhe interpolate possono sostituire non solo le chiamate ai metodi di formato composito, ma possono anche essere utilizzati nelle operazioni di concatenazione di stringhe per produrre codice più conciso e chiaro. 

Un confronto tra i seguenti due esempi di codice viene illustrato il superiorità di stringhe interpolate tramite la concatenazione di stringhe e le chiamate ai metodi di formattazione composita. L'uso di più operazioni di concatenazione di stringhe nell'esempio seguente produce codice dettagliato e difficile da leggere.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Al contrario, l'uso delle stringhe interpolate nell'esempio seguente produce codice molto più chiara, concisa rispetto dell'istruzione di concatenazione di stringhe e la chiamata al <xref:System.String.Format%2A> metodo nell'esempio precedente.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Dove trovare un elenco delle stringhe di formato predefinito che può essere usato con gli elementi di formato?  
  
-   Per tutti i tipi a virgola mobile e integrali, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per i valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Per i valori di enumerazione, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Per la <xref:System.TimeSpan> valori, vedere [stringhe di formato TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) e [stringhe di formato TimeSpan personalizzate](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Per la <xref:System.Guid> valori, vedere la sezione Osservazioni del <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> pagina di riferimento.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Come si controlla l'allineamento delle stringhe di risultato che sostituiscono gli elementi di formato?  
 La sintassi generale di un elemento di formato è:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 in cui *allineamento* è un intero con segno che definisce la larghezza del campo. Se questo valore è negativo, il testo nel campo viene allineato a sinistra. Se è positivo, il testo è allineato a destra.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Come si controlla il numero di cifre dopo il separatore decimale?  
 Tutti i [stringhe di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) ad eccezione di "D" (che viene usato con solo numeri interi), "G", "R" e "X" Consenti a un identificatore di precisione che definisce il numero di cifre decimali nella stringa di risultato. L'esempio seguente usa le stringhe di formato numerico standard per controllare il numero di cifre decimali nella stringa di risultato.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Se si usa un' [stringa di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md), usare l'identificatore di formato "0" per controllare il numero di cifre decimali nella stringa di risultato, come illustrato nell'esempio seguente.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Come si controlla il numero di cifre integrali?  
 Per impostazione predefinita, le operazioni di formattazione visualizzano solo cifre integrali diverso da zero. Se si desidera formattare numeri interi, è possibile usare un identificatore di precisione con "D" e "X" stringhe di formato standard per controllare il numero di cifre.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 È possibile aggiungere un numero intero o a virgola mobile e con zeri iniziali per produrre una stringa di risultato con un numero specificato di cifre integrali con il valore "0" [identificatore di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md), come illustrato nell'esempio seguente.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Il numero di elementi è possibile includere nell'elenco formato?  
 Non sono previsti limiti pratici. Il secondo parametro del <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo è contrassegnato con il <xref:System.ParamArrayAttribute> attributo, che consente di includere un elenco delimitato da virgole o una matrice di oggetti come l'elenco di formato.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Come includere valori letterali parentesi graffe ("{" e "}") nella stringa di risultato?  
 Ad esempio, come si impedisce la seguente chiamata al metodo generi un <xref:System.FormatException> eccezione?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Una singola apertura o la parentesi graffa di chiusura viene sempre interpretato come l'inizio o alla fine di un elemento di formato. Per essere interpretato letteralmente, deve essere codificata. Una graffa mediante l'aggiunta di un'altra parentesi graffa ("{{" e "}}" invece di "{" e "}"), come nella chiamata al metodo seguente:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Tuttavia, anche con caratteri di escape delle parentesi graffe sono facilmente interpretate. È consigliabile includere le parentesi graffe nell'elenco di formato e usare elementi di formato per inserirli nella stringa di risultato, come illustrato nell'esempio seguente.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Il motivo per cui la chiamata al metodo String. Format viene generata un'eccezione FormatException?  
 La causa più comune dell'eccezione è che l'indice di un elemento di formato non corrisponde a un oggetto nell'elenco formato. In genere indica che è stata misnumbered gli indici degli elementi di formato o ha dimenticato di includere un oggetto nell'elenco di formato. Tenta di includere una parentesi graffa sinistra o destra senza caratteri di escape di caratteri genera anche un <xref:System.FormatException>. In alcuni casi, l'eccezione è il risultato di un errore di digitazione; ad esempio, un errore tipico è digitata "[" (la parentesi quadra aperta) invece di "{" (la parentesi graffa sinistra).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Se il metodo Format(System.IFormatProvider,System.String,System.Object[]) supporta matrici di parametri, perché il mio codice genera un'eccezione quando si usa una matrice?  
 Ad esempio, il codice seguente genera un <xref:System.FormatException> eccezione:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Si tratta di un problema di risoluzione dell'overload del compilatore. Poiché il compilatore non è possibile convertire una matrice di integer in una matrice di oggetti, considera la matrice di integer come un solo argomento, in modo che chiama il <xref:System.String.Format%28System.String%2CSystem.Object%29> (metodo). Poiché sono presenti quattro elementi di formato, ma solo un singolo elemento nell'elenco formato, viene generata l'eccezione.  
  
 Poiché Visual Basic né c# può convertire una matrice di interi in una matrice di oggetti, è necessario eseguire la conversione prima di chiamare il <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> (metodo). Nell'esempio seguente fornisce un'implementazione.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Esaminare numerosi esempi che chiamano il <xref:System.String.Format%2A> metodo vengono intercalati tramite i [osservazioni](#remarks) sezione di questo articolo.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

È anche possibile scaricare un set completo di `String.Format` esempi, inclusi una [progetto .NET Core 2.0 per Visual c#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) e un [progetto .NET Core 2.0 per Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), dal [dotnet / repository GitHub degli esempi](https://github.com/dotnet/samples).

Di seguito sono indicati alcuni degli esempi inclusi nell'articolo:

### <a name="create-a-format-string"></a>Creare una stringa di formato

[Inserimento di una stringa](#inserting-a-string)  
[L'elemento di formato](#the-format-item)  
[Elementi di formato che hanno lo stesso indice](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Controllare l'output formattato

[Controllare la formattazione](#controlling-formatting)  
[Controllare la spaziatura](#controlling-spacing)  
[Controllo dell'allineamento](#controlling-alignment)  
[Controllo del numero di cifre integrali](#how-do-i-control-the-number-of-integral-digits)  
[Controllo del numero di cifre dopo il separatore decimale](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Tra parentesi graffe letterale in una stringa di risultato](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Verificare le stringhe di formato distinzione delle impostazioni cultura

[Formattazione dipendente dalle impostazioni cultura](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Personalizzare l'operazione di formattazione

[Un'operazione di formattazione personalizzata](#example-a-custom-formatting-operation)  
[Un provider di intercettazione e il formattatore numerale romano](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Oggetto da formattare.</param>
        <summary>Sostituisce uno o più elementi di formato in una stringa con la rappresentazione di stringa di un oggetto specificato.</summary>
        <returns>Copia di <paramref name="format" /> in cui qualsiasi elemento di formato viene sostituito dalla rappresentazione di stringa di <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di un'espressione nella relativa rappresentazione di stringa e incorporare la rappresentazione in una stringa. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Esempio: Formattazione di un singolo argomento  
 
 L'esempio seguente usa il <xref:System.String.Format%28System.String%2CSystem.Object%29> metodo per incorporare l'età di un individuo a metà di una stringa.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">L'elemento di formato nel parametro <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Sostituisce l'elemento di formato presente in una stringa specificata con la rappresentazione di stringa di un oggetto corrispondente in una matrice specificata.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalla rappresentazione di stringa degli oggetti corrispondenti in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di quattro o più espressioni per le rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. Poiché il `args` parametro è contrassegnato con il <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attributo, è possibile passare gli oggetti al metodo come singoli argomenti o come un <xref:System.Object> matrice. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Esempio: Formattazione di più di tre argomenti  
 
 In questo esempio crea una stringa che contiene i dati sulla temperatura minimo e massimo in una data specifica. La stringa di formato composito ha cinque elementi di formato nell'esempio c# e sei nell'esempio Visual Basic. Due degli elementi di formato definire la larghezza della rappresentazione di stringa del relativo valore corrispondente e il primo elemento di formato include anche una stringa di formato di ora e data standard.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 È anche possibile passare gli oggetti da formattare come una matrice anziché da un elenco di argomenti.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> o <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore o uguale alla lunghezza della matrice <paramref name="args" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Oggetto da formattare.</param>
        <summary>Sostituisce uno o più elementi di formato presenti in una stringa specificata con la rappresentazione di stringa dell'oggetto corrispondente. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui uno o più elementi di formato vengono sostituiti dalla rappresentazione di stringa di <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di un'espressione nella relativa rappresentazione di stringa e incorporare la rappresentazione in una stringa. Nell'esecuzione della conversione, il metodo Usa formattazione dipendente dalle impostazioni cultura o un formattatore personalizzato. Il metodo converte `arg0` alla relativa rappresentazione di stringa chiamando relativo **ToString (IFormatProvider)** metodo oppure, se l'oggetto del corrispondente elemento di formato include una stringa di formato chiamando relativo **ToString ( String, IFormatProvider)** (metodo). Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** (metodo).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Sostituisce gli elementi di formato presenti in una stringa con le rappresentazioni di stringa degli oggetti corrispondenti in una matrice specificata. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalla rappresentazione di stringa degli oggetti corrispondenti in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire quattro o più espressioni per le rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. Nell'esecuzione della conversione, il metodo Usa formattazione dipendente dalle impostazioni cultura o un formattatore personalizzato. Il metodo converte ognuno <xref:System.Object> argomento alla relativa rappresentazione di stringa chiamando relativo **ToString (IFormatProvider)** metodo oppure, se l'oggetto del corrispondente elemento di formato include una stringa di formato chiamando relativo **ToString(String,IFormatProvider)** (metodo). Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** (metodo).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Esempio: Cultura formattazione  
 Questo esempio viene usato il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo per visualizzare la rappresentazione di stringa di alcuni valori di data e ora e valori numerici con varie impostazioni cultura.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> o <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore o uguale alla lunghezza della matrice <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato presenti in una stringa con la rappresentazione di stringa di due oggetti specificati.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato vengono sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di due espressioni per le rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Esempio: Formattazione di due argomenti  
 
 Questo esempio Usa la <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> metodo per visualizzare i dati di temperatura e ora archiviati in un oggetto generico <xref:System.Collections.Generic.Dictionary%602> oggetto. Si noti che la stringa di formato include tre elementi di formato, anche se sono presenti solo due oggetti da formattare. Poiché il primo oggetto nell'elenco (un valore data e ora) viene utilizzato da due elementi di formato: verrà visualizzato il primo formato elemento l'ora e il secondo Visualizza la data.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero o uno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato presenti in una stringa con la rappresentazione di stringa di due oggetti specificati. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato vengono sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire le rappresentazioni di stringa di due espressioni e incorporare tali rappresentazioni in una stringa. Nell'esecuzione della conversione, il metodo Usa formattazione dipendente dalle impostazioni cultura o un formattatore personalizzato. Il metodo converte ognuno <xref:System.Object> argomento alla relativa rappresentazione di stringa chiamando relativo **ToString (IFormatProvider)** metodo oppure, se l'oggetto del corrispondente elemento di formato include una stringa di formato chiamando relativo **ToString(String,IFormatProvider)** (metodo). Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** (metodo).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero o uno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <param name="arg2">Terzo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato in una stringa con le rappresentazioni di stringa di tre oggetti specificati.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di tre espressioni per le rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Esempio: Formattazione di tre argomenti  
 
 Questo esempio Usa la <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodo per creare una stringa in cui viene illustrato il risultato di un valore booleano `And` operazione con due valori integer. Si noti che la stringa di formato include sei elementi di formato, ma il metodo ha solo tre elementi nell'elenco dei parametri, poiché ogni elemento viene formattato in due modi diversi.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore di due.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <param name="arg2">Terzo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato in una stringa con le rappresentazioni di stringa di tre oggetti specificati. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) per convertire le rappresentazioni di stringa di tre espressioni e incorporare tali rappresentazioni in una stringa. Nell'esecuzione della conversione, il metodo Usa formattazione dipendente dalle impostazioni cultura o un formattatore personalizzato. Il metodo converte ognuno <xref:System.Object> argomento alla relativa rappresentazione di stringa chiamando relativo **ToString (IFormatProvider)** metodo oppure, se l'oggetto del corrispondente elemento di formato include una stringa di formato chiamando relativo **ToString(String,IFormatProvider)** (metodo). Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** (metodo).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore di due.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un oggetto che può eseguire l'iterazione fra i singoli caratteri di questa stringa.</summary>
        <returns>Oggetto enumeratore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Invece di chiamare il <xref:System.String.GetEnumerator%2A> metodo per recuperare un <xref:System.CharEnumerator> dell'oggetto che è quindi possibile usare per enumerare una stringa, è necessario usare il costrutto di iterazione del linguaggio (in c#, in C + + c++ /CLI CLR e in Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in c# [per ogni](/cpp/dotnet/for-each-in) in C + + / CLR, e [per ogni](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).
  
 Questo metodo consente di eseguire l'iterazione di singoli caratteri in una stringa. Ad esempio, Visual Basic `For Each` e c# `foreach` istruzioni richiamano questo metodo per restituire un <xref:System.CharEnumerator> oggetto che può fornire l'accesso di sola lettura per i caratteri in questa istanza di stringa.  
  
   
  
## Examples  
 Nell'esempio seguente esegue l'iterazione di caratteri nelle stringhe diverse e visualizza le informazioni sui relativi caratteri singoli. Usa il costrutto di linguaggio dell'iterazione anziché a una chiamata al <xref:System.String.GetEnumerator%2A> (metodo).  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash di questa stringa.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento di <xref:System.String.GetHashCode%2A> dipende dalla relativa implementazione, che potrebbe variare da una versione di common language runtime a un altro. È un motivo per cui questo può verificarsi per migliorare le prestazioni di <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Se due oggetti stringa sono uguali, la <xref:System.String.GetHashCode%2A> metodo restituisce valori identici. Tuttavia, non c'è un valore di codice hash univoco per ogni valore di stringa univoco. Stringhe diverse possono restituire lo stesso codice hash.  
>   
>  Il codice hash non è garantito a essere stabile. I codici hash per stringhe identiche possono differire in tutte le versioni di .NET Framework e su più piattaforme (ad esempio 32 bit e 64 bit) per una singola versione di .NET Framework. In alcuni casi, possono anche differire dal dominio applicazione. Ciò implica due esecuzioni successive dello stesso programma possono restituire codici hash differenti.  
>   
>  Di conseguenza, i codici non devono mai essere usati all'esterno del dominio applicazione in cui sono stati creati, hash non deve mai essere usati come campi di chiave in una raccolta e non deve essere persistente.  
>   
>  Infine, non usare il codice hash anziché un valore restituito da una funzione hash di crittografia se è necessario un hash crittografico. Per gli hash di crittografia, usare una classe derivata dal <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
>   
>  Per altre informazioni sui codici hash, vedere <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Nelle App desktop, è possibile usare la [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) per generare codice hash univoco su una base al dominio dell'applicazione. Ciò può ridurre il numero di conflitti e migliorare le prestazioni complessive di inserimenti e le ricerche che usano tabelle hash. Nell'esempio seguente viene illustrato come utilizzare il [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definisce un per generare codice hash univoco su una base di dominio dell'applicazione. Ciò può ridurre il numero di conflitti e migliorare le prestazioni complessive di inserimenti e le ricerche che usano tabelle hash. Nell'esempio seguente viene illustrato come utilizzare il. Definisce un `DisplayString` classe che include una costante di stringa privata, `s`, il cui valore è "This is a una stringa". Viene inoltre incluso un metodo `ShowStringHashCode` tramite cui vengono visualizzati il valore stringa e il codice hash con il nome del dominio applicazione in cui il metodo è in esecuzione.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Quando si esegue l'esempio senza fornire un file di configurazione, restituisce un output analogo al seguente. Si noti che i codici hash per la stringa sono identici nei due domini applicazione.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Tuttavia, se si aggiunge il file di configurazione seguente alla directory di esempio e, successivamente, si esegue l'esempio, i codici hash per la stessa stringa risulteranno diversi dal dominio dell'applicazione.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Quando il file di configurazione è presente, l'esempio visualizza il seguente output:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  I codici hash vengono usati per inserire e recuperare gli oggetti con chiavi da tabelle hash in modo efficiente. Tuttavia, i codici hash non identificano in modo univoco le stringhe. Stringhe identiche con codici hash uguali, ma common language runtime può anche assegnare lo stesso codice hash per stringhe diverse. Inoltre, i codici hash possono variare dalla versione di .NET Framework, dalla piattaforma all'interno di una sola versione e dal dominio applicazione. Per questo motivo, è consigliabile non serializzare o mantenere i valori di codice hash, né utilizzarle come chiavi in una tabella hash o un dizionario.  
  
 Per altre informazioni sull'uso dei codici hash e il `GetHashCode` metodo, vedere <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.GetHashCode%2A> metodo tramite varie funzionalità di stringhe di input.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il valore restituito da <see cref="M:System.String.GetHashCode" /> dipende dalla piattaforma. La differenza nelle versioni a 32 e 64 bit di .NET Framework. Anche possibile differiscono tra le versioni di .NET Framework.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.TypeCode" /> per la classe <see cref="T:System.String" />.</summary>
        <returns>Costante enumerata <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente mostra le <xref:System.TypeCode> costante enumerata per la <xref:System.String> tipo.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice in base zero della prima occorrenza di un carattere Unicode specificato o di una stringa all'interno di questa istanza. Il metodo restituisce -1 se la stringa o il carattere non viene trovato nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza del carattere Unicode specificato in questa stringa.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se viene trovato il carattere; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come è possibile cercare un <xref:System.String> di un carattere utilizzando il <xref:System.String.IndexOf%2A> (metodo).  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se viene trovata la stringa; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. La ricerca inizia nella posizione del primo carattere di questa istanza e continua fino a quando l'ultima posizione di carattere.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` costituito solo da uno o più caratteri ignorabili, il <xref:System.String.IndexOf%28System.String%29> metodo restituisce sempre 0 (zero) per indicare che non viene trovata la corrispondenza all'inizio dell'istanza corrente. Nell'esempio seguente, il <xref:System.String.IndexOf%28System.String%29> metodo viene usato per trovare tre sottostringhe (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se nell'esempio viene eseguito nel [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, in ogni caso, poiché il segno meno facoltativo è un carattere ignorabile, il risultato è lo stesso come se il segno meno facoltativo non era stato incluso in `value`. Quando si cercano un segno meno facoltativo solo, il metodo restituisce 0 (zero) per indicare che ha trovato una corrispondenza all'inizio della stringa.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Nell'esempio seguente esegue la ricerca per "n" in "animali". Poiché gli indici di stringa iniziano da zero anziché a uno, il <xref:System.String.IndexOf%28System.String%29> metodo indica che "n" è nella posizione 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 L'esempio seguente usa il <xref:System.String.IndexOf%2A> metodo per determinare la posizione iniziale di un nome di polizia di una frase. Questa posizione viene quindi utilizzata per inserire un aggettivo descritti animale nella frase.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per trovare il primo indice di una sottostringa all'interno di un'istanza di stringa usando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza del carattere Unicode specificato in questa stringa. La ricerca ha inizio alla posizione del carattere specificata.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio della stringa se viene trovato il carattere oppure -1 in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0. Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa. Se `startIndex` è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.  
  
 La ricerca sarà compreso `startIndex` alla fine della stringa.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.IndexOf%2A> (metodo).  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di 0 (zero) o maggiore della lunghezza della stringa.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza. La ricerca ha inizio alla posizione del carattere specificata.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0. Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa. Se `startIndex` è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. La ricerca inizia in corrispondenza di `startIndex` carattere posizione di questa istanza e continua fino a quando l'ultima posizione di carattere.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` costituito solo da uno o più caratteri ignorabili, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se nell'esempio viene eseguito nel [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Nell'esempio seguente esegue la ricerca di tutte le occorrenze di una stringa specificata all'interno di una stringa di destinazione.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di 0 (zero) o maggiore della lunghezza di questa stringa.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per trovare il primo indice di una sottostringa che si verifica dopo una posizione di carattere specifico usando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <see cref="T:System.String" /> corrente. Un parametro specifica il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione dell'indice del parametro <paramref name="value" /> se tale stringa viene trovata; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Il `comparisonType` parametro specifica per cercare il `value` parametro usando le impostazioni cultura correnti o invariante, tramite una ricerca tra maiuscole e minuscole o maiuscole e minuscole e usando le regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.IndexOf%2A> metodo di cui trovare la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metodo restituisce sempre 0 (zero) per indicare che non viene trovata la corrispondenza all'inizio dell'istanza corrente.  Nell'esempio seguente, il <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metodo viene usato per trovare tre sottostringhe (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, poiché il segno meno facoltativo è un carattere ignorabile, una ricerca dipendente dalle impostazioni cultura restituisce lo stesso valore che verrebbe restituito se il segno meno facoltativo non incluse nella stringa di ricerca. Una ricerca ordinale, tuttavia, correttamente consente di trovare il segno meno facoltativo in una stringa e segnala che è assente dalla seconda stringa.  [! codice csharp [System.String.IndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable26.cs#26)] [! codice vb [System.String.IndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza del carattere specificato in questa istanza. La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio della stringa se viene trovato il carattere oppure -1 in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca inizia dalla `startIndex` e continua `startIndex`  +  `count` -1. Il carattere `startIndex`  +  `count` non è incluso nella ricerca.  
  
 Numerazione dell'indice inizia da 0 (zero). Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.IndexOf%2A> (metodo).  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure  <paramref name="startIndex" /> è maggiore della lunghezza di questa stringa.  oppure  <paramref name="count" /> è maggiore della lunghezza di questa stringa meno <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza. La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0 (zero). Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. La ricerca inizia dalla `startIndex` e continua `startIndex`  +  `count` -1. Il carattere `startIndex`  +  `count` non è incluso nella ricerca.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` costituito solo da uno o più caratteri ignorabili, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dal terzo sesto posizioni dei caratteri in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se nell'esempio viene eseguito nel [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando esegue un confronto con distinzione delle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze della stringa "he" all'interno di una sottostringa della stringa di un altro. Si noti che il numero di caratteri da cercare deve essere ricalcolato per ogni iterazione di ricerca.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure  <paramref name="startIndex" /> è maggiore della lunghezza di questa stringa.  oppure  <paramref name="count" /> è maggiore della lunghezza di questa stringa meno <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per usare le regole di confronto della lingua corrente per eseguire questa operazione, chiamare il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <see cref="T:System.String" /> corrente. I parametri specificano la posizione iniziale della ricerca nella stringa corrente e il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione dell'indice in base zero del parametro <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0. Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa. Se `startIndex` è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.  
  
 Il `comparisonType` parametro specifica per cercare il `value` parametro usando le impostazioni cultura correnti o invariante, tramite una ricerca tra maiuscole e minuscole o maiuscole e minuscole e usando le regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.IndexOf%2A> metodo di cui trovare la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di 0 (zero) o maggiore della lunghezza di questa stringa.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" inizia con la terza posizione del carattere in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando esegue un confronto con distinzione delle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m". Il metodo restituisce l'indice del segno della prima stringa solo quando esegue un confronto ordinale.  [! codice csharp [System.String.IndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable25.cs#25)] [! codice vb [System.String.IndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <see cref="T:System.String" /> corrente. I parametri specificano la posizione di ricerca iniziale nella stringa corrente, il numero di caratteri nella stringa corrente in cui eseguire la ricerca e il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione dell'indice in base zero del parametro <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0 (zero). Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.  
  
 La ricerca inizia dalla `startIndex` e continua `startIndex`  +  `count` -1. Il carattere `startIndex`  +  `count` non è incluso nella ricerca.  
  
 Il `comparisonType` parametro specifica per cercare il `value` parametro usando le impostazioni cultura correnti o invariante, tramite una ricerca tra maiuscole e minuscole o maiuscole e minuscole e usando le regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.IndexOf%2A> metodo di cui trovare la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure <paramref name="startIndex" /> è maggiore della lunghezza di questa istanza.  oppure  <paramref name="count" /> è maggiore della lunghezza di questa stringa meno <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dal terzo sesto posizioni dei caratteri in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando esegue un confronto con distinzione delle impostazioni cultura. Quando esegue un confronto ordinale, tuttavia, trova la sottostringa solo nella prima stringa. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno ma restituisce l'indice di "m" quando esegue un confronto con distinzione delle impostazioni cultura. Il metodo restituisce l'indice del segno della prima stringa solo quando esegue un confronto ordinale.  [! codice csharp [System.String.IndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable24.cs#24)] [! codice vb [System.String.IndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata. Il metodo restituisce -1 se i caratteri nella matrice non vengono trovati nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata.</summary>
        <returns>Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 La ricerca di `anyOf` tra maiuscole e minuscole. Se `anyOf` è una matrice vuota, trova il metodo una corrispondenza all'inizio della stringa (vale a dire, in corrispondenza dell'indice zero).  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova la vocale prima in una stringa.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata. La ricerca ha inizio alla posizione del carattere specificata.</summary>
        <returns>Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Il `startIndex` parametro può variare da 0 a una minore della lunghezza dell'istanza di stringa.  
  
 La ricerca sarà compreso `startIndex` alla fine della stringa.  
  
 La ricerca di `anyOf` tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se il valore scalare Unicode è uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice dell'occorrenza di qualsiasi carattere della stringa "è" all'interno di una sottostringa della stringa di un altro.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è negativo.  oppure  <paramref name="startIndex" /> è maggiore del numero di caratteri in questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata. La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</summary>
        <returns>Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca inizia dalla `startIndex` e continua `startIndex`  +  `count` -1. Il carattere `startIndex`  +  `count` non è incluso nella ricerca.  
  
 Numerazione dell'indice inizia da zero. Il `startIndex` parametro può variare da 0 a una minore della lunghezza dell'istanza di stringa.  
  
 La ricerca di `anyOf` tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se il valore scalare Unicode è uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice dell'occorrenza di qualsiasi carattere della stringa "aid" all'interno di una sottostringa della stringa di un altro.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure <paramref name="count" /> + <paramref name="startIndex" /> è maggiore del numero di caratteri in questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">La posizione dell'indice in base zero dell'inserimento.</param>
        <param name="value">Stringa da inserire.</param>
        <summary>Restituisce una nuova stringa in cui una stringa specificata viene inserita in una posizione di indice specificata in questa istanza.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma con <paramref name="value" /> inserito in corrispondenza della posizione <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `startIndex` è uguale alla lunghezza di questa istanza, `value` viene aggiunto alla fine di questa istanza.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui `value` viene inserito nell'istanza corrente.  
  
 Ad esempio, il valore restituito di `"abc".Insert(2, "XYZ")` è "abXYZc".  
  
   
  
## Examples  
 L'esempio seguente inserisce un carattere di spazio in quarta posizione del carattere (carattere in corrispondenza dell'indice 3) di una stringa.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 La seguente applicazione console richiede agli utenti di immettere uno o più aggettivi per descrivere due animali. Chiama quindi il <xref:System.String.Insert%2A> per inserire il testo immesso dall'utente in una stringa.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="startIndex" /> è negativo o maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da cercare nel pool di centralizzazione.</param>
        <summary>Recupera il riferimento del sistema all'oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Riferimento del sistema a <paramref name="str" />, se è centralizzato; in caso contrario, nuovo riferimento a una stringa con il valore di <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime gestisce l'archiviazione delle stringhe mediante una tabella denominata pool di centralizzazione, che contiene un solo riferimento a ogni stringa letterale univoca dichiarati o creati a livello di codice nel programma. Di conseguenza, un'istanza di una stringa letterale con un valore specifico è presente una sola volta nel sistema.  
  
 Ad esempio, se si assegna la stessa stringa letterale a diverse variabili, il runtime recupera il riferimento stesso per la stringa letterale dal pool di centralizzazione e lo assegna a ogni variabile.  
  
 Il <xref:System.String.Intern%2A> metodo Usa il pool di centralizzazione per cercare una stringa uguale al valore di `str`. Se tale stringa è presente, viene restituito il relativo riferimento nel pool di centralizzazione. Se la stringa non esiste, un riferimento a `str` viene aggiunto al pool di centralizzazione, tale riferimento viene restituito.  
  
 Nell'esempio seguente, l'edizione s1 stringa, che ha un valore di "MyTest", è già inserita perché è un valore letterale nel programma. Il <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe genera un nuovo oggetto stringa con lo stesso valore di s1. Un riferimento a tale stringa viene assegnato al livello s2. Il <xref:System.String.Intern%2A> metodo cerca una stringa che contiene lo stesso valore di s2. Poiché esiste una stringa di questo tipo, il metodo restituisce lo stesso riferimento che viene assegnato al livello s1. Tale riferimento viene quindi assegnato al livello s3. I riferimenti s1 e S2 confrontare diversi perché fanno riferimento a oggetti diversi. riferimenti a s1 ed s3 risultano uguali perché fanno riferimento alla stessa stringa.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Questo metodo per confrontare il <xref:System.String.IsInterned%2A> (metodo).  
  
## <a name="version-considerations"></a>Considerazioni sulla versione  
 Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], il <xref:System.String.Intern%2A> metodo verrà ripristinato il comportamento in .NET Framework 1.0 e 1.1 in relazione all'inserimento di una stringa vuota. Nell'esempio seguente, la variabile `str1` viene assegnato un riferimento a <xref:System.String.Empty>, mentre la variabile `str2` viene assegnato il riferimento al <xref:System.String.Empty> che viene restituita chiamando il <xref:System.String.Intern%2A> metodo dopo aver convertito un <xref:System.Text.StringBuilder>il cui valore è <xref:System.String.Empty> in una stringa. Quindi i riferimenti contenuti `str1` e `str2` vengono confrontate per verificarne l'uguaglianza.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 Nel [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], e [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` e `str2` sono uguali. Nel [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] e [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` e `str2` non sono uguali.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Se si sta tentando di ridurre la quantità totale di memoria allocata dall'applicazione, tenere presente che l'inserimento di una stringa ha due effetti collaterali indesiderati. In primo luogo, la memoria allocata per centralizzate <xref:System.String> oggetti non viene probabilmente essere rilasciata fino alla terminazione di common language runtime (CLR). Il motivo è che il riferimento del CLR per il centralizzato <xref:System.String> object può persistere anche dopo l'applicazione, o anche il dominio dell'applicazione, viene terminato. In secondo luogo, per intern una stringa, è necessario creare prima di tutto la stringa. La memoria usata dal <xref:System.String> oggetto ancora deve essere allocato, anche se la memoria potrebbe diventare sottoposto a garbage collection.  
  
 .NET Framework versione 2.0 introduce il <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> membro di enumerazione. Il <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membro contrassegna un assembly in modo da non richiedere stringhe letterali. È possibile applicare <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> a un assembly usando il <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attributo. Inoltre, quando si usa la [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) per compilare un assembly prima della fase di esecuzione, le stringhe non vengono inserite in tutti i moduli.  
  
   
  
## Examples  
 L'esempio seguente usa tre stringhe hanno lo stesso valore per determinare se una stringa appena creata e una stringa inserita sono uguali.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da cercare nel pool di centralizzazione.</param>
        <summary>Recupera un riferimento a un oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Riferimento a <paramref name="str" />, se è presente nel pool di centralizzazione di Common Language Runtime; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime gestisce automaticamente una tabella denominata al pool di centralizzazione, che contiene una singola istanza di ogni costante di stringa letterale univoca dichiarati in un programma, nonché qualsiasi istanza univoca di <xref:System.String> è possibile aggiungere a livello di programmazione chiamando il <xref:System.String.Intern%2A> (metodo).  
  
 Pool di centralizzazione di consente di conservare l'archivio di stringhe. Se si assegna una costante di stringa letterale a diverse variabili, ogni variabile è impostata per fare riferimento nel pool di centralizzazione anziché fare riferimento a diverse istanze della stessa costante <xref:System.String> che hanno valori identici.  
  
 Questo metodo cerca `str` nel pool di centralizzazione. Se `str` è già stato inserito, un riferimento a tale istanza viene restituita; in caso contrario, `null` viene restituito.  
  
 Questo metodo per confrontare il <xref:System.String.Intern%2A> (metodo).  
  
 Questo metodo non restituisce un valore booleano. Se si chiama il metodo perché si desidera che un valore booleano che indica se una determinata stringa è inserita, è possibile usare codice simile al seguente.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  A partire da .NET Framework versione 2.0, è possibile eseguire l'override del pool di centralizzazione di quando si usa la [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) per installare un assembly nella cache delle immagini native in un computer locale. Per altre informazioni, vedere le considerazioni sulle prestazioni nella sezione Osservazioni per il <xref:System.String.Intern%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato che le stringhe letterali vengono inserite automaticamente dal compilatore.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Specifica se la stringa è in un particolare formato di normalizzazione Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Specifica se la stringa è nel formato di normalizzazione Unicode C.</summary>
        <returns>
          <see langword="true" /> se la stringa è in formato di normalizzazione C; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalente costituito da set di unione e/o i caratteri Unicode composti. L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, ricerca e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato di normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. Normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta attualmente i formati di normalizzazione C, D, KC e KD.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa è normalizzata correttamente in varie forme di normalizzazione.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> restituzione del metodo <see langword="false" /> , non appena rileva il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguite da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo genererà un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formato di normalizzazione Unicode.</param>
        <summary>Specifica se la stringa è nel formato di normalizzazione Unicode indicato.</summary>
        <returns>
          <see langword="true" /> se la stringa è nel formato di normalizzazione specificato dal parametro <paramref name="normalizationForm" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalente costituito da set di unione e/o i caratteri Unicode composti. L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, ricerca e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato di normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. Normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta attualmente i formati di normalizzazione C, D, KC e KD.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.IsNormalized%2A> e <xref:System.String.Normalize%2A> metodi.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> restituzione del metodo <see langword="false" /> , non appena rileva il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguite da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo genererà un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da testare.</param>
        <summary>Indica se la stringa specificata è <see langword="null" /> o una stringa <see cref="F:System.String.Empty" />.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è <see langword="null" /> o una stringa vuota (""); in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> è un metodo pratico che consente di testare contemporaneamente se un <xref:System.String> viene `null` o il relativo valore è <xref:System.String.Empty>. È equivalente al codice seguente:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 È possibile usare la <xref:System.String.IsNullOrWhiteSpace%2A> metodo per verificare se è una stringa `null`, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>, o è costituito solo da spazi vuoti.  
  
## <a name="what-is-a-null-string"></a>Che cos'è una stringa null?  
 È una stringa `null` se non è stato assegnato un valore (in C++ e Visual Basic) o se in modo esplicito è stato assegnato un valore di `null`. Anche se il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità può gestire correttamente una stringa null, come illustrato nell'esempio seguente, si prova a chiamare uno se i relativi membri genera un <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Che cos'è una stringa vuota?  
 Una stringa è vuota se viene assegnato in modo esplicito una stringa vuota ("") o <xref:System.String.Empty?displayProperty=nameWithType>. Una stringa vuota è un <xref:System.String.Length%2A> pari a 0.  Nell'esempio seguente crea una stringa vuota e viene visualizzato il relativo valore e la relativa lunghezza.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 Nell'esempio seguente esamina tre stringhe e determina se ogni stringa ha un valore, è una stringa vuota o è `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da testare.</param>
        <summary>Indica se una stringa specificata è <see langword="null" />, vuota o è composta solo da spazi vuoti.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è <see langword="null" /> o <see cref="F:System.String.Empty" /> oppure se <paramref name="value" /> è composto solo da spazi vuoti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> è un metodo pratico che è simile al codice seguente, ad eccezione del fatto che offre prestazioni migliori:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Gli spazi vuoti sono definiti dallo standard Unicode. Il <xref:System.String.IsNullOrWhiteSpace%2A> metodo interpreta qualsiasi carattere che restituisce un valore di `true` quando viene passato per il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo come un carattere di spazio vuoto.  
  
   
  
## Examples  
 Nell'esempio seguente crea una matrice di stringhe e quindi passa ogni elemento della matrice in cui il <xref:System.String.IsNullOrWhiteSpace%2A> (metodo).  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena gli elementi di una matrice specificata o i membri di una raccolta, usando tra gli elementi o i membri il separatore specificato.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>values</c> ha più di un elemento.</param>
        <param name="values">Raccolta che contiene le stringhe da concatenare.</param>
        <summary>Concatena i membri di una raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> costruita di tipo <see cref="T:System.String" />, usando tra i membri il separatore specificato.</summary>
        <returns>Stringa costituita dai membri di <paramref name="values" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="values" /> non dispone di membri, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` viene `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece usato. Se qualsiasi membro del `values` è `null`, viene invece utilizzata una stringa vuota.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> è un metodo pratico che consente di concatenare ogni elemento in un `IEnumerable(Of String)` raccolta senza prima convertire gli elementi in una matrice di stringhe. È particolarmente utile con espressioni di query Language-Integrated Query (LINQ). L'esempio seguente passa un `List(Of String)` oggetto contenente le lettere maiuscole o minuscole dell'alfabeto a un'espressione lambda che consente di selezionare lettere che si trovano uguale o maggiore di una determinata lettera (ovvero, nell'esempio, "M"). Il `IEnumerable(Of String)` raccolta restituita dal <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene passato per il <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodo per visualizzare il risultato come stringa singola.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a un <xref:System.Collections.Generic.List%601> oggetto di tipo <xref:System.String>, che viene quindi passata al <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (metodo).  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>value</c> ha più di un elemento.</param>
        <param name="values">Matrice contenente gli elementi da concatenare.</param>
        <summary>Concatena gli elementi di una matrice di oggetti, usando tra gli elementi il separatore specificato.</summary>
        <returns>Stringa costituita dagli elementi di <paramref name="values" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="values" /> è una matrice vuota, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` viene `null` o se qualsiasi elemento del `values` diverso da è il primo elemento `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece usato. Vedere la sezione Note per i chiamanti se il primo elemento della `values` è `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> è un metodo pratico che consente di concatenare ogni elemento nella matrice di oggetti senza conversione in modo esplicito gli elementi in stringhe. La rappresentazione di stringa di ogni oggetto nella matrice viene derivata mediante la chiamata dell'oggetto `ToString` (metodo).  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato in una matrice di integer, che viene quindi passata al <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> (metodo).  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Se il primo elemento della <paramref name="values" /> viene <see langword="null" />, il <see cref="M:System.String.Join(System.String,System.Object[])" /> metodo concatenare gli elementi <paramref name="values" /> ma restituisce invece <see cref="F:System.String.Empty" />. Sono disponibili numerosi possibili soluzioni al problema. Il più semplice consiste nell'assegnare il valore <see cref="F:System.String.Empty" /> al primo elemento della matrice, come illustrato nell'esempio seguente viene illustrato.  [! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>value</c> ha più di un elemento.</param>
        <param name="value">Matrice contenente gli elementi da concatenare.</param>
        <summary>Concatena tutti gli elementi di una matrice di stringhe, usando tra gli elementi il separatore specificato.</summary>
        <returns>Stringa costituita dagli elementi di <paramref name="value" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="value" /> è una matrice vuota, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, se `separator` è "," e gli elementi della `value` sono "apple", "arancione", "grape" e "pear," `Join(separator, value)` restituisce "apple, orange, grape, pear".  
  
 Se `separator` viene `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece usato. Se qualsiasi elemento in `value` è `null`, viene invece utilizzata una stringa vuota.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Join%2A> (metodo).  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>value</c> ha più di un elemento.</param>
        <param name="value">Matrice contenente gli elementi da concatenare.</param>
        <param name="startIndex">Primo elemento di <c>value</c> da usare.</param>
        <param name="count">Numero di elementi di <c>value</c> da usare.</param>
        <summary>Concatena gli elementi specificati di una matrice di stringhe, usando tra gli elementi il separatore specificato.</summary>
        <returns>Stringa costituita dalle stringhe di <paramref name="value" /> delimitate dalla stringa <paramref name="separator" />.  oppure  <see cref="F:System.String.Empty" /> se <paramref name="count" /> è zero, se <paramref name="value" /> non ha elementi o se <paramref name="separator" /> e tutti gli elementi di <paramref name="value" /> sono <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, se `separator` è "," e gli elementi della `value` sono "apple", "arancione", "grape" e "pear," `Join(separator, value, 1, 2)` restituisce "arancione, grape".  
  
 Se `separator` viene `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece usato. Se qualsiasi elemento in `value` è `null`, viene invece utilizzata una stringa vuota.  
  
   
  
## Examples  
 Nell'esempio seguente consente di concatenare due elementi da una matrice di nomi di frutta.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="count" /> è minore di 0.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="count" /> è maggiore del numero di elementi in <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Il tipo dei membri del <c>valori</c>.</typeparam>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>values</c> ha più di un elemento.</param>
        <param name="values">Raccolta che contiene gli oggetti da concatenare.</param>
        <summary>Concatena i membri di una raccolta, usando tra i membri il separatore specificato.</summary>
        <returns>Stringa costituita dai membri di <paramref name="values" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="values" /> non dispone di membri, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` viene `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece usato. Se qualsiasi membro del `values` è `null`, viene invece utilizzata una stringa vuota.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> è un metodo pratico che consente di concatenare ogni membro di un <xref:System.Collections.Generic.IEnumerable%601> raccolta senza prima convertirli in stringhe. La rappresentazione di stringa di ogni oggetto nella <xref:System.Collections.Generic.IEnumerable%601> è derivata tramite la chiamata dell'oggetto raccolta `ToString` (metodo).  
  
 Questo metodo è determinato utile con espressioni di query Language-Integrated Query (LINQ). Ad esempio, il codice seguente definisce una semplice `Animal` classe che contiene il nome di un animale e l'ordine a cui appartiene. Definisce quindi una <xref:System.Collections.Generic.List%601> oggetto che contiene un numero di `Animal` oggetti. Il <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene chiamato il metodo di estensione per estrarre le `Animal` oggetti la cui proprietà `Order` proprietà è uguale a "Roditore". Il risultato viene passato per il <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (metodo).  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a un <xref:System.Collections.Generic.List%601> oggetto di tipo integer, che viene quindi passata al <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (metodo).  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato o di una stringa all'interno di questa istanza. Il metodo restituisce -1 se la stringa o il carattere non viene trovato nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato all'interno di questa istanza.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se viene trovato il carattere; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 Questo metodo avvia la ricerca dalla posizione dell'ultimo carattere dell'istanza e continua all'indietro verso l'inizio fino al completamento `value` viene trovato o viene esaminata la posizione del primo carattere. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 L'esempio seguente definisce un `ExtractFilename` metodo che usa il <xref:System.String.LastIndexOf%28System.Char%29> metodo per trovare l'ultimo carattere separatore di directory in una stringa ed estrarre il nome di file della stringa. Se il file esiste, il metodo restituisce il nome del file senza il relativo percorso.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza.</summary>
        <returns>Posizione iniziale nell'indice in base zero di <paramref name="value" /> se viene trovata la stringa; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia dalla posizione dell'ultimo carattere dell'istanza e continua all'indietro verso l'inizio fino al completamento `value` viene trovato o viene esaminata la posizione del primo carattere.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` costituito solo da uno o più caratteri ignorabili, il <xref:System.String.LastIndexOf%28System.String%29> metodo restituisce sempre <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, che rappresenta l'ultima posizione di indice nell'istanza corrente. Nell'esempio seguente, il <xref:System.String.LastIndexOf%28System.String%29> metodo viene usato per trovare tre sottostringhe (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se nell'esempio viene eseguito nel [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, in ogni caso, poiché il segno meno facoltativo è un carattere ignorabile, il risultato è lo stesso come se il segno meno facoltativo non era stato incluso in `value`. Quando si cercano un segno meno facoltativo solo, il metodo restituisce 5 e 6. Questi valori corrispondono all'indice dell'ultimo carattere nelle due stringhe.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 L'esempio seguente rimuove l'apertura e chiusura di tag HTML da una stringa se il tag di inizio e fine della stringa. Se una stringa termina con una chiusura carattere parentesi quadra (">"), l'esempio Usa il <xref:System.String.LastIndexOf%2A> metodo per individuare l'inizio del tag di fine.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per trovare l'ultimo indice di una sottostringa all'interno di un'istanza di stringa usando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per la relativa <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato all'interno di questa istanza. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se tale carattere viene trovato oppure –1 se non viene trovato o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> -1. questo metodo inizia la ricerca di `startIndex` posizione di questa istanza e procede all'indietro verso l'inizio dell'istanza corrente fino al completamento di caratteri `value` viene trovato o viene esaminata la posizione del primo carattere. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo cerca tutti i caratteri dall'ultimo carattere della stringa all'inizio. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di un carattere in una stringa a partire dalla fine della stringa all'inizio della stringa.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore o uguale alla lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</summary>
        <returns>Posizione dell'indice iniziale in base zero di <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` posizione di questa istanza e procede all'indietro verso l'inizio fino al carattere `value` viene trovato o viene esaminata la posizione del primo carattere. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo cerca tutti i caratteri dall'ultimo carattere della stringa all'inizio.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` costituito solo da uno o più caratteri ignorabili, il <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metodo viene usato per trovare una sottostringa che include un segno meno facoltativo (U + 00AD) e che precede o include la "m" finale in una stringa. Se nell'esempio viene eseguito nel [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, perché viene ignorato il segno meno facoltativo nella stringa di ricerca, la chiamata al metodo per trovare una sottostringa che include il segno meno facoltativo e una "m" restituisce la posizione di "m" nella stringa, mentre questo viene chiamato per trovare un substrin g costituito il segno meno facoltativo e "n" restituisce la posizione di "n". Quando la stringa di ricerca contiene solo il segno meno facoltativo, il metodo restituisce l'indice della "m", che rappresenta il valore di `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di una stringa nella stringa di destinazione, a partire dalla fine della stringa di destinazione all'inizio della stringa di destinazione.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore della lunghezza dell'istanza corrente.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di -1 o maggiore di zero.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per trovare l'indice di una sottostringa che precede una particolare posizione di carattere utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per la relativa <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno dell'oggetto <see cref="T:System.String" /> corrente. Un parametro specifica il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione iniziale dell'indice in base zero del parametro <paramref name="value" /> se tale stringa viene trovata; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 Il `comparisonType` parametro specifica per cercare il `value` parametro usando le impostazioni cultura correnti o invariante, tramite una ricerca tra maiuscole e minuscole o maiuscole e minuscole e usando le regole di confronto ordinale o word.  
  
 La ricerca inizia dalla posizione dell'ultimo carattere dell'istanza e continua all'indietro verso l'inizio fino al completamento `value` viene trovato o viene esaminata la posizione del primo carattere.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.LastIndexOf%2A> metodo di trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="options" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metodo restituisce sempre <see cref="P:System.String.Length" /> – 1, che rappresenta l'ultima posizione di indice nell'istanza corrente.  Nell'esempio seguente, il <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metodo viene usato per trovare tre sottostringhe (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, poiché il segno meno facoltativo è un carattere ignorabile, una ricerca dipendente dalle impostazioni cultura restituisce lo stesso valore che verrebbe restituito se il segno meno facoltativo non incluse nella stringa di ricerca. Una ricerca ordinale, tuttavia, correttamente consente di trovare il segno meno facoltativo in una stringa e segnala che è assente dalla seconda stringa.  [! codice csharp [System.String.LastIndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof26.cs#26)] [! codice vb [System.String.LastIndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza del carattere Unicode specificato in una sottostringa all'interno di questa istanza. La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se tale carattere viene trovato oppure –1 se non viene trovato o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 Questo metodo inizia la ricerca di `startIndex` posizione e procede a ritroso verso l'inizio di questa istanza fino al completamento di caratteri `value` viene trovato o `count` sono state esaminate le posizioni dei caratteri. Ad esempio, se `startIndex` viene <xref:System.String.Length%2A> - 1, il metodo esegue la ricerca all'indietro `count` dall'ultimo carattere nella stringa di caratteri. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se il valore scalare Unicode è uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di un carattere in una sottostringa a partire dalla fine della sottostringa all'inizio della sottostringa.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore o uguale alla lunghezza di questa istanza.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> - <paramref name="count" /> + 1 è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza. La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</summary>
        <returns>Posizione dell'indice iniziale in base zero di <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` posizione di questa istanza e procede all'indietro verso l'inizio fino al carattere `value` viene trovato o `count` sono state esaminate le posizioni dei caratteri. Ad esempio, se `startIndex` viene <xref:System.String.Length%2A> - 1, il metodo esegue la ricerca all'indietro `count` dall'ultimo carattere nella stringa di caratteri.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` costituito solo da uno o più caratteri ignorabili, il <xref:System.String.LastIndexOf%2A> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.LastIndexOf%2A> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) i due caratteri che precedono l'elemento finale "m" di due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se nell'esempio viene eseguito nel [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando esegue un confronto con distinzione delle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di una stringa nella sottostringa a partire dalla fine della sottostringa all'inizio della sottostringa.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è maggiore della lunghezza di questa istanza.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifica una posizione non inclusa in questa istanza.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="start" /> è minore di -1 o maggiore di zero.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="count" /> è maggiore di 1.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per eseguire questa operazione usando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per la relativa <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno dell'oggetto <see cref="T:System.String" /> corrente. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa. Un parametro specifica il tipo di confronto da effettuare durante la ricerca della stringa specificata.</summary>
        <returns>Posizione dell'indice iniziale in base zero del parametro <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` posizione e procede a ritroso fino al completamento di caratteri `value` viene trovato o viene esaminata la posizione del primo carattere. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo cerca tutti i caratteri dall'ultimo carattere della stringa all'inizio.  
  
 Il `comparisonType` parametro specifica per cercare il `value` parametro usando le impostazioni cultura correnti o invariante, tramite una ricerca tra maiuscole e minuscole o maiuscole e minuscole e usando le regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.LastIndexOf%2A> metodo di trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore della lunghezza dell'istanza corrente.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di -1 o maggiore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m", a partire da finale "m" in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando esegue un confronto con distinzione delle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m". Il metodo restituisce l'indice del segno della prima stringa solo quando esegue un confronto ordinale.  [! codice csharp [System.String.LastIndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof25.cs#25)] [! codice vb [System.String.LastIndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza. La ricerca inizia in una posizione del carattere specificata e continua all'indietro verso l'inizio della stringa per il numero di posizioni dei caratteri indicato. Un parametro specifica il tipo di confronto da effettuare durante la ricerca della stringa specificata.</summary>
        <returns>Posizione dell'indice iniziale in base zero del parametro <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` posizione e procede a ritroso fino al completamento di caratteri `value` viene trovato o `count` sono state esaminate le posizioni dei caratteri. Ad esempio, se `startIndex` viene <xref:System.String.Length%2A> - 1, il metodo esegue la ricerca all'indietro `count` dall'ultimo carattere nella stringa di caratteri.  
  
 Il `comparisonType` parametro specifica per cercare il `value` parametro usando le impostazioni cultura correnti o invariante, tramite una ricerca tra maiuscole e minuscole o maiuscole e minuscole e usando le regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.LastIndexOf%2A> metodo di trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è maggiore della lunghezza di questa istanza.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifica una posizione non inclusa in questa istanza.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="start" /> è minore di -1 o maggiore di zero.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="count" /> è maggiore di 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non vengono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo viene usato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguito da una "m" in tutti, ma la prima posizione del carattere prima finale "m" in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando esegue un confronto con distinzione delle impostazioni cultura. Quando esegue un confronto ordinale, tuttavia, trova la sottostringa solo nella prima stringa. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno ma restituisce l'indice di "m" quando esegue un confronto con distinzione delle impostazioni cultura. Il metodo restituisce l'indice del segno della prima stringa solo quando esegue un confronto ordinale.  [! codice csharp [System.String.LastIndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof24.cs#24)] [! codice vb [System.String.LastIndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode. Il metodo restituisce -1 se i caratteri nella matrice non vengono trovati nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode.</summary>
        <returns>Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo avvia la ricerca dalla posizione dell'ultimo carattere dell'istanza e continua all'indietro verso l'inizio fino a un carattere nel `anyOf` viene trovato o viene esaminata la posizione del primo carattere. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice dell'ultima occorrenza di qualsiasi carattere nella stringa "è" all'interno di un'altra stringa.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</summary>
        <returns>Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" /> oppure se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo inizia la ricerca di `startIndex` posizione di questa istanza e procede all'indietro verso l'inizio fino a un carattere nel carattere `anyOf` viene trovato o viene esaminata la posizione del primo carattere. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice dell'ultima occorrenza di qualsiasi carattere nella stringa "è" all'interno di una sottostringa della stringa di un altro.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> specifica una posizione non inclusa in questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode. La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</summary>
        <returns>Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" /> oppure se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo inizia la ricerca di `startIndex` posizione di questa istanza e procede all'indietro verso l'inizio fino a un carattere nel carattere `anyOf` viene trovato o `count` sono state esaminate le posizioni dei caratteri. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (cultura), in cui un carattere viene considerato equivalente a un altro solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca dipendente dalle impostazioni cultura, usare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metodo, in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio la legatura "" (U + 00 C 6), potrebbe essere considerato equivalente a tutte le occorrenze di componenti del carattere di correggere sequenza, ad esempio quello "AE" (u+0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice dell'ultima occorrenza di qualsiasi carattere della stringa "Aid" all'interno di una sottostringa della stringa di un altro.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e il risultato dell'operazione <paramref name="startIndex" /> meno <paramref name="count" /> + 1 è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di caratteri nell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <value>Numero di caratteri nella stringa corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Length%2A> proprietà restituisce il numero di <xref:System.Char> oggetti in questo caso, non il numero di caratteri Unicode. Il motivo è che un carattere Unicode può essere rappresentato da più di un <xref:System.Char>. Usare la <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe per lavorare con ogni carattere Unicode anziché ogni <xref:System.Char>.  
  
 In alcuni linguaggi, ad esempio C e C++, un carattere null indica la fine di una stringa. In .NET Framework, un carattere null può essere incorporato in una stringa. Quando una stringa include uno o più caratteri null, vengono inclusi nella lunghezza della stringa di totale. Ad esempio, nella stringa seguente, la lunghezza delle sottostringhe "abc" e "def" sono separati da un carattere null. Il <xref:System.String.Length%2A> proprietà restituisce 7, che indica che includa i sei caratteri alfabetici, nonché il carattere null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Length%2A> proprietà.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa la cui rappresentazione binaria è in un formato di normalizzazione Unicode specifico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode C.</summary>
        <returns>Nuova stringa normalizzata il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalente costituito da set di unione e/o i caratteri Unicode composti. Uno dei punti di codice seguente, ad esempio, può rappresentare la lettera "ắ":  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, ricerca e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato di normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. Normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta i quattro normalizzazione (C, D, KC e KD) che sono definiti dallo standard Unicode. Quando le due stringhe vengono rappresentate nello stesso formato di normalizzazione, theycan essere confrontati mediante un confronto ordinale.  
  
 Per normalizzare e confrontare due stringhe, eseguire le operazioni seguenti:  
  
1.  Ottenere le stringhe da confrontare da un'origine di input, ad esempio un file o un dispositivo di input utente.  
  
2.  Chiamare il <xref:System.String.Normalize> metodo per normalizzare le stringhe di formato di normalizzazione C.  
  
3.  Per confrontare due stringhe, chiamare un metodo che supporta il confronto ordinale tra stringhe, ad esempio il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo e fornire il valore di <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oppure <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> come il <xref:System.StringComparison> argomento. Per ordinare una matrice di stringhe normalizzate, passare un `comparer` valore del <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oppure <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> a un overload appropriato del <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Generare le stringhe nell'output ordinato in base all'ordine indicato nel passaggio precedente.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente normalizza una stringa a ognuno dei quattro formati di normalizzazione, conferma che la stringa è stata normalizzata in base al formato di normalizzazione specificato, quindi vengono elencati i punti di codice nella stringa normalizzata.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> restituzione del metodo <see langword="false" /> , non appena rileva il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguite da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo genererà un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formato di normalizzazione Unicode.</param>
        <summary>Restituisce una nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode specificato.</summary>
        <returns>Nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione specificato nel parametro <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalente costituito da set di unione e/o i caratteri Unicode composti. L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, ricerca e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato di normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. Normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta i quattro normalizzazione (C, D, KC e KD) che sono definiti dallo standard Unicode. Quando le due stringhe vengono rappresentate nello stesso formato di normalizzazione, possono essere confrontate utilizzando un confronto ordinale.  
  
 Per normalizzare e confrontare due stringhe, eseguire le operazioni seguenti:  
  
1.  Ottenere le stringhe da confrontare da un'origine di input, ad esempio un file o un dispositivo di input utente.  
  
2.  Chiamare il <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metodo per normalizzare le stringhe da un formato di normalizzazione specificato.  
  
3.  Per confrontare due stringhe, chiamare un metodo che supporta il confronto ordinale tra stringhe, ad esempio il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo e fornire il valore di <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oppure <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> come il <xref:System.StringComparison> argomento. Per ordinare una matrice di stringhe normalizzate, passare un `comparer` valore del <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oppure <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> a un overload appropriato del <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Generare le stringhe nell'output ordinato in base all'ordine indicato nel passaggio precedente.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente normalizza una stringa a ognuno dei quattro formati di normalizzazione, conferma che la stringa è stata normalizzata in base al formato di normalizzazione specificato, quindi vengono elencati i punti di codice nella stringa normalizzata.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> restituzione del metodo <see langword="false" /> , non appena rileva il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguite da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo potrebbe generare un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <summary>Determina se due stringhe specificate hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il valore di <paramref name="a" /> è uguale al valore di <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.op_Equality%2A> metodo definisce il funzionamento dell'operatore di uguaglianza per il <xref:System.String> classe. Consente codice come quello illustrato nella sezione esempio. L'operatore, a sua volta, chiama il metodo statico <xref:System.String.Equals%28System.String%2CSystem.String%29> metodo, che esegue un confronto ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura).  
  
> [!NOTE]
>  Il compilatore Visual Basic non consente di risolvere l'operatore di uguaglianza come una chiamata al <xref:System.String.op_Equality%2A> (metodo). Al contrario, l'operatore di uguaglianza esegue il wrapping di una chiamata al <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'operatore di uguaglianza.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <summary>Determina se due stringhe specificate hanno valori diversi.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="a" /> è diverso dal valore del parametro <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per la <xref:System.String> classe.   Consente codice come quello illustrato nella sezione esempi.  
  
 Il <xref:System.String.op_Inequality%2A> operatore a sua volta chiama il metodo statico <xref:System.String.Equals%28System.String%2CSystem.String%29> metodo, che esegue un confronto ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura).  
  
> [!NOTE]
>  Il compilatore Visual Basic non consente di risolvere l'operatore di disuguaglianza come una chiamata al <xref:System.String.op_Inequality%2A> (metodo). Al contrario, l'operatore di disuguaglianza esegue il wrapping di una chiamata al <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'operatore di disuguaglianza.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa di lunghezza specificata in cui la parte iniziale della stringa corrente viene riempita con spazi o con un carattere Unicode specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <summary>Restituisce una nuova stringa che allinea a destra i caratteri in questa istanza mediante l'aggiunta a sinistra di un numero di spazi tale da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a destra mediante l'aggiunta a sinistra di un numero di spazi tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno spazio di Unicode è definito come 0x0020 esadecimale.  
  
 Il <xref:System.String.PadLeft%28System.Int32%29> metodo riempie l'inizio della stringa restituita. Ciò significa che, quando usato con lingue da destra a sinistra, aggiunge la parte destra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadLeft%2A> metodo riempie l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con spazi vuoti iniziali in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadLeft%2A> (metodo).  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <param name="paddingChar">Carattere di riempimento Unicode.</param>
        <summary>Restituisce una nuova stringa che allinea a destra i caratteri in questa istanza mediante l'aggiunta a sinistra di una sequenza di elementi pari al carattere Unicode specificato, in modo da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a destra mediante l'aggiunta a sinistra di un numero di caratteri <paramref name="paddingChar" /> tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> metodo riempie l'inizio della stringa restituita. Ciò significa che, quando usato con lingue da destra a sinistra, aggiunge la parte destra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadLeft%2A> metodo riempie l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con leader `paddingChar` caratteri in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadLeft%2A> (metodo).  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa di lunghezza specificata in cui la parte finale della stringa corrente è riempita con spazi o con una sequenza di elementi pari a un carattere Unicode specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <summary>Restituisce una nuova stringa che allinea a sinistra i caratteri in questa stringa mediante l'aggiunta a destra di un numero di spazi tale da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a sinistra mediante l'aggiunta a destra di un numero di spazi tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno spazio di Unicode è definito come 0x0020 esadecimale.  
  
 Il <xref:System.String.PadRight%28System.Int32%29> metodo riempie la fine della stringa restituita. Ciò significa che, quando usato con lingue da destra a sinistra, aggiunge la parte sinistra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadRight%2A> metodo riempie l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con spazi vuoti finali in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadRight%2A> (metodo).  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <param name="paddingChar">Carattere di riempimento Unicode.</param>
        <summary>Restituisce una nuova stringa che allinea a sinistra i caratteri in questa stringa mediante l'aggiunta a destra di un carattere Unicode specificato, in modo da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a sinistra mediante l'aggiunta a destra di un numero di caratteri <paramref name="paddingChar" /> tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> metodo riempie la fine della stringa restituita. Ciò significa che, quando usato con lingue da destra a sinistra, aggiunge la parte sinistra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadRight%2A> metodo riempie l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con finali `paddingChar` caratteri in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadRight%2A> (metodo).  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa in cui dalla stringa corrente viene eliminato un numero specificato di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione in base zero da cui iniziare l'eliminazione dei caratteri.</param>
        <summary>Restituisce una nuova stringa in cui sono stati eliminati tutti i caratteri dell'istanza corrente a partire da una posizione specificata fino all'ultima posizione.</summary>
        <returns>Nuova stringa equivalente a questa stringa tranne che per i caratteri eliminati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], le stringhe sono in base zero. Il valore della `startIndex` parametro può essere compreso tra zero e uno minore della lunghezza dell'istanza di stringa.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri dalla posizione `startIndex` alla fine della stringa originale sono state rimosse.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Remove%2A> (metodo). Il caso successivo all'ultima rimuove tutto il testo a partire dall'indice specificato fino alla fine della stringa. Nell'ultimo caso rimuove tre caratteri a partire dall'indice specificato.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di zero.  oppure  <paramref name="startIndex" /> specifica una posizione esterna a questa stringa.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione in base zero da cui iniziare l'eliminazione dei caratteri.</param>
        <param name="count">Numero di caratteri da eliminare.</param>
        <summary>Restituisce una nuova stringa in cui è stato eliminato un numero specificato di caratteri nell'istanza corrente a partire da una posizione specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza tranne che per i caratteri eliminati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], le stringhe sono in base zero. Il valore della `startIndex` parametro può essere compreso tra zero e uno minore della lunghezza dell'istanza di stringa.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui il numero di caratteri specificato da di `count` parametro sono stati rimossi. La rimozione di caratteri in corrispondenza della posizione specificata da `startIndex`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come è possibile rimuovere il secondo nome da un nome completo.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="count" /> è minore di zero.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="count" /> specifica una posizione esterna a questa istanza.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa in cui tutte le occorrenze di un carattere Unicode o di un oggetto <see cref="T:System.String" /> specificati presenti nella stringa corrente vengono sostituite con un altro carattere Unicode o oggetto <see cref="T:System.String" /> specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carattere Unicode da sostituire.</param>
        <param name="newChar">Carattere Unicode con cui sostituire tutte le occorrenze di <c>oldChar</c>.</param>
        <summary>Restituisce una nuova stringa in cui tutte le occorrenze di un carattere Unicode specificato presenti in questa istanza vengono sostituite con un altro carattere Unicode specificato.</summary>
        <returns>Stringa equivalente a questa istanza, salvo per il fatto che tutte le istanze di <paramref name="oldChar" /> vengono sostituite con <paramref name="newChar" />. Se <paramref name="oldChar" /> non viene trovato nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura) per trovare `oldChar`.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutte le occorrenze di `oldChar` vengono sostituiti da `newChar`.  
  
 Poiché questo metodo restituisce la stringa modificata, è possibile concatenare le chiamate successive al <xref:System.String.Replace%2A> metodo per eseguire sostituzioni di più sulla stringa originale. Chiamate al metodo vengono eseguite da sinistra a destra. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 L'esempio seguente crea un elenco di valori delimitati da virgole, sostituendo le virgole per gli spazi vuoti tra una serie di numeri.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Stringa da sostituire.</param>
        <param name="newValue">Stringa con cui sostituire tutte le occorrenze di <c>oldValue</c>.</param>
        <summary>Restituisce una nuova stringa in cui tutte le occorrenze di una stringa specificata nell'istanza corrente vengono sostituite con un'altra stringa specificata.</summary>
        <returns>Stringa equivalente alla stringa corrente, salvo per il fatto che tutte le istanze di <paramref name="oldValue" /> vengono sostituite con <paramref name="newValue" />. Se <paramref name="oldValue" /> non viene trovato nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `newValue` viene `null`, tutte le occorrenze di `oldValue` vengono rimossi.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutte le occorrenze di `oldValue` vengono sostituiti da `newValue`.  
  
 Questo metodo esegue una ricerca ordinale (maiuscole/minuscole e distinzione delle impostazioni cultura) per trovare `oldValue`.  
  
 Poiché questo metodo restituisce la stringa modificata, è possibile concatenare le chiamate successive al <xref:System.String.Replace%2A> metodo per eseguire sostituzioni di più sulla stringa originale. Chiamate al metodo vengono eseguite da sinistra a destra. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 L'esempio seguente illustra come usare il <xref:System.String.Replace%2A> metodo per correggere un errore di ortografia.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> è la stringa vuota ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una matrice di stringhe contenente le sottostringhe di questa istanza delimitate dagli elementi di una stringa o matrice di caratteri Unicode specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> viene usato per suddividere una stringa delimitata in sottostringhe. È possibile usare una matrice di caratteri per specificare zero, uno o più caratteri di delimitazione (il <xref:System.String.Split%28System.Char%5B%5D%29> metodo), oppure è possibile usare una matrice di caratteri per specificare zero, uno o più stringhe di delimitazione. Gli overload del <xref:System.String.Split%2A> metodo consentono di limitare il numero di sottostringhe restituito dal metodo (il <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> metodo), per determinare se le stringhe vuote vengono incluse nelle sottostringhe restituite (il <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metodi, o eseguire entrambe le operazioni (il <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> metodi).  
  
> [!IMPORTANT]
>  Per informazioni più dettagliate sul <xref:System.String.Split%2A> metodo, come anche per esempi di chiamare ogni rapporto di overload, vedere la documentazione per i singoli overload di <xref:System.String.Split%2A>.  
  
 Il <xref:System.String.Split%2A> (metodo) non è sempre il modo migliore per suddividere una stringa delimitata in sottostringhe. Se non si vuole estrarre tutte le sottostringhe di una stringa delimitata o se si desidera analizzare una stringa in base a un modello anziché un set di caratteri di delimitazione, prendere in considerazione le alternative seguenti.  
  
## <a name="regular-expressions"></a>Espressioni regolari  
 Se le stringhe conforme a un modello predefinito, è possibile usare un'espressione regolare per estrarre e gestire i relativi elementi. Ad esempio, se le stringhe hanno il formato "*numero* *operando* *numero*" è possibile usare un [espressione regolare](~/docs/standard/base-types/regular-expressions.md) per estrarre e gestire il elementi della stringa. Di seguito è riportato un esempio:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Criterio di espressione regolare `(\d+)\s+([-+*/])\s+(\d+)` è definito nel modo seguente:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al primo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più caratteri spazio vuoto.|  
|`([-+*/])`|Corrisponde un segno di operatori aritmetici (+, -, *, o /). Equivale al secondo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più caratteri spazio vuoto.|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al terzo gruppo di acquisizione.|  
  
 È anche possibile usare un'espressione regolare per estrarre le sottostringhe da una stringa basata su un modello anziché un set fisso di caratteri. Quando una di queste condizioni si verifica, questo è uno scenario comune:  
  
-   Uno o più caratteri delimitatori non sempre fungere da un delimitatore di <xref:System.String> istanza.  
  
-   La sequenza e il numero di caratteri di delimitazione è variabile o sconosciuto.  
  
 Ad esempio, il <xref:System.String.Split%2A> metodo non può essere usato per suddividere la stringa seguente, perché il numero di `\n` (in c#) o `vbCrLf` (in Visual Basic) di caratteri è variabile, e non sempre fungono da delimitatori.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Un'espressione regolare di questa stringa è possibile suddividere facilmente, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Criterio di espressione regolare `\[([^\[\]]+)\]` è definito nel modo seguente:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\[`|Corrisponde a una parentesi quadra aperta.|  
|`([^\[\]]+)`|Corrisponde a qualsiasi carattere che non è una parentesi o una parentesi di chiusura una o più volte. Equivale al primo gruppo di acquisizione.|  
|`\]`|Corrisponde a una parentesi di chiusura.|  
  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> è quasi identico al metodo <xref:System.String.Split%2A?displayProperty=nameWithType>, ad eccezione del fatto che suddivide una stringa in base a un criterio di espressione regolare invece di un set di caratteri predefinito. Ad esempio, l'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodo per suddividere una stringa che contiene le sottostringhe delimitate da varie combinazioni di trattini e altri caratteri.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Criterio di espressione regolare `\s-\s?[+*]?\s?-\s` è definito nel modo seguente:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\s-`|Corrisponde a un carattere di spazio vuoto seguito da un trattino.|  
|`\s?`|Trova la corrispondenza zero o un carattere di spazio vuoto.|  
|`[+*]?`|Corrisponde a zero o una occorrenza di uno il + o * carattere.|  
|`\s?`|Trova la corrispondenza zero o un carattere di spazio vuoto.|  
|`-\s`|Corrisponde a un trattino seguita da uno spazio vuoto.|  
  
## <a name="search-methods-and-the-substring-method"></a>I metodi di ricerca e il metodo Substring  
 Se non si è interessati a tutte le sottostringhe in una stringa, è preferibile usare uno dei metodi di confronto tra stringhe che restituisce l'indice in corrispondenza del quale inizia la corrispondenza. È quindi possibile chiamare il <xref:System.String.Substring%2A> metodo per estrarre la sottostringa da. I metodi di confronto di stringhe includono:  
  
-   <xref:System.String.IndexOf%2A>, che restituisce l'indice in base zero della prima occorrenza di un carattere o stringa in un'istanza di stringa.  
  
-   <xref:System.String.IndexOfAny%2A>, che restituisce l'indice in base zero nell'istanza della stringa corrente della prima occorrenza di qualsiasi carattere in una matrice di caratteri.  
  
-   <xref:System.String.LastIndexOf%2A>, che restituisce l'indice in base zero dell'ultima occorrenza di un carattere o stringa in un'istanza di stringa.  
  
-   <xref:System.String.LastIndexOfAny%2A>, che restituisce un indice in base zero nell'istanza della stringa corrente dell'ultima occorrenza di qualsiasi carattere in una matrice di caratteri.  
  
 L'esempio seguente usa il <xref:System.String.IndexOf%2A> metodo per individuare i periodi in una stringa. Usa quindi il <xref:System.String.Substring%2A> metodo a restituire frasi intere.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <summary>Suddivide una stringa in sottostringhe basate sui caratteri in una matrice.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe da questa istanza delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una stringa è delimitata da un set di caratteri noto, è possibile usare il <xref:System.String.Split%28System.Char%5B%5D%29> metodo per separarlo in sottostringhe. Per altri modi per estrarre le sottostringhe da una stringa, vedere la [alternative a String. Split](#Alternatives) sezione.  
  
## <a name="return-value-details"></a>Dettagli del valore restituito  
 Caratteri delimitatori non sono inclusi gli elementi della matrice restituita. Ad esempio, se la matrice separatore include il carattere "-" e il valore dell'istanza della stringa corrente è "aa-bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".  
  
 Se questa istanza non contiene i caratteri in `separator`, la matrice restituita è costituito da un singolo elemento che contiene questa istanza.  
  
 Ogni elemento della `separator` definisce un carattere di delimitazione separato. Se due i delimitatori sono adiacenti o all'inizio o alla fine di questa istanza viene trovato un delimitatore, l'elemento corrispondente nella matrice restituita contiene <xref:System.String.Empty>. Ecco alcuni esempi:  
  
|Valore stringa|Separatore|Matrice restituita|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nuovo Char [] {',', ' '} (c#)<br /><br /> Char () = {"," c, "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] {} (c#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>Matrice di separatore  
 Ogni elemento del separatore definisce un delimitatore separato che è costituito da un singolo carattere. Se il `separator` argomento è `null` o non contiene caratteri, il metodo considera gli spazi vuoti come delimitatori. Gli spazi vuoti sono definiti da Unicode standard; restituiscono `true` se vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo).  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>Risoluzione dell'overload String.Split(Char[]) e compilatore  
 Anche se il singolo parametro per questo overload del metodo <xref:System.String.Split%2A?displayProperty=nameWithType> è una matrice di caratteri, è possibile chiamare con un singolo carattere, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Poiché il `separator` parametro è decorato con il <xref:System.ParamArrayAttribute> attributo, i compilatori interpreterà un singolo carattere come una matrice di caratteri a elemento singolo. Ciò non avviene per altri <xref:System.String.Split%2A?displayProperty=nameWithType> overload che includono una `separator` parametro; è necessario passare in modo esplicito questi overload una matrice di caratteri come il `separator` argomento.  
  
## <a name="comparison-details"></a>Dettagli relativi al confronto  
 Il <xref:System.String.Split%28System.Char%5B%5D%29> metodo consente di estrarre le sottostringhe di questa stringa delimitate da uno o più dei caratteri di `separator` della matrice e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%28System.Char%5B%5D%29> metodo cerca i delimitatori mediante l'esecuzione di confronti con le regole di ordinamento per ordinale tra maiuscole e minuscole. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>Alternative a String. Split  
 Il <xref:System.String.Split%2A> (metodo) non è sempre il modo migliore per suddividere una stringa delimitata in sottostringhe. Se non si vuole estrarre tutte le sottostringhe di una stringa delimitata o se si desidera analizzare una stringa in base a un modello anziché un set di caratteri di delimitazione, prendere in considerazione le alternative seguenti.  
  
### <a name="regular-expressions"></a>Espressioni regolari  
 Se le stringhe conforme a un modello predefinito, è possibile usare un'espressione regolare per estrarre e gestire i relativi elementi. Ad esempio, se le stringhe hanno il formato "*numero* *operando* *numero*" è possibile usare un [espressione regolare](~/docs/standard/base-types/regular-expressions.md) per estrarre e gestire il elementi della stringa. Di seguito è riportato un esempio:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Criterio di espressione regolare `(\d+)\s+([-+*/])\s+(\d+)` è definito nel modo seguente:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al primo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più caratteri spazio vuoto.|  
|`([-+*/])`|Corrisponde un segno di operatori aritmetici (+, -, *, o /). Equivale al secondo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più caratteri spazio vuoto.|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al terzo gruppo di acquisizione.|  
  
 È anche possibile usare un'espressione regolare per estrarre le sottostringhe da una stringa basata su un modello anziché un set fisso di caratteri. Quando una di queste condizioni si verifica, questo è uno scenario comune:  
  
-   Uno o più caratteri delimitatori non sempre fungere da un delimitatore di <xref:System.String> istanza.  
  
-   La sequenza e il numero di caratteri di delimitazione è variabile o sconosciuto.  
  
 Ad esempio, il <xref:System.String.Split%2A> metodo non può essere usato per suddividere la stringa seguente, perché il numero di `\n` (in c#) o `vbCrLf` (in Visual Basic) di caratteri è variabile, e non sempre fungono da delimitatori.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Un'espressione regolare di questa stringa è possibile suddividere facilmente, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Criterio di espressione regolare `\[([^\[\]]+)\]` è definito nel modo seguente:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\[`|Corrisponde a una parentesi quadra aperta.|  
|`([^\[\]]+)`|Corrisponde a qualsiasi carattere che non è una parentesi o una parentesi di chiusura una o più volte. Equivale al primo gruppo di acquisizione.|  
|`\]`|Corrisponde a una parentesi di chiusura.|  
  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> è quasi identico al metodo <xref:System.String.Split%2A?displayProperty=nameWithType>, ad eccezione del fatto che suddivide una stringa in base a un criterio di espressione regolare invece di un set di caratteri predefinito. Ad esempio, l'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodo per suddividere una stringa che contiene le sottostringhe delimitate da varie combinazioni di trattini e altri caratteri.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Criterio di espressione regolare `\s-\s?[+*]?\s?-\s` è definito nel modo seguente:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\s-`|Corrisponde a un carattere di spazio vuoto seguito da un trattino.|  
|`\s?`|Trova la corrispondenza zero o un carattere di spazio vuoto.|  
|`[+*]?`|Corrisponde a zero o una occorrenza di uno il + o * carattere.|  
|`\s?`|Trova la corrispondenza zero o un carattere di spazio vuoto.|  
|`-\s`|Corrisponde a un trattino seguita da uno spazio vuoto.|  
  
### <a name="search-methods-and-the-substring-method"></a>I metodi di ricerca e il metodo Substring  
 Se non si è interessati a tutte le sottostringhe in una stringa, è preferibile usare uno dei metodi di confronto tra stringhe che restituisce l'indice in corrispondenza del quale inizia la corrispondenza. È quindi possibile chiamare il <xref:System.String.Substring%2A> metodo per estrarre la sottostringa da. I metodi di confronto di stringhe includono:  
  
-   <xref:System.String.IndexOf%2A>, che restituisce l'indice in base zero della prima occorrenza di un carattere o stringa in un'istanza di stringa.  
  
-   <xref:System.String.IndexOfAny%2A>, che restituisce l'indice in base zero nell'istanza della stringa corrente della prima occorrenza di qualsiasi carattere in una matrice di caratteri.  
  
-   <xref:System.String.LastIndexOf%2A>, che restituisce l'indice in base zero dell'ultima occorrenza di un carattere o stringa in un'istanza di stringa.  
  
-   <xref:System.String.LastIndexOfAny%2A>, che restituisce un indice in base zero nell'istanza della stringa corrente dell'ultima occorrenza di qualsiasi carattere in una matrice di caratteri.  
  
 L'esempio seguente usa il <xref:System.String.IndexOf%2A> metodo per individuare i periodi in una stringa. Usa quindi il <xref:System.String.Substring%2A> metodo a restituire frasi intere.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi di allocano della memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede prestazioni ottimali, o se la gestione dell'allocazione di memoria è fondamentale per l'applicazione, è consigliabile usare la <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> (metodo). Hai anche la possibilità di usare il <xref:System.String.Compare%2A> metodo per individuare una sottostringa all'interno di una stringa.  
  
 Per suddividere una stringa in corrispondenza di un carattere separatore, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere separatore nella stringa. Per suddividere una stringa in una stringa di separazione, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Usare quindi il <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali per i restanti caratteri della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene usato per suddividere le stringhe in più <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come estrarre singole parole da un blocco di testo, considerando gli spazi vuoti e segni di punteggiatura come delimitatori. La matrice di caratteri passata per la `separator` parametro del <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo è costituito da un carattere di spazio e un carattere di tabulazione, con alcuni simboli di punteggiatura comuni.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi usano un set identico di spazi vuoti Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="count">Numero massimo di sottostringhe da restituire.</param>
        <summary>Suddivide una stringa in un numero massimo di sottostringhe in base ai caratteri in una matrice. Numero massimo di sottostringhe da restituire.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa istanza delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri delimitatori non sono inclusi gli elementi della matrice restituita.  
  
 Se questa istanza non contiene i caratteri in `separator`, la matrice restituita è costituito da un singolo elemento che contiene questa istanza. Se `count` è uguale a zero, viene restituita una matrice vuota.  
  
 Se il `separator` parametro è `null` o non contiene caratteri, gli spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e ritorno `true` se vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo).  
  
 Ogni elemento della `separator` definisce un carattere di delimitazione separato. Se due i delimitatori sono adiacenti o all'inizio o alla fine di questa istanza viene trovato un delimitatore, l'elemento corrispondente della matrice contiene <xref:System.String.Empty>.  
  
 Se sono presenti più di `count` sottostringhe di questa istanza, il primo `count` -1 sottostringhe vengono restituiti nel primo `count` -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.  
  
 Se `count` è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibile e viene generata alcuna eccezione.  
  
 Nella tabella seguente vengono forniti esempi.  
  
|Valore stringa|Separatore|Conteggio|Matrice restituita|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nuovo Char [] {',', ' '} (c#)<br /><br /> Char () = {"," c, "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] {} (c#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] null (c#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] null (c#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi di allocano della memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede prestazioni ottimali, o se la gestione dell'allocazione di memoria è fondamentale per l'applicazione, è consigliabile usare il <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOfAny%2A> metodo e, facoltativamente, il <xref:System.String.Compare%2A> (metodo), per individuare una sottostringa all'interno di una stringa.  
  
 Se si suddivide una stringa in corrispondenza di un carattere separatore, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere separatore nella stringa. Se si suddivide una stringa in una stringa di separazione, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Usare quindi il <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali per i restanti caratteri della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene usato per suddividere le stringhe in più <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come `count` influisce sul numero delle stringe restituite dalle <xref:System.String.Split%2A>.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi usano un set identico di spazi vuoti Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in sottostringhe in base ai caratteri in una matrice. È possibile specificare se le sottostringhe includono elementi della matrice vuota.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Dettagli del valore restituito  
 Caratteri di delimitazione (i caratteri di `separator` matrice) non sono inclusi gli elementi della matrice restituita. Ad esempio, se il `separator` matrice include il carattere "-" e il valore dell'istanza della stringa corrente è "aa-bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".  
  
 Se questa istanza non contiene i caratteri in `separator`, la matrice restituita è costituito da un singolo elemento che contiene questa istanza.  
  
 Se il `options` parametro è <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, il metodo restituisce una matrice vuota.  
  
 Ogni elemento della `separator` definisce un delimitatore separato che è costituito da un singolo carattere. Se il `options` argomento è <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o viene trovato un delimitatore all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty?displayProperty=nameWithType>. Ad esempio, se `separator` include due elementi, "-" e "\_", il valore dell'istanza della stringa è "-\_aa -\_" e il valore della `options` argomento è <xref:System.StringSplitOptions.None>, il metodo restituisce una matrice di stringhe con i seguenti cinque elementi:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che precede la "-" carattere in corrispondenza dell'indice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota tra le "-" carattere in corrispondenza dell'indice 0 e il carattere "_" in corrispondenza dell'indice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che segue il carattere "_" in corrispondenza dell'indice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che segue il "-" carattere in corrispondenza dell'indice 5.  
  
## <a name="the-separator-array"></a>Matrice di separatore  
 Se il `separator` parametro è `null` o non contiene caratteri, gli spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e ritorno `true` se vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo).  
  
 Se il `separator` parametro nella chiamata a questo overload del metodo è `null`, si verifica un errore di risoluzione dell'overload del compilatore. Per identificare in modo non ambiguo il metodo chiamato, il codice deve indicare il tipo del `null`. Nell'esempio seguente vengono illustrati diversi modi per identificarlo in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>Dettagli relativi al confronto  
 Il <xref:System.String.Split%2A> metodo consente di estrarre le sottostringhe di questa stringa delimitate da uno o più dei caratteri di `separator` parametro e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%2A> metodo cerca i delimitatori mediante l'esecuzione di confronti con le regole di ordinamento per ordinale tra maiuscole e minuscole. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi di allocano della memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede prestazioni ottimali, o se la gestione dell'allocazione di memoria è fondamentale per l'applicazione, è consigliabile usare il <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOfAny%2A> metodo e, facoltativamente, il <xref:System.String.Compare%2A> (metodo), per individuare una sottostringa all'interno di una stringa.  
  
 Se si suddivide una stringa in corrispondenza di un carattere separatore, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere separatore nella stringa. Se si suddivide una stringa in una stringa di separazione, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Usare quindi il <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali per i restanti caratteri della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene usato per suddividere le stringhe in più <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.StringSplitOptions> enumerazione da includere o escludere le sottostringhe generate dal <xref:System.String.Split%2A> (metodo).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi usano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di stringhe che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in sottostringhe in base alle stringhe in una matrice. È possibile specificare se le sottostringhe includono elementi della matrice vuota.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da una o più stringhe indicate in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una stringa è delimitata da un set noto di stringhe, è possibile usare il <xref:System.String.Split%2A> metodo per separarlo in sottostringhe.  
  
## <a name="return-value-details"></a>Dettagli del valore restituito  
 Stringhe del delimitatore non sono inclusi gli elementi della matrice restituita. Ad esempio, se il `separator` matrice include la stringa "-" e il valore dell'istanza della stringa corrente è "aa - bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".  
  
 Se questa istanza non contiene una delle stringhe in `separator`, la matrice restituita è costituito da un singolo elemento che contiene questa istanza.  
  
 Se il `options` parametro è <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, il metodo restituisce una matrice vuota.  
  
 Ogni elemento della `separator` definisce un delimitatore separato che è costituito da uno o più caratteri. Se il `options` argomento è <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o viene trovato un delimitatore all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty?displayProperty=nameWithType>. Ad esempio, se `separator` include due elementi, "-" e "_", il valore dell'istanza della stringa è "- _aa -\_" e il valore della `options` argomento è <xref:System.StringSplitOptions.None>, il metodo restituisce una matrice di stringa con i seguenti cinque elementi:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che precede la "-" sottostringa in corrispondenza dell'indice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota tra le "-" sottostringa in corrispondenza dell'indice 0 e la sottostringa "_" in corrispondenza dell'indice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che segue la sottostringa "_" in corrispondenza dell'indice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che segue il "-" sottostringa in corrispondenza dell'indice 5.  
  
## <a name="the-separator-array"></a>Matrice di separatore  
 Se uno degli elementi in `separator` è costituito da più caratteri, la sottostringa intera viene considerata un delimitatore. Ad esempio, se uno degli elementi in `separator` è "10", provare a suddividere la stringa "This10is10a10string." Restituisce la matrice di quattro elementi seguente: {"This", "is", "a", "string". }.  
  
 Se il `separator` parametro è `null` o non contiene caratteri, gli spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e ritorno `true` se vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo).  
  
 Se il `separator` parametro nella chiamata a questo overload del metodo è `null`, si verifica un errore di risoluzione dell'overload del compilatore. Per identificare in modo non ambiguo il metodo chiamato, il codice deve indicare il tipo del `null`. Nell'esempio seguente vengono illustrati diversi modi per identificarlo in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>Dettagli relativi al confronto  
 Il <xref:System.String.Split%2A> metodo consente di estrarre le sottostringhe di questa stringa delimitate da uno o più delle stringhe di `separator` parametro e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%2A> metodo cerca i delimitatori mediante l'esecuzione di confronti con le regole di ordinamento per ordinale tra maiuscole e minuscole. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
 Il <xref:System.String.Split%2A> metodo ignora qualsiasi elemento della `separator` il cui valore è `null` o una stringa vuota ("").  
  
 Per evitare risultati ambigui quando le stringhe nella `separator` hanno in comune, i caratteri la <xref:System.String.Split%2A> operazione procede a partire dall'inizio alla fine del valore dell'istanza e corrisponde al primo elemento di `separator` uguale al delimitatore nel istanza. L'ordine in cui le sottostringhe si verificano nell'istanza ha la precedenza sull'ordine degli elementi in `separator`.  
  
 Si consideri, ad esempio, un'istanza il cui valore è "abcdef". Se il primo elemento in `separator` era "ef" e il secondo elemento è stato "bcde", il risultato dell'operazione split sarebbe una matrice di stringhe che contiene due elementi, "a" e "f". Ciò avviene perché la sottostringa dell'istanza, "bcde", viene rilevata e corrisponde a un elemento in `separator` prima che venga rilevata la sottostringa "f".  
  
 Tuttavia, se il primo elemento di `separator` era "bcd" e il secondo elemento è stato "bc", il risultato dell'operazione split sarebbe una matrice di stringhe che contiene due elementi, "a" e "ef". Questo accade perché "bcd" è il primo delimitatore individuato in `separator` che corrisponde a un delimitatore nell'istanza. Se è stato annullato. l'ordine dei separatori di "bc" è stato il primo elemento e il secondo elemento è stato "bcd", il risultato sarà una matrice di stringhe che contiene due elementi, "a" e "def".  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi di allocano della memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede prestazioni ottimali, o se la gestione dell'allocazione di memoria è fondamentale per l'applicazione, è consigliabile usare il <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOfAny%2A> metodo e, facoltativamente, il <xref:System.String.Compare%2A> (metodo), per individuare una sottostringa all'interno di una stringa.  
  
 Se si suddivide una stringa in corrispondenza di un carattere separatore, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere separatore nella stringa. Se si suddivide una stringa in una stringa di separazione, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Usare quindi il <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali per i restanti caratteri della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene usato per suddividere le stringhe in più <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente illustra la differenza tra le matrici restituite mediante una chiamata di una stringa <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> metodo con relativo `options` uguale al parametro <xref:System.StringSplitOptions.None?displayProperty=nameWithType> e <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 L'esempio seguente definisce una matrice di separatori che includono segni di punteggiatura e caratteri di spazio. Il passaggio di questa matrice insieme a un valore di <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> per il <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metodo restituisce una matrice costituita da singole parole dalla stringa.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Si noti che il metodo viene chiamato con il `options` argomento impostato su <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Ciò impedisce la matrice restituita inclusi <xref:System.String.Empty?displayProperty=nameWithType> valori che rappresentano corrispondenze di sottostringhe vuota tra segni di punteggiatura e caratteri di spazio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi usano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="count">Numero massimo di sottostringhe da restituire.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in un numero massimo di sottostringhe in base ai caratteri in una matrice.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri delimitatori non sono inclusi gli elementi della matrice restituita.  
  
 Se questa istanza non contiene i caratteri in `separator`, o `count` parametro è 1, la matrice restituita è costituito da un singolo elemento che contiene questa istanza. Se il `separator` parametro è `null` o non contiene caratteri, gli spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e ritorno `true` se vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo). Tuttavia, se il `separator` parametro nella chiamata a questo overload del metodo è `null`, si verifica un errore di risoluzione dell'overload del compilatore. Per identificare in modo non ambiguo il metodo chiamato, il codice deve indicare il tipo di null. Nell'esempio seguente vengono illustrati diversi modi per identificarlo in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Se il `count` parametro è uguale a zero, o il `options` parametro è <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, viene restituita una matrice vuota.  
  
 Ogni elemento della `separator` definisce un carattere di delimitazione separato. Se il `options` parametro è <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o viene trovato un delimitatore all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty>.  
  
 Se sono presenti più di `count` sottostringhe di questa istanza, il primo `count` -1 sottostringhe vengono restituiti nel primo `count` -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.  
  
 Se `count` è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibile e viene generata alcuna eccezione.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi di allocano della memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede prestazioni ottimali, o se la gestione dell'allocazione di memoria è fondamentale per l'applicazione, è consigliabile usare il <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOfAny%2A> metodo e, facoltativamente, il <xref:System.String.Compare%2A> (metodo), per individuare una sottostringa all'interno di una stringa.  
  
 Se si suddivide una stringa in corrispondenza di un carattere separatore, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere separatore nella stringa. Se si suddivide una stringa in una stringa di separazione, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Usare quindi il <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali per i restanti caratteri della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene usato per suddividere le stringhe in più <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.StringSplitOptions> enumerazione da includere o escludere le sottostringhe generate dal <xref:System.String.Split%2A> (metodo).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi usano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di stringhe che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="count">Numero massimo di sottostringhe da restituire.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in un numero massimo di sottostringhe in base alle stringe in una matrice. È possibile specificare se le sottostringhe includono elementi della matrice vuota.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da una o più stringhe indicate in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Dettagli del valore restituito  
 Stringhe del delimitatore non sono inclusi gli elementi della matrice restituita.  
  
 Se questa istanza non contiene una delle stringhe nelle `separator`, o `count` parametro è 1, la matrice restituita è costituito da un singolo elemento che contiene questa istanza. Se il `separator` parametro è `null` o non contiene caratteri, gli spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e ritorno `true` se vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo). Tuttavia, se il `separator` parametro nella chiamata a questo overload del metodo è `null`, si verifica un errore di risoluzione dell'overload del compilatore. Per identificare in modo non ambiguo il metodo chiamato, il codice deve indicare il tipo del `null`. Nell'esempio seguente vengono illustrati diversi modi per identificarlo in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Se il `count` parametro è uguale a zero, o il `options` parametro è <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, viene restituita una matrice vuota.  
  
 Ogni elemento della `separator` definisce un delimitatore separato che è costituito da uno o più caratteri. Se il `options` parametro è <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o viene trovato un delimitatore all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty>.  
  
 Se sono presenti più di `count` sottostringhe di questa istanza, il primo `count` -1 sottostringhe vengono restituiti nel primo `count` -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.  
  
 Se `count` è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibile e viene generata alcuna eccezione.  
  
## <a name="the-separator-array"></a>Matrice di separatore  
 Se uno degli elementi in `separator` è costituito da più caratteri, la sottostringa intera viene considerata un delimitatore. Ad esempio, se uno degli elementi in `separator` è "10", provare a suddividere la stringa "This10is10a10string." Restituisce la matrice di quattro elementi: {"This", "is", "a", "string". }.  
  
## <a name="comparison-details"></a>Dettagli relativi al confronto  
 Il <xref:System.String.Split%2A> metodo consente di estrarre le sottostringhe di questa stringa delimitate da uno o più delle stringhe di `separator` parametro e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%2A> metodo cerca i delimitatori mediante l'esecuzione di confronti con le regole di ordinamento per ordinale tra maiuscole e minuscole. Per altre informazioni sui word, la stringa e gli ordinamenti ordinale, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
 Il <xref:System.String.Split%2A> metodo ignora qualsiasi elemento della `separator` il cui valore è `null` o una stringa vuota ("").  
  
 Per evitare risultati ambigui quando le stringhe nella `separator` hanno in comune, caratteri il <xref:System.String.Split%2A> metodo consente di passare dall'inizio alla fine del valore dell'istanza e corrisponde al primo elemento di `separator` uguale al delimitatore nella istanza. L'ordine in cui le sottostringhe si verificano nell'istanza ha la precedenza sull'ordine degli elementi in `separator`.  
  
 Si consideri, ad esempio, un'istanza il cui valore è "abcdef". Se il primo elemento in `separator` era "ef" e il secondo elemento è stato "bcde", il risultato dell'operazione split sarebbe "a" e "f". Ciò avviene perché la sottostringa dell'istanza, "bcde", viene rilevata e corrisponde a un elemento in `separator` prima che venga rilevata la sottostringa "f".  
  
 Tuttavia, se il primo elemento di `separator` era "bcd" e il secondo elemento è stato "bc", il risultato dell'operazione split sarebbe "a" e "ef". Questo accade perché "bcd" è il primo delimitatore individuato in `separator` che corrisponde a un delimitatore nell'istanza. Se è stato annullato. l'ordine dei separatori di "bc" è stato il primo elemento e il secondo elemento è stato "bcd", il risultato sarà "a" e "def".  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi di allocano della memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede prestazioni ottimali, o se la gestione dell'allocazione di memoria è fondamentale per l'applicazione, è consigliabile usare il <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOfAny%2A> metodo e, facoltativamente, il <xref:System.String.Compare%2A> (metodo), per individuare una sottostringa all'interno di una stringa.  
  
 Se si suddivide una stringa in corrispondenza di un carattere separatore, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere separatore nella stringa. Se si suddivide una stringa in una stringa di separazione, usare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Usare quindi il <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali per i restanti caratteri della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene usato per suddividere le stringhe in più <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.StringSplitOptions> enumerazione da includere o escludere le sottostringhe generate dal <xref:System.String.Split%2A> (metodo).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contiene caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi usano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde a una stringa specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare.</param>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata.</summary>
        <returns>
          <see langword="true" /> se l'inizio di questa stringa corrisponde al parametro <paramref name="value" />; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo confronta `value` con la sottostringa all'inizio di questa istanza è uguale alla lunghezza `value`e restituisce un valore che indica se sono uguali. Equivalenti `value` deve essere una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>), deve essere un riferimento a questa istanza stesso o deve corrispondere all'inizio di questa istanza.  
  
 Questo metodo esegue un confronto di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente definisce una `StripStartTags` metodo che usa il <xref:System.String.StartsWith%28System.String%29> tag di inizio per rimuovere HTML dall'inizio di una stringa. Si noti che il `StripStartTags` viene chiamato in modo ricorsivo per garantire che vengano rimossi più tag di inizio HTML all'inizio della riga. L'esempio non vengono rimossi i tag HTML incorporati in una stringa.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per determinare se una stringa inizia con una particolare sottostringa tramite le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per la relativa <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che determina la modalità di confronto tra questa stringa e <c>value</c>.</param>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata se confrontata usando l'opzione di confronto specificata.</summary>
        <returns>
          <see langword="true" /> se l'istanza inizia con <paramref name="value" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.StartsWith%2A> metodo confronta la `value` parametro alla sottostringa all'inizio di questa stringa e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento a questa stessa stringa, deve essere una stringa vuota (""), o deve corrispondere all'inizio di questa stringa. Il tipo di confronto eseguito dal <xref:System.String.StartsWith%2A> metodo dipende dal valore della `comparisonType` parametro. Il confronto è possibile usare le convenzioni delle impostazioni cultura correnti (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> e <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) o la lingua inglese (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> e <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), o essere costituito da un confronto carattere per carattere dei punti di codice (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Il confronto può anche essere distinzione maiuscole/minuscole (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, o <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), o possibile Ignora maiuscole/minuscole (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Nell'esempio seguente cerca la stringa "the" all'inizio di una stringa più lunga che inizia con la parola "The". Come l'output illustrato nell'esempio, una chiamata al <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> metodo che esegue un confronto tra maiuscole e minuscole, ma indipendenti dalle impostazioni cultura non riesce a trovare la stringa, mentre una chiamata che esegue un confronto delle impostazioni cultura e case insensitive corrisponde alla stringa.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Nell'esempio seguente determina se una stringa inizia con una particolare sottostringa. Inizializza una matrice di stringhe bidimensionale. Il primo elemento nella seconda dimensione contiene una stringa e il secondo elemento contiene la stringa da cercare all'inizio della prima stringa. I risultati sono interessati dalla scelta di impostazioni cultura, se verrà ignorato caso e se viene eseguito un confronto ordinale. Si noti che quando l'istanza di stringa contiene un alfabeto, confronti con distinzione delle impostazioni cultura con i relativi caratteri consecutivi corrispondano correttamente.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Informazioni relative alle impostazioni cultura che determinano le modalità di confronto tra questa stringa e <c>value</c>. Se <c>culture</c> è <see langword="null" />, verranno usate le impostazioni cultura correnti.</param>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante le impostazioni cultura specificate.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> corrisponde all'inizio di questa stringa; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo confronta la `value` parametro per la sottostringa all'inizio di questa stringa che rappresenta la stessa lunghezza `value`e restituisce un valore che indica se sono uguali. Equivalenti `value` deve essere una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>), deve essere un riferimento a questa istanza stesso o deve corrispondere all'inizio di questa istanza.  
  
 Questo metodo esegue un confronto con le maiuscole e minuscole specificata e le impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa si verifica all'inizio di un'altra stringa. Il <xref:System.String.StartsWith%2A> metodo viene chiamato più volte con distinzione maiuscole/minuscole e maiuscole/minuscole diverse impostazioni cultura che determinano i risultati della ricerca.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera una sottostringa da questa istanza.  Si tratta di un membro di overload. Per informazioni complete su questo membro, inclusi la sintassi, l'uso e gli esempi, fare clic su un nome nell'elenco degli overload.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale in base zero del carattere di una sottostringa in questa istanza.</param>
        <summary>Recupera una sottostringa da questa istanza. La sottostringa inizia in corrispondenza di un carattere specificato e continua fino alla fine della stringa.</summary>
        <returns>Stringa equivalente alla sottostringa che inizia in corrispondenza di <paramref name="startIndex" /> in questa istanza oppure <see cref="F:System.String.Empty" /> se <paramref name="startIndex" /> è uguale alla lunghezza di questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si chiama il <xref:System.String.Substring%28System.Int32%29> metodo per estrarre una sottostringa da una stringa che inizia alla posizione del carattere specificato e termina alla fine della stringa. Posizione del carattere iniziale è in base zero; in altre parole, il primo carattere nella stringa è in corrispondenza dell'indice 0, non dell'indice 1. Per estrarre una sottostringa che inizia alla posizione del carattere specificato e termina prima alla fine della stringa, chiamare il <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> (metodo).  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che inizia in corrispondenza di `startIndex` posizione nella stringa corrente.  
  
 Per estrarre una sottostringa che inizia con un determinato carattere o sequenza di caratteri, chiamare un metodo, ad esempio <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOf%2A> per ottenere il valore di `startIndex`. Nel secondo esempio viene illustrato questo oggetto. estrae un valore di chiave che inizia una posizione di carattere dopo il carattere "=".  
  
 Se `startIndex` è uguale a zero, il metodo restituisce la stringa originale invariata.  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere una sottostringa da una stringa.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 L'esempio seguente usa il <xref:System.String.Substring%2A> metodo per separare le coppie chiave/valore delimitate da un uguale a carattere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Il <xref:System.String.IndexOf%2A> metodo viene utilizzato per ottenere la posizione del carattere è uguale a nella stringa. La chiamata ai <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo estrae il nome della chiave, che inizia dal primo carattere nella stringa e si estende per il numero di caratteri restituito dalla chiamata al metodo il <xref:System.String.IndexOf%2A> (metodo). La chiamata al <xref:System.String.Substring%28System.Int32%29> metodo estrae quindi il valore assegnato alla chiave. Inizia in una posizione del carattere di là del carattere è uguale a e si estende alla fine della stringa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale in base zero del carattere di una sottostringa in questa istanza.</param>
        <param name="length">Numero di caratteri nella sottostringa.</param>
        <summary>Recupera una sottostringa da questa istanza. La sottostringa inizia in corrispondenza della posizione del carattere specificata e ha la lunghezza specificata.</summary>
        <returns>Stringa equivalente alla sottostringa di lunghezza <paramref name="length" /> che inizia in corrispondenza di <paramref name="startIndex" /> in questa istanza oppure <see cref="F:System.String.Empty" /> se <paramref name="startIndex" /> è uguale alla lunghezza di questa istanza e <paramref name="length" /> è zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si chiama il <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo per estrarre una sottostringa da una stringa che inizia alla posizione del carattere specificato e termina prima della fine della stringa. Posizione del carattere iniziale è in base zero; in altre parole, il primo carattere nella stringa è in corrispondenza dell'indice 0, non dell'indice 1. Per estrarre una sottostringa che inizia nella posizione del carattere specificata e continua fino alla fine della stringa, chiamare il <xref:System.String.Substring%28System.Int32%29> (metodo).  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa con `length` caratteri a partire dal `startIndex` posizione nella stringa corrente.  
  
 Il `length` parametro rappresenta il numero totale di caratteri da estrarre dall'istanza della stringa corrente. Ciò include il carattere iniziale in corrispondenza dell'indice `startIndex`.  In altre parole, il <xref:System.String.Substring%2A> metodo tenta di estrarre i caratteri dall'indice `startIndex` all'indice `startIndex`  +  `length` - 1.  
  
 Per estrarre una sottostringa che inizia con un determinato carattere o sequenza di caratteri, chiamare un metodo, ad esempio <xref:System.String.IndexOf%2A> oppure <xref:System.String.LastIndexOf%2A> per ottenere il valore di `startIndex`.  
  
 Se la sottostringa si estende da `startIndex` a una sequenza di caratteri specificato, è possibile chiamare un metodo, ad esempio <xref:System.String.IndexOf%2A> o <xref:System.String.LastIndexOf%2A> per ottenere l'indice del carattere finale o sequenza di caratteri.  È possibile convertire tale valore in una posizione di indice nella stringa come indicato di seguito:  
  
-   Se è stata eseguita la ricerca per un singolo carattere che è possibile contrassegnare la fine della sottostringa, il `length` parametro è uguale a `endIndex`  -  `startIndex` + 1, dove `endIndex` è il valore restituito del <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> metodo. Nell'esempio seguente estrae un blocco continuo di caratteri "b" da una stringa.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Se è stato cercato più caratteri che sono possibile contrassegnare la fine della sottostringa, il `length` parametro è uguale a `endIndex`  +  `endMatchLength`  -  `startIndex`, dove `endIndex` è il valore restituito del <xref:System.String.IndexOf%2A> oppure <xref:System.String.IndexOf%2A> metodo. e `endMatchLength` è la lunghezza della sequenza di caratteri che contrassegna la fine della sottostringa. L'esempio seguente estrae un blocco di testo che contiene un file XML `<definition>` elemento.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Se il carattere o sequenza di caratteri non è incluso alla fine della sottostringa, il `length` parametro è uguale a `endIndex`  -  `startIndex`, dove `endIndex` è il valore restituito del <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> metodo.  
  
 Se `startIndex` è uguale a zero e uguale alla lunghezza della stringa corrente, il metodo restituisce la stringa originale invariata.  
  
   
  
## Examples  
 L'esempio seguente illustra una semplice chiamata al <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo che estrae i due caratteri da una stringa che inizia nella posizione del carattere sesta (vale a dire, in corrispondenza dell'indice cinque).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 L'esempio seguente usa il <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo nei tre casi seguenti per isolare le sottostringhe all'interno di una stringa. Nei due casi vengono utilizzate le sottostringhe nei confronti e nel terzo caso viene generata un'eccezione perché sono stati specificati parametri non validi.  
  
-   Estrae il carattere singolo e alla terza posizione nella stringa (in corrispondenza dell'indice 2) e lo confronta con "c". Restituisce questo confronto `true`.  
  
-   Estrae zero caratteri a partire dalla quarta posizione nella stringa (in corrispondenza dell'indice 3) e lo passa al <xref:System.String.IsNullOrEmpty%2A> (metodo). Restituisce true perché la chiamata per il <xref:System.String.Substring%2A> restituzione del metodo <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Tenta di estrarre un carattere a partire dalla posizione quarto nella stringa. Poiché non è presente alcun carattere in quella posizione, la chiamata al metodo genera un <xref:System.ArgumentOutOfRangeException> eccezione.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 L'esempio seguente usa il <xref:System.String.Substring%2A> metodo per separare le coppie chiave/valore delimitate da un uguale a carattere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Il <xref:System.String.IndexOf%2A> metodo viene utilizzato per ottenere la posizione del carattere è uguale a nella stringa. La chiamata ai <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo estrae il nome della chiave, che inizia dal primo carattere nella stringa e si estende per il numero di caratteri restituito dalla chiamata al metodo il <xref:System.String.IndexOf%2A> (metodo). La chiamata al <xref:System.String.Substring%28System.Int32%29> metodo estrae quindi il valore assegnato alla chiave. Inizia in una posizione del carattere di là del carattere è uguale a e si estende alla fine della stringa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La somma di <paramref name="startIndex" /> e <paramref name="length" /> indica una posizione non all'interno di questa istanza.  oppure  <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione dell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <returns>Enumeratore fortemente tipizzato che può essere usato per eseguire l'iterazione nell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere usato solo quando la <xref:System.String> istanza viene eseguito il cast a un <xref:System.Collections.Generic.IEnumerable%601> oggetto interfaccia. Per altre informazioni, vedere il metodo <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione dell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <returns>Enumeratore utilizzabile per eseguire l'iterazione degli elementi della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.Collections.IEnumerable>. Per altre informazioni, vedere il metodo <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> se il valore della stringa corrente è <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> se il valore della stringa corrente è <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Il valore della stringa corrente non è <see cref="F:System.Boolean.TrueString" /> o <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.Byte.MaxValue" /> o minore di <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Carattere in corrispondenza dell'indice 0 nell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero minore di <see cref="F:System.Decimal.MinValue" /> o maggiore di <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.Int16.MaxValue" /> o minore di <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.SByte.MaxValue" /> o minore di <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo dell'oggetto restituito.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ChangeType%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile convertire il valore dell'oggetto <see cref="T:System.String" /> corrente nel tipo specificato dal parametro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.UInt16.MaxValue" /> o minore di <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di  <see cref="F:System.UInt32.MaxValue" /> o minore di <see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia i caratteri di questa istanza in una matrice di caratteri Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia i caratteri di questa istanza in una matrice di caratteri Unicode.</summary>
        <returns>Matrice di caratteri Unicode i cui elementi sono i singoli caratteri di questa istanza. Se l'istanza è una stringa vuota, la matrice restituita sarà vuota e di lunghezza zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia ogni carattere (vale a dire, ognuna <xref:System.Char> oggetto) in una stringa in una matrice di caratteri. Il primo carattere copiato è in corrispondenza dell'indice zero della matrice di caratteri restituiti; l'ultimo carattere copiato è in corrispondenza dell'indice <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Per creare una stringa di caratteri in una matrice di caratteri, chiamare il <xref:System.String.%23ctor%28System.Char%5B%5D%29> costruttore.  
  
 Per creare una matrice di byte che contiene i caratteri codificati in una stringa, creare un'istanza appropriata <xref:System.Text.Encoding> oggetto e chiamare relativo <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> (metodo). Alcune delle codifiche standard disponibili in .NET Framework includono quanto segue:  
  
|Codifica|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Per altre informazioni, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.String.ToCharArray%2A> metodo per estrarre i caratteri in una stringa in una matrice di caratteri. Quindi Visualizza la stringa originale e gli elementi nella matrice.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 Nell'esempio seguente definisce una stringa che contiene i caratteri utilizzati come delimitatori di una stringa delimitata. Chiama quindi il <xref:System.String.ToCharArray%2A> per creare una matrice di caratteri che può essere passata al metodo il <xref:System.String.Split%28System.Char%5B%5D%29> metodo per suddividere la stringa delimitata in relative sottostringhe singoli.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale di una sottostringa in questa istanza.</param>
        <param name="length">Lunghezza della sottostringa in questa istanza.</param>
        <summary>Copia i caratteri di una determinata sottostringa di questa istanza in una matrice di caratteri Unicode.</summary>
        <returns>Matrice di caratteri Unicode i cui elementi sono il numero <paramref name="length" /> di caratteri di questa istanza a partire dalla posizione <paramref name="startIndex" /> del carattere.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia i caratteri in una parte di una stringa in una matrice di caratteri. Per creare una stringa da un intervallo di caratteri in una matrice di caratteri, chiamare il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore.  
  
 Il `startIndex` in base zero. Vale a dire, l'indice del primo carattere nell'istanza della stringa è zero.  
  
 Se `length` è uguale a zero, la matrice restituita è vuota e ha lunghezza zero. Se questa istanza è `null` o una stringa vuota (""), la matrice restituita è vuota e ha lunghezza zero.  
  
 Per creare una matrice di byte che contiene i caratteri codificati in una parte di una stringa, creare un'istanza appropriata <xref:System.Text.Encoding> oggetto e chiamare relativo <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> (metodo). Alcune delle codifiche standard disponibili in .NET Framework includono quanto segue:  
  
|Codifica|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Per altre informazioni, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Nell'esempio seguente converte una sottostringa all'interno di una stringa in una matrice di caratteri, quindi enumera e visualizza gli elementi della matrice.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="length" /> è maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri minuscoli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri minuscoli.</summary>
        <returns>Stringa di caratteri minuscoli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo prende in considerazione le regole delle impostazioni cultura correnti.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente sono stati convertiti in caratteri minuscoli.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 L'operazione di maiuscole e minuscole risultante dalla chiamata di <xref:System.String.ToLower> metodo tiene conto delle convenzioni delle impostazioni cultura correnti. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodi. Questa operazione produce lo stesso risultato in tutte le impostazioni cultura (a differenza di <xref:System.String.ToLower> (metodo)) ed esegue in modo più efficiente.  
  
   
  
## Examples  
 L'esempio seguente converte misti di alcune stringhe in caratteri minuscoli.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare metodi di maiuscole e minuscole delle stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per convertire un carattere in minuscolo usando le convenzioni delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> overload del metodo con un valore di <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> per la relativa <paramref name="culture" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
        <summary>Restituisce una copia di questa stringa convertita in caratteri minuscoli, usando le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura specificate.</summary>
        <returns>Equivalente in caratteri minuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le regole delle impostazioni cultura specificate per il `culture` parametro determinano il modo il caso della stringa vengono modificati.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente sono stati convertiti in caratteri minuscoli.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se si passa il <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> metodo una <xref:System.Globalization.CultureInfo> oggetto diverso da <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l'operazione di maiuscole e minuscole per considerare le regole specifiche delle impostazioni cultura. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> (metodo). Ciò produce lo stesso risultato in tutte le impostazioni cultura ed esegue in modo più efficiente.  
  
   
  
## Examples  
 Nell'esempio seguente converte le due stringhe di caratteri maiuscoli in caratteri minuscoli utilizzando le impostazioni cultura inglese degli Stati e turco di Turchia, quindi confronta le stringhe di caratteri minuscole. Le stringhe in maiuscolo sono identiche ad eccezione del fatto che per ogni occorrenza di Unicode LATINO lettera maiuscola ricerca per categorie in un'unica stringa, l'altra stringa contiene ALFABETO LATINO I con punto precedente.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia dell'oggetto <see cref="T:System.String" /> convertito in caratteri minuscoli mediante le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura invariabili.</summary>
        <returns>Equivalente in caratteri minuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lingua inglese rappresenta impostazioni cultura che è indipendente dalla lingua. È associato con la lingua inglese, ma non con un paese specifico. Per altre informazioni, vedere la proprietà <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se l'applicazione dipende dal caso di una stringa che cambia in modo prevedibile che è indipendente dalle impostazioni cultura correnti, usare il <xref:System.String.ToLowerInvariant%2A> (metodo). Il <xref:System.String.ToLowerInvariant%2A> metodo è equivalente a `ToLower(CultureInfo.InvariantCulture)`. Il metodo è consigliato quando una raccolta di stringhe deve essere visualizzato in un ordine prevedibile in un controllo dell'interfaccia utente.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente sono stati convertiti in caratteri minuscoli.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodi.  
  
   
  
## Examples  
 L'esempio seguente definisce una matrice di stringhe che contiene una singola parola in un numero di lingue. Il <xref:System.String.ToLowerInvariant%2A> metodo viene utilizzato per popolare gli elementi di una matrice parallela con la versione di ogni parola tra maiuscole e minuscole. Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo viene utilizzato per ordinare la matrice con distinzione maiuscole/minuscole in base all'ordine di elementi nella matrice di caratteri minuscolo per garantire che gli elementi vengono visualizzati nello stesso ordine indipendentemente dal linguaggio.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore di questa istanza in un oggetto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce questa istanza di <see cref="T:System.String" />. Non viene eseguita alcuna conversione effettiva.</summary>
        <returns>Stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché questo metodo restituisce semplicemente la stringa corrente non modificata, non è necessario chiamarlo direttamente. Viene in genere chiamato in modo implicito in un'operazione, come illustrato nell'esempio di formattazione composita.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.ToString%2A> (metodo). Si noti che l'esempio non chiama esplicitamente il <xref:System.String.ToString%2A> (metodo). Al contrario, il metodo viene chiamato in modo implicito dal [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Riservato) Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Restituisce questa istanza di <see cref="T:System.String" />. Non viene eseguita alcuna conversione effettiva.</summary>
        <returns>Stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` è riservato e non partecipa attualmente questa operazione.  
  
 Poiché questo metodo restituisce semplicemente la stringa corrente non modificata, non è necessario chiamarlo direttamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri maiuscoli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri maiuscoli.</summary>
        <returns>Equivalente in caratteri maiuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa le regole delle impostazioni cultura correnti per convertire ogni carattere nell'istanza corrente nell'equivalente maiuscolo. Se un carattere non ha un equivalente maiuscolo, verrà riportato invariato nella stringa restituita.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente sono stati convertiti in caratteri maiuscoli.  
  
 Il <xref:System.String.ToUpper%2A> metodo viene spesso utilizzato per convertire una stringa in lettere maiuscole in modo che può essere utilizzato in un confronto tra maiuscole e minuscole. Un metodo migliore per eseguire il confronto tra maiuscole e minuscole consiste nel chiamare un metodo di confronto di stringa che contiene un <xref:System.StringComparison> parametro il cui valore è impostato su <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> per un confronto tra maiuscole e minuscole, distinzione delle impostazioni cultura.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 L'operazione di maiuscole e minuscole risultante dalla chiamata di <xref:System.String.ToUpper> metodo tiene conto delle convenzioni delle impostazioni cultura correnti. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> (metodo). Questa operazione produce lo stesso risultato in tutte le impostazioni cultura (a differenza di <xref:System.String.ToUpper> (metodo)) ed esegue in modo più efficiente.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.String.ToUpper%2A> metodo per convertire una serie di stringhe solo carattere che contengono ogni carattere nei set di caratteri esteso latino di base, Supplemento latino 1 e latina. Visualizza quindi ogni stringa con caratteri maiuscoli sono diverso dal carattere minuscolo.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) tramite, è consigliabile evitare di chiamare metodi di maiuscole e minuscole delle stringhe che sostituiscono i valori predefiniti e invece chiamano metodi che richiedono parametri da specificato in modo esplicito. Per convertire una stringa in lettere maiuscole usando le convenzioni delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> overload del metodo con un valore di <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> per la relativa <paramref name="culture" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
        <summary>Restituisce una copia di questa stringa convertita in caratteri maiuscoli, usando le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura specificate.</summary>
        <returns>Equivalente in caratteri maiuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le regole delle impostazioni cultura specificate per il `culture` parametro determinano il modo nel caso di una stringa vengono modificati.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente sono stati convertiti in caratteri maiuscoli.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se si passa il <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> metodo una <xref:System.Globalization.CultureInfo> oggetto diverso da <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l'operazione di maiuscole e minuscole per considerare le regole specifiche delle impostazioni cultura. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> (metodo). Ciò produce lo stesso risultato in tutte le impostazioni cultura ed esegue in modo più efficiente.  
  
   
  
## Examples  
 Nell'esempio seguente converte una stringa di caratteri minuscoli in due stringhe di caratteri maiuscoli mediante le impostazioni cultura inglese degli Stati e turco di Turchia, quindi confronta le stringhe in maiuscolo. Le stringhe in maiuscolo sono identiche ad eccezione del fatto che per ogni occorrenza di Unicode LATINO lettera maiuscola ricerca per categorie in un'unica stringa, l'altra stringa contiene ALFABETO LATINO I con punto precedente.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia dell'oggetto <see cref="T:System.String" /> convertito in caratteri maiuscoli mediante le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura invariabili.</summary>
        <returns>Equivalente in caratteri maiuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lingua inglese rappresenta impostazioni cultura che è indipendente dalla lingua. È associato con la lingua inglese, ma non con un paese specifico. Per altre informazioni, vedere la proprietà <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se l'applicazione dipende dal caso di una stringa che cambia in modo prevedibile che è indipendente dalle impostazioni cultura correnti, usare il <xref:System.String.ToUpperInvariant%2A> (metodo). Il <xref:System.String.ToUpperInvariant%2A> metodo è equivalente a `ToUpper(CultureInfo.InvariantCulture)`. Il metodo è consigliato quando una raccolta di stringhe deve essere visualizzato in un ordine prevedibile in un controllo dell'interfaccia utente.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente sono stati convertiti in caratteri maiuscoli.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodi.  
  
   
  
## Examples  
 L'esempio seguente definisce una matrice di stringhe che contiene una singola parola in un numero di lingue. Il <xref:System.String.ToUpperInvariant%2A> metodo viene utilizzato per popolare gli elementi di una matrice parallela con la versione di ogni parola tra maiuscole e minuscole. Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo viene utilizzato per ordinare la matrice con distinzione maiuscole/minuscole in base all'ordine di elementi nella matrice di lettere maiuscole per garantire che gli elementi vengono visualizzati nello stesso ordine indipendentemente dal linguaggio.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa in cui vengono rimosse tutte le occorrenze iniziali e finali di un set di caratteri specificati contenuti nell'oggetto <see cref="T:System.String" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli spazi vuoti iniziali e finali dall'oggetto <see cref="T:System.String" /> corrente.</summary>
        <returns>Stringa risultante dopo che tutti gli spazi vuoti sono stati rimossi dall'inizio e dalla fine della stringa corrente. Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Trim%2A> metodo rimuove dalla stringa corrente tutti i caratteri spazi vuoti iniziali e finali. Ogni operazione di rimozione di spazi iniziali e finali si interrompe quando viene rilevato un carattere di spazio non vuoto. Ad esempio, se la stringa corrente è "abc. xyz", il <xref:System.String.Trim%2A> metodo restituisce "abc. xyz". Per rimuovere spazi tra parole in una stringa, usare una [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Se il <xref:System.String.Trim%2A> metodo rimuove tutti i caratteri dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui vengono rimossi tutti i caratteri spazi vuoti iniziali e finali trovati nell'istanza corrente.  
  
 Se la stringa corrente è uguale a <xref:System.String.Empty> o tutti i caratteri nell'istanza corrente è costituito da spazi vuoti, il metodo restituisce <xref:System.String.Empty>.  
  
 Gli spazi vuoti sono definiti dallo standard Unicode. Il <xref:System.String.Trim> metodo rimossi tutti i caratteri iniziali e finali che producono un valore restituito pari `true` quando vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Trim?displayProperty=nameWithType> metodo per rimuovere eventuali spazi aggiuntivi da immesso dall'utente prima della concatenazione di stringhe.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e versioni precedenti viene mantenuto un elenco interno degli spazi rimossi da questo metodo. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], il metodo elimina tutti gli spazi vuoti Unicode (ovvero caratteri che producono un <see langword="true" /> valore restituito quando vengono passati al <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (metodo)). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> nel metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e rimuove le versioni precedenti i due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non Taglia spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), spazio senza interruzione NARROW (U + 202F) e Media spazio MATEMATICI (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matrice di caratteri Unicode da rimuovere oppure <see langword="null" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.String" /> corrente tutte le occorrenze iniziali e finali di un set di caratteri specificati in una matrice.</summary>
        <returns>Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <paramref name="trimChars" /> sono state rimosse dall'inizio e dalla fine della stringa corrente. Se <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota, verranno rimossi invece gli spazi vuoti. Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Trim%2A> metodo rimuove dalla stringa corrente tutti i caratteri iniziali e finali nel `trimChars` parametro. Ogni iniziali e finali trim operazione termina quando un carattere che non si trova in `trimChars` viene rilevato. Ad esempio, se la stringa corrente è "123abc456xyz789" e `trimChars` contiene le cifre da "1" e "9", il <xref:System.String.Trim%2A> metodo restituisce "abc456xyz".  
  
> [!NOTE]
>  Se il <xref:System.String.Trim%2A> metodo rimuove tutti i caratteri dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutte le iniziali e finali `trimChars` trovato nell'istanza corrente vengono rimossi.  
  
 Se la stringa corrente è uguale a <xref:System.String.Empty> o tutti i caratteri nell'istanza corrente è costituito da caratteri di `trimChars` della matrice, il metodo restituisce <xref:System.String.Empty>.  
  
 Se `trimChars` viene `null` o una matrice vuota, questo metodo rimuove gli eventuali caratteri iniziali o finali che comportano la restituzione del metodo `true` quando vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> , metodo  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo per rimuovere i caratteri apostrofo ('), asterisco (*) e lo spazio da una stringa.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti gestisce un elenco interno degli spazi rimossi da questo metodo se <paramref name="trimChars" /> è <see langword="null" /> oppure matrice vuota. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], se <paramref name="trimChars" /> viene <see langword="null" /> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (, ovvero caratteri che producono un <see langword="true" /> valore restituito quando vengono passati per il <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metodo). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> nel metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e rimuove le versioni precedenti i due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non Taglia spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), spazio senza interruzione NARROW (U + 202F) e Media spazio MATEMATICI (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matrice di caratteri Unicode da rimuovere oppure <see langword="null" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.String" /> corrente tutte le occorrenze finali di un set di caratteri specificati in una matrice.</summary>
        <returns>Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <paramref name="trimChars" /> sono state rimosse dalla fine della stringa corrente. Se <paramref name="trimChars" /> è <see langword="null" /> o se è una matrice vuota, verranno rimossi invece gli spazi vuoti Unicode. Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.TrimEnd%2A> metodo rimuove dalla stringa corrente in tutti i caratteri finali di `trimChars` parametro. L'operazione di rimozione si interrompe quando il primo carattere non contenuta in `trimChars` viene rilevata alla fine della stringa. Ad esempio, se la stringa corrente è "123abc456xyz789" e `trimChars` contiene le cifre da "1" e "9", il <xref:System.String.TrimEnd%2A> metodo restituisce "123abc456xyz".  
  
> [!NOTE]
>  Se il <xref:System.String.TrimEnd%2A> metodo rimuove tutti i caratteri dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri finali disponibili in `trimChars` vengono rimosse dalla stringa corrente.  
  
   
  
## Examples  
 L'esempio seguente illustra come usare il <xref:System.String.TrimEnd%28System.Char%5B%5D%29> metodo per eliminare gli spazi o segni di punteggiatura dalla fine della stringa.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti gestisce un elenco interno degli spazi rimossi da questo metodo se <paramref name="trimChars" /> è <see langword="null" /> oppure matrice vuota. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], se <paramref name="trimChars" /> viene <see langword="null" /> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (, ovvero caratteri che producono un <see langword="true" /> valore restituito quando vengono passati per il <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metodo). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> nel metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e rimuove le versioni precedenti i due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non Taglia spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), spazio senza interruzione NARROW (U + 202F) e Media spazio MATEMATICI (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matrice di caratteri Unicode da rimuovere oppure <see langword="null" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.String" /> corrente tutte le occorrenze iniziali di un set di caratteri specificati in una matrice.</summary>
        <returns>Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <paramref name="trimChars" /> sono state rimosse dall'inizio della stringa corrente. Se <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota, verranno rimossi invece gli spazi vuoti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.TrimStart%2A> metodo rimuove dalla stringa corrente in tutti i caratteri iniziali di `trimChars` parametro. L'operazione di rimozione si interrompe quando un carattere che non si trova in `trimChars` viene rilevato. Ad esempio, se la stringa corrente è "123abc456xyz789" e `trimChars` contiene le cifre da "1" e "9", il <xref:System.String.TrimStart%2A> metodo restituisce "abc456xyz789".  
  
> [!NOTE]
>  Se il <xref:System.String.TrimStart%2A> metodo rimuove tutti i caratteri dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui vengono rimossi tutti i caratteri spazi vuoti iniziali trovati nell'istanza corrente.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.TrimStart%2A> metodo per rimuovere gli spazi vuoti e caratteri di commento dalle righe di codice sorgente. Il `StripComments` metodo esegue il wrapping di una chiamata a <xref:System.String.TrimStart%2A> e lo passa una matrice di caratteri che contiene uno spazio e il carattere di commento, ovvero un apostrofo (') in una barra (/) nel linguaggio c# e Visual Basic. Il <xref:System.String.TrimStart%2A> metodo viene chiamato anche per rimuovere gli spazi vuoti iniziali quando si valuta se una stringa è un commento.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 Nell'esempio seguente viene illustrata una chiamata al metodo `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti gestisce un elenco interno degli spazi rimossi da questo metodo se <paramref name="trimChars" /> è <see langword="null" /> oppure matrice vuota. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], se <paramref name="trimChars" /> viene <see langword="null" /> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (, ovvero caratteri che producono un <see langword="true" /> valore restituito quando vengono passati per il <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metodo). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> nel metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e rimuove le versioni precedenti i due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non Taglia spazi vuoti Unicode: separatore vocale MONGOLO (U + 180E), spazio senza interruzione NARROW (U + 202F) e Media spazio MATEMATICI (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>