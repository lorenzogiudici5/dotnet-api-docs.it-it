<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="478485e5e57fcdc6085cef5cf6ccbabb05365869" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39776977" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contiene metodi per creare tipi di oggetti, localmente o in remoto, oppure per ottenere riferimenti a oggetti remoti esistenti. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Activator.CreateInstance%2A> metodo crea un'istanza di un tipo definito in un assembly richiamando il costruttore che corrisponde maggiormente gli argomenti specificati. Se viene specificato alcun argomento, il costruttore che non accetta parametri, vale a dire, il costruttore predefinito, viene richiamato.  
  
 È necessario disporre di autorizzazioni sufficienti per cercare e chiamare un costruttore. in caso contrario, viene generata un'eccezione. Per impostazione predefinita, solo i costruttori pubblici vengono considerati durante la ricerca di un costruttore. Se non è possibile trovare alcun costruttore o un costruttore predefinito, viene generata un'eccezione.  
  
 Un parametro di strumento di associazione specifica un oggetto che cerca un assembly per un costruttore appropriato. È possibile specificare i propri criteri di ricerca e dello strumento di associazione. Se nessun gestore di associazione è specificato, verrà usato un binder predefinito. Per altre informazioni, vedere le classi <xref:System.Reflection.Binder?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un parametro evidenza influisce sui criteri di sicurezza e le autorizzazioni per il costruttore. Per altre informazioni, vedere la classe <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Un'istanza di un tipo può essere creata in un sito locale o remoto. Se il tipo viene creato in modalità remota, un parametro di attributo di attivazione specifica l'URI del sito remoto. La chiamata di creazione dell'istanza può passare attraverso i siti intermedi prima che raggiunga il sito remoto. Altri attributi di attivazione è possono modificare l'ambiente, o il contesto, in cui la chiamata viene eseguita nei siti remoti e intermedi.  
  
 Se l'istanza viene creata in locale, viene restituito un riferimento a tale oggetto. Se l'istanza viene creata in modalità remota, viene restituito un riferimento a un proxy. L'oggetto remoto viene modificato tramite il proxy come se fosse un oggetto locale.  
  
 Il <xref:System.Activator.GetObject%2A> metodo crea un proxy a un oggetto remoto attualmente in esecuzione, un oggetto noto attivati dal server o un servizio Web XML. È possibile specificare il supporto di connessione, vale a dire, il canale. Per altre informazioni, vedere la classe <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Gli assembly contengono le definizioni dei tipi. Il <xref:System.Activator.CreateInstance%2A> metodo crea un'istanza di un tipo da un assembly attualmente in esecuzione. Il <xref:System.Activator.CreateInstanceFrom%2A> metodo crea un'istanza da un file contenente un assembly. Il <xref:System.Activator.CreateComInstanceFrom%2A> metodo crea un'istanza di un oggetto COM da un file contenente un assembly.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Activator> classe costruzione dinamica di oggetti in fase di esecuzione.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'istanza dell'oggetto COM il cui nome è specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <summary>Crea un'istanza dell'oggetto COM il cui nome viene specificato, usando il file di assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Oggetto <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attributo con il valore `true` deve essere applicato in modo esplicito o per impostazione predefinita per il tipo COM in modo che il <xref:System.Activator.CreateComInstanceFrom%2A> metodo consente di creare un'istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException> viene generata un'eccezione.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per creare tipi non pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici è limitato alla concessione del chiamante impostare o da un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> o <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile creare un'istanza tramite COM.  
  
oppure 
 Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta.  
  
oppure 
Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> è la stringa vuota ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <param name="hashValue">Valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</param>
        <summary>Crea un'istanza dell'oggetto COM il cui nome viene specificato, usando il file di assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Oggetto <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attributo con il valore `true` deve essere applicato in modo esplicito o per impostazione predefinita per il tipo COM in modo che il <xref:System.Activator.CreateComInstanceFrom%2A> metodo consente di creare un'istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException> viene generata un'eccezione.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per creare tipi non pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici è limitato alla concessione del chiamante impostare o da un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> o <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> è la stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.
        
oppure 
        <paramref name="assemblyName" /> è maggiore della lunghezza massima definita nel sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> è stato trovato, ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una codebase che non inizia con "file://" senza l'oggetto <see langword="WebPermission" /> richiesto.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile creare un'istanza tramite COM.  
  
oppure 
 Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta.  
  
oppure 
Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'istanza del tipo specificato usando il costruttore più adatto ai parametri specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Oggetto di contesto di attivazione che specifica l'oggetto da creare.</param>
        <summary>Crea un'istanza del tipo designato dall'oggetto <see cref="T:System.ActivationContext" /> specificato.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'oggetto appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Il contesto di attivazione viene usato durante l'attivazione basata su manifesto per configurare i criteri di dominio e per fornire un modello di sicurezza basato sull'applicazione. Il <xref:System.ActivationContext> classe contiene un <xref:System.ApplicationIdentity> oggetto che fornisce l'accesso al manifesto dell'applicazione. Per altre informazioni, vedere la classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto da creare.</param>
        <summary>Crea un'istanza del tipo specificato usando il costruttore predefinito di tale tipo.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore da richiamare deve essere accessibile.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a tipi non pubblici se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici è limitato alla concessione del chiamante impostare o da un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Activator.CreateInstance%28System.Type%29> (metodo). Vengono create istanze di diversi tipi e i relativi valori predefiniti vengono visualizzati.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="type" /> è un tipo generico aperto (ovvero, la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> non può essere un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
oppure 
La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
L'assembly che contiene <paramref name="type" /> è un assembly dinamico creato con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore chiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.MemberAccessException" />. </para>
          </block>  
  
Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.MissingMemberException" />. </para>
          </block>  
  
Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> è un oggetto COM ma l'identificatore di classe usato per ottenere il tipo non è valido oppure la classe identificata non è registrata.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> non è un tipo valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per accedere a tipi non pubblici indipendentemente dalla loro grant imposta. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Oggetto di contesto di attivazione che specifica l'oggetto da creare.</param>
        <param name="activationCustomData">Matrice di stringhe Unicode contenente i dati di attivazione personalizzati.</param>
        <summary>Crea un'istanza del tipo designato dall'oggetto <see cref="T:System.ActivationContext" /> specificato e attivato con i dati di attivazione personalizzati specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'oggetto appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Il contesto di attivazione viene usato durante l'attivazione basata su manifesto per configurare i criteri di dominio e per fornire un modello di sicurezza basato sull'applicazione. Il <xref:System.ActivationContext> classe contiene un <xref:System.ApplicationIdentity> oggetto che fornisce l'accesso al manifesto dell'applicazione. Per altre informazioni, vedere la classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando l'assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
 `assemblyName` può corrispondere a uno dei seguenti nomi:  
  
-   Il nome semplice di un assembly, senza il relativo percorso o estensione del file. Ad esempio, si specificherà `TypeExtensions` per un assembly il cui percorso e nome sono .\bin\TypeExtensions.dll.  
  
-   Nome completo di un assembly firmato costituito dal nome semplice, dalla versione, dalle impostazioni cultura e dal token di chiave pubblica; ad esempio, "TypeExtensions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=181869f2f7435b51".  
  
 Per altre informazioni su come common language runtime identifica e carica gli assembly, vedere [modo in cui il Runtime individua gli assembly](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Per informazioni sull'uso di file di configurazione dell'applicazione per definire i percorsi di assembly, vedere [che specifica la posizione dell'Assembly](~/docs/framework/configure-apps/specify-assembly-location.md). Se `assemblyName` viene trovato, viene caricato nel contesto predefinito.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per creare tipi non pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici è limitato alla concessione del chiamante impostare o da un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene definita una classe denominata `Person` in un assembly denominato `PersonInfo`. Si noti che la classe `Person` dispone di due costruttori, uno dei quali è senza parametri.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 Nell'esempio seguente viene chiamato il metodo <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> per creare un'istanza della classe `Person`. Richiede che venga aggiunto un riferimento a PersonInfo.dll al progetto. Poiché il metodo <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> chiama il costruttore predefinito della classe `Person`, nell'esempio viene assegnato un valore alla relativa proprietà `Name`.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Tuttavia, <xref:System.Activator.CreateInstance%2A> viene spesso chiamato per creare un'istanza di un tipo che supera i limiti del computer o che non è noto in fase di progettazione. In questo caso, non è possibile includere un riferimento all'assembly nel progetto e non è possibile eseguire chiamate con associazione anticipata ai membri del tipo. Per ovviare a questa limitazione, nell'esempio seguente viene utilizzato il metodo <xref:System.Activator.CreateInstance%2A> insieme alla reflection per assegnare un valore alla proprietà `Person` dell'oggetto `Name` e per visualizzarne il valore.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto da creare.</param>
        <param name="nonPublic">
          <see langword="true" /> se può corrispondere un costruttore predefinito pubblico o non pubblico, <see langword="false" /> se può corrispondere solo un costruttore predefinito pubblico.</param>
        <summary>Crea un'istanza del tipo specificato usando il costruttore predefinito di tale tipo.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a tipi non pubblici e membri se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici e i membri è limitato concedere impostato o a un suo sottoinsieme del chiamante. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="type" /> è un tipo generico aperto (ovvero, la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> non può essere un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
oppure 
La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
L'assembly che contiene <paramref name="type" /> è un assembly dinamico creato con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore chiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> è un oggetto COM ma l'identificatore di classe usato per ottenere il tipo non è valido oppure la classe identificata non è registrata.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> non è un tipo valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto da creare.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <summary>Crea un'istanza del tipo specificato usando il costruttore più adatto ai parametri specificati.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore da richiamare deve essere accessibile e deve fornire massima corrispondenza con l'elenco di argomenti specificato.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a tipi non pubblici se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici è limitato alla concessione del chiamante impostare o da un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> metodo per creare un <xref:System.String> oggetto. Chiama il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> costruttore per creare un'istanza di una stringa che contiene dieci elementi da una matrice di caratteri a partire dalla posizione quattordicesimo.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 L'esempio seguente crea una matrice di matrici cui elementi sono gli argomenti da passare a un <xref:System.String> costruttore. Viene quindi passato a ogni matrice di <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> metodo per richiamare il costruttore di stringa appropriata.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="type" /> è un tipo generico aperto (ovvero, la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> non può essere un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
oppure 
La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
L'assembly che contiene <paramref name="type" /> è un assembly dinamico creato con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore chiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.MemberAccessException" />. </para>
          </block>  
  
Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.MissingMemberException" />. </para>
          </block>  
  
Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> è un oggetto COM ma l'identificatore di classe usato per ottenere il tipo non è valido oppure la classe identificata non è registrata.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> non è un tipo valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto in cui viene creato il tipo denominato <c>typeName</c>.</param>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato nel dominio remoto specificato, usando l'assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Activator.CreateInstance%2A> quando un host deve eseguire il codice in un dominio dell'applicazione con autorizzazioni di sicurezza limitate.  
  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
> [!NOTE]
>  Questo metodo Usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> per richiedere che il chiamante immediato disponga di attendibilità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> o <paramref name="domain" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Impossibile creare un'istanza di un tipo astratto.  
  
oppure 
Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando l'assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per creare tipi non pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni di tipi non pubblici è limitato al set di concessioni del chiamante oppure a un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
 <paramref name="activationAttributes" /> non è un oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />.  
  
matrice.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Si è verificato un errore durante il tentativo di attivazione remota in una destinazione specificata in <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto da creare.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo specificato usando il costruttore più adatto ai parametri specificati.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore da richiamare deve essere accessibile e deve fornire massima corrispondenza con l'elenco di argomenti specificato.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a tipi non pubblici se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici è limitato alla concessione del chiamante impostare o da un suo sottoinsieme. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="type" /> è un tipo generico aperto (ovvero, la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> non può essere un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
oppure 
La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
L'assembly che contiene <paramref name="type" /> è un assembly dinamico creato con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore chiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> è un oggetto COM ma l'identificatore di classe usato per ottenere il tipo non è valido oppure la classe identificata non è registrata.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> non è un tipo valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto da creare.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>type</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>type</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>type</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <summary>Crea un'istanza del tipo specificato usando il costruttore più adatto ai parametri specificati.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore da richiamare deve fornire massima corrispondenza con l'elenco di argomenti specificato in base ai vincoli del binder specificato e attributi di associazione.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a tipi non pubblici e membri se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici e i membri è limitato concedere impostato o a un suo sottoinsieme del chiamante. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="type" /> è un tipo generico aperto (ovvero, la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> non può essere un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
oppure 
La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
L'assembly che contiene <paramref name="type" /> è un assembly dinamico creato con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore chiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> è un oggetto COM ma l'identificatore di classe usato per ottenere il tipo non è valido oppure la classe identificata non è registrata.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> non è un tipo valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto da creare.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>type</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>type</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>type</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo specificato usando il costruttore più adatto ai parametri specificati.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore da richiamare deve fornire massima corrispondenza con l'elenco di argomenti specificato in base ai vincoli del binder specificato e attributi di associazione.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a tipi non pubblici e membri se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni di tipi non pubblici e membri è limitato al chiamante set di autorizzazioni o a un sottoinsieme di questa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="type" /> è un tipo generico aperto (ovvero, la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> non può essere un <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
oppure 
La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
L'assembly che contiene <paramref name="type" /> è un assembly dinamico creato con <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore chiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> è un oggetto COM ma l'identificatore di classe usato per ottenere il tipo non è valido oppure la classe identificata non è registrata.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> non è un tipo valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando l'assembly denominato e il costruttore più adatto ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per creare tipi non pubblici e membri, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici e i membri è limitato concedere impostato o a un suo sottoinsieme del chiamante. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5.)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio in cui viene creato il tipo denominato <c>typeName</c>.</param>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato nel dominio remoto specificato, usando l'assembly denominato e il costruttore che corrisponde maggiormente ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Activator.CreateInstance%2A> quando un host deve eseguire il codice in un dominio dell'applicazione con autorizzazioni di sicurezza limitate.  
  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
> [!NOTE]
>  Questo metodo Usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> per richiedere che il chiamante immediato disponga di attendibilità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityInfo">Informazioni usate per prendere decisioni relative ai criteri di sicurezza e per concedere autorizzazioni di codice.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando l'assembly denominato e il costruttore più adatto ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per creare tipi non pubblici e membri, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dell'assembly che contiene i tipi non pubblici e i membri è limitato concedere impostato o a un suo sottoinsieme del chiamante. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio in cui viene creato il tipo denominato <c>typeName</c>.</param>
        <param name="assemblyName">Nome dell'assembly nel quale viene ricercato il tipo denominato <c>typeName</c>. Se <c>assemblyName</c> è <see langword="null" />, viene effettuata la ricerca nell'assembly in esecuzione.</param>
        <param name="typeName">Nome completo del tipo di oggetto preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, corrisponde a una matrice che contiene un unico oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. L'oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifica l'URL necessario per attivare un oggetto remoto.</param>
        <param name="securityAttributes">Informazioni usate per prendere decisioni relative ai criteri di sicurezza e per concedere autorizzazioni di codice.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato nel dominio remoto specificato, usando l'assembly denominato e il costruttore che corrisponde maggiormente ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Activator.CreateInstance%2A> quando un host deve eseguire il codice in un dominio dell'applicazione con autorizzazioni di sicurezza limitate.  
  
 Usare <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> per scartare il valore restituito.  
  
> [!NOTE]
>  Questo metodo Usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> per richiedere che il chiamante immediato disponga di attendibilità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Il tipo COM non è stato ottenuto tramite <see cref="Overload:System.Type.GetTypeFromProgID" /> o <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">La creazione di tipi <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" />, o di matrici di questi tipi, non è supportata.  
  
oppure 
 <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
Il costruttore che corrisponde maggiormente a <paramref name="args" /> ha argomenti <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.  
  
oppure 
La codebase o il nome dell'assembly non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo da creare.</typeparam>
        <summary>Crea un'istanza del tipo designato dal parametro di tipo generico specificato, usando il costruttore senza parametri.</summary>
        <returns>Riferimento all'oggetto di recente creazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Activator.CreateInstance%60%601> metodo generico viene usato dai compilatori per implementare la creazione di istanze di tipi specificati dai parametri di tipo. Ad esempio, nel metodo generico seguente, l'implementazione di `new T()` (`gcnew T()` in C++) usa il <xref:System.Activator.CreateInstance%60%601> metodo generico.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 In generale, non viene utilizzato per il <xref:System.Activator.CreateInstance%60%601> codice generico metodo nell'applicazione, perché il tipo deve essere noto in fase di compilazione. Se il tipo è noto in fase di compilazione, è possibile usare la creazione di istanze normale sintassi (`new` operatore in c# `New` in Visual Basic `gcnew` in C++). Se il tipo non è noto in fase di compilazione, è possibile chiamare un overload non generico di <xref:System.Activator.CreateInstance%2A>.  
  
 Non sono presenti overload del <xref:System.Activator.CreateInstance%60%601> metodo generico che accettano elenchi di argomenti, perché esegue l'overload non generico di <xref:System.Activator.CreateInstance%2A> forniscono già risoluzione del costruttore ad associazione tardiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.MissingMemberException" />. </para>
          </block>  
  
Il tipo specificato per <paramref name="T" /> non ha un costruttore senza parametri.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando il file di assembly denominato e il costruttore più adatto ai parametri specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato usando il file di assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Activator.CreateInstanceFrom%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Activator> classe.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'oggetto <see cref="T:System.Security.Permissions.FileIOPermission" /> necessario.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto in cui viene creato il tipo denominato <c>typeName</c>.</param>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato nel dominio remoto specificato, usando il file di assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Activator.CreateInstanceFrom%2A> quando un host deve eseguire il codice in un dominio dell'applicazione con autorizzazioni di sicurezza limitate.  
  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
> [!NOTE]
>  Questo metodo Usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> per richiedere che il chiamante immediato disponga di attendibilità.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'oggetto <see cref="T:System.Security.Permissions.FileIOPermission" /> necessario.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato usando il file di assembly denominato e il costruttore predefinito.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'oggetto <see cref="T:System.Security.Permissions.FileIOPermission" /> necessario.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando il file di assembly denominato e il costruttore più adatto ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione <see cref="T:System.Security.Permissions.FileIOPermission" /> necessaria.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto in cui viene creato il tipo denominato <c>typeName</c>.</param>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato nel dominio remoto specificato, usando i file di assembly denominato e il costruttore che corrisponde maggiormente ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Activator.CreateInstanceFrom%2A> quando un host deve eseguire il codice in un dominio dell'applicazione con autorizzazioni di sicurezza limitate.  
  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere le sezioni di eccezioni dei <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'oggetto <see cref="T:System.Security.Permissions.FileIOPermission" /> necessario.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyName" /> è stato compilato per una versione di Common Language Runtime successiva alla versione attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityInfo">Informazioni usate per prendere decisioni relative ai criteri di sicurezza e per concedere autorizzazioni di codice.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato, usando il file di assembly denominato e il costruttore più adatto ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione <see cref="T:System.Security.Permissions.FileIOPermission" /> necessaria.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio remoto in cui viene creato il tipo denominato <c>typeName</c>.</param>
        <param name="assemblyFile">Nome di un file contenente un assembly nel quale viene ricercato il tipo denominato <c>typeName</c>.</param>
        <param name="typeName">Nome del tipo preferito.</param>
        <param name="ignoreCase">
          <see langword="true" /> per specificare che la ricerca di <c>typeName</c> non fa distinzione tra maiuscole e minuscole, <see langword="false" /> per specificare che la ricerca fa distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che usa <c>bindingAttr</c> e <c>args</c> per cercare e identificare il costruttore <c>typeName</c>. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice di argomenti che corrisponde ai parametri del costruttore da chiamare in quanto a numero, ordine e tipo. Se <c>args</c> è una matrice vuota oppure è <see langword="null" />, viene chiamato il costruttore che non accetta parametri, ovvero il costruttore predefinito.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per prendere decisioni relative ai criteri di sicurezza e per concedere autorizzazioni di codice.</param>
        <summary>Crea un'istanza del tipo il cui nome è specificato nel dominio remoto specificato, usando i file di assembly denominato e il costruttore che corrisponde maggiormente ai parametri specificati.</summary>
        <returns>Handle di cui deve essere annullato il wrapping per accedere all'istanza appena creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Activator.CreateInstanceFrom%2A> quando un host deve eseguire il codice in un dominio dell'applicazione con autorizzazioni di sicurezza limitate.  
  
 Usare il <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metodo per l'operazione unwrap il valore restituito.  
  
> [!NOTE]
>  Questo metodo Usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> per richiedere che il chiamante immediato disponga di attendibilità.  
  
 Per informazioni su altri tipi di eccezioni che possono essere generate dai metodi chiamati, vedere la sezione delle eccezioni di <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MemberAccessException">Non è possibile creare un'istanza di una classe astratta o questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il costruttore, richiamato tramite reflection, ha generato un'eccezione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'oggetto <see cref="T:System.Security.Permissions.FileIOPermission" /> necessario.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> non è una matrice vuota e il tipo creato non deriva da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime (CLR) e <paramref name="assemblyName" /> è stato compilato per una versione di CLR successiva a quella attualmente caricata. Si noti che le versioni 2.0, 3.0 e 3.5 di .NET Framework usano tutte CLR versione 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la possibilità di eseguire la ricerca dei percorsi di directory e leggerne il contenuto. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a tipi non pubblici e i membri indipendentemente dal set di concessioni. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un proxy per un oggetto o un servizio Web XML conosciuto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo dell'oggetto noto al quale si vuole effettuare la connessione.</param>
        <param name="url">URL dell'oggetto noto.</param>
        <summary>Crea un proxy per l'oggetto noto indicato dal tipo e dall'URL specificati.</summary>
        <returns>Proxy che punta a un endpoint messo a disposizione dall'oggetto noto richiesto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il proxy per inviare messaggi all'oggetto remoto. Non vengono inviati messaggi attraverso la rete fino a quando non viene chiamato un metodo sul proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> o <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> non è sottoposto al marshalling da un riferimento e non è un'interfaccia.</exception>
        <exception cref="T:System.MemberAccessException">Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Tipo dell'oggetto noto al quale si vuole effettuare la connessione.</param>
        <param name="url">URL dell'oggetto noto.</param>
        <param name="state">Dati specifici del canale o <see langword="null" />.</param>
        <summary>Crea un proxy per l'oggetto noto indicato dal tipo, dall'URL e dai dati di canale specificati.</summary>
        <returns>Proxy che punta a un endpoint messo a disposizione dall'oggetto noto richiesto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il proxy per inviare messaggi all'oggetto remoto. Non vengono inviati messaggi attraverso la rete fino a quando non viene chiamato un metodo sul proxy.  
  
 Il `state` parametro comunica informazioni al canale e viene passato per il <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> o <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> non è sottoposto al marshalling da un riferimento e non è un'interfaccia.</exception>
        <exception cref="T:System.MemberAccessException">Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per accedere alle classi gestite dal codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Oggetto che riceve un puntatore all'oggetto di informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per accedere alle classi gestite dal codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Quando termina, questo metodo contiene un puntatore a un percorso che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto. Questo parametro viene passato non inizializzato.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per accedere alle classi gestite dal codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">ID dispatch che identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, matrice di argomenti DISPID per argomenti denominati e conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore al percorso in cui archiviare il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sulle eccezioni.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per accedere alle classi gestite dal codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
  </Members>
</Type>