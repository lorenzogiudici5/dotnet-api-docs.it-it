<Type Name="Single" FullName="System.Single">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7590cc7037371cad434620354b5fa48848bb03e8" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52235984" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un numero a virgola mobile a precisione singola.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single> tipo di valore rappresenta un numero a 32 bit e precisione singola con valori compresi tra e 3,402823e38 negativo e 3,402823e38 positivo, nonché zero positivo o negativo <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>e non un numero (<xref:System.Single.NaN>). Consente di rappresentare i valori che sono molto grandi (ad esempio, le distanze tra pianeti o galassie) o molto piccolo (ad esempio, la massa modellistica della materia in chilogrammi) e che sono spesso imprecise (ad esempio la distanza da terra a un altro sistema solare ). Il <xref:System.Single> tipo è conforme a IEC 60559: 1989 (IEEE 754) per l'aritmetica binaria a virgola mobile.  
  
 Questo argomento include le sezioni seguenti:  
  
-   [Rappresentazione a virgola mobile e precisione](#Precision)  
  
-   [Test dell'uguaglianza](#Equality)  
  
-   [Le eccezioni e valori a virgola mobile](#Exceptions)  
  
-   [Conversione del tipo e la struttura Single](#Conversion)  
  
-   [Funzionalità a virgola mobile](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> fornisce metodi per confrontare le istanze di questo tipo, per convertire il valore di un'istanza alla relativa rappresentazione di stringa e convertire la rappresentazione di stringa di un numero a un'istanza di questo tipo. Per informazioni su come i codici di specifica del formato controllano la rappresentazione di stringa dei tipi di valore, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md), [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md), e [numerico personalizzato Stringhe di formato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Rappresentazione a virgola mobile e precisione  
 Il <xref:System.Single> tipo di dati archivia valori a virgola mobile a precisione singola in un formato binario a 32 bit, come illustrato nella tabella seguente:  
  
|Parte|Bit|  
|----------|----------|  
|Significando o nella mantissa|0-22|  
|Esponente|23-30|  
|Sign (0 = positivo, 1 = negativo)|31|  
  
 Proprio come le frazioni decimali in grado di rappresentare esattamente alcuni valori frazionari (ad esempio 1 o 3 o <xref:System.Math.PI?displayProperty=nameWithType>), frazioni binarie in grado di rappresentare alcuni valori frazionari. Ad esempio, 2 o 10, che viene rappresentato esattamente da. 2 per una frazione decimale, è rappresentato da.0011111001001100 come frazione binaria, con il modello "1100" ripetuta all'infinito. In questo caso, il valore a virgola mobile e fornisce una rappresentazione imprecisa del numero che rappresenta. Eseguire altre operazioni matematiche sul valore a virgola mobile originale spesso aumenta la mancanza di precisione. Ad esempio, se si confrontano i risultati della moltiplicazione.3 da 10 e aggiungono.3 a.3 nove tentativi, verrà visualizzato tale aggiunta produce risultati meno precisi, dal momento che implica otto più operazioni di moltiplicazione. Si noti che questa disparità è evidente solo se si visualizza due <xref:System.Single> valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md)che, se necessario, vengono visualizzati tutti i 9 cifre di precisione supportato dal <xref:System.Single> tipo.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Poiché alcuni numeri non possono essere rappresentati esattamente come valori binari frazionari, numeri a virgola mobile possono solo i numeri reali approssimativi.  
  
 Tutti i numeri a virgola mobile hanno un numero limitato di cifre significative, che determina anche l'accuratezza con cui un valore a virgola mobile offre un'approssimazione di un numero reale. Oggetto <xref:System.Single> valore ha fino a 7 cifre decimali di precisione, anche se internamente viene gestito un massimo di 9 cifre. Ciò significa che alcune operazioni a virgola mobile potrebbero non essere la precisione per impostare un valore a virgola mobile. Nell'esempio seguente definisce un valore a virgola mobile a precisione singola elevato e quindi aggiunge il prodotto di <xref:System.Single.Epsilon?displayProperty=nameWithType> e un milione di miliardi ad esso. Tuttavia, il prodotto è troppo piccolo per modificare il valore a virgola mobile originale. La cifra meno significativa è dei millesimi, mentre la cifra più significativa del prodotto è 10<sup>-30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Precisione limitata di un numero a virgola mobile ha diverse conseguenze:  
  
-   Due numeri a virgola mobile apparentemente uguali per una particolare precisione potrebbero non risultare uguali perché le cifre meno significative sono diverse. Nell'esempio seguente, una serie di numeri verranno sommati e il totale viene confrontato con il totale previsto. Anche se i due valori sembrano uguali, una chiamata al `Equals` metodo indica che non si trovano.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Se si modificano gli elementi di formato nel <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> istruzione dal `{0}` e `{1}` al `{0:R}` e `{1:R}` per visualizzare tutte le cifre significative dei due <xref:System.Single> valori, è chiaro che due valori sono diversi perché di una perdita di precisione durante le operazioni di addizione. In questo caso, il problema può essere risolto tramite la chiamata di <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> metodo per arrotondare il <xref:System.Single> valori alla precisione desiderato prima di eseguire il confronto.  
  
-   Un'operazione matematica o di confronto che usa un numero a virgola mobile potrebbe non produrre lo stesso risultato se viene usato un numero decimale, perché il numero a virgola mobile binario potrebbe non essere uguale al numero decimale. Un esempio precedente illustrato questo visualizzando il risultato della moltiplicazione.3 da 10 e aggiunta.3 a.3 nove volte.  
  
     Quando la precisione numerica operazioni con i valori frazionari è importante, usare il <xref:System.Decimal> invece del tipo di <xref:System.Single> tipo. Quando la precisione numerica operazioni con i valori integrali oltre l'intervallo del <xref:System.Int64> o <xref:System.UInt64> tipi è importante, utilizzare il <xref:System.Numerics.BigInteger> tipo.  
  
-   Un valore potrebbe non eseguire il round trip se è interessato un numero a virgola mobile. Eseguire il round trip si ha un valore se un'operazione converte un numero a virgola mobile originale in un altro formato, un'operazione inversa trasforma il formato convertito nuovamente in un numero a virgola mobile e il numero a virgola mobile finale è uguale all'istanza originale numero a virgola mobile. Il round trip potrebbe non riuscire perché uno o più cifre meno significative vengono perse o modificate in una conversione. Nell'esempio seguente tre <xref:System.Single> valori vengono convertiti in stringhe e salvati in un file. Come illustrato nell'output, anche se i valori sembrano identiche, i valori ripristinati non sono uguali ai valori originali.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     In questo caso, i valori possono essere correttamente sottoposto a round-trip tramite il "G9" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) per mantenere la precisione completa dei <xref:System.Single> valori, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> i valori hanno precisione inferiore rispetto a <xref:System.Double> valori. Oggetto <xref:System.Single> valore che viene convertito in un equivalente apparentemente <xref:System.Double> spesso non è uguale il <xref:System.Double> valore a causa delle differenze nella precisione. Nell'esempio seguente, il risultato di operazioni di divisione identici viene assegnato a un <xref:System.Double> valore e un <xref:System.Single> valore. Dopo il <xref:System.Single> viene eseguito il cast di valore a un <xref:System.Double>, viene illustrato un confronto tra i due valori che non sono uguali.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Per evitare questo problema, usare il <xref:System.Double> del tipo di dati al posto del <xref:System.Single> tipo di dati o usare il <xref:System.Math.Round%2A> metodo in modo che entrambi i valori hanno la stessa precisione.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Test dell'uguaglianza  
 Per essere considerati uguali, due <xref:System.Single> valori devono rappresentare valori identici. Tuttavia, a causa delle differenze nella precisione tra i valori o a causa di una perdita di precisione da uno o entrambi i valori, valori a virgola mobile che dovrebbero essere identici spesso risultare venga fatta a causa delle differenze nelle cifre meno significative. Di conseguenza, le chiamate al <xref:System.Single.Equals%2A> metodo per determinare se due valori sono uguali o chiamate per il <xref:System.Single.CompareTo%2A> metodo per stabilire la relazione tra due <xref:System.Single> valori, spesso provocare risultati imprevisti. Ciò è evidente nell'esempio seguente, in cui due apparentemente uguali <xref:System.Single> valori risultare venga fatta, perché il primo valore è 7 cifre di precisione, mentre il secondo valore è 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 I valori calcolati che seguire diversi percorsi di codice e che vengono modificati in modi diversi spesso rivelino non uguali. Nell'esempio seguente, una <xref:System.Single> viene elevato al quadrato valore e quindi viene calcolata la radice quadrata per ripristinare il valore originale. Un secondo <xref:System.Single> viene moltiplicato per 3.51 ed elevato al quadrato prima che la radice quadrata del risultato viene diviso per 3.51 per ripristinare il valore originale. Anche se i due valori sembrano identiche, una chiamata al <xref:System.Single.Equals%28System.Single%29> metodo indica che non sono uguali. Utilizzando la stringa di formato standard "G9" per restituire una stringa di risultato che consente di visualizzare tutte le cifre significative della ognuno <xref:System.Single> valore indica che il secondo valore è.0000000000001 minore rispetto alla prima.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 Nei casi in cui è probabile che influiscono sul risultato di un confronto di una perdita di precisione, è possibile usare le tecniche seguenti invece di chiamare il <xref:System.Single.Equals%2A> o <xref:System.Single.CompareTo%2A> metodo:  
  
-   Chiamare il <xref:System.Math.Round%2A?displayProperty=nameWithType> metodo per assicurarsi che entrambi i valori hanno la stessa precisione. L'esempio seguente modifica un esempio precedente per usare questo approccio, in modo che due valori frazionari sono equivalenti.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Si noti che il problema di precisione sono ancora valide per l'arrotondamento dei valori punto intermedio. Per altre informazioni, vedere il metodo <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Verificare l'uguaglianza approssimativo anziché l'uguaglianza. Questa tecnica che è necessario definire entrambi assoluto quantità mediante il quale i due valori possono differire ma ancora essere uguale o che si definiscono una relativa quantità mediante il quale il valore più piccolo possibile divergono dal valore più grande.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> In alcuni casi viene utilizzata come misura della distanza tra due assoluta <xref:System.Single> valori durante la verifica dell'uguaglianza.  Tuttavia <xref:System.Single.Epsilon?displayProperty=nameWithType> misura il valore più piccolo che può essere aggiunto a o sottratto da, un <xref:System.Single> il cui valore è uguale a zero. Per la maggior parte delle positivo e negativo <xref:System.Single> valori, il valore di <xref:System.Single.Epsilon?displayProperty=nameWithType> è troppo piccolo per essere rilevato. Pertanto, tranne i valori che sono pari a zero, non è consigliabile l'uso nei test per verificarne l'uguaglianza.  
  
     L'esempio seguente usa il secondo approccio per definire un `IsApproximatelyEqual` metodo che verifica la relativa differenza tra due valori. Anche di mette a confronto i risultati di chiamate per il `IsApproximatelyEqual` metodo e il <xref:System.Single.Equals%28System.Single%29> (metodo).  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Le eccezioni e valori a virgola mobile  
 Operazioni con i valori a virgola mobile non generano eccezioni, a differenza delle operazioni con tipi integrali, che generano eccezioni in caso di operazioni non valide, ad esempio divisione per zero o di overflow.  In alternativa, in queste situazioni, il risultato di un'operazione a virgola mobile è zero, un numero infinito positivo, infinito negativo o non è un numero (NaN):  
  
-   Se il risultato di un'operazione a virgola mobile è troppo piccolo per il formato di destinazione, il risultato è zero. Ciò può verificarsi quando vengono moltiplicati due numeri a virgola mobile molto piccoli, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Se la grandezza del risultato dell'operazione a virgola mobile supera l'intervallo del formato di destinazione, il risultato dell'operazione è <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>, nel modo appropriato per il segno del risultato. Il risultato di un'operazione che causa l'overflow <xref:System.Single.MaxValue?displayProperty=nameWithType> viene <xref:System.Single.PositiveInfinity>e il risultato di un'operazione che causa l'overflow <xref:System.Single.MinValue?displayProperty=nameWithType> è <xref:System.Single.NegativeInfinity>, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> comporta anche da una divisione per zero con un dividendi positivi, e <xref:System.Single.NegativeInfinity> dà come risultato una divisione per zero con dividendo negativo.  
  
-   Se un'operazione a virgola mobile non è valida, il risultato dell'operazione è <xref:System.Single.NaN>. Ad esempio, <xref:System.Single.NaN> risultati dalle operazioni seguenti:  
  
    -   Divisione per zero con dividendo pari a zero. Si noti che gli altri casi di divisione per zero risultati in uno <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>.  
  
    -   Qualsiasi operazione a virgola mobile con input non valido. Ad esempio, il tentativo di trovare la radice quadrata di un valore negativo restituisce <xref:System.Single.NaN>.  
  
    -   Qualsiasi operazione con un argomento il cui valore è <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Conversioni di tipi e la struttura del singola  
 Il <xref:System.Single> struttura non definisce qualsiasi operatore di conversione esplicita o implicita, invece, le conversioni vengono implementate dal compilatore.  
  
 Nella tabella seguente sono elencate le conversioni possibili di un valore di altri tipi numerici primitivi a un <xref:System.Single> valore, indicando anche se la conversione è widening o narrowing e se ne risultante <xref:System.Single> potrebbe essere meno preciso rispetto di valore originale.  
  
|Conversione da|Widening o narrowing|Possibile perdita di precisione|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|No|  
|<xref:System.Decimal>|Widening<br /><br /> Si noti che in c# è necessario un operatore cast.|Sì. <xref:System.Decimal> supporta 29 cifre decimali di precisione; <xref:System.Single> supporta 9.|  
|<xref:System.Double>|Narrowing; vengono convertiti in valori out-of-range <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> o <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Sì. <xref:System.Double> supporta 17 cifre decimali di precisione; <xref:System.Single> supporta 9.|  
|<xref:System.Int16>|Widening|No|  
|<xref:System.Int32>|Widening|Sì. <xref:System.Int32> supporta 10 cifre decimali di precisione; <xref:System.Single> supporta 9.|  
|<xref:System.Int64>|Widening|Sì. <xref:System.Int64> supporta 19 cifre decimali di precisione; <xref:System.Single> supporta 9.|  
|<xref:System.SByte>|Widening|No|  
|<xref:System.UInt16>|Widening|No|  
|<xref:System.UInt32>|Widening|Sì. <xref:System.UInt32> supporta 10 cifre decimali di precisione; <xref:System.Single> supporta 9.|  
|<xref:System.UInt64>|Widening|Sì. <xref:System.Int64> supporta 20 cifre decimali di precisione; <xref:System.Single> supporta 9.|  
  
 Nell'esempio seguente converte il valore minimo o massimo di altri tipi numerici primitivi in un <xref:System.Single> valore.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Inoltre, il <xref:System.Double> i valori <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> convertire a <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, rispettivamente.  
  
 Si noti che la conversione del valore di alcuni tipi numeric a un <xref:System.Single> valore possa comportare una perdita di precisione. Come illustrato nell'esempio, una perdita di precisione viene possibile quando si convertono <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, e <xref:System.UInt64> valori <xref:System.Single> valori.  
  
 La conversione di un <xref:System.Single> valore per un <xref:System.Double> è una conversione verso un. La conversione può comportare una perdita di precisione se il <xref:System.Double> tipo non dispone di una rappresentazione esatta per il <xref:System.Single> valore.  
  
 La conversione di un <xref:System.Single> valore su un valore di qualsiasi tipo numerico primitivo diverso da un <xref:System.Double> è una conversione di narrowing e richiede un operatore di cast (in c#) o un metodo di conversione (in Visual Basic). Valori non compresi nell'intervallo del tipo di dati di destinazione, che sono definiti per il tipo di destinazione `MinValue` e `MaxValue` le proprietà, si comportano come illustrato nella tabella seguente.  
  
|Tipo di destinazione|Risultato|  
|-----------------|------------|  
|Qualsiasi tipo integrale|Un <xref:System.OverflowException> eccezione se la conversione viene eseguita in un contesto controllato.<br /><br /> Se la conversione viene eseguita in un contesto non verificato (impostazione predefinita in c#), l'operazione di conversione ha esito positivo ma il valore causa un overflow.|  
|<xref:System.Decimal>|Un <xref:System.OverflowException> eccezione,|  
  
 È inoltre <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> generare un <xref:System.OverflowException> per le conversioni da valori integer in un contesto controllato, ma questi overflow di valori quando convertiti in numeri interi in un contesto non verificato. Per le conversioni verso <xref:System.Decimal>, genera sempre un' <xref:System.OverflowException>. Per le conversioni verso <xref:System.Double>, vengono convertite <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, rispettivamente.  
  
 Si noti che tramite la conversione può comportare una perdita di precisione un <xref:System.Single> valore a un altro tipo numerico. Nel caso di conversione non integrali <xref:System.Single> valori, come illustrato nell'output dell'esempio, il componente frazionario viene perso quando il <xref:System.Single> valore viene arrotondato (come in Visual Basic) o troncato (come in c#). Per le conversioni verso <xref:System.Decimal> valori, il <xref:System.Single> valore non può avere una rappresentazione esatta nel tipo di dati di destinazione.  
  
 L'esempio seguente converte un numero di <xref:System.Single> valori a diversi altri tipi numerici. Le conversioni si verificano in un contesto controllato in Visual Basic (predefinito) e nel linguaggio c# (perché il [controllato](~/docs/csharp/language-reference/keywords/checked.md) parola chiave). L'output dell'esempio mostra il risultato per le conversioni in sia selezionato un contesto non verificato. È possibile eseguire conversioni in un contesto non verificato in Visual Basic per la compilazione con il `/removeintchecks+` opzione del compilatore e nel linguaggio c# Commentando il `checked` istruzione.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Per altre informazioni sulla conversione dei tipi numerici, vedere [conversione di tipi in .NET Framework](~/docs/standard/base-types/type-conversion.md) e [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funzionalità a virgola mobile  
 Il <xref:System.Single> struttura e i tipi correlati forniscono i metodi per eseguire le seguenti categorie di operazioni:  
  
-   **Confronto tra valori**. È possibile chiamare il <xref:System.Single.Equals%2A> metodo per determinare se due <xref:System.Single> i valori sono uguali, oppure il <xref:System.Single.CompareTo%2A> metodo per stabilire la relazione tra due valori.  
  
     Il <xref:System.Single> struttura supporta anche un set completo di operatori di confronto. Ad esempio, è possibile di test per verificarne l'uguaglianza o disuguaglianza, o determinare se un valore è maggiore o uguale a un altro valore. Se uno degli operandi è un <xref:System.Double>, il <xref:System.Single> valore viene convertito in un <xref:System.Double> prima di eseguire il confronto. Se uno degli operandi è un tipo integrale, viene convertito in un <xref:System.Single> prima di eseguire il confronto. Anche se queste sono di ampliamento, essi può comportare una perdita di precisione.  
  
    > [!WARNING]
    >  A causa delle differenze nella precisione, due <xref:System.Single> valori che si prevedono di essere uguali potrebbero risultare venga fatta, che influisce sul risultato del confronto. Vedere le [test dell'uguaglianza](#Equality) sezione per altre informazioni sul confronto tra due <xref:System.Single> valori.  
  
     È inoltre possibile chiamare il <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, e <xref:System.Single.IsNegativeInfinity%2A> metodi da testare per questi valori speciali.  
  
-   **Operazioni matematiche**. Operazioni aritmetiche comuni quali addizione, sottrazione, moltiplicazione e divisione vengono implementate da compilatori di linguaggio e istruzioni Common Intermediate Language (CIL) anziché da <xref:System.Single> metodi. Se l'altro operando in un'operazione matematica è una <xref:System.Double>, il <xref:System.Single> viene convertito in un <xref:System.Double> prima di eseguire l'operazione e il risultato dell'operazione è anche un <xref:System.Double> valore. Se l'altro operando è un tipo integrale, viene convertito in un <xref:System.Single> prima di eseguire l'operazione e il risultato dell'operazione è anche un <xref:System.Single> valore.  
  
     È possibile eseguire altre operazioni matematiche chiamando `static` (`Shared` in Visual Basic) in metodi il <xref:System.Math?displayProperty=nameWithType> classe. Sono inclusi metodi aggiuntivi aritmetici più utilizzati (, ad esempio <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, e <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometry (ad esempio <xref:System.Math.Cos%2A?displayProperty=nameWithType> e <xref:System.Math.Sin%2A?displayProperty=nameWithType>) e calcolo (ad esempio <xref:System.Math.Log%2A?displayProperty=nameWithType>).  In tutti i casi, il <xref:System.Single> valore viene convertito in un <xref:System.Double>.  
  
     È inoltre possibile modificare i singoli bit di un <xref:System.Single> valore. Il <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> metodo restituisce il modello di bit in una matrice di byte.  Passando la matrice di byte per il <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> metodo, è inoltre possibile mantenere il <xref:System.Single> schema di valore del bit in un integer a 32 bit.  
  
-   **Arrotondamento**. Arrotondamento viene spesso usato come una tecnica per ridurre l'impatto delle differenze tra i valori causati da problemi di rappresentazione a virgola mobile e precisione. È possibile arrotondare un <xref:System.Single> valore chiamando il <xref:System.Math.Round%2A?displayProperty=nameWithType> (metodo). Si noti tuttavia che il <xref:System.Single> valore viene convertito in un <xref:System.Double> prima il metodo viene chiamato, la conversione può comportare una perdita di precisione.  
  
-   **Formattazione**. È possibile convertire un <xref:System.Single> valore alla relativa rappresentazione di stringa chiamando il <xref:System.Single.ToString%2A> metodo oppure usando la [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità. Per informazioni sul modo in cui le stringhe di formato controllano la rappresentazione di stringa dei valori a virgola mobile, vedere la [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md) argomenti.  
  
-   **Analisi di stringhe**. È possibile convertire la rappresentazione di stringa del valore a virgola mobile a un <xref:System.Single> valore chiamando il <xref:System.Single.Parse%2A> o <xref:System.Single.TryParse%2A> (metodo). Se l'operazione di analisi non riesce, il <xref:System.Single.Parse%2A> metodo genera un'eccezione, mentre la <xref:System.Single.TryParse%2A> restituzione del metodo `false`.  
  
-   **Conversione del tipo**. Il <xref:System.Single> struttura fornisce un'implementazione esplicita dell'interfaccia per il <xref:System.IConvertible> interfaccia, che supporta la conversione tra qualsiasi due tipi di dati .NET Framework standard. I compilatori di linguaggio supportano anche la conversione implicita di valori per tutti gli altri tipi numerici standard tranne la conversione di <xref:System.Double> a <xref:System.Single> valori. Conversione di un valore di qualsiasi tipo numerico standard diverso da un <xref:System.Double> a un <xref:System.Single> è una conversione verso e non richiede l'uso di un metodo di conversione o di operatore di cast.  
  
     Conversione di valori integer a 32 e 64 bit, tuttavia, può comportare una perdita di precisione. La tabella seguente elenca le differenze di precisione per 32 bit, 64 bit, e <xref:System.Double> tipi:  
  
    |Tipo|Precisione massima (in cifre decimali)|Precisione interna (in cifre decimali)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> e <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> e <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Il problema di precisione più di frequente riguarda <xref:System.Single> i valori che vengono convertiti in <xref:System.Double> valori. Nell'esempio seguente, due valori prodotti da operazioni di divisione identiche sono diversi, perché uno dei valori è un valore di virgola mobile e precisione singola convertito in un <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri di questo tipo sono thread-safe. I membri che sembrano modificare lo stato dell'istanza è in realtà restituiscono una nuova istanza inizializzata con il nuovo valore. Come con qualsiasi altro tipo, la lettura e scrittura in una variabile condivisa che contiene un'istanza di questo tipo deve essere protetto da un blocco per garantire la thread safety.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta questa istanza con un oggetto specificato o con un'altra istanza di <see cref="T:System.Single" /> e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore dell'oggetto specificato o dell'altra istanza di <see cref="T:System.Single" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare o <see langword="null" />.</param>
        <summary>Confronta questa istanza con un oggetto specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e di <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> Minore di zero 
 </term><description> L'istanza è minore di <paramref name="value" />.  
  
oppure 
L'istanza non è un numero (<see cref="F:System.Single.NaN" />) e <paramref name="value" /> è un numero.  
  
 </description></item><item><term> Zero 
 </term><description> L'istanza è uguale a <paramref name="value" />.  
  
oppure 
L'istanza e il valore non sono un numero (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />, o <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> L'istanza è maggiore di <paramref name="value" />.  
  
oppure 
L'istanza è un numero e <paramref name="value" /> non è un numero (<see cref="F:System.Single.NaN" />).  
  
oppure 
 <paramref name="value" /> è <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` il parametro deve essere `null` o un'istanza di <xref:System.Single>; in caso contrario, viene generata un'eccezione. Qualsiasi istanza di <xref:System.Single>, indipendentemente dal relativo valore, viene considerato maggiore `null`.  
  
 I valori devono essere identici per essere considerate uguali. In particolare quando i valori a virgola mobile dipendono da più operazioni matematiche, è comune per la perdita di precisione e i relativi valori essere quasi identici tranne che per le cifre meno significative. Per questo motivo, il valore restituito del <xref:System.Single.CompareTo%2A> metodo può sembrare sorprendente in alcuni casi. Ad esempio, moltiplicazione per un particolare valore seguito da una divisione per lo stesso valore deve produrre il valore originale, ma nell'esempio seguente, il valore calcolato risulta maggiore del valore originale. Visualizzazione di tutte le cifre significative dei due valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indica che il valore calcolato è diverso dal valore originale in relative cifre meno significative. Per informazioni sulla gestione di questi confronti, vedere la sezione Osservazioni del <xref:System.Single.Equals%28System.Single%29> (metodo).  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Questo metodo viene implementato per supportare il <xref:System.IComparable> interfaccia. Si noti che, sebbene una <xref:System.Single.NaN> non è considerato uguale a un altro <xref:System.Single.NaN> (anche se stesso), il <xref:System.IComparable> che richiede l'interfaccia `A.CompareTo(A)` restituiscono zero.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.CompareTo%2A> (metodo).  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un oggetto <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Numero a virgola mobile a precisione singola da confrontare.</param>
        <summary>Confronta questa istanza con un numero a virgola mobile a precisione singola specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore del numero a virgola mobile a precisione singola specificato.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e di <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> Minore di zero 
 </term><description> L'istanza è minore di <paramref name="value" />.  
  
oppure 
L'istanza non è un numero (<see cref="F:System.Single.NaN" />) e <paramref name="value" /> è un numero.  
  
 </description></item><item><term> Zero 
 </term><description> L'istanza è uguale a <paramref name="value" />.  
  
oppure 
Sia l'istanza che il <paramref name="value" /> non sono un numero (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> o <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> L'istanza è maggiore di <paramref name="value" />.  
  
oppure 
L'istanza è un numero e <paramref name="value" /> non è un numero (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori devono essere identici per essere considerate uguali. È comune per i valori a virgola mobile a perdita di precisione e diventare quasi identici tranne che per le cifre meno significative, in particolare quando i valori dipendono più operazioni matematiche. Per questo motivo, il valore restituito del <xref:System.Single.CompareTo%2A> metodo può a volte sembrare sorprendente. Moltiplicazione per qualsiasi valore seguito da una divisione per lo stesso valore, ad esempio, deve produrre il valore originale. Tuttavia, nell'esempio seguente, il valore calcolato risulta maggiore del valore originale. Visualizzazione di tutte le cifre significative dei due valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indica che il valore calcolato è diverso dal valore originale in relative cifre meno significative. Per informazioni sulla gestione di questi confronti, vedere la sezione Osservazioni del <xref:System.Single.Equals%28System.Single%29> (metodo).  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Questo metodo implementa il <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto il <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> metodo perché non è necessario convertire il `value` parametro a un oggetto.  
  
 Si noti che, anche se un oggetto il cui valore è <xref:System.Single.NaN> non viene considerato uguale a un altro oggetto il cui valore è <xref:System.Single.NaN> (anche se stesso), il <xref:System.IComparable%601> che richiede l'interfaccia `A.CompareTo(A)` restituiscono zero.  
  
## <a name="widening-conversions"></a>conversioni verso un tipo di dati più grande  
 A seconda del linguaggio di programmazione, potrebbe essere possibile codificare una <xref:System.Single.CompareTo%2A> metodo in cui il tipo di parametro ha un minor numero di bit (è più stretta) rispetto al tipo di istanza. Questo è possibile perché alcuni linguaggi di programmazione eseguono conversioni implicite che rappresenta il parametro come un tipo con il numero di bit dell'istanza.  
  
 Ad esempio, si supponga che il tipo di istanza sia <xref:System.Single> e il tipo di parametro è <xref:System.Int32>. Il compilatore Microsoft c# genera le istruzioni per rappresentare il valore del parametro come un <xref:System.Single> , quindi genera un <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> metodo che confronta i valori dell'istanza e la rappresentazione ampliata del parametro.  
  
 Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento implicite dei tipi numerici. Per altre informazioni, vedere la [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md) argomento.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 Esempio di codice seguente illustra le versioni generiche e del <xref:System.Single.CompareTo%2A> metodo per diversi tipi di riferimento e valore.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Rappresenta il valore <see cref="T:System.Single" /> positivo più piccolo maggiore di zero. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Single.Epsilon> proprietà riflette il valore positivo più piccolo <xref:System.Single> valore significativo nelle operazioni numeriche o confronti quando il valore della <xref:System.Single> istanza è uguale a zero. Ad esempio, il codice seguente mostra che zero e <xref:System.Single.Epsilon> sono considerati uguali ai valori, mentre zero e la metà del valore di <xref:System.Single.Epsilon> sono considerati uguali.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Più precisamente, il formato a virgola mobile a precisione singola è costituito da un segno, una mantissa a 23 bit o significando e un esponente a 8 bit. Come illustrato nell'esempio seguente, zero ha un esponente di-126 e una mantissa pari a 0. <xref:System.Single.Epsilon> ha un esponente di-126 e una mantissa a 1. Ciò significa che <xref:System.Single.Epsilon?displayProperty=nameWithType> è positivo più piccolo <xref:System.Single> valore maggiore di zero, che rappresenta il valore minimo possibile e l'incremento più piccolo possibile per un <xref:System.Single> cui esponente è-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Tuttavia, il <xref:System.Single.Epsilon> proprietà non è una misura generale della precisione del <xref:System.Single> digitare; viene applicato solo ai <xref:System.Single> istanze che presentano un valore pari a zero.  
  
> [!NOTE]
>  Il valore della <xref:System.Single.Epsilon> proprietà non è equivalente alla epsilon macchina, che rappresenta il limite superiore dell'errore relativo a causa di arrotondamento in aritmetica a virgola mobile.  
  
 Il valore di questa costante è 1.4e-45.  
  
 Due numeri a virgola mobile apparentemente equivalenti potrebbero non risultare uguali a causa delle differenze nelle cifre meno significative. Ad esempio, l'espressione c#, `(float)1/3 == (float)0.33333`, non risulta uguale perché l'operazione di divisione sul lato sinistro ha la precisione massima, mentre la costante sul lato destro è precisa solo alle cifre specificate. Se si crea un algoritmo personalizzato che determina se due numeri a virgola mobile possono essere considerati uguali, è necessario usare un valore maggiore di <xref:System.Single.Epsilon> per stabilire il margine di differenza per i due valori assoluto accettabile (costante) considerate uguali. (In genere, il margine di differenza è notevolmente maggiore <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Note sulla piattaforma  
 Nei sistemi ARM, il valore della <xref:System.Single.Epsilon> costante è troppo piccolo per essere rilevato, in modo che equivale a zero. È possibile definire un valore alternativo epsilon uguale a 1.175494351E-38 invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due istanze di <see cref="T:System.Single" /> rappresentano lo stesso valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con l'istanza.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è un'istanza di <see cref="T:System.Single" /> ed è uguale al valore dell'istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.Equals%2A> metodo deve essere utilizzato con cautela, perché due valori apparentemente equivalenti possono essere diversi a causa di diversa precisione tra due valori. L'esempio seguente segnala che il <xref:System.Single> valore.3333 e <xref:System.Single> restituito dalla divisione di 1 per 3 non sono uguali.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Invece di confronto di uguaglianza, si consiglia di adottare tecnica che definisca un margine accettabile di differenza tra due valori (ad esempio. % 01 di uno dei valori). Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabilmente a causa delle differenze nella precisione e, di conseguenza, i valori possono risultare uguali. L'esempio seguente usa questa tecnica per confrontare.33333 e 1 o 3, i due <xref:System.Single> valori che è disponibile l'esempio di codice precedente venga fatta.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 In questo caso, i valori sono uguali.  
  
> [!NOTE]
>  In quanto <xref:System.Single.Epsilon> definisce l'espressione minimo di un valore positivo con un intervallo è prossimo a zero, il margine di differenza deve essere maggiore <xref:System.Single.Epsilon>. In genere, è notevolmente maggiore <xref:System.Single.Epsilon>.  
  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.Equals%2A> (metodo).  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Risoluzione dell'overload del compilatore può tenere conto un'apparente differenza nel comportamento dei due <see cref="M:System.Single.Equals(System.Object)" /> overload del metodo. Se una conversione implicita tra il <paramref name="obj" /> argomento e una <see cref="T:System.Single" /> viene definito e l'argomento non è tipizzato come un <see cref="T:System.Object" />, i compilatori possono eseguire una conversione implicita e chiamare il <see cref="M:System.Single.Equals(System.Single)" /> (metodo). In caso contrario, che chiamano il <see cref="M:System.Single.Equals(System.Object)" /> metodo, che restituisce sempre <see langword="false" /> se relativi <paramref name="obj" /> argomento non è un <see cref="T:System.Single" /> valore. Nell'esempio seguente viene illustrata la differenza nel comportamento tra i due overload. Nel caso di tutti i tipi numerici primitivi, ad eccezione di <see cref="T:System.Double" /> in Visual Basic e ad eccezione di <see cref="T:System.Decimal" /> e <see cref="T:System.Double" /> in c#, restituisce il primo confronto <see langword="true" /> perché il compilatore esegue automaticamente una conversione verso e chiamate il <see cref="M:System.Single.Equals(System.Single)" /> metodo, mentre il secondo confronto restituisce <see langword="false" /> perché il compilatore chiama il <see cref="M:System.Single.Equals(System.Object)" /> (metodo).  
  
[! codice-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! codice vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con l'istanza.</param>
        <summary>Restituisce un valore che indica se l'istanza e un oggetto <see cref="T:System.Single" /> specificato rappresentano lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è uguale all'istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia le prestazioni leggermente migliori rispetto <xref:System.Single.Equals%2A> perché non è necessario convertire il `obj` parametro a un oggetto.  
  
## <a name="widening-conversions"></a>conversioni verso un tipo di dati più grande  
 A seconda del linguaggio di programmazione, potrebbe essere possibile al codice un <xref:System.Single.Equals%2A> metodo in cui il tipo di parametro ha un minor numero di bit (è più stretta) rispetto al tipo di istanza. Questo è possibile perché alcuni linguaggi di programmazione eseguono conversioni implicite che rappresenta il parametro come un tipo con il numero di bit dell'istanza.  
  
 Ad esempio, si supponga che il tipo di istanza sia <xref:System.Single> e il tipo di parametro è <xref:System.Int32>. Il compilatore Microsoft c# genera le istruzioni per rappresentare il valore del parametro come un <xref:System.Single> dell'oggetto e quindi genera un <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> metodo che confronta i valori dell'istanza e la rappresentazione ampliata del parametro.  
  
 Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento implicite dei tipi numerici. Per altre informazioni, vedere la [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md) argomento.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 Il <xref:System.Single.Equals%2A> metodo deve essere utilizzato con cautela, perché due valori apparentemente equivalenti possono essere diversi a causa di diversa precisione tra due valori. L'esempio seguente segnala che il <xref:System.Single> valore.3333 e <xref:System.Single> restituito dalla divisione di 1 per 3 non sono uguali.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Tecnica di un confronto che evita i problemi associati di confronto per uguaglianza implica la definizione di un margine accettabile di differenza tra due valori (ad esempio. % 01 di uno dei valori). Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabile che sia un risultato di differenze di precisione e, di conseguenza, i valori possono risultare uguali. L'esempio seguente usa questa tecnica per confrontare.33333 e 1 o 3, che sono illustrati i due <xref:System.Single> valori che è disponibile l'esempio di codice precedente venga fatta.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 In questo caso, i valori sono uguali.  
  
> [!NOTE]
>  In quanto <xref:System.Single.Epsilon> definisce l'espressione minimo di un valore positivo con un intervallo è prossimo a zero, il margine di differenza deve essere maggiore <xref:System.Single.Epsilon>. In genere, è notevolmente maggiore <xref:System.Single.Epsilon>. Per questo motivo, è consigliabile non utilizzare <xref:System.Double.Epsilon> quando si confrontano <xref:System.Double> i valori per verificarne l'uguaglianza.  
  
 Una seconda tecnica che consente di evitare i problemi associati di confronto di uguaglianza implica la differenza tra due numeri a virgola mobile con un valore assoluto. Se la differenza è minore o uguale al valore assoluto, i numeri sono uguali. Se è maggiore, i numeri non sono uguali. Un modo per eseguire questa operazione consiste nel selezionare in modo arbitrario un valore assoluto. Tuttavia, ciò è problematica, perché un margine accettabile di differenza dipende dalla grandezza del <xref:System.Single> valori. Una seconda modalità si avvale di una funzionalità di progettazione nel formato a virgola mobile: la differenza tra i componenti di mantissa in rappresentazioni di integer di due valori a virgola mobile e indica il numero di possibili valori a virgola mobile che separa il due valori. Ad esempio, la differenza tra 0,0 e <xref:System.Single.Epsilon> è 1, in quanto <xref:System.Single.Epsilon> è il più piccolo valore rappresentabile, quando si lavora con un <xref:System.Single> il cui valore è uguale a zero. L'esempio seguente usa questa tecnica per confrontare.33333 e 1 o 3, che sono illustrati i due <xref:System.Double> i valori che l'esempio di codice precedente con il <xref:System.Single.Equals%28System.Single%29> trovato metodo venga fatta. Si noti che l'esempio Usa la <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> e <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> metodi per convertire un valore a virgola mobile a precisione singola alla relativa rappresentazione in integer.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri potrebbe produrre risultati diversi a seconda della versione di .NET Framework, dal momento che la precisione della rappresentazione interna dei numeri.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Risoluzione dell'overload del compilatore può tenere conto un'apparente differenza nel comportamento dei due <see cref="M:System.Single.Equals(System.Object)" /> overload del metodo. Se una conversione implicita tra il <paramref name="obj" /> argomento e una <see cref="T:System.Single" /> viene definito e l'argomento non è tipizzato come un <see cref="T:System.Object" />, i compilatori possono eseguire una conversione implicita e chiamare il <see cref="M:System.Single.Equals(System.Single)" /> (metodo). In caso contrario, che chiamano il <see cref="M:System.Single.Equals(System.Object)" /> metodo, che restituisce sempre <see langword="false" /> se relativi <paramref name="obj" /> argomento non è un <see cref="T:System.Single" /> valore. Nell'esempio seguente viene illustrata la differenza nel comportamento tra i due overload. Nel caso di tutti i tipi numerici primitivi, ad eccezione di <see cref="T:System.Double" /> in Visual Basic e ad eccezione di <see cref="T:System.Decimal" /> e <see cref="T:System.Double" /> in c#, restituisce il primo confronto <see langword="true" /> perché il compilatore esegue automaticamente una conversione verso e chiamate il <see cref="M:System.Single.Equals(System.Single)" /> metodo, mentre il secondo confronto restituisce <see langword="false" /> perché il compilatore chiama il <see cref="M:System.Single.Equals(System.Object)" /> (metodo).  
  
[! codice-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! codice vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.TypeCode" /> del tipo di valore <see cref="T:System.Single" />.</summary>
        <returns>Costante enumerata <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Numero a virgola mobile e con precisione singola.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito negativo o positivo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> restituisce <see cref="F:System.Single.PositiveInfinity" /> o <see cref="F:System.Single.NegativeInfinity" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.IsInfinity%2A> (metodo).  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Numero a virgola mobile e con precisione singola.</param>
        <summary>Restituisce un valore che indica se il valore specificato non è un numero (<see cref="F:System.Single.NaN" />).</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> restituisce un valore non numerico (<see cref="F:System.Single.NaN" />); in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Single.NaN> per segnalare che il risultato dell'operazione è non definito. Ad esempio, dividendo 0,0 da 0.0 comporta <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> Restituisce `false` se un <xref:System.Single> il valore è <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>. Per verificare questi valori, usare il <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, e <xref:System.Single.IsNegativeInfinity%2A> metodi.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.IsNaN%2A> (metodo).  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Numero a virgola mobile e con precisione singola.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito negativo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> viene valutato in <see cref="F:System.Single.NegativeInfinity" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Single.NegativeInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.IsNegativeInfinity%2A> (metodo).  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Numero a virgola mobile e con precisione singola.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito positivo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> viene valutato in <see cref="F:System.Single.PositiveInfinity" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Single.PositiveInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.IsPositiveInfinity%2A> (metodo).  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Rappresenta il valore massimo possibile di <see cref="T:System.Single" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è positivo 3.40282347E + 38.  
  
 Il risultato di un'operazione che supera <xref:System.Single.MaxValue?displayProperty=nameWithType> è <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. Nell'esempio riportato di seguito <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> risultati dalle operazioni di addizione e moltiplicazione elevamento a potenza quando il risultato supera <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.MaxValue> costante.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Rappresenta il valore più piccolo possibile di <see cref="T:System.Single" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è negativo e 3,402823E38.  
  
 Il risultato di un'operazione che è minore di <xref:System.Single.MinValue?displayProperty=nameWithType> è <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Nell'esempio riportato di seguito <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> risultante dalla sottrazione e moltiplicazione operazioni quando il risultato è minore di <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.MinValue> costante.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Rappresenta un valore non numerico (<see langword="NaN" />). Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restituisce un metodo o un operatore <xref:System.Single.NaN> quando il risultato di un'operazione è indefinito. Ad esempio, il risultato della divisione zero da zero è <xref:System.Single.NaN>, come illustrato nell'esempio seguente. (Ma si noti che un numero diverso da zero di divisione per zero restituisce uno <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>, in base al segno del divisore.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Inoltre, di chiamare un metodo con un <xref:System.Single.NaN> valore o un'operazione su una <xref:System.Single.NaN> valore restituisce <xref:System.Single.NaN>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Usare il <xref:System.Single.IsNaN%2A> metodo per determinare se un valore non è un numero. In generale, <xref:System.Single> operatori non possono essere utilizzati per confrontare <xref:System.Single.NaN?displayProperty=nameWithType> con altre <xref:System.Single> i valori, anche se i metodi di confronto (ad esempio <xref:System.Single.Equals%2A> e <xref:System.Single.CompareTo%2A>) possono. Nell'esempio seguente viene illustrata la differenza nel comportamento tra <xref:System.Single> metodi e gli operatori di confronto.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Single.NaN> costante.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Rappresenta l'infinito negativo. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è il risultato della divisione di un numero negativo per zero.  
  
 Questa costante viene restituita quando il risultato di un'operazione è minore di <xref:System.Single.MinValue>.  
  
 Usare <xref:System.Single.IsNegativeInfinity%2A> per determinare se un valore restituisce l'infinito negativo.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.NegativeInfinity> costante.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due valori <see cref="T:System.Single" /> specificati sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.op_Equality%2A> metodo consente di definire l'operatore di uguaglianza per <xref:System.Single> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Single" />specificato è maggiore di un altro valore <see cref="T:System.Single" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.op_GreaterThan%2A> metodo consente di definire l'operazione di maggiore-operatore per <xref:System.Single> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Single" /> specificato è maggiore o uguale a un altro valore <see cref="T:System.Single" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento dell'operatore di maggiore-than-or-equal per <xref:System.Single> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due valori <see cref="T:System.Single" /> specificati non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.op_Inequality%2A> metodo consente di definire l'operatore di disuguaglianza per <xref:System.Single> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se il valore <see cref="T:System.Single" /> specificato è minore o uguale a un altro valore <see cref="T:System.Single" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.op_LessThan%2A> metodo consente di definire l'operazione di minore di-operatore per <xref:System.Single> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Single" /> specificato è minore o uguale a un altro valore <see cref="T:System.Single" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di-than-or-equal per <xref:System.Single> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nel numero a virgola mobile a precisione singola equivalente.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <summary>Converte la rappresentazione di stringa di un numero nel numero a virgola mobile a precisione singola equivalente.</summary>
        <returns>Numero a virgola mobile a precisione singola equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 [*ws*] [*sign*] [*cifre integrali*[*,*]]*cifre integrali*[*.* [*cifre frazionarie*]] [e [*sign*]*esponenziale cifre*] [*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di caratteri di spazio vuoto.|  
|*sign*|Simbolo di segno negativo o un simbolo di segno positivo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Può essere usato solo un segno iniziale.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Viene eseguito *cifre integrali* possono essere partizionati da un simbolo di separatore di gruppi. In alcune impostazioni cultura, ad esempio, una virgola (,) separa i gruppi di migliaia. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|*,*|Impostazioni cultura specifiche migliaia simbolo del separatore.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Il `s` parametro viene interpretato mediante una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Ciò significa che lo spazio vuoto e migliaia sono consentiti separatori ma non sono i simboli di valuta. Per definire in modo esplicito gli elementi (ad esempio i simboli di valuta, migliaia, gli spazi vuoti e separatori) che possono essere presenti in `s`, usare il <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> overload del metodo.  
  
 Il `s` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura correnti del sistema. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Per analizzare una stringa usando le informazioni di formattazione delle impostazioni cultura specifica, usare il <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> o <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (metodo).  
  
 In genere, se si passa il <xref:System.Single.Parse%2A> una stringa che viene creato chiamando il metodo di <xref:System.Single.ToString%2A> metodo, l'originale <xref:System.Single> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali.  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Single.Parse%28System.String%29> metodo per convertire una matrice di stringhe in equivalente <xref:System.Single> valori.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in formato valido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Single.MinValue" /> o maggiore di <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analisi di stringhe numeriche in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <paramref name="s" />. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato nel rispettivo numero a virgola mobile a precisione singola equivalente.</summary>
        <returns>Numero a virgola mobile a precisione singola equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio gli spazi vuoti, migliaia separatori e i simboli di valuta) che sono consentiti nel `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Nell'esempio <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. A seconda del valore di `style`, possono anche assumere la forma:  
  
 [*ws*] [*$*] [*sign*] [*cifre integrali*[*,*]] *cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*esponenziale cifre*] [*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
 *ws*  
 Una serie di spazi vuoti. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.  
  
 $  
 Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Simbolo di valuta di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.  
  
 *sign*  
 Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Il segno può essere visualizzati all'inizio del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.  
  
 *integral-digits*  
 Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.  
  
 ,  
 Un separatore di gruppi di impostazioni cultura specifiche. Separatore di gruppi di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag  
  
 .  
 Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.  
  
 *fractional-digits*  
 Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.  
  
 E  
 Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.  
  
 *cifre esponenziali.*  
 Una serie di cifre comprese tra 0 e 9 che specificano un esponente.  
  
> [!NOTE]
> Eventuali caratteri di terminazione null (u+0000) nella `s` vengono ignorati dall'operazione di analisi, indipendentemente dal valore della `style` argomento.

 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. I rimanenti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere presenti, ma non devono essere presenti, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag hanno effetto sugli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in `s` oltre alle cifre|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o un carattere "E, che indica la notazione esponenziale". Questo flag di per sé supporta i valori nel formato *cifre*elettronica*cifre*; altri flag sono necessari per analizzare correttamente le stringhe con tali elementi come segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Migliaia elemento separatore (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|L'elemento di valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `s`, *sign* all'inizio del `s`e il simbolo di separatore decimale (.). Il `s` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale.|  
  
 Alcuni esempi di `s` sono "100", "-123,456,789", "123.45 e + 6", "+ 500", "5e2", "3.1416", "600.", "-. 123" e "-Infinity".  
  
 Il `s` parametro viene analizzato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura correnti del sistema. Per specificare le impostazioni cultura le cui informazioni di formattazione viene utilizzati per l'operazione di analisi, chiamare il <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> rapporto di overload.  
  
 In genere, se si passa il <xref:System.Single.Parse%2A> una stringa che viene creato chiamando il metodo di <xref:System.Single.ToString%2A> metodo, l'originale <xref:System.Single> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali.  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> per analizzare le rappresentazioni di stringa del metodo <xref:System.Single> valori. L'esempio Usa le informazioni di formattazione per le impostazioni cultura en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non è un numero in formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Single.MinValue" /> o maggiore di <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  
  
oppure 
 <paramref name="style" /> include il valore di <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analisi di stringhe numeriche in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relativamente a <paramref name="s" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in un determinato formato specifico delle impostazioni cultura nel numero a virgola mobile a precisione singola equivalente.</summary>
        <returns>Numero a virgola mobile a precisione singola equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene utilizzato in genere il testo che può essere formattato in svariati modi per convertire un <xref:System.Single> valore. Ad esempio, può essere utilizzato per convertire il testo immesso dall'utente in una casella di testo HTML in un valore numerico.  
  
 Il `s` parametro viene interpretato mediante una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per le impostazioni cultura specificate da `provider`, oppure può contenere una stringa nel formato:  
  
 [*ws*] [*sign*]*cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*esponenziale cifre*] [*ws*]  
  
 Elementi facoltativi vengono racchiusi tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+).|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Viene eseguito *cifre integrali* possono essere partizionati da un simbolo di separatore di gruppi. In alcune impostazioni cultura, ad esempio, una virgola (,) separa i gruppi di migliaia. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Per altre informazioni sui formati numerici, vedere la [formattazione di tipi](~/docs/standard/base-types/formatting-types.md) argomento.  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura. Quando il <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> metodo viene richiamato, viene chiamato il `provider` del parametro <xref:System.IFormatProvider.GetFormat%2A> metodo e lo passa a un <xref:System.Type> oggetto che rappresenta il <xref:System.Globalization.NumberFormatInfo> tipo. Il <xref:System.IFormatProvider.GetFormat%2A> metodo quindi restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni relative al formato del `s` parametro. Esistono tre modi per usare il `provider` parametro per fornire informazioni di formattazione personalizzate per l'operazione di analisi:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che forniscono informazioni di formattazione. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   È possibile passare l'oggetto effettivo <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   È possibile passare un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo crea un'istanza e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null` o un <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere le informazioni di formattazione per impostazioni cultura correnti del sistema viene usata.  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Alcuni esempi di `s` sono "100", "-123,456,789", "123.45 e + 6", "+ 500", "5e2", "3.1416", "600.", "-. 123" e "-Infinity".  
  
   
  
## Examples  
 L'esempio seguente è il gestore di eventi di un form Web click del pulsante. Usa la matrice restituita dal <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> proprietà per determinare le impostazioni locali dell'utente. Crea quindi un <xref:System.Globalization.CultureInfo> oggetto che corrisponde a tali impostazioni locali. Il <xref:System.Globalization.NumberFormatInfo> appartenente all'oggetto <xref:System.Globalization.CultureInfo> oggetto viene quindi passato al <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> input del metodo per convertire l'utente a un <xref:System.Single> valore.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in formato valido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Single.MinValue" /> o maggiore di <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analisi di stringhe numeriche in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <paramref name="s" />. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relativamente a <paramref name="s" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e in un formato specifico delle impostazioni cultura nel numero a virgola mobile a precisione singola equivalente.</summary>
        <returns>Numero a virgola mobile a precisione singola equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio gli spazi vuoti, migliaia separatori e i simboli di valuta) che sono consentiti nel `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Nell'esempio <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per le impostazioni cultura specificate da `provider`. A seconda del valore di `style`, possono anche assumere la forma:  
  
 [*ws*] [*$*] [*sign*] [*cifre integrali*,]*cifre integrali*[. [ *cifre frazionarie*]] [E [*sign*]*cifre esponenziali*] [*ws*]  
  
 Elementi racchiusi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|$|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Simbolo di valuta di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Il segno può essere visualizzati all'inizio del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Un separatore di gruppi di impostazioni cultura specifiche. Separatore di gruppi di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `s` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
> [!NOTE]
> Eventuali caratteri di terminazione null (u+0000) nella `s` vengono ignorati dall'operazione di analisi, indipendentemente dal valore della `style` argomento.

 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. I rimanenti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere presenti, ma non devono essere presenti, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag hanno effetto sugli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in `s` oltre alle cifre|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o un carattere "E, che indica la notazione esponenziale". Questo flag di per sé supporta i valori nel formato *cifre*elettronica*cifre*; altri flag sono necessari per analizzare correttamente le stringhe con tali elementi come segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Migliaia elemento separatore (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|L'elemento di valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `s`, *sign* all'inizio del `s`e il simbolo di separatore decimale (.). Il `s` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale.|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura relative al formato di `value`. In genere, `provider` può essere una qualsiasi delle operazioni seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni sulla formattazione numeriche. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider> e Usa le <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> per creare un'istanza e restituire il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, il <xref:System.Globalization.NumberFormatInfo> dell'oggetto per la lingua corrente viene utilizzata.  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> per analizzare le rappresentazioni di stringa del metodo <xref:System.Single> valori. Ogni stringa in una matrice viene analizzata usando le convenzioni di formattazione di en-US, nl-NL e impostazioni cultura personalizzate. Le impostazioni cultura personalizzate definiscono il simbolo di separatore di gruppo come il carattere di sottolineatura ("_") e le dimensioni del gruppo come due.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un valore numerico.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  
  
oppure 
 <paramref name="style" /> è il valore di <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Single.MinValue" /> o maggiore di <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analisi di stringhe numeriche in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Rappresenta l'infinito positivo. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è il risultato della divisione di un numero positivo per zero.  
  
 Questa costante viene restituita quando il risultato di un'operazione è maggiore di <xref:System.Single.MaxValue>.  
  
 Usare <xref:System.Single.IsPositiveInfinity%2A> per determinare se un valore restituisce l'infinito positivo.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Single.PositiveInfinity> costante.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> se il valore dell'istanza corrente non è uguale a zero; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Questa conversione non è supportata. Il tentativo di usare questo metodo genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Questa conversione non è supportata. Il tentativo di usare questo metodo genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, invariato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo nel quale convertire questo valore <see cref="T:System.Single" />.</param>
        <param name="provider">Oggetto che fornisce informazioni sul formato del valore restituito.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Single> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.ToString> formati del metodo un <xref:System.Single> valore il valore predefinito ("G" o generali) formato delle impostazioni cultura correnti. Se si desidera specificare un formato diverso o delle impostazioni cultura, usare gli altri overload del <xref:System.Single.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Single.ToString%28System.String%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 cifre integrali [accesso] [. [ cifre frazionarie]] [esponenziale e [accesso] cifre]  
  
 Elementi facoltativi vengono racchiusi tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9. La tabella seguente elenca ogni elemento:  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di cifre che specifica la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|'.'|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre che specifica la parte frazionaria del numero.|  
|'e'|Un carattere minuscolo "e", che indica una notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre che specifica un esponente.|  
  
 Alcuni esempi del valore restituito sono "100", "-123,456,789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'esempio seguente usa il valore predefinito <xref:System.Single.ToString%2A?displayProperty=nameWithType> metodo per visualizzare le rappresentazioni di stringa di un numero di <xref:System.Single> valori.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Single.Parse%28System.String%29> metodo con il <xref:System.Single.ToString> (metodo).  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico di questa istanza nella rappresentazione di stringa equivalente usando le informazioni di formato specifiche delle impostazioni cultura.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.ToString%28System.IFormatProvider%29> formati del metodo un <xref:System.Single> valore il valore predefinito ("G" o generali) formato di una cultura specificata. Se si desidera specificare le impostazioni cultura correnti o un formato diverso, usare gli altri overload del <xref:System.Single.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura (corrente) predefinite|<xref:System.Single.ToString>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Single.ToString%28System.String%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 cifre integrali [accesso] [. [ cifre frazionarie]] [esponenziale e [accesso] cifre]  
  
 Elementi facoltativi vengono racchiusi tra parentesi quadre ([e]). Gli elementi contenenti il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9. La tabella seguente elenca ogni elemento.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|segno|Un segno negativo o un simbolo di segno positivo.|  
|cifre integrali|Una serie di cifre che specifica la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|'.'|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|cifre frazionarie|Una serie di cifre che specifica la parte frazionaria del numero.|  
|'e'|Un carattere minuscolo "e", che indica una notazione esponenziale (scientifica).|  
|cifre esponenziali.|Una serie di cifre che specifica un esponente.|  
  
 Alcuni esempi del valore restituito sono "100", "-123,456,789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto. In genere `provider` è un <xref:System.Globalization.CultureInfo> oggetto o un <xref:System.Globalization.NumberFormatInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate nella formattazione. Se `provider` viene `null`, il valore restituito viene formattato con il <xref:System.Globalization.NumberFormatInfo> i dati per le impostazioni cultura correnti.  
  
 Per convertire un <xref:System.Single> valore alla relativa rappresentazione di stringa usando impostazioni cultura specifiche e una stringa di formato specifico, chiamata di <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 L'esempio seguente mostra la rappresentazione di stringa di due <xref:System.Single> i valori usando <xref:System.Globalization.CultureInfo> gli oggetti che rappresentano più impostazioni cultura diverse.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico.</param>
        <summary>Converte il valore numerico di questa istanza nell'equivalente rappresentazione di stringa usando il formato specificato.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.ToString%28System.String%29> formati del metodo un <xref:System.Single> valore in un formato specificato usando le convenzioni delle impostazioni cultura correnti. Se si desidera usare il valore predefinito ("G" o generali) formattare o specificare una lingua diversa, usare gli altri overload del <xref:System.Single.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura (corrente) predefinite|<xref:System.Single.ToString>|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la rappresentazione di stringa del valore dell'istanza corrente, come specificato dalle `format`.  
  
 Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valida, ad eccezione D e X, nonché qualsiasi combinazione di identificatori di formato numerico personalizzato. Se format è `null` o una stringa vuota, il valore restituito viene formattata con l'identificatore di formato numerico standard ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Per impostazione predefinita, il valore restituito contiene solo 7 cifre di precisione anche se internamente viene gestito un massimo di 9 cifre. Se il valore di questa istanza è maggiore di 7 cifre, <xref:System.Single.ToString%28System.String%29> restituisce <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anziché il numero previsto. Se è necessario ottenere una maggiore precisione, specificare `format` con la specifica di formato "G9", che restituisce sempre un massimo di 9 cifre di precisione o "R", che restituisce 7 cifre se il numero può essere rappresentato con 9 cifre o che la precisione se il numero può essere rappresentato solo con la massima precisione.  
  
   
  
## Examples  
 Nell'esempio seguente definisce un valore numerico e li formatta come valore di valuta usando la stringa di formato numerico standard "C" e come valore numerico a tre cifre decimali utilizzando la stringa di formato numerico standard "N". Le stringhe di risultato vengono formattate usando le convenzioni delle impostazioni cultura en-US. Per altre informazioni sulle stringhe di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 L'esempio seguente mostra alcuni <xref:System.Single> i valori usando ognuno degli identificatori di formato numerico standard supportati insieme alle due stringhe di formato numerico personalizzato. Uno di tali stringhe di formato personalizzato viene illustrato come aggiungere un <xref:System.Single> valore con zeri iniziali. Nella conversione di valori numerici in stringhe, l'esempio Usa le convenzioni di formattazione delle impostazioni cultura en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Procedura: aggiungere zeri iniziali a un numero</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente usando il formato specificato e le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza corrente, in base a quanto specificato da <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> formati del metodo un <xref:System.Single> valore in un formato specifico delle impostazioni cultura specificata. Se si desidera usare le impostazioni di formato o le impostazioni cultura predefinite, usare gli altri overload del <xref:System.Single.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura (corrente) predefinite|<xref:System.Single.ToString>|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Single.ToString%28System.String%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la rappresentazione di stringa del valore dell'istanza corrente, come specificato dalle `format`.  
  
 Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valida, ad eccezione D e X, nonché qualsiasi combinazione di identificatori di formato numerico personalizzato. Se `format` è `null` o una stringa vuota, il valore restituito per questa istanza viene formattata con l'identificatore di formato numerico standard ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto. In genere `provider` è un <xref:System.Globalization.CultureInfo> oggetto o un <xref:System.Globalization.NumberFormatInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate nella formattazione. Se `provider` viene `null`, il valore restituito viene formattato con il <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
 Per impostazione predefinita, il valore restituito contiene solo 7 cifre di precisione anche se internamente viene gestito un massimo di 9 cifre. Se il valore di questa istanza è maggiore di 7 cifre, <xref:System.Single.ToString%2A> restituisce <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anziché il numero previsto. Se è necessario ottenere una maggiore precisione, specificare `format` con la specifica di formato "G9", che restituisce sempre un massimo di 9 cifre di precisione o "R", che restituisce 7 cifre se il numero può essere rappresentato con 9 cifre o che la precisione se il numero può essere rappresentato solo con la massima precisione.  
  
   
  
## Examples  
 L'esempio seguente mostra un <xref:System.Single> valore tramite ognuno degli identificatori di formato numerico standard supportati per varie impostazioni cultura.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Procedura: aggiungere zeri iniziali a un numero</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nel numero a virgola mobile a precisione singola equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che rappresenta un numero da convertire.</param>
        <param name="result">Quando questo metodo viene restituito, contiene il numero a virgola mobile a precisione singola equivalente al valore numerico o al simbolo contenuto in <paramref name="s" />, se la conversione ha esito positivo oppure zero se la conversione non riesce. La conversione non viene eseguita se il parametro <paramref name="s" /> è <see langword="null" /> o <see cref="F:System.String.Empty" />, non è un numero in formato valido o rappresenta un numero minore di <see cref="F:System.Single.MinValue" /> o maggiore di <see cref="F:System.Single.MaxValue" />. Questo parametro viene passato non inizializzato. Qualsiasi valore fornito in origine in <paramref name="result" /> verrà sovrascritto.</param>
        <summary>Converte la rappresentazione di stringa di un numero nel numero a virgola mobile a precisione singola equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <returns>
          <see langword="true" /> se <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload differisce dal <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> metodo restituendo un valore booleano che indica se l'operazione di analisi è stata completata invece di restituire il valore numerico analizzato. Elimina la necessità di usare la gestione delle eccezioni da testare per una <xref:System.FormatException> nel caso in cui `s` non è valido e non può essere analizzata correttamente.  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (nel confronto tra stringhe è distinzione maiuscole/minuscole), o una stringa nel formato:  
  
 [ws] [accesso] [cifre integrali,] cifre integrali [. [ cifre frazionarie]] [esponenziale e [accesso] cifre] [ws]  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|*,*|Un simbolo di separatore gruppo di impostazioni cultura specifiche.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano la parte frazionaria del numero.|  
|*E*|Un carattere maiuscolo o minuscolo 'e', che indica una notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano un esponente.|  
  
 Il `s` parametro viene interpretato mediante una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Ciò significa che lo spazio vuoto e migliaia sono consentiti separatori ma non sono i simboli di valuta. Per definire in modo esplicito gli elementi (ad esempio i simboli di valuta, migliaia, gli spazi vuoti e separatori) che possono essere presenti in `s`, usare il <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> overload del metodo.  
  
 Il `s` parametro viene analizzato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura correnti del sistema. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Analizzare una stringa, usando le informazioni di formattazione di un altro specificati dalle impostazioni cultura, usare il <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> overload del metodo.  
  
 In genere, se si passa il <xref:System.Single.TryParse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Single.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Single> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali.  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> metodo per convertire le rappresentazioni di stringa di valori numerici per <xref:System.Single> valori. Si presuppone che en-US è la lingua corrente.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analisi di stringhe numeriche in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che rappresenta un numero da convertire.</param>
        <param name="style">Combinazione bit per bit di valori di enumerazione che indica il formato consentito di <paramref name="s" />. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relativamente a <paramref name="s" />.</param>
        <param name="result">Quando questo metodo viene restituito, contiene il numero a virgola mobile a precisione singola equivalente al valore numerico o al simbolo contenuto in <paramref name="s" />, se la conversione ha esito positivo oppure zero se la conversione non riesce. La conversione non viene eseguita se il parametro <paramref name="s" /> è <see langword="null" /> o <see cref="F:System.String.Empty" />, non presenta un formato conforme a <paramref name="style" />, rappresenta un numero minore di <see cref="F:System.Single.MinValue" /> o maggiore di <see cref="F:System.Single.MaxValue" /> o se <paramref name="style" /> non è una combinazione valida di costanti enumerate dell'oggetto <see cref="T:System.Globalization.NumberStyles" />. Questo parametro viene passato non inizializzato. Qualsiasi valore fornito in origine in <paramref name="result" /> verrà sovrascritto.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e in un formato specifico delle impostazioni cultura nel numero a virgola mobile a precisione singola equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <returns>
          <see langword="true" /> se <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload differisce dal <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo restituendo un valore booleano che indica se l'operazione di analisi è stata completata invece di restituire il valore numerico analizzato. Elimina la necessità di usare la gestione delle eccezioni da testare per una <xref:System.FormatException> nel caso in cui `s` non è valido e non può essere analizzata correttamente.  
  
 Il `style` parametro definisce il formato consentito del `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Nell'esempio <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> per le impostazioni cultura indicata da `provider`. Inoltre, a seconda del valore di `style`, il `s` parametro può includere gli elementi seguenti:  
  
 [ws] [$] [accesso] [cifre integrali,] cifre integrali [cifre frazionarie] [esponenziale e [accesso] cifre] [ws]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag. Può essere visualizzato in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> o <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> delle proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metodo del `provider` parametro. Il simbolo di valuta può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|*,*|Impostazioni cultura specifiche migliaia simbolo del separatore. Migliaia di cultura correnti simbolo del separatore visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*e*|Il carattere e o E, a indicare che `s` può rappresentare un numero usando la notazione esponenziale. Il `s` parametro può rappresentare un numero in notazione esponenziale se style è incluso il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
> [!NOTE]
> Eventuali caratteri di terminazione null (u+0000) nella `s` vengono ignorati dall'operazione di analisi, indipendentemente dal valore della `style` argomento.

 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. I rimanenti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere ma non devono essere presenti nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag hanno effetto sugli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in s oltre alle cifre|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|L'elemento language *.* e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il `s` parametro anche possibile usare la notazione esponenziale. Questo flag di per sé supporta i valori nel formato *cifre integrali*E*cifre esponenziali*; altri flag necessari per analizzare correttamente le stringhe in una notazione esponenziale con elementi quali segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Il *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Il *$* elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti. Il `s` parametro non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `s`, *sign* all'inizio del `s`e il *.* simbolo. Il `s` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (*,),* e il punto decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli stili, ad eccezione di `s` non può rappresentare un numero esadecimale.|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura. Quando il <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> metodo viene richiamato, viene chiamato il `provider` del parametro <xref:System.IFormatProvider.GetFormat%2A> metodo e lo passa a un <xref:System.Type> oggetto che rappresenta il <xref:System.Globalization.NumberFormatInfo> tipo. Il <xref:System.IFormatProvider.GetFormat%2A> metodo quindi restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni relative al formato del `s` parametro. Esistono tre modi per usare il `provider` parametro per fornire informazioni di formattazione personalizzate per l'operazione di analisi:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che forniscono informazioni di formattazione. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   È possibile passare l'oggetto effettivo <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   È possibile passare un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo crea un'istanza e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, la formattazione dei `s` viene interpretato in base il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> metodo per analizzare la rappresentazione di stringa di numeri che hanno uno stile specifico e vengono formattati usando le convenzioni delle impostazioni cultura specifiche.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  
  
oppure 
 <paramref name="style" /> è il valore di <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analisi di stringhe numeriche in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>