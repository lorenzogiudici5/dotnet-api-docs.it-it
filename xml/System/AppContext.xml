<Type Name="AppContext" FullName="System.AppContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="893966e3a9901acea67237c6fa8d21aea736380a" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/04/2018" />
    <Meta Name="ms.locfileid" Value="34568285" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class AppContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AppContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.AppContext" />
  <TypeSignature Language="VB.NET" Value="Public Class AppContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppContext abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.AppContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce i membri per l'impostazione e il recupero dei dati relativi al contesto di un'applicazione.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.AppContext> classe consente agli autori di librerie fornire un meccanismo di rifiuto esplicito uniforme per la nuova funzionalità per i propri utenti. che stabilisce un contratto a regime di controllo libero ("loosely-coupled") tra componenti per poter comunicare una richiesta di rinuncia esplicita. Questa funzionalità è importante in genere quando viene apportata una modifica alle funzionalità esistenti. Al contrario, esiste già un consenso esplicito per la nuova funzionalità.  
  
## <a name="appcontext-for-library-developers"></a>AppContext per gli sviluppatori di librerie  
 Utilizzano le librerie di <xref:System.AppContext> passa da una classe per definire ed esporre la compatibilità, mentre gli utenti di libreria possono impostare tali opzioni per influire sul comportamento della libreria. Per impostazione predefinita, le librerie forniscono la nuova funzionalità e la modificano (cioè offrono la funzionalità precedente) solo se l'opzione è impostata.  Questo consente alle librerie fornire di nuovo comportamento per un'API esistente pur continuando a supportare i chiamanti che dipendono dal comportamento precedente.  
  
### <a name="defining-the-switch-name"></a>Definire il nome del commutatore  
 Il modo più comune per consentire ai consumer della libreria di rifiutare esplicitamente un cambiamento di comportamento consiste nel definire un parametro denominato.  Il relativo `value` elemento è una coppia nome/valore costituita da nome di un commutatore e il relativo <xref:System.Boolean> valore.  Per impostazione predefinita, l'opzione è sempre implicitamente `false`, che fornisce il nuovo comportamento (e rende il nuovo comportamento opt-in per impostazione predefinita). Impostare l'opzione su `true` consente, che fornisce il comportamento legacy. Impostare in modo esplicito l'opzione su `false` fornisce anche il nuovo comportamento.  
  
 È opportuno usare un formato coerente per i nomi di parametro, poiché si tratta di un contratto formale esposto da una libreria. Di seguito sono riportati due formati ovvi.  
  
-   *Opzione*.*spaziodeinomi*.*nomeopzione*  
  
-   *Opzione*.*libreria*.*nomeopzione*  
  
 Una volta definire e documentare il commutatore, i chiamanti possono utilizzarla tramite il Registro di sistema, aggiungendo un [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) elemento per i file di configurazione dell'applicazione, oppure chiamando il <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> metodo a livello di codice. Vedere il [AppContext per consumer della libreria](#ForConsumers) sezione per ulteriori informazioni su come i chiamanti usare e impostare il valore di <xref:System.AppContext> opzioni di configurazione.  
  
 Quando in common language runtime viene eseguita un'applicazione, legge le impostazioni di compatibilità del Registro di sistema automaticamente e carica il file di configurazione dell'applicazione per popolare l'applicazione <xref:System.AppContext> istanza. Poiché il <xref:System.AppContext> istanza viene compilata a livello di codice dal chiamante o dal runtime, non è necessario intraprendere alcuna azione, ad esempio la chiamata di <xref:System.AppContext.SetSwitch%2A> metodo, per configurare il <xref:System.AppContext> istanza.  
  
### <a name="checking-the-setting"></a>L'impostazione di controllo  
 È quindi possibile controllare se un consumer è dichiarato il valore del parametro e act chiamando in modo appropriato il <xref:System.AppContext.TryGetSwitch%2A?displayProperty=nameWithType> metodo. Il metodo restituisce `true` se il `switchName` viene trovato argomento e quando il metodo restituisce, l'oggetto `isEnabled` argomento indica il valore dell'opzione.  In caso contrario, il metodo restituisce `false`.  
  
### <a name="an-example"></a>Un esempio  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.AppContext> classe per consentire al cliente di scegliere il comportamento di un metodo di libreria originale.   Di seguito è la versione 1.0 di una libreria denominata `StringLibrary`. Definisce un `SubstringStartsAt` metodo che esegue un confronto ordinale per determinare l'indice iniziale di una sottostringa all'interno di una stringa più grande.  
  
 [!code-csharp[System.AppContext.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example4.cs#4)]
 [!code-vb[System.AppContext.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example4.vb#4)]  
  
 Nell'esempio seguente, quindi, utilizza la libreria per trovare l'indice iniziale della sottostringa "archæ" in "Il archaeologist". Poiché il metodo esegue un confronto ordinale, Impossibile trovare la sottostringa.  
  
 [!code-csharp[System.AppContext.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example4.cs#5)]
 [!code-vb[System.AppContext.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example4.vb#5)]  
  
 Versione 2 della libreria, tuttavia, cambia il `SubstringStartsAt` metodo da utilizzare a confronto con distinzione delle impostazioni cultura.  
  
 [!code-csharp[System.AppContext.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example6.cs#6)]
 [!code-vb[System.AppContext.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example6.vb#6)]  
  
 Se l'app viene ricompilato per l'esecuzione con la nuova versione della libreria, ora segnala che è possibile trovare la sottostringa "archæ" in corrispondenza dell'indice 4 in "Il archaeologist".  
  
 [!code-csharp[System.AppContext.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example6.cs#7)]
 [!code-vb[System.AppContext.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example6.vb#7)]  
  
 Questa modifica è possibile impedire l'interruzione le applicazioni che dipendono dal comportamento originale definendo un [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) passare. In questo caso, il commutatore denominato `StringLibrary.DoNotUseCultureSensitiveComparison`. Il valore predefinito, `false`, indica che la libreria deve eseguire il confronto con distinzione delle impostazioni cultura versione 2.0. `true` indica che la libreria deve eseguire il confronto ordinale versione 1.0.  Una lieve modifica del codice precedente consente al consumer di libreria impostare l'opzione per determinare il tipo di confronto, che il metodo esegue.  
  
 [!code-csharp[System.AppContext.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example8.cs#8)]
 [!code-vb[System.AppContext.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example8.vb#8)]  
  
 Se l'applicazione può quindi utilizzare il file di configurazione seguente per ripristinare il comportamento della versione 1.0.  
  
```xml  
  
<configuration>  
   <runtime>  
      <AppContextSwitchOverrides value="StringLibrary.DoNotUseCultureSensitiveComparison=true" />   
   </runtime>  
</configuration>  
  
```  
  
 Quando l'applicazione viene eseguita con il file di configurazione presentano, produce il seguente output:  
  
```  
'archæ' not found in 'The archaeologist'  
```  
  
<a name="ForConsumers"></a>   
## <a name="appcontext-for-library-consumers"></a>AppContext per consumer della libreria  
 Se si è il consumer di una libreria, il <xref:System.AppContext> classe consente di sfruttare i vantaggi del meccanismo di rifiuto esplicito del metodo di raccolta per nuove funzionalità o di una libreria.   I singoli metodi della libreria di classi che si sta chiamando definiscono particolare opzioni che abilitano o disabilitano un nuovo comportamento. Il valore dell'opzione è un valore booleano. Se è `false`, che è in genere il valore predefinito, il nuovo comportamento è abilitato; in caso `true`, il nuovo comportamento è disabilitato e il membro si comporta come in precedenza.  
  
 È possibile impostare il valore di un commutatore in uno dei tre modi:  
  
-   Chiamando il <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> metodo nel codice.  Il `switchName` argomento definisce il nome del commutatore e `isEnabled` proprietà definisce il valore dell'opzione. Poiché <xref:System.AppContext> è una classe statica, è disponibile in base al dominio per ogni applicazione.  
  
     La chiamata di <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> con ambito di applicazione; vale a dire influisce solo l'applicazione.  
  
-   Aggiungendo un `<AppContextSwitchOverrides>` elemento per il [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sezione del file app. config. Il commutatore ha un solo attributo, `value`, il cui valore è una stringa che rappresenta una coppia chiave/valore contenente il nome del commutatore e il relativo valore.  
  
     Per definire più commutatori, separare coppia chiave/valore dell'opzione ogni nel [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) dell'elemento `value` attributo con un punto e virgola. In tal caso, il `<AppContextSwitchOverrides>` elemento presenta il formato seguente:  
  
    ```xml  
    <AppContextSwitchOverrides value="switchName1=value1;switchName2=value2" />  
    ```  
  
     Utilizzando il `<AppContextSwitchOverrides>` elemento per definire un'impostazione di configurazione con ambito di applicazione; vale a dire influisce solo l'applicazione.  

    > [!NOTE]    
    > Per informazioni sulle opzioni definite da .NET Framework, vedere il [ \<AppContextSwitchOverrides > elemento](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md).

-   Tramite l'aggiunta di un valore di stringa il cui nome è il nome del commutatore per il `HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext` chiave del Registro di sistema. Il valore deve essere la rappresentazione di stringa di un <xref:System.Boolean> che può essere analizzato dal <xref:System.Boolean.Parse%2A?displayProperty=nameWithType> (metodo), vale a dire deve essere "True", "true", "False" o "false". Se il runtime incontra un altro valore, ignora il commutatore.  
  
     Utilizzo del Registro di sistema per definire un <xref:System.AppContext> switch è dotato di ambito del computer; ovvero, influisce su tutte le applicazioni in esecuzione nel computer.  
  
 Se si imposta la stessa opzione in più modo, è l'ordine di precedenza per determinare quale impostazione esegue l'override di altri:  
  
1.  L'impostazione a livello di codice.  
  
2.  L'impostazione nel file di configurazione app.  
  
3.  L'impostazione del Registro di sistema.  
  
 Di seguito è riportato una semplice applicazione che passa un URI di file per il <xref:System.IO.Path.GetDirectoryName%2A?displayProperty=nameWithType> metodo.  Durante l'esecuzione in .NET Framework 4.6, genera un <xref:System.ArgumentException> perché `file://` non è più una parte di un percorso file valida.  
  
 [!code-csharp[System.AppContext.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/ForConsumers1.cs#10)]
 [!code-vb[System.AppContext.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/ForConsumers1.vb#10)]  
  
 Per ripristinare il comportamento del metodo precedente ed evitare l'eccezione, è possibile aggiungere il `Switch.System.IO.UseLegacyPathHandling` passare al file di configurazione dell'applicazione per un esempio:  
  
```xml  
<configuration>  
    <runtime>  
        <AppContextSwitchOverrides value="Switch.System.IO.UseLegacyPathHandling=true" />    
    </runtime>  
</configuration>  
```  
## <a name="see-also"></a>Vedere anche
[Opzione AppContext](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public static string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppContext.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso della directory base usata dal resolver dell'assembly per verificare la presenza di assembly.</summary>
        <value>Percorso della directory base usata dal resolver dell'assembly per verificare la presenza di assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di una per ogni proprietà del dominio applicazione. Il valore corrisponde al <xref:System.AppDomain.BaseDirectory%2A?displayProperty=nameWithType> proprietà del dominio applicazione corrente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'elemento dati.</param>
        <summary>Restituisce il valore dell'elemento dati denominato assegnato al dominio applicazione corrente.</summary>
        <returns>Valore di <paramref name="name" />, se <paramref name="name" /> identifica un valore denominato; in caso contrario, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSwitch">
      <MemberSignature Language="C#" Value="public static void SetSwitch (string switchName, bool isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetSwitch(string switchName, bool isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.SetSwitch(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetSwitch (switchName As String, isEnabled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetSwitch(System::String ^ switchName, bool isEnabled);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchName" Type="System.String" />
        <Parameter Name="isEnabled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="switchName">Nome dell'opzione.</param>
        <param name="isEnabled">Valore dell'opzione.</param>
        <summary>Imposta il valore di un'opzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.AppContext> classe consente agli autori di librerie fornire un meccanismo di rifiuto esplicito uniforme per la nuova funzionalità per i propri utenti. che stabilisce un contratto a regime di controllo libero ("loosely-coupled") tra componenti per poter comunicare una richiesta di rinuncia esplicita. Questa funzionalità è importante in genere quando viene apportata una modifica alle funzionalità esistenti. Al contrario, esiste già un consenso esplicito per la nuova funzionalità.  
  
 Il <xref:System.AppContext.SetSwitch%2A> metodo viene chiamato da un'applicazione (o una libreria) per dichiarare il valore di un'opzione (che è sempre un <xref:System.Boolean> valore) che definisce una libreria dipendente. L'opzione è sempre implicitamente `false`, che fornisce il nuovo comportamento. Impostare l'opzione su `true` consente, che fornisce il comportamento legacy. Impostare in modo esplicito l'opzione su `false` fornisce anche il nuovo comportamento. La libreria dipendente può quindi controllare il valore dell'opzione chiamando il <xref:System.AppContext.TryGetSwitch%2A> metodo.  
  
> [!NOTE]
>  È opportuno usare un formato coerente per i nomi di parametro, poiché si tratta di un contratto formale esposto da una libreria. Di seguito sono riportati due formati ovvi.  
>   
>  -   *Opzione*.*spaziodeinomi*.*nomeopzione*  
> -   *Opzione*.*libreria*.*nomeopzione*  
  
 Per le applicazioni in esecuzione su .NET Framework, oltre a impostare il valore di un'opzione a livello di programmazione, è anche possibile impostare:  
  
-   Aggiungendo il nome del commutatore e il valore per il [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) elemento il [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sezione di un file di configurazione dell'applicazione. Ad esempio, il seguente definisce un commutatore denominato `Libraries.FPLibrary.UseExactFloatingPointComparison` il cui valore è `False`.  
  
    ```xml  
  
    <configuration>  
       <runtime>  
          <AppContextSwitchOverrides value="Libraries.FPLibrary.UseExactFloatingPointComparison=false" />   
       </runtime>  
    </configuration>  
  
    ```  
  
-   Tramite l'aggiunta di un valore di stringa il cui nome è il nome del commutatore per il `HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext` chiave del Registro di sistema. Il valore deve essere la rappresentazione di stringa di un <xref:System.Boolean> che può essere analizzato dal <xref:System.Boolean.Parse%2A?displayProperty=nameWithType> (metodo), vale a dire deve essere "True", "true", "False" o "false".  
  
 Se `switchName` esiste già, il relativo valore viene sovrascritto dal `isEnabled` argomento.  Vale a dire, la chiamata più recente per il <xref:System.AppContext.SetSwitch%2A> metodo sostituisce il valore definito nel Registro di sistema, in un file di configurazione dell'applicazione o dalle chiamate precedenti al <xref:System.AppContext.SetSwitch%2A> (metodo).  
 
 ### <a name="appcontextsetswitch-and-net-core"></a>AppContext.SetSwitch e .NET Core

.NET core supporta la chiamata a livello di codice con il <xref:System.AppContext.SetSwitch%2A> solo di metodo. Sono supportate le opzioni seguenti:

|Opzione|Valori|Descrizione|
|--|--|--|
|`System.Net.Http.useSocketsHttpHandler` |`true`|`false`|Determina se alto livello, ad esempio le API di rete <xref:System.Net.Http.HttpClient> usare <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> (`true`) o <xref:System.Net.Http.HttpClientHandler?displayProperty=nameWithType> (`false`).|   
  
## Examples  
 La riga di codice seguente imposta un'opzione denominata `Switch.AmazingLib.ThrowOnException` a `true`, che consente un comportamento legacy. La libreria è possibile controllare quindi se un consumer della libreria è impostato il valore dell'opzione chiamando il <xref:System.AppContext.TryGetSwitch%2A> metodo.  
  
 [!code-csharp[System.AppContext.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/TestValue1.cs#1)]
 [!code-vb[System.AppContext.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/TestValue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="switchName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="switchName" /> è <see cref="F:System.String.Empty" />.</exception>
        <altmember cref="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public static string TargetFrameworkName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppContext.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ TargetFrameworkName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome della versione del framework di destinazione dell'applicazione corrente.</summary>
        <value>Nome della versione del framework di destinazione dell'applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome della versione di framework di destinazione corrisponde al valore del <xref:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName%2A?displayProperty=nameWithType> proprietà. Per un elenco di nomi di framework di destinazione per .NET Framework, vedere il [ &lt;supportedRuntime&gt; elemento](~/docs/framework/configure-apps/file-schema/startup/supportedruntime-element.md) elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Versioning.TargetFrameworkAttribute" />
        <altmember cref="P:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSwitch">
      <MemberSignature Language="C#" Value="public static bool TryGetSwitch (string switchName, out bool isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSwitch(string switchName, [out] bool&amp; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetSwitch (switchName As String, ByRef isEnabled As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetSwitch(System::String ^ switchName, [Runtime::InteropServices::Out] bool % isEnabled);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchName" Type="System.String" />
        <Parameter Name="isEnabled" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="switchName">Nome dell'opzione.</param>
        <param name="isEnabled">Quando questo metodo termina, contiene il valore di <c>switchName</c> se <c>switchName</c> è stato trovato oppure <see langword="false" /> se <c>switchName</c> non è stato trovato. Questo parametro viene passato non inizializzato.</param>
        <summary>Prova a ottenere il valore di un'opzione.</summary>
        <returns>
          <see langword="true" /> se <paramref name="switchName" /> è stato impostato e l'argomento <paramref name="isEnabled" /> contiene il valore dell'opzione; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.AppContext> classe consente agli autori di librerie fornire un meccanismo di rifiuto esplicito uniforme per la nuova funzionalità per i propri utenti. che stabilisce un contratto a regime di controllo libero ("loosely-coupled") tra componenti per poter comunicare una richiesta di rinuncia esplicita. Questa funzionalità è importante in genere quando viene apportata una modifica alle funzionalità esistenti. Al contrario, esiste già un consenso esplicito per la nuova funzionalità.  
  
 Common language runtime popola automaticamente i commutatori assegnati a un <xref:System.AppContext> istanza mediante la lettura del Registro di sistema e file di configurazione dell'applicazione. Il valore di queste opzioni possa quindi essere sottoposto a override e aggiunta di nuovi switch, chiamando la <xref:System.AppContext.SetSwitch%2A> metodo.  
  
 Una libreria chiama il <xref:System.AppContext.TryGetSwitch%2A> metodo per verificare se i relativi consumer stato dichiarato il valore dell'opzione e agire in modo appropriato su di esso.  Per impostazione predefinita, se l'opzione non è definito, le nuove funzionalità sono abilitata... Se l'opzione è definita e il relativo valore è `false`, la nuova funzionalità è abilitata anche. Se il valore è `true`, il comportamento legacy è abilitato.  
  
   
  
## Examples  
 Nell'esempio seguente determina se un consumer della libreria è impostato un commutatore denominato `Switch.AmazingLib.ThrowOnException`.  
  
 [!code-csharp[System.AppContext.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/TestValue1.cs#2)]
 [!code-vb[System.AppContext.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/TestValue1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="switchName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="switchName" /> è <see cref="F:System.String.Empty" />.</exception>
        <altmember cref="M:System.AppContext.SetSwitch(System.String,System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>