<Type Name="WriteableBitmap" FullName="System.Windows.Media.Imaging.WriteableBitmap">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d8faee124c2155a6b75d903b393c805332cebd28" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30669665" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WriteableBitmap extends System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Imaging.WriteableBitmap" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WriteableBitmap&#xA;Inherits BitmapSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class WriteableBitmap sealed : System::Windows::Media::Imaging::BitmapSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Imaging.BitmapSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> che può essere scritto e aggiornato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Windows.Media.Imaging.WriteableBitmap> classe per aggiornare ed eseguire il rendering di una bitmap con cadenza per frame. Ciò è utile per la generazione del contenuto algoritmico, ad esempio un'immagine frattale e di visualizzazione dei dati, ad esempio un visualizzatore musicale.  
  
 La <xref:System.Windows.Media.Imaging.WriteableBitmap> classe utilizza due buffer. Il *buffer nascosto* allocata nella memoria di sistema e accumula il contenuto non è attualmente visualizzato. Il *buffer anteriore* allocata nella memoria di sistema e il contenuto che è attualmente visualizzato. Il sistema di rendering copia front buffer di memoria video per la visualizzazione.  
  
 Due thread utilizzano questi buffer. Il *thread dell'interfaccia utente* genera l'interfaccia utente ma non viene visualizzata sullo schermo. Il thread dell'interfaccia utente risponde per l'input dell'utente, timer e altri eventi. Un'applicazione può disporre di più thread dell'interfaccia utente. Il *thread di rendering* compone e visualizza le modifiche effettuate dal thread dell'interfaccia utente. È il rendering di un solo thread per ogni applicazione.  
  
 Il thread UI scrive il contenuto al buffer nascosto. Il thread di rendering legge il contenuto dal front buffer e lo copia in memoria video. Le modifiche al buffer nascosto vengono rilevate con aree rettangolari modificate.  
  
 Chiamare uno del <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overload per aggiornare e visualizzare automaticamente il contenuto del buffer nascosto.  
  
 Per un maggiore controllo sugli aggiornamenti e per l'accesso al buffer nascosto a thread multipli, utilizzare il seguente flusso di lavoro.  
  
1.  Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> metodo riservare il buffer nascosto per gli aggiornamenti.  
  
2.  Ottenere un puntatore al buffer nascosto accedendo il <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> proprietà.  
  
3.  Scrivere le modifiche al buffer nascosto. Altri thread può scrivere modifiche sul buffer nascosto quando il <xref:System.Windows.Media.Imaging.WriteableBitmap> è bloccato.  
  
4.  Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> metodo per indicare le aree che sono stati modificati.  
  
5.  Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodo per rilasciare il buffer nascosto e consentire la visualizzazione sullo schermo.  
  
 Quando gli aggiornamenti vengono inviati al thread di rendering, il thread di rendering copia i rettangoli modificati dal buffer nascosto front buffer. Il sistema di rendering controlla questo scambio per evitare i deadlock e ridisegnare elementi, ad esempio "interruzione".  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come un <xref:System.Windows.Media.Imaging.WriteableBitmap> può essere utilizzato come origine di un <xref:System.Windows.Controls.Image> per disegnare pixel quando il mouse viene spostato.  
  
 [!code-csharp[WriteableBitmap2#WriteableBitmapFullPage](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#writeablebitmapfullpage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Imaging.BitmapSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (source As BitmapSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(System::Windows::Media::Imaging::BitmapSource ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Media.Imaging.BitmapSource" />
      </Parameters>
      <Docs>
        <param name="source">Interfaccia <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> da utilizzare per l’inizializzazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> utilizzando l'oggetto <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> costruttore è preferita rispetto all'utilizzo di questo costruttore.  
  
 Se `source` non utilizza un formato di bitmap supportato in modo nativo, vengono applicate le conversioni per ogni aggiornamento frame, riducendo le prestazioni di formato.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 pixelWidth, int32 pixelHeight, float64 dpiX, float64 dpiY, valuetype System.Windows.Media.PixelFormat pixelFormat, class System.Windows.Media.Imaging.BitmapPalette palette) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, System::Windows::Media::PixelFormat pixelFormat, System::Windows::Media::Imaging::BitmapPalette ^ palette);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pixelWidth" Type="System.Int32" />
        <Parameter Name="pixelHeight" Type="System.Int32" />
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
        <Parameter Name="pixelFormat" Type="System.Windows.Media.PixelFormat" />
        <Parameter Name="palette" Type="System.Windows.Media.Imaging.BitmapPalette" />
      </Parameters>
      <Docs>
        <param name="pixelWidth">Larghezza desiderata della bitmap.</param>
        <param name="pixelHeight">Altezza desiderata della bitmap.</param>
        <param name="dpiX">La [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] orizzontale della bitmap.</param>
        <param name="dpiY">Il [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] verticale della bitmap.</param>
        <param name="pixelFormat">Il <see cref="T:System.Windows.Media.PixelFormat" /> della bitmap.</param>
        <param name="palette">Il <see cref="T:System.Windows.Media.Imaging.BitmapPalette" /> della bitmap.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> con i parametri specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori preferiti per `pixelFormat` sono <xref:System.Windows.Media.PixelFormats.Bgr32%2A> e <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. Questi formati sono supportati in modo nativo e non richiedono una conversione di formato. Altri `pixelFormat` valori richiedono una conversione di formato per ogni aggiornamento frame, riducendo le prestazioni.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">Un oggetto di tipo <see cref="T:System.Windows.Int32Rect" /> che rappresenta l’area che ha subito modifiche. Le dimensioni sono espresse in pixel.</param>
        <summary>Specifica l'area della bitmap che ha subito modifiche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> metodo per indicare le modifiche apportate dal codice al buffer nascosto.  
  
 Quando si chiama questo metodo più volte, le aree modificate vengono accumulate in una rappresentazione sufficiente, ma non necessariamente minima. Per motivi di efficienza, solo le aree che sono contrassegnate come dirty sono necessariamente essere copiate nel front buffer. Tuttavia, qualsiasi parte della bitmap può essere copiati in avanti, è necessario assicurarsi che il buffer nascosto sia sempre valido.  
  
 Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> metodo solo tra le chiamate al <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodi, come descritto nel <xref:System.Windows.Media.Imaging.WriteableBitmap> commenti relativi alla classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come specificare l'area del back buffer modificata utilizzando il <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> metodo.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La bitmap non è stata bloccata tramite una chiamata al metodo <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> o <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dirtyRect" /> non rientra nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BackBuffer">
      <MemberSignature Language="C#" Value="public IntPtr BackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int BackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBuffer As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr BackBuffer { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un puntatore al buffer nascosto.</summary>
        <value>Oggetto di tipo <see cref="T:System.IntPtr" /> che punta all’indirizzo di base del buffer nascosto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il buffer contiene il contenuto della bitmap in formato di pixel richiesto dall'utente.  
  
 Aggiornare il buffer nascosto solo tra le chiamate al <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodi. Se non si esegue il flusso di lavoro di blocco/sblocco descritto nel <xref:System.Windows.Media.Imaging.WriteableBitmap> commenti relativi alla classe comportamenti imprevedibili, ad esempio di rimozione, possono verificarsi.  
  
 L'indirizzo del buffer nascosto non cambia.  
  
## <a name="thread-safety"></a>Thread safety  
 È possibile passare il <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> puntatore a componenti esterni e di altri thread per l'elaborazione, ma in caso contrario, è necessario implementare una coordinamento dei thread personalizzati. In particolare, è necessario assicurarsi che il thread dell'interfaccia utente specifica aree modificate tramite la chiamata di <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> metodo e sblocchi il buffer chiamando il <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackBufferStride">
      <MemberSignature Language="C#" Value="public int BackBufferStride { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BackBufferStride" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBufferStride As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BackBufferStride { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica il numero di byte in una singola riga di dati pixel.</summary>
        <value>Un intero che indica il numero di byte in una singola riga di dati pixel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile di questo oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />, eseguendo copie complete dei valori dell'oggetto. Durante la copia delle proprietà di dipendenza, questo metodo copia i riferimenti alle risorse e i data binding (che potrebbero non essere più risolti), ma non le animazioni né i relativi valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato sarà <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per produrre copie modificabili di bloccata <xref:System.Windows.Freezable> oggetti (o qualsiasi <xref:System.Windows.Freezable> oggetto). Per comodità, questo metodo nasconde la versione ereditata con un'implementazione fortemente tipizzata.  
  
 Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile dell'oggetto <see cref="T:System.Windows.Media.Animation.ByteAnimationUsingKeyFrames" />, eseguendo copie complete dei valori correnti di tale oggetto. I riferimenti alle risorse, i data binding e le animazioni non vengono copiati, ma vengono copiati i relativi valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato sarà <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per produrre copie modificabili di bloccata <xref:System.Windows.Freezable> oggetti (o qualsiasi <xref:System.Windows.Freezable> oggetto). Per comodità, questo metodo nasconde la versione ereditata con un'implementazione fortemente tipizzata.  
  
 Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riserva il buffer nascosto per aggiornamenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> metodo incrementa il conteggio dei blocchi. Quando un <xref:System.Windows.Media.Imaging.WriteableBitmap> è bloccato, il sistema di rendering non invia gli aggiornamenti fino al <xref:System.Windows.Media.Imaging.WriteableBitmap> viene sbloccato completamente dalle chiamate al <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodo.  
  
 È possibile utilizzare il <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> metodo per supportare le implementazioni a thread multipli. In questi scenari, il thread dell'interfaccia utente blocca la bitmap ed espone il buffer nascosto agli altri thread. Quando il thread di lavoro ha completato un frame, il thread UI aggiunge rettangoli modificati e sblocca il buffer.  
  
 Il thread dell'interfaccia utente può bloccare quando il thread di rendering acquisisce un blocco per il buffer nascosto per copiarne il front buffer. Se la latenza di tale blocco è troppo lunga, utilizzare il <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> metodo per un breve periodo di tempo di attesa e sbloccare il thread dell'interfaccia utente per eseguire altre attività quando il buffer è bloccato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come riservare il buffer nascosto tramite il <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> metodo.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.Windows.Duration" /> che rappresenta la durata del tempo di attesa. Un valore uguale a 0 produce un ritorno immediato. Un valore di <see cref="P:System.Windows.Duration.Forever" /> blocca la bitmap per un periodo di tempo indefinito.</param>
        <summary>Esegue un tentativo di bloccare la bitmap, attendendo un periodo non superiore al tempo di attesa specificato.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato acquisito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene acquisito un blocco, il comportamento del <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> metodo è lo stesso come il <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è impostato su <see cref="P:System.Windows.Duration.Automatic" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia il buffer nascosto rendendolo disponibile per la visualizzazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodo decrementa il conteggio dei blocchi. Quando il conteggio dei blocchi raggiunge 0, viene richiesto un passaggio di rendering, se il <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> metodo è stato chiamato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rilasciare il buffer nascosto tramite il <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> metodo.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La bitmap non è stata bloccata tramite una chiamata al metodo <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> o <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WritePixels">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna i pixel della bitmap scrivibile.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array pixels, int32 stride, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, pixels As Array, stride As Integer, offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ pixels, int stride, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="pixels" Type="System.Array" />
        <Parameter Name="stride" Type="System.Int32" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Il rettangolo dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> da aggiornare.</param>
        <param name="pixels">La matrice di pixel utilizzata per aggiornare la bitmap.</param>
        <param name="stride">Stride dell'area di aggiornamento in <c>pixels</c>.</param>
        <param name="offset">Offset del buffer di input.</param>
        <summary>Aggiorna i pixel nella regione specificata della bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload vengono preferiti all'utilizzo di questo metodo.  
  
> [!NOTE]
>  In attendibilità parziale, utilizzare il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> rapporto di overload.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come aggiornare un pixel nel buffer nascosto tramite il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> metodo.  
  
 [!code-csharp[WriteableBitmap2#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più delle condizioni seguenti sono vere.  
  
 <paramref name="sourceRect" /> non rientra nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="stride" /> &lt; 1  
  
 <paramref name="offset" /> &lt; 0</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pixels" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          L’oggetto <paramref name="pixels" /> ha rango diverso da 1 o 2, o una lunghezza minore o uguale a 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int buffer, int32 bufferSize, int32 stride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, buffer As IntPtr, bufferSize As Integer, stride As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="buffer" Type="System.IntPtr" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="stride" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Il rettangolo dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> da aggiornare.</param>
        <param name="buffer">Buffer di input utilizzato per aggiornare la bitmap.</param>
        <param name="bufferSize">Dimensione del buffer di input.</param>
        <param name="stride">Stride dell'area di aggiornamento in <c>buffer</c>.</param>
        <summary>Aggiorna i pixel nella regione specificata della bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload vengono preferiti all'utilizzo di questo metodo.  
  
> [!NOTE]
>  In attendibilità parziale, utilizzare il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più delle condizioni seguenti sono vere.  
  
 <paramref name="sourceRect" /> non rientra nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="bufferSize" /> &lt; 1  
  
 <paramref name="stride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array sourceBuffer, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As Array, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.Array" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Rettangolo in <c>sourceBuffer</c> da copiare.</param>
        <param name="sourceBuffer">Buffer di input utilizzato per aggiornare la bitmap.</param>
        <param name="sourceBufferStride">Lo stride del buffer di input, in byte.</param>
        <param name="destinationX">Coordinata x di destinazione del pixel più a sinistra nel buffer nascosto.</param>
        <param name="destinationY">Coordinata y di destinazione del pixel più in alto nel buffer nascosto.</param>
        <summary>Aggiorna i pixel nella regione specificata della bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> per aggiornare il <xref:System.Windows.Media.Imaging.WriteableBitmap> automaticamente con il contenuto di `sourceBuffer`. Chiamare questo metodo è equivalente all'opzione di <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> flusso di lavoro descritto nel <xref:System.Windows.Media.Imaging.WriteableBitmap> commenti relativi alla classe.  
  
> [!NOTE]
>  Utilizzare questo overload in attendibilità parziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più delle condizioni seguenti sono vere.  
  
 <paramref name="sourceRect" /> non rientra nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" /> o <paramref name="destinationY" /> non rientrano nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceBuffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          L’oggetto <paramref name="sourceBuffer" /> ha rango diverso da 1 o 2, o una lunghezza minore o uguale a 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int sourceBuffer, int32 sourceBufferSize, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As IntPtr, sourceBufferSize As Integer, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.IntPtr" />
        <Parameter Name="sourceBufferSize" Type="System.Int32" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Rettangolo in <c>sourceBuffer</c> da copiare.</param>
        <param name="sourceBuffer">Buffer di input utilizzato per aggiornare la bitmap.</param>
        <param name="sourceBufferSize">Dimensione del buffer di input.</param>
        <param name="sourceBufferStride">Lo stride del buffer di input, in byte.</param>
        <param name="destinationX">Coordinata x di destinazione del pixel più a sinistra nel buffer nascosto.</param>
        <param name="destinationY">Coordinata y di destinazione del pixel più in alto nel buffer nascosto.</param>
        <summary>Aggiorna i pixel nella regione specificata della bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> per aggiornare il <xref:System.Windows.Media.Imaging.WriteableBitmap> automaticamente con il contenuto di `sourceBuffer`. Chiamare questo metodo è equivalente all'opzione di <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> e <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> flusso di lavoro descritto nel <xref:System.Windows.Media.Imaging.WriteableBitmap> commenti relativi alla classe.  
  
> [!NOTE]
>  In attendibilità parziale, utilizzare il <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più delle condizioni seguenti sono vere.  
  
 <paramref name="sourceRect" /> non rientra nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" /> o <paramref name="destinationY" /> non rientrano nei limiti dell’oggetto <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferSize" /> &lt; 1  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceBuffer" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>