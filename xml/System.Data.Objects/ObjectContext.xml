<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ecd2cd4d50ae6c4da37e807f9e72409216e26900" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39825013" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce funzionalità per l'esecuzione di query e l'utilizzo di dati delle entità come oggetti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  La classe <xref:System.Data.Objects.ObjectContext> non è thread-safe. L'integrità degli oggetti dati in un <xref:System.Data.Objects.ObjectContext> non può essere assicurata in scenari di multithreading.  
  
 Il <xref:System.Data.Objects.ObjectContext> classe è la classe primaria per l'interazione con i dati come oggetti che sono istanze dei tipi di entità definiti in un modello concettuale. Un'istanza della classe <xref:System.Data.Objects.ObjectContext> incapsula gli elementi seguenti:  
  
-   Una connessione al database sotto forma di oggetto <xref:System.Data.EntityClient.EntityConnection>.  
  
-   I metadati che descrivono il modello sotto forma di oggetto <xref:System.Data.Metadata.Edm.MetadataWorkspace>.  
  
-   Un oggetto <xref:System.Data.Objects.ObjectStateManager> che gestisce gli oggetti salvati in modo persistente nella cache.  
  
 Quando il livello di oggetto che rappresenta un modello concettuale viene generato dagli strumenti di Entity Data Model, la classe che rappresenta il <xref:System.Data.Metadata.Edm.EntityContainer> per il modello è derivato dal <xref:System.Data.Objects.ObjectContext>.  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Nell'esempio viene illustrato come costruire un oggetto <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Oggetto <see cref="T:System.Data.EntityClient.EntityConnection" /> che contiene riferimenti al modello e alla connessione all'origine dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Objects.ObjectContext" /> con la connessione specificata. Durante la costruzione, l'area di lavoro metadati viene estratta dall'oggetto <see cref="T:System.Data.EntityClient.EntityConnection" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="connection" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> non è valido.  -oppure- L'area di lavoro metadati non è valida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Stringa di connessione che fornisce inoltre l'accesso alle informazioni sui metadati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Objects.ObjectContext" /> con la stringa di connessione e il nome del contenitore di entità predefinito specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `connectionString` è una stringa che contiene le informazioni necessarie per accedere a un modello concettuale e per la connessione a un'origine dati. La classe <xref:System.Data.EntityClient.EntityConnectionStringBuilder> può essere utilizzata per formattare correttamente la stringa.  
  
 Genera una stringa di connessione denominata archiviata nel file di configurazione dell'applicazione. Questa stringa di connessione denominata può essere fornita anziché il `connectionString` parametro quando si crea il <xref:System.Data.Objects.ObjectContext> classe.  
  
   
  
## Examples  
 L'esempio in questo argomento si basa sul [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Nell'esempio viene illustrato come costruire un oggetto <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="connectionString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" /> non è valido.  -oppure-  L'area di lavoro metadati non è valida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">Oggetto <see cref="T:System.Data.EntityClient.EntityConnection" /> che contiene riferimenti al modello e alla connessione all'origine dati.</param>
        <param name="defaultContainerName">Nome del contenitore di entità predefinito. Quando <c>defaultContainerName</c> viene impostato tramite questo metodo, la proprietà diventa di sola lettura.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Objects.ObjectContext" /> con la connessione e il nome del contenitore di entità specificati.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="connection" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="connection" />, <paramref name="defaultContainerName" /> o l'area di lavoro metadati non è valida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Stringa di connessione che fornisce inoltre l'accesso alle informazioni sui metadati.</param>
        <param name="defaultContainerName">Nome del contenitore di entità predefinito. Quando <c>defaultContainerName</c> viene impostato tramite questo metodo, la proprietà diventa di sola lettura.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Objects.ObjectContext" /> con la stringa di connessione e il nome del contenitore di entità specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `connectionString` è una stringa che contiene le informazioni necessarie per accedere a un modello concettuale e per la connessione a un'origine dati. La classe <xref:System.Data.EntityClient.EntityConnectionStringBuilder> può essere utilizzata per formattare correttamente la stringa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="connectionString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="connectionString" />, <paramref name="defaultContainerName" /> o l'area di lavoro metadati non è valida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accetta tutte le modifiche apportate agli oggetti nel contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accetta le modifiche apportate a tutte le voci associate nell'oggetto <xref:System.Data.Objects.ObjectStateManager> in modo che lo stato risultante sia Unchanged o Detached.  
  
 Questo metodo scorre tutti gli oggetti <xref:System.Data.Objects.ObjectStateEntry> all'interno di <xref:System.Data.Objects.ObjectStateManager> con lo stato Added o Modified, quindi imposta lo stato della voce su Unchanged. Gli elementi Deleted diventano Detached.  
  
 Se il <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodo è stato chiamato e il <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> non è stato specificato, l'utente deve chiamare il <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> (metodo). Il metodo <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> è utile nello scenario in cui una transazione non è stata eseguita correttamente e l'utente desidera riprovare.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Rappresenta il nome del set di entità che può essere qualificato facoltativamente dal nome del contenitore di entità.</param>
        <param name="entity">Oggetto <see cref="T:System.Object" /> da aggiungere.</param>
        <summary>Aggiunge un oggetto al contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.Data.Objects.ObjectContext.AddObject%2A> su <xref:System.Data.Objects.ObjectContext> per aggiungere l'oggetto al contesto dell'oggetto. Eseguire questa operazione quando si tratta di un nuovo oggetto non ancora presente nell'origine dati. Per altre informazioni, vedere [collegamento e scollegamento di oggetti](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Gli oggetti vengono aggiunti all'oggetto <xref:System.Data.Objects.ObjectStateManager> nello stato <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> o <xref:System.Data.EntityState.Added>.  
  
 Quando si crea un nuovo oggetto correlato a un altro oggetto nel contesto dell'oggetto, aggiungere l'oggetto utilizzando uno dei metodi seguenti:  
  
-   Chiamare il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> su <xref:System.Data.Objects.DataClasses.EntityCollection%601> e specificare l'oggetto correlato. Eseguire questa operazione per una relazione uno-a-molti o molti-a-molti.  
  
-   Impostare la proprietà <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> dell'oggetto <xref:System.Data.Objects.DataClasses.EntityReference%601> sull'oggetto correlato. Eseguire questa operazione per una relazione uno-a-uno o molti-a-uno.  
  
 Per altre informazioni, vedere [creazione, aggiunta, modifica e l'eliminazione di oggetti](http://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Se l'oggetto si trova in un stato detached non deve avere un <xref:System.Data.EntityKey>.  
  
 Le regole per il `entitySetName` formato sono i seguenti:  
  
-   Se il <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> proprietà viene `null`, il `entitySetName` deve essere completo come in * \<nome contenitore entità >*.* \<Nome Set entità >*.  
  
-   Se <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> non è `null`, il `entitySetName` può essere * \<nome contenitore entità >*.* \<Nome Set entità >* oppure * \<nome Set entità >*.  
  
 Se il `object` ha un <xref:System.Data.EntityKey> e `entitySetName` ha un valore, il <xref:System.Data.Metadata.Edm.EntitySet> dell'entità di chiave deve corrispondere il <xref:System.Data.Metadata.Edm.EntitySet> che è stato trovato in base il `entitySetName` e al nome di contenitore di entità.  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'esempio aggiunge un nuovo prodotto e Salva le modifiche apportate al database.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="entity" /> è <see langword="null" />.  -oppure-  L'oggetto <paramref name="entitySetName" /> non è qualificato.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="currentEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Tipo di entità dell'oggetto.</typeparam>
        <param name="entitySetName">Nome del set di entità a cui appartiene l'oggetto.</param>
        <param name="currentEntity">Oggetto disconnesso contenente gli aggiornamenti delle proprietà da applicare all'oggetto originale. La chiave di entità di <c>currentEntity</c> deve corrispondere alla proprietà <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> di una voce nell'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Copia i valori scalari dall'oggetto fornito nell'oggetto in <see cref="T:System.Data.Objects.ObjectContext" /> che dispone della stessa chiave.</summary>
        <returns>Oggetto aggiornato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> metodo viene usato per applicare le modifiche apportate agli oggetti esterni di <xref:System.Data.Objects.ObjectContext>, ad esempio oggetti disconnessi che vengono ricevuti da un servizio Web. Il metodo copia i valori scalari dall'oggetto specificato nell'oggetto nel <xref:System.Data.Objects.ObjectContext> che ha la stessa chiave. È possibile usare il <xref:System.Data.EntityKey> dell'oggetto disconnesso per recuperare un'istanza di questo oggetto dall'origine dati. Per altre informazioni, vedere [procedura: restituire un oggetto specifico usando la relativa chiave](http://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Tutti i valori che differiscono dai valori originali dell'oggetto vengono contrassegnati come modificata. Si noti che il metodo non si applica i valori correnti degli oggetti correlati di `currentEntity`.  
  
 Se si dispone di un grafico con i valori correnti e applicare i valori originali, chiamare <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> (metodo).  
  
 È anche possibile usare il <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> del <xref:System.Data.Objects.ObjectSet%601> oppure <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A> metodo del <xref:System.Data.Objects.ObjectStateEntry>. Per altre informazioni, vedere [compilazione di applicazioni a N livelli](http://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySetName" /> o <paramref name="current" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> derivante da <paramref name="entitySetName" /> non corrisponde all'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> di <see cref="T:System.Data.EntityKey" /> dell'oggetto.  -oppure-  L'oggetto non si trova in stato <see cref="T:System.Data.Objects.ObjectStateManager" /> o si trova in stato <see cref="F:System.Data.EntityState.Detached" />.  -oppure-  La chiave di entità dell'oggetto fornito non è valida.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="entitySetName" /> è una stringa vuota.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="originalEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Tipo dell'oggetto entità.</typeparam>
        <param name="entitySetName">Nome del set di entità a cui appartiene l'oggetto.</param>
        <param name="originalEntity">Oggetto disconnesso contenente i valori originali da applicare all'oggetto. La chiave di entità di <c>originalEntity</c> deve corrispondere alla proprietà <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> di una voce nell'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Copia i valori scalari dall'oggetto fornito nel set di valori originali per l'oggetto nell'oggetto <see cref="T:System.Data.Objects.ObjectContext" /> con la stessa chiave.</summary>
        <returns>Oggetto aggiornato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> metodo viene usato per applicare le modifiche apportate agli oggetti esterni di <xref:System.Data.Objects.ObjectContext>, ad esempio oggetti disconnessi che vengono ricevuti da un servizio Web. Il metodo copia i valori scalari dall'oggetto specificato nell'oggetto nel <xref:System.Data.Objects.ObjectContext> che ha la stessa chiave. È possibile usare il <xref:System.Data.EntityKey> dell'oggetto disconnesso per recuperare un'istanza di questo oggetto dall'origine dati. Per altre informazioni, vedere [procedura: restituire un oggetto specifico usando la relativa chiave](http://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Tutti i valori che differiscono dai valori correnti dell'oggetto vengono contrassegnati come modificata. Si noti che il metodo non si applica i valori correnti degli oggetti correlati di `originalEntity`.  
  
 Se si dispone di un grafico con i valori originali e si desidera applicare i valori correnti, chiamare <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> (metodo).  
  
 È anche possibile usare il <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> del <xref:System.Data.Objects.ObjectSet%601> oppure <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A> metodo del <xref:System.Data.Objects.ObjectStateEntry>. Per altre informazioni, vedere [compilazione di applicazioni a N livelli](http://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySetName" /> o <paramref name="original" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> derivante da <paramref name="entitySetName" /> non corrisponde all'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> di <see cref="T:System.Data.EntityKey" /> dell'oggetto.  -oppure-  Un oggetto <see cref="T:System.Data.Objects.ObjectStateEntry" /> per l'oggetto non è presente nell'oggetto <see cref="T:System.Data.Objects.ObjectStateManager" />. -oppure-  L'oggetto si trova in stato <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Detached" />.  -oppure-  La chiave di entità dell'oggetto fornito non è valida o ne sono state modificate le proprietà.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="entitySetName" /> è una stringa vuota.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nome del set di entità a cui appartiene l'oggetto.</param>
        <param name="changed">Oggetto disconnesso contenente gli aggiornamenti delle proprietà da applicare all'oggetto originale.</param>
        <summary>Applica le modifiche delle proprietà da un oggetto disconnesso a un oggetto già connesso al contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> viene utilizzato per applicare le modifiche delle proprietà da una versione modificata e disconnessa di un oggetto alla versione originale connessa a <xref:System.Data.Objects.ObjectContext>. Vengono supportati scenari, ad esempio i servizi Web, in cui un oggetto entità viene disconnesso e inviato a un'applicazione remota dove vengono eseguiti gli aggiornamenti delle proprietà. Questo metodo consente di applicare più facilmente le modifiche all'oggetto originale.  
  
 Dopo la chiamata al metodo <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>, lo stato dell'oggetto sarà <xref:System.Data.EntityState.Modified>. È necessario chiamare il metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> per aggiornare l'origine dati.  
  
 L'oggetto originale deve essere presente in <xref:System.Data.Objects.ObjectStateManager> e deve trovarsi nello stato <xref:System.Data.EntityState.Modified> o <xref:System.Data.EntityState.Unchanged>. L'oggetto originale viene modificato solo se sono state modificate le proprietà nel `changed` oggetto.  
  
 La proprietà <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> dell'oggetto fornito deve essere impostata su un valore di <xref:System.Data.EntityKey> valido.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> non influisce sulle proprietà di navigazione o sugli oggetti correlati.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> imposta solo le proprietà che sono presenti nei metadati dell'entità per il tipo. Ad esempio, le proprietà aggiunte in una classe parziale non vengono incluse nell'operazione <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se <paramref name="entitySetName" /> è <see langword="null" /> o una stringa vuota.  -oppure-  Quando <paramref name="changed" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Quando l'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> derivante da <paramref name="entitySetName" /> non corrisponde all'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> di <see cref="T:System.Data.EntityKey" /> dell'oggetto.  -oppure-  Quando l'entità si trova in uno stato diverso da <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Unchanged" />.  -oppure-  L'oggetto originale non è connesso al contesto.</exception>
        <exception cref="T:System.ArgumentException">Quando il tipo dell'oggetto <paramref name="changed" /> non è lo stesso tipo dell'oggetto originale.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto da connettere.</param>
        <summary>Connette un oggetto o un oggetto grafico al contesto dell'oggetto quando l'oggetto contiene una chiave di entità.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.Data.Objects.ObjectContext.Attach%2A> su <xref:System.Data.Objects.ObjectContext> per connettere l'oggetto al contesto dell'oggetto. Eseguire questa operazione quando l'oggetto è già presente nell'origine dati ma non è attualmente connesso al contesto. Per altre informazioni, vedere [personalizzazione di oggetti](http://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 <xref:System.Data.Objects.ObjectContext.Attach%2A> viene utilizzato per connettere un oggetto o l'oggetto di primo livello in un oggetto grafico.  
  
 L'oggetto da connettere deve implementare <xref:System.Data.Objects.DataClasses.IEntityWithKey> per esporre un oggetto <xref:System.Data.EntityKey>. Tutte le classi di entità generate implementano <xref:System.Data.Objects.DataClasses.IEntityWithKey>.  
  
 Quando si collega gli oggetti correlati, è necessario chiamare anche `Attach` nella <xref:System.Data.Objects.DataClasses.EntityReference%601> o il <xref:System.Data.Objects.DataClasses.EntityCollection%601> per definire la relazione.  
  
 Questo metodo chiama il metodo <xref:System.Data.Objects.ObjectContext.AttachTo%2A>.  
  
 Le considerazioni seguenti riguardano la connessione di oggetti:  
  
-   Se l'oggetto che viene connesso contiene oggetti correlati, anche tali oggetti vengono connessi al contesto dell'oggetto.  
  
-   Gli oggetti vengono aggiunti al contesto dell'oggetto nello stato Unchanged.  
  
-   L'oggetto passato al metodo <xref:System.Data.Objects.ObjectContext.Attach%2A> deve avere un valore <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> valido. Se l'oggetto non ha un valore <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> valido, utilizzare il metodo <xref:System.Data.Objects.ObjectContext.AttachTo%2A> per specificare il nome del set di entità.  
  
   
  
## Examples  
 L'esempio in questo argomento si basa sul [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). In questo esempio vengono connessi due oggetti, quindi viene definita la relazione.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="entity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Chiave di entità non valida.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Rappresenta il nome del set di entità che può essere qualificato facoltativamente dal nome del contenitore di entità.</param>
        <param name="entity">Oggetto <see cref="T:System.Object" /> da connettere.</param>
        <summary>Connette un oggetto o un oggetto grafico al contesto dell'oggetto in un set di entità specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.Data.Objects.ObjectContext.AttachTo%2A> nella <xref:System.Data.Objects.ObjectContext> per connettere l'oggetto a un'entità specifica impostata nel contesto dell'oggetto oppure se l'oggetto dispone di un `null` (`Nothing` in Visual Basic) <xref:System.Data.EntityKey> valore. Per altre informazioni, vedere [collegamento e scollegamento di oggetti](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 L'oggetto da connettere può essere un singolo oggetto o può fare parte del grafico.  
  
 Le regole per il `entitySetName` formato sono i seguenti:  
  
-   Se il <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> proprietà viene `null`, il `entitySetName` deve essere completo come in * \<nome contenitore entità >*.* \<Nome Set entità >*.  
  
-   Se il <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> non è `null`, il `entitySetName` può essere * \<nome contenitore entità >*.* \<Nome Set entità >* oppure * \<nome Set entità >*.  
  
 Non è necessario che l'oggetto da connettere contenga un oggetto <xref:System.Data.EntityKey> ad esso associato. Se l'oggetto è privo di una chiave di entità, quindi `entitySetName` non può essere una stringa vuota.  
  
 Se l'oggetto da connettere presenta un' <xref:System.Data.EntityKey> e `entitySetName` ha un valore, il <xref:System.Data.Metadata.Edm.EntitySet> dell'entità di chiave deve corrispondere il <xref:System.Data.Metadata.Edm.EntitySet> che è stato trovato in base il `entitySetName` e al nome di contenitore di entità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="entity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Set di entità non valido.  -oppure-  L'oggetto dispone di una chiave temporanea.  -oppure-  L'oggetto contiene un oggetto <see cref="T:System.Data.EntityKey" /> e <see cref="T:System.Data.Metadata.Edm.EntitySet" /> non corrisponde al set di entità passato come argomento del metodo.  -oppure-  L'oggetto non contiene un oggetto <see cref="T:System.Data.EntityKey" /> e non viene fornito un set di entità.  -oppure-  Un oggetto presente nel grafico dell'oggetto contiene un oggetto <see cref="T:System.Data.EntityKey" /> temporaneo.  -oppure-  Un oggetto presente nel grafico dell'oggetto contiene un oggetto <see cref="T:System.Data.EntityKey" /> non valido, ad esempio i valori nella chiave non corrispondono ai valori nell'oggetto.  Impossibile trovare il set di entità in base al nome <paramref name="entitySetName" /> e al nome del contenitore di entità specificati.  -oppure-  Un oggetto presente nel grafico dell'oggetto esiste già in un altro gestore degli stati.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di timeout, espresso in secondi, per tutte le operazioni relative al contesto dell'oggetto. Il valore <see langword="null" /> indica che verrà utilizzato il valore predefinito del provider sottostante.</summary>
        <value>Valore <see cref="T:System.Int32" /> che rappresenta il valore di timeout espresso in secondi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il timeout predefinito per le query di oggetto e l'operazione <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> è definito dal provider di connessione sottostante. È tuttavia possibile eseguire l'override di questo valore di timeout predefinito utilizzando la proprietà <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> in <xref:System.Data.Objects.ObjectContext>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 Eseguire questa operazione in presenza di una query complessa o quando altri problemi di prestazioni provocano il timeout frequente delle query o delle chiamate a <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
   
  
## Examples  
 [Query di oggetto](http://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore di timeout è minore di 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la connessione utilizzata dal contesto dell'oggetto.</summary>
        <value>Oggetto <see cref="T:System.Data.Common.DbConnection" /> che rappresenta la connessione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce l'oggetto connessione passato nel costruttore o creato durante la costruzione. La proprietà della connessione viene determinata dai costruttori utilizzati.  
  
   
  
## Examples  
 In questo esempio viene creato un oggetto <xref:System.Data.EntityClient.EntityConnection>, che viene passato nel costruttore di un oggetto <xref:System.Data.Objects.ObjectContext> con esecuzione prolungata. La connessione viene aperta manualmente. Entrambi gli oggetti <xref:System.Data.EntityClient.EntityConnection> e <xref:System.Data.Objects.ObjectContext> vengono eliminati manualmente.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se l'istanza <see cref="T:System.Data.Objects.ObjectContext" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'istanza di <see cref="T:System.Data.Objects.ObjectContextOptions" /> che contiene le opzioni che influiscono sul comportamento di <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
        <value>Istanza di <see cref="T:System.Data.Objects.ObjectContextOptions" /> che contiene le opzioni che influiscono sul comportamento di <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea il database utilizzando la connessione all'origine dati corrente e i metadati in <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> per visualizzare il script data definition language (DDL). Chiamare <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> per eseguire lo script.  
  
 La maggior parte delle operazioni viene delegata al <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> (metodo).  
  
 Per altre informazioni, vedere [uso di Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera uno script Data Definition Language (DDL) che crea oggetti dello schema (tabelle, chiavi primarie, chiavi esterne) per i metadati in <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> carica metadati dai file Store Schema Definition Language (SSDL).</summary>
        <returns>Script DDL che crea oggetti dello schema per i metadati in <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> per visualizzare lo script DDL. Chiamare <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> per eseguire lo script.  
  
 La maggior parte delle operazioni viene delegata al <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> (metodo).  
  
 Per altre informazioni, vedere [uso di Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nome completo del set di entità a cui appartiene l'oggetto entità.</param>
        <param name="entity">Oggetto per il quale viene recuperata la chiave di entità.</param>
        <summary>Crea la chiave di entità per un oggetto specifico o restituisce la chiave di entità se già esiste.</summary>
        <returns>
          <see cref="T:System.Data.EntityKey" /> dell'oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un' <xref:System.Data.EntityKey> non esiste per il `entity`, il <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> metodo crea una nuova chiave per tale.  
  
 Questo metodo viene utilizzato per determinare se un oggetto contenente lo stesso oggetto <xref:System.Data.EntityKey> è già connesso a <xref:System.Data.Objects.ObjectContext>. Se un oggetto contenente lo stesso oggetto <xref:System.Data.EntityKey> è già connesso, viene generata un'eccezione. Utilizzare il metodo <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> per tentare di recuperare l'oggetto <xref:System.Data.EntityKey> dell'oggetto disconnesso prima di chiamare il metodo <xref:System.Data.Objects.ObjectContext.Attach%2A>.  
  
   
  
## Examples  
 L'esempio in questo argomento si basa sul [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). In questo esempio viene utilizzato il metodo <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> per recuperare la chiave di entità di un oggetto esistente.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Quando uno dei parametri è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se <paramref name="entitySetName" /> è vuoto.  -oppure-  Quando il tipo dell'oggetto <paramref name="entity" /> non è presente nel set di entità.  -oppure-  Quando il parametro <paramref name="entitySetName" /> non è completo.</exception>
        <exception cref="T:System.InvalidOperationException">Quando la chiave di entità non può essere costruita correttamente in base ai parametri specificati.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo di oggetto da restituire.</typeparam>
        <summary>Crea e restituisce un'istanza del tipo richiesto.</summary>
        <returns>Istanza del tipo <paramref name="T" /> richiesto o istanza di un tipo derivato che consente l'utilizzo di <paramref name="T" /> con Entity Framework. L'oggetto restituito è un'istanza del tipo richiesto o un'istanza di un tipo derivato che consente l'utilizzo del tipo richiesto con Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.CreateObject%2A> metodo viene utilizzato con classi di dati personalizzate POCO per assicurarsi che l'oggetto restituito possa essere gestito correttamente da Entity Framework. Per altre informazioni, vedere [i requisiti per la creazione di proxy POCO](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) e [utilizzano entità POCO](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Tipo di entità dell'oggetto <see cref="T:System.Data.Objects.ObjectSet`1" /> richiesto.</typeparam>
        <summary>Crea una nuova istanza di <see cref="T:System.Data.Objects.ObjectSet`1" /> utilizzata per eseguire query su oggetti dell'entità specificata, aggiungere tali oggetti, modificarli ed eliminarli.</summary>
        <returns>Nuova istanza di <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> non viene impostata in <see cref="T:System.Data.Objects.ObjectContext" />.  -oppure-  Il tipo specificato appartiene a più di un set di entità.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Tipo di entità dell'oggetto <see cref="T:System.Data.Objects.ObjectSet`1" /> richiesto.</typeparam>
        <param name="entitySetName">Nome del set di entità per l'oggetto <see cref="T:System.Data.Objects.ObjectSet`1" /> restituito. La stringa deve essere qualificata dal nome del contenitore predefinito se la proprietà <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> non è impostata su <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Crea una nuova istanza di <see cref="T:System.Data.Objects.ObjectSet`1" /> utilizzata per eseguire query su oggetti del tipo specificato e con il nome del set di entità specificato, aggiungere tali oggetti, modificarli ed eliminarli.</summary>
        <returns>Nuova istanza di <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> derivante da <paramref name="entitySetName" /> non corrisponde all'oggetto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> di <see cref="T:System.Data.EntityKey" /> dell'oggetto.  -oppure-  La proprietà <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> non è impostata in <see cref="T:System.Data.Objects.ObjectContext" /> e il nome non è qualificato come parte del parametro <paramref name="entitySetName" />.  -oppure-  Il tipo specificato appartiene a più di un set di entità.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="types">Enumerazione di oggetti <see cref="T:System.Type" /> che rappresentano classi di dati personalizzate mappate al modello concettuale.</param>
        <summary>Genera un tipo equivalente che può essere utilizzato con Entity Framework per ogni tipo nell'enumerazione fornita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipi singoli nel `types` enumerazione che non eseguono il mapping a un tipo di entità nel modello concettuale vengono ignorati.  
  
 Per altre informazioni, vedere [i requisiti per la creazione di proxy POCO](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) e [utilizzano entità POCO](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo di entità dell'oggetto <see cref="T:System.Data.Objects.ObjectQuery`1" /> restituito.</typeparam>
        <param name="queryString">Stringa di query da eseguire.</param>
        <param name="parameters">Parametri da passare alla query.</param>
        <summary>Crea un oggetto <see cref="T:System.Data.Objects.ObjectQuery`1" /> nel contesto dell'oggetto corrente utilizzando la stringa di query specificata.</summary>
        <returns>Oggetto <see cref="T:System.Data.Objects.ObjectQuery`1" /> del tipo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Data.Objects.ObjectContext.CreateQuery%2A> per creare un oggetto <xref:System.Data.Objects.ObjectQuery%601> del tipo specificato appartenente al contesto dell'oggetto corrente.  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Nell'esempio viene creata una query semplice e viene scorso la raccolta di risultati.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="queryString" /> o il parametro <paramref name="parameters" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Controlla se il database specificato come database nella connessione all'origine dati corrente esiste nell'origine dati.</summary>
        <returns>
          <see langword="true" /> se il database esiste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maggior parte delle operazioni viene delegata al <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> (metodo).  
  
 Per altre informazioni, vedere [uso di Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del contenitore predefinito.</summary>
        <value>Oggetto <see cref="T:System.String" /> che rappresenta il nome del contenitore predefinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> non restituisce mai `null`; restituisce il valore impostato o una stringa vuota. L'utente può impostare questa proprietà su `null`, ma il nome verrà impostato internamente su una stringa vuota, in modo che l'utente non dovrà mai cercare sia una stringa vuota e `null`.  
  
 Il nome del contenitore predefinito viene definito anche come parte di un costruttore. Se il nome del contenitore predefinito viene impostato tramite il costruttore protetto, la proprietà diventa di sola lettura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina il database specificato come database nella connessione all'origine dati corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maggior parte delle operazioni viene delegata al <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> (metodo).  
  
 Per altre informazioni, vedere [uso di Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto che specifica l'entità da eliminare. L'oggetto può trovarsi in qualsiasi stato ad eccezione di <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Contrassegna un oggetto per l'eliminazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrassegna un oggetto per l'eliminazione da <xref:System.Data.Objects.ObjectStateManager>. L'oggetto viene eliminato dall'origine dati quando viene chiamato il metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
 L'eliminazione dell'oggetto padre comporta anche l'eliminazione di tutti gli oggetti figlio nella relazione vincolata. Il risultato è identico a quello prodotto dall'attivazione della proprietà `CascadeDelete` nell'associazione per la relazione.  
  
 Il <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> metodo può essere chiamato su oggetti che sono già stati eliminati.  
  
   
  
## Examples  
 Questi esempi si basano sulla [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Questo esempio si costruisce un <xref:System.Data.EntityKey> con uno specifico ID di prodotto, Usa la chiave per recuperare un oggetto prodotto dall'origine dati, viene eliminato il prodotto e Salva le modifiche apportate al database.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 In questo esempio viene eliminato un elemento di ordine esistente, aggiunge un nuovo elemento e Salva le modifiche apportate al database.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> non esiste.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto da disconnettere. Viene rimosso solo l'elemento <c>entity</c>. Se sono presenti oggetti correlati che vengono rilevati dallo stesso elemento <see cref="T:System.Data.Objects.ObjectStateManager" />, tali oggetti non verranno disconnessi automaticamente.</param>
        <summary>Rimuove l'oggetto dal contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rimuove l'oggetto da <xref:System.Data.Objects.ObjectStateManager>. In questo modo vengono disabilitati il rilevamento delle modifiche e la risoluzione di identità per l'oggetto. Per altre informazioni, vedere [collegamento e scollegamento di oggetti](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Dopo la chiamata al metodo <xref:System.Data.Objects.ObjectContext.Detach%2A>, il sistema non manterrà più i riferimenti che puntano a questo oggetto che potrà essere raccolto dal Garbage Collector.  
  
> [!NOTE]
>  La procedura di Garbage Collection può verificarsi solo se il codice utente non contiene alcun riferimento all'oggetto disconnesso.  
  
 Le considerazioni seguenti riguardano la disconnessione di oggetti:  
  
-   <xref:System.Data.Objects.ObjectContext.Detach%2A> influisce solo sull'oggetto specifico passato al metodo. Se l'oggetto che viene disconnesso ha oggetti correlati nel contesto dell'oggetto, tali oggetti non vengono disconnessi.  
  
-   La disconnessione degli oggetti non influisce sui dati presenti nell'origine dati.  
  
-   Le direttive di eliminazione a catena e i vincoli referenziali non vengono applicati durante un'operazione di disconnessione.  
  
 Per altre informazioni, vedere [collegamento e scollegamento di oggetti](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="entity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> non è associato all'oggetto <see cref="T:System.Data.Objects.ObjectContext" />, ad esempio è stato appena creato e non è stato ancora associato a un contesto oppure è stato ottenuto mediante un altro contesto o è già stato disconnesso.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Assicura che le modifiche di <see cref="T:System.Data.Objects.ObjectStateEntry" /> siano sincronizzate con le modifiche in tutti gli oggetti di cui tiene traccia <see cref="T:System.Data.Objects.ObjectStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse utilizzate dal contesto dell'oggetto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse utilizzate dal contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è stata aperta da Entity Framework, questo metodo chiude la connessione. Dopo aver <xref:System.Data.Objects.ObjectContext.Dispose%2A> viene chiamato, operazioni che richiedono una connessione aperta, ad esempio l'esecuzione di una query o la chiamata di <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metodo genererà un'eccezione. Le operazioni che non richiedono una connessione aperta, ad esempio la formulazione di una query o la connessione di oggetti, non genereranno un'eccezione. Il <xref:System.Data.Objects.ObjectContext.Dispose%2A> metodo chiude le connessioni aperte in modo esplicito.  
  
 Limitazione dell'ambito di un' <xref:System.Data.Objects.ObjectContext> all'interno di un `using` blocco (`Using` in Visual Basic) assicura la corretta eliminazione delle risorse. Per altre informazioni, vedere [alla gestione delle connessioni e transazioni](http://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 Il <xref:System.Data.Objects.ObjectContext.Dispose> chiamate al metodo il `virtual` (`Overridable` in Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse utilizzate dal contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiude la connessione. Dopo aver <xref:System.Data.Objects.ObjectContext.Dispose%2A> viene chiamato, operazioni che richiedono una connessione aperta, ad esempio l'esecuzione di una query o la chiamata di <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metodo genererà un'eccezione. Le operazioni che non richiedono una connessione aperta, ad esempio la formulazione di una query o la connessione di oggetti, non genereranno un'eccezione.  
  
 Limitazione dell'ambito di un' <xref:System.Data.Objects.ObjectContext> all'interno di un `using` blocco (`Using` in Visual Basic) assicura che le risorse vengano eliminate correttamente. Per altre informazioni, vedere [alla gestione delle connessioni e transazioni](http://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Nome della stored procedure o della funzione. Il nome può includere il nome del contenitore, ad esempio <c>&lt;Container Name&gt;.&lt;Function Name&gt;</c>. Quando è noto il nome del contenitore predefinito, è necessario solo il nome della funzione.</param>
        <param name="parameters">Matrice di oggetti <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Esegue una stored procedure o una funzione definita nell'origine dati ed espressa nel modello concettuale, rimuove qualsiasi risultato restituito dalla funzione e restituisce il numero di righe interessate dall'esecuzione.</summary>
        <returns>Numero di righe interessate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> è null o vuoto  -oppure-  <paramref name="function" /> non viene trovato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore dell'entità non supporta <paramref name="function" />.  -oppure-  Tipi non corrispondenti nel lettore e in <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Tipo di entità dell'oggetto <see cref="T:System.Data.Objects.ObjectResult`1" /> restituito quando viene eseguita la funzione sull'origine dati. Questo tipo deve implementare <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nome della stored procedure o della funzione. Il nome può includere il nome del contenitore, ad esempio <c>&lt;Container Name&gt;.&lt;Function Name&gt;</c>. Quando è noto il nome del contenitore predefinito, è necessario solo il nome della funzione.</param>
        <param name="parameters">Matrice di oggetti <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Esegue una stored procedure o una funzione definita nell'origine dati e mappata nel modello concettuale, con i parametri specificati. Restituisce un oggetto <see cref="T:System.Data.Objects.ObjectResult`1" /> tipizzato.</summary>
        <returns>Oggetto <see cref="T:System.Data.Objects.ObjectResult`1" /> per i dati restituiti dalla stored procedure.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> è un metodo helper che viene usato per eseguire stored procedure o funzioni definite nell'origine dati ed espressa nel modello concettuale. Gli strumenti di Entity Data Model generano un metodo per ogni elemento nel modello concettuale. Questi metodi chiamano l'oggetto fortemente tipizzato `ExecuteFunction` per restituire un oggetto tipizzato <xref:System.Data.Objects.ObjectResult%601>. Per altre informazioni, vedere [codice dell'applicazione usando Stored procedure (Framework di entità)](http://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Tutti i parametri per la funzione sono necessari nella matrice di parametri e tutti i tipi vengono confrontati con i metadati per la funzione di importazione, incluso il tipo della funzione stessa. `null` per i tipi di valore CLR sono consentiti valori. La convalida dei parametri viene eseguita dal provider.  
  
 Il <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> metodo viene utilizzato il <xref:System.Data.Objects.MergeOption> pari a <xref:System.Data.Objects.MergeOption.AppendOnly>. Pertanto, se un oggetto esiste già nel contesto dell'oggetto, non venga caricato dall'origine dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> è null o vuoto  -oppure-  <paramref name="function" /> non viene trovato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore dell'entità non supporta <paramref name="function" />.  -oppure-  Tipi non corrispondenti nel lettore e in <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Tipo di entità dell'oggetto <see cref="T:System.Data.Objects.ObjectResult`1" /> restituito quando viene eseguita la funzione sull'origine dati. Questo tipo deve implementare <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nome della stored procedure o della funzione. Il nome può includere il nome del contenitore, ad esempio <c>&lt;Container Name&gt;.&lt;Function Name&gt;</c>. Quando è noto il nome del contenitore predefinito, è necessario solo il nome della funzione.</param>
        <param name="mergeOption">Oggetto <see cref="T:System.Data.Objects.MergeOption" /> da utilizzare quando viene eseguita la query.</param>
        <param name="parameters">Matrice di oggetti <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Esegue la stored procedure o la funzione specificata, definita nell'origine dati ed espressa nel modello concettuale, con i parametri specificati e l'opzione di unione. Restituisce un oggetto <see cref="T:System.Data.Objects.ObjectResult`1" /> tipizzato.</summary>
        <returns>Oggetto <see cref="T:System.Data.Objects.ObjectResult`1" /> per i dati restituiti dalla stored procedure.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> è un metodo helper che viene usato per eseguire stored procedure o funzioni definite nell'origine dati ed espressa nel modello concettuale. Gli strumenti di Entity Data Model generano un metodo per ogni elemento nel modello concettuale. Questi metodi chiamano l'oggetto fortemente tipizzato `ExecuteFunction` per restituire un oggetto tipizzato <xref:System.Data.Objects.ObjectResult%601>. Per altre informazioni, vedere [codice dell'applicazione usando Stored procedure (Framework di entità)](http://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Tutti i parametri per la funzione sono necessari nella matrice di parametri e tutti i tipi vengono confrontati con i metadati per la funzione di importazione, incluso il tipo della funzione stessa. `null` per i tipi di valore CLR sono consentiti valori. La convalida dei parametri viene eseguita dal provider.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> è null o vuoto  -oppure-  <paramref name="function" /> non viene trovato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore dell'entità non supporta <paramref name="function" />.  -oppure-  Tipi non corrispondenti nel lettore e in <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Comando da eseguire, nel linguaggio nativo dell'origine dati.</param>
        <param name="parameters">Matrice di parametri da passare al comando.</param>
        <summary>Esegue un comando arbitrario direttamente sull'origine dati utilizzando la connessione esistente.</summary>
        <returns>Numero di righe interessate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'uso di comandi con parametri consente di salvaguardarsi da attacchi SQL injection, un cui un utente non autorizzato inserisce in un'istruzione SQL un comando che compromette la sicurezza del server. I comandi con parametri salvaguardarsi da attacchi SQL injection garantendo che i valori ricevuti da un'origine esterna verranno passati come semplici valori e non fa parte dell'istruzione SQL. Di conseguenza, i comandi SQL inseriti in un valore non vengono eseguiti nell'origine dati. Verranno invece valutati solo come un valore del parametro. Oltre ai vantaggi di sicurezza, i comandi con parametri rappresentano un metodo pratico per organizzare i valori passati con un'istruzione SQL o a una stored procedure.  
  
 Il valore `parameters` può essere una matrice di oggetti <xref:System.Data.Common.DbParameter> o una matrice di valori dei parametri. Se i valori vengono forniti solo, una matrice di <xref:System.Data.Common.DbParameter> gli oggetti vengono creati in base all'ordine dei valori nella matrice.  
  
 Il comando di archiviazione viene eseguito nel contesto della transazione corrente, se è presente una transazione corrente.  
  
 Per altre informazioni, vedere:  
  
 [Eseguire direttamente comandi Store](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) e  
  
 [Procedura: eseguire direttamente comandi sull'origine dati](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="commandText">Comando da eseguire, nel linguaggio nativo dell'origine dati.</param>
        <param name="parameters">Matrice di parametri da passare al comando.</param>
        <summary>Esegue una query direttamente sull'origine dati che restituisce una sequenza di risultati tipizzati.</summary>
        <returns>Enumerazione di oggetti di tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> metodo utilizza la connessione esistente per eseguire un comando arbitrario direttamente sull'origine dati. Il comando di archiviazione viene eseguito nel contesto della transazione corrente, se tale transazione esiste.  
  
 La chiamata al metodo <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> equivale alla chiamata al metodo <xref:System.Data.Common.DbCommand.ExecuteReader%2A> della classe <xref:System.Data.Common.DbCommand>. Solo mediante il metodo <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> vengono restituite le entità mentre mediante il metodo <xref:System.Data.Common.DbCommand.ExecuteReader%2A> vengono restituiti i valori di proprietà dell'oggetto <xref:System.Data.Common.DbDataReader>.  
  
 Chiamare il <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> con l'entità specificata nome del set, se si desidera che per i risultati da rilevare.  
  
 Chiamare il <xref:System.Data.Objects.ObjectContext.Translate%2A> metodo per convertire un <xref:System.Data.Common.DbDataReader> in oggetti entità quando il lettore contiene righe di dati che eseguono il mapping al tipo di entità specificato.  
  
 L'uso di comandi con parametri consente di salvaguardarsi da attacchi SQL injection, un cui un utente non autorizzato inserisce in un'istruzione SQL un comando che compromette la sicurezza del server. I comandi con parametri salvaguardarsi da attacchi SQL injection garantendo che i valori ricevuti da un'origine esterna verranno passati come semplici valori e non fa parte dell'istruzione SQL. Di conseguenza, i comandi SQL inseriti in un valore non vengono eseguiti nell'origine dati. Verranno invece valutati solo come un valore del parametro. Oltre ai vantaggi di sicurezza, i comandi con parametri rappresentano un metodo pratico per organizzare i valori passati con un'istruzione SQL o a una stored procedure.  
  
 Il valore `parameters` può essere una matrice di oggetti <xref:System.Data.Common.DbParameter> o una matrice di valori dei parametri. Se i valori vengono forniti solo, una matrice di <xref:System.Data.Common.DbParameter> gli oggetti vengono creati in base all'ordine dei valori nella matrice.  
  
 Per altre informazioni, vedere:  
  
 [Eseguire direttamente comandi Store](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) e  
  
 [Procedura: eseguire direttamente comandi sull'origine dati](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="commandText">Comando da eseguire, nel linguaggio nativo dell'origine dati.</param>
        <param name="entitySetName">Set di entità del tipo <c>TResult</c>. Se non viene fornito un nome del set di entità, i risultati non verranno rilevati.</param>
        <param name="mergeOption">Oggetto <see cref="T:System.Data.Objects.MergeOption" /> da utilizzare quando viene eseguita la query. Il valore predefinito è <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Matrice di parametri da passare al comando.</param>
        <summary>Esegue una query direttamente sull'origine dati e restituisce una sequenza di risultati tipizzati. Specificare il set di entità e l'opzione di unione in modo da poter rilevare i risultati della query come entità.</summary>
        <returns>Enumerazione di oggetti di tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> metodo utilizza la connessione esistente per eseguire un comando arbitrario direttamente sull'origine dati. Il comando di archiviazione viene eseguito nel contesto della transazione corrente, se tale transazione esiste.  
  
 La chiamata al metodo <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> equivale alla chiamata al metodo <xref:System.Data.Common.DbCommand.ExecuteReader%2A> della classe <xref:System.Data.Common.DbCommand>. Solo mediante il metodo <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> vengono restituite le entità mentre mediante il metodo <xref:System.Data.Common.DbCommand.ExecuteReader%2A> vengono restituiti i valori di proprietà dell'oggetto <xref:System.Data.Common.DbDataReader>.  
  
 Specificare il che nome del set di entità se si desidera che per i risultati da rilevare come entità.  
  
 Chiamare <xref:System.Data.Objects.ObjectContext.Translate%2A> metodo per convertire un <xref:System.Data.Common.DbDataReader> in oggetti entità quando il lettore contiene righe di dati che eseguono il mapping al tipo di entità specificato.  
  
 L'uso di comandi con parametri consente di salvaguardarsi da attacchi SQL injection, un cui un utente non autorizzato inserisce in un'istruzione SQL un comando che compromette la sicurezza del server. I comandi con parametri salvaguardarsi da attacchi SQL injection garantendo che i valori ricevuti da un'origine esterna verranno passati come semplici valori e non fa parte dell'istruzione SQL. Di conseguenza, i comandi SQL inseriti in un valore non vengono eseguiti nell'origine dati. Verranno invece valutati solo come un valore del parametro. Oltre ai vantaggi di sicurezza, i comandi con parametri rappresentano un metodo pratico per organizzare i valori passati con un'istruzione SQL o a una stored procedure.  
  
 Il valore `parameters` può essere una matrice di oggetti <xref:System.Data.Common.DbParameter> o una matrice di valori dei parametri. Se i valori vengono forniti solo, una matrice di <xref:System.Data.Common.DbParameter> gli oggetti vengono creati in base all'ordine dei valori nella matrice.  
  
 Per altre informazioni, vedere:  
  
 [Eseguire direttamente comandi Store](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) e  
  
 [Procedura: eseguire direttamente comandi sull'origine dati](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i tipi di proxy esistenti.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> di tutti i tipi di proxy esistenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> metodo viene utilizzato durante la generazione di oggetti proxy è abilitata per le entità POCO. Per altre informazioni, vedere [i requisiti per la creazione di proxy POCO](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) e [utilizzano entità POCO](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'oggetto da trovare.</param>
        <summary>Restituisce un oggetto contenente la chiave di entità specificata.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta un'istanza di un tipo di entità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> tenta di recuperare un oggetto contenente l'oggetto <xref:System.Data.EntityKey> specificato da <xref:System.Data.Objects.ObjectStateManager>. Se l'oggetto non è attualmente caricato nel contesto dell'oggetto, viene eseguita una query nel tentativo di restituire l'oggetto dall'origine dati. Per altre informazioni, vedere [query di oggetto](http://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> genera un'eccezione <xref:System.Data.ObjectNotFoundException> quando non è possibile trovare l'oggetto. Per evitare di gestire questa eccezione, utilizzare invece il metodo <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>.  
  
 Questo metodo restituirà gli oggetti che si trovano nello stato <xref:System.Data.EntityState.Deleted>.  
  
 Non è possibile utilizzare una chiave temporanea per restituire un oggetto dall'origine dati.  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Nell'esempio viene creato un oggetto <xref:System.Data.EntityKey> per un'entità del tipo specificato, viene quindi recuperata un'entità in base alla chiave.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">L'oggetto non viene trovato nell'oggetto <see cref="T:System.Data.Objects.ObjectStateManager" /> né nell'origine dati.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Oggetto <see cref="T:System.Type" /> dell'oggetto proxy.</param>
        <summary>Restituisce il tipo di entità dell'entità POCO associata a un oggetto proxy di un tipo specificato.</summary>
        <returns>Classe <see cref="T:System.Type" /> dell'entità POCO associata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> metodo viene utilizzato durante la generazione di oggetti proxy è abilitata per le entità POCO. Per altre informazioni, vedere [i requisiti per la creazione di proxy POCO](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) e [utilizzano entità POCO](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica in modo esplicito un oggetto correlato quando si utilizzano classi di dati personalizzate POCO.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizzano classi di dati personalizzate POCO, gli oggetti correlati non possono essere caricati in modo esplicito, ad esempio le istanze dei tipi di entità generati dagli strumenti di Entity Data Model. Questo accade perché gli strumenti generano le proprietà di navigazione che restituiscono un <xref:System.Data.Objects.DataClasses.EntityCollection%601> oppure <xref:System.Data.Objects.DataClasses.EntityReference%601> di oggetti correlati quando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> viene chiamato su un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Le entità POCO possono comunque essere caricate utilizzando il caricamento lazy impostando il <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> proprietà `true` nell'istanza di <xref:System.Data.Objects.ObjectContextOptions> restituito dal <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> proprietà, o tramite il caricamento eager con il <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodo sul <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entity">Entità per la quale devono essere caricati gli oggetti correlati.</param>
        <param name="navigationProperty">Nome della proprietà di navigazione che restituisce gli oggetti correlati da caricare.</param>
        <summary>Carica in modo esplicito un oggetto correlato all'oggetto fornito in base alla proprietà di navigazione specificata e utilizzando l'opzione di unione predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metodo deve essere chiamato per ottenere il caricamento esplicito quando si utilizzano classi di dati personalizzate POCO.  
  
 Dopo aver chiamato <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l'oggetto correlato è possibile accedere tramite le proprietà di navigazione dell'entità di origine.  
  
 Quando si utilizzano classi di dati personalizzate POCO, gli oggetti correlati non possono essere caricati in modo esplicito, ad esempio le istanze dei tipi di entità generati dagli strumenti di Entity Data Model. Questo accade perché gli strumenti generano le proprietà di navigazione che restituiscono un <xref:System.Data.Objects.DataClasses.EntityCollection%601> oppure <xref:System.Data.Objects.DataClasses.EntityReference%601> di oggetti correlati quando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> viene chiamato su un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Le entità POCO possono comunque essere caricate utilizzando il caricamento lazy impostando il <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> proprietà `true` nell'istanza di <xref:System.Data.Objects.ObjectContextOptions> restituito dal <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> proprietà, o tramite il caricamento eager con il <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodo sul <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Quando la <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> viene chiamato il metodo, gli oggetti vengono caricati nel <xref:System.Data.Objects.ObjectContext> usando il valore predefinito <xref:System.Data.Objects.MergeOption> valore <xref:System.Data.Objects.MergeOption.AppendOnly>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <paramref name="entity" /> è nello stato <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />,  -oppure-  Il parametro <paramref name="entity" /> è associato all'altra istanza dell'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="entity">Entità per la quale devono essere caricati gli oggetti correlati.</param>
        <param name="navigationProperty">Nome della proprietà di navigazione che restituisce gli oggetti correlati da caricare.</param>
        <param name="mergeOption">Valore di <see cref="T:System.Data.Objects.MergeOption" /> da utilizzare quando si caricano gli oggetti correlati.</param>
        <summary>Carica in modo esplicito un oggetto correlato all'oggetto fornito in base alla proprietà di navigazione specificata e utilizzando l'opzione di unione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metodo deve essere chiamato per ottenere il caricamento esplicito quando si utilizzano classi di dati personalizzate POCO.  
  
 Dopo aver chiamato <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l'oggetto correlato è possibile accedere tramite le proprietà di navigazione dell'entità di origine.  
  
 Quando si utilizzano classi di dati personalizzate POCO, gli oggetti correlati non possono essere caricati in modo esplicito, ad esempio le istanze dei tipi di entità generati dagli strumenti di Entity Data Model. Questo accade perché gli strumenti generano le proprietà di navigazione che restituiscono un <xref:System.Data.Objects.DataClasses.EntityCollection%601> oppure <xref:System.Data.Objects.DataClasses.EntityReference%601> di oggetti correlati quando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> viene chiamato su un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Le entità POCO possono comunque essere caricate utilizzando il caricamento lazy impostando il <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> proprietà `true` nell'istanza di <xref:System.Data.Objects.ObjectContextOptions> restituito dal <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> proprietà, o tramite il caricamento eager con il <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodo sul <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <paramref name="entity" /> è nello stato <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />,  -oppure-  Il parametro <paramref name="entity" /> è associato all'altra istanza dell'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Oggetto di origine per il quale vengono caricati gli oggetti correlati.</param>
        <param name="selector">Espressione LINQ che definisce gli oggetti correlati da caricare.</param>
        <summary>Carica in modo esplicito un oggetto correlato all'oggetto fornito in base alla query LINQ specificata e utilizzando l'opzione di unione predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metodo deve essere chiamato per ottenere il caricamento esplicito quando si utilizzano classi di dati personalizzate POCO.  
  
 Dopo aver chiamato <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l'oggetto correlato è possibile accedere tramite le proprietà di navigazione dell'entità di origine.  
  
 La proprietà da caricare viene specificata da un'espressione LINQ, che deve essere sotto forma di un accesso ai membri di proprietà semplice, come in `(entity) => entity.PropertyName`, dove *NomeProprietà* è la proprietà di navigazione che restituisce gli oggetti correlati da caricare. Se si usano altre forme dell'espressione LINQ, si verificherà un'eccezione.  
  
 Quando si utilizzano classi di dati personalizzate POCO, gli oggetti correlati non possono essere caricati in modo esplicito, ad esempio le istanze dei tipi di entità generati dagli strumenti di Entity Data Model. Questo accade perché gli strumenti generano le proprietà di navigazione che restituiscono un <xref:System.Data.Objects.DataClasses.EntityCollection%601> oppure <xref:System.Data.Objects.DataClasses.EntityReference%601> di oggetti correlati quando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> viene chiamato su un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Le entità POCO possono comunque essere caricate utilizzando il caricamento lazy impostando il <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> proprietà `true` nell'istanza di <xref:System.Data.Objects.ObjectContextOptions> restituito dal <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> proprietà, o tramite il caricamento eager con il <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodo sul <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> non fornisce un parametro di input valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> è null.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <paramref name="entity" /> è nello stato <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />,  -oppure-  Il parametro <paramref name="entity" /> è associato all'altra istanza dell'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Oggetto di origine per il quale vengono caricati gli oggetti correlati.</param>
        <param name="selector">Espressione LINQ che definisce gli oggetti correlati da caricare.</param>
        <param name="mergeOption">Valore di <see cref="T:System.Data.Objects.MergeOption" /> da utilizzare quando si caricano gli oggetti correlati.</param>
        <summary>Carica in modo esplicito un oggetto correlato all'oggetto fornito in base alla query LINQ specificata e utilizzando l'opzione di unione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metodo deve essere chiamato per ottenere il caricamento esplicito quando si utilizzano classi di dati personalizzate POCO.  
  
 Dopo aver chiamato <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l'oggetto correlato è possibile accedere tramite le proprietà di navigazione dell'entità di origine.  
  
 La proprietà da caricare viene specificata da un'espressione LINQ, che deve essere sotto forma di un accesso ai membri di proprietà semplice, come in `(entity) => entity.PropertyName` in cui *NomeProprietà* è la proprietà di navigazione che restituisce gli oggetti correlati da caricare. Se si usano altre forme dell'espressione LINQ, si verificherà un'eccezione.  
  
 Quando si utilizzano classi di dati personalizzate POCO, gli oggetti correlati non possono essere caricati in modo esplicito, ad esempio le istanze dei tipi di entità generati dagli strumenti di Entity Data Model. Questo accade perché gli strumenti generano le proprietà di navigazione che restituiscono un <xref:System.Data.Objects.DataClasses.EntityCollection%601> oppure <xref:System.Data.Objects.DataClasses.EntityReference%601> di oggetti correlati quando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> viene chiamato su un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Le entità POCO possono comunque essere caricate utilizzando il caricamento lazy impostando il <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> proprietà `true` nell'istanza di <xref:System.Data.Objects.ObjectContextOptions> restituito dal <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> proprietà, o tramite il caricamento eager con il <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodo sul <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> non fornisce un parametro di input valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> è null.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <paramref name="entity" /> è nello stato <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />,  -oppure-  Il parametro <paramref name="entity" /> è associato all'altra istanza dell'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'area di lavoro metadati utilizzata dal contesto dell'oggetto.</summary>
        <value>Oggetto <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> associato all'oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.Data.Metadata.Edm.MetadataWorkspace> è un'API di runtime centrale che è possibile utilizzare per interagire con i metadati Entity Data Model (EDM) nel contesto di un'applicazione. Per altre informazioni, vedere [area di lavoro metadati](http://msdn.microsoft.com/library/601aee56-3eda-4caa-9082-a01df76c5e84).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un nuovo oggetto entità viene creato dai dati nell'origine dati come parte di una query o di un'operazione di caricamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato dopo tutte scalari, complesse e proprietà di riferimento sono state impostate su un oggetto, ma prima che siano caricate le raccolte. Se un oggetto con lo stesso valore chiave esiste nel contesto dell'oggetto, Entity Framework non sarà possibile ricreare l'oggetto e non verrà generato questo evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gestore degli stati dell'oggetto utilizzato dal contesto dell'oggetto per rilevare le modifiche dell'oggetto.</summary>
        <value>Oggetto <see cref="T:System.Data.Objects.ObjectStateManager" /> utilizzato dall'oggetto <see cref="T:System.Data.Objects.ObjectContext" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questi esempi si basano sulla [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). In questo esempio viene recuperato l'oggetto <xref:System.Data.Objects.ObjectStateManager> da <xref:System.Data.Objects.ObjectContext> e viene utilizzato il gestore degli stati per accedere a un oggetto nel contesto.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 In questo esempio viene utilizzato il metodo <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> sull'oggetto <xref:System.Data.Objects.ObjectStateManager> restituito per ottenere un oggetto in base alla relativa chiave di entità.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il provider della query LINQ associato a questo contesto dell'oggetto.</summary>
        <value>Istanza di <see cref="T:System.Linq.IQueryProvider" /> utilizzata dal contesto dell'oggetto.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna oggetti specifici nel contesto dell'oggetto con i dati presenti nell'origine dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine in cui vengono aggiornati gli oggetti non è deterministico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Valore di <see cref="T:System.Data.Objects.RefreshMode" /> che indica se le modifiche alla proprietà nel contesto dell'oggetto vengono sovrascritte con i valori della proprietà presenti nell'origine dati.</param>
        <param name="collection">Raccolta <see cref="T:System.Collections.IEnumerable" /> di oggetti da aggiornare.</param>
        <summary>Aggiorna una raccolta di oggetti nel contesto dell'oggetto con i dati presenti nell'origine dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo ha il duplice scopo di consentire agli oggetti nel contesto dell'oggetto di essere aggiornati con i dati presenti nell'origine dati e di rappresentare il meccanismo mediante il quale è possibile risolvere i conflitti. Per altre informazioni, vedere [salvataggio delle modifiche e gestione della concorrenza](http://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 L'ordine in cui vengono aggiornati gli oggetti non è deterministico.  
  
 Dopo la chiamata a <xref:System.Data.Objects.ObjectContext.Refresh%2A>, i valori originali dell'oggetto verranno sempre aggiornati con il valore dell'origine dati, mentre i valori correnti potrebbero essere aggiornati o meno con il valore dell'origine dati. Dipende dal valore <xref:System.Data.Objects.RefreshMode>. Il <xref:System.Data.Objects.RefreshMode.StoreWins> modalità significa che gli oggetti nella raccolta devono essere aggiornati in modo da corrispondere i valori dell'origine dati. <xref:System.Data.Objects.RefreshMode.ClientWins> significa che solo le modifiche nel contesto dell'oggetto verranno rese persistenti, anche se sono state apportate altre modifiche nell'origine dati.  
  
 Per essere certi che gli oggetti siano stati aggiornati in base a una logica lato origine dei dati, è possibile chiamare <xref:System.Data.Objects.ObjectContext.Refresh%2A> con <xref:System.Data.Objects.RefreshMode.StoreWins> dopo la chiamata al metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> non è valido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> è vuoto.  -oppure-  Un oggetto non è connesso al contesto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Uno dei valori di <see cref="T:System.Data.Objects.RefreshMode" /> che specifica la modalità da utilizzare per l'aggiornamento di <see cref="T:System.Data.Objects.ObjectStateManager" />.</param>
        <param name="entity">Oggetto da aggiornare.</param>
        <summary>Aggiorna un oggetto nel contesto dell'oggetto con i dati presenti nell'origine dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A> ha il duplice scopo di consentire a un oggetto di essere aggiornato con i dati presenti nell'origine dati e di rappresentare il meccanismo mediante il quale è possibile risolvere i conflitti. Per altre informazioni, vedere [salvataggio delle modifiche e gestione della concorrenza](http://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 L'ordine in cui vengono aggiornati gli oggetti non è deterministico.  
  
 Dopo la chiamata al metodo <xref:System.Data.Objects.ObjectContext.Refresh%2A>, i valori originali dell'oggetto verranno sempre aggiornati con il valore dell'origine dati, mentre i valori correnti potrebbero essere aggiornati o meno con il valore dell'origine dati. Dipende da <xref:System.Data.Objects.RefreshMode>. La modalità <xref:System.Data.Objects.RefreshMode.StoreWins> implica che l'oggetto deve essere aggiornato in modo da corrispondere ai valori dell'origine dati. Il valore <xref:System.Data.Objects.RefreshMode.ClientWins> implica che solo le modifiche nel contesto dell'oggetto vengono rese persistenti, anche se sono state apportate altre modifiche nell'origine dati.  
  
 Per essere certi che un oggetto sia stato aggiornato in base alla logica lato origine dei dati, è possibile chiamare il metodo <xref:System.Data.Objects.ObjectContext.Refresh%2A> con il valore <xref:System.Data.Objects.RefreshMode.StoreWins> dopo la chiamata al metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Nell'esempio si tenta di salvare modifiche che possono provocare un conflitto di concorrenza. Viene quindi illustrato come risolvere il conflitto di concorrenza aggiornando il contesto dell'oggetto prima di salvare nuovamente le modifiche.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> non è valido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> è vuoto.  -oppure-  Un oggetto non è connesso al contesto.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rende persistenti tutti gli aggiornamenti all'origine dati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende persistenti tutti gli aggiornamenti all'origine dati e reimposta il rilevamento delle modifiche nel contesto dell'oggetto.</summary>
        <returns>Il numero di oggetti che si trovano nello stato <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Deleted" /> al momento della chiamata a <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per essere certi che gli oggetti presenti nel client siano stati aggiornati in base alla logica lato origine dei dati, è possibile chiamare il metodo <xref:System.Data.Objects.ObjectContext.Refresh%2A> con il valore <xref:System.Data.Objects.RefreshMode.StoreWins> dopo la chiamata a <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Per altre informazioni, vedere [salvataggio delle modifiche e gestione della concorrenza](http://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> opera all'interno di una transazione. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> sarà il rollback di tale transazione e genera un'eccezione se dirty <xref:System.Data.Objects.ObjectStateEntry> oggetti non possono essere persistente.  
  
 Se si è verificata una violazione della concorrenza ottimistica, viene generata un'eccezione <xref:System.Data.OptimisticConcurrencyException>. È possibile risolvere una violazione della concorrenza ottimistica rilevandola, chiamando il metodo <xref:System.Data.Objects.ObjectContext.Refresh%2A> con il valore <xref:System.Data.Objects.RefreshMode.StoreWins> o <xref:System.Data.Objects.RefreshMode.ClientWins> e quindi chiamando nuovamente <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Per altre informazioni, vedere [procedura: gestire la concorrenza dei dati nel contesto dell'oggetto](http://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). In questo esempio si tenta di salvare modifiche che possono provocare un conflitto di concorrenza. Viene quindi illustrato come risolvere il conflitto di concorrenza aggiornando il contesto dell'oggetto prima di salvare nuovamente le modifiche.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Si è verificata una violazione di concorrenza ottimistica nell'origine dati.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Questo parametro è necessario per il supporto delle transazioni lato client. Se il valore è <see langword="true" />, il rilevamento delle modifiche in tutti gli oggetti viene reimpostato dopo il completamento del metodo <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />. Se il valore è <see langword="false" />, è necessario chiamare il metodo <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> dopo <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Rende persistenti tutti gli aggiornamenti all'origine dati e reimposta facoltativamente il rilevamento delle modifiche nel contesto dell'oggetto.</summary>
        <returns>Il numero di oggetti che si trovano nello stato <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Deleted" /> al momento della chiamata a <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29> metodo invece.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Se si è verificata una violazione della concorrenza ottimistica.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">Valore di <see cref="T:System.Data.Objects.SaveOptions" /> che determina il comportamento dell'operazione.</param>
        <summary>Rende persistenti tutti gli aggiornamenti all'origine dati con l'oggetto <see cref="T:System.Data.Objects.SaveOptions" /> specificato.</summary>
        <returns>Il numero di oggetti che si trovano nello stato <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Deleted" /> al momento della chiamata a <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload specificato del <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> per assicurarsi che il <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> viene chiamato prima di salvare le modifiche per l'origine dati o che <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> viene chiamato dopo aver salvato le modifiche apportate all'origine dati.  
  
 Questa enumerazione ha un <xref:System.FlagsAttribute> che consente una combinazione bit per bit dei valori dei membri.  
  
 Per assicurarsi che gli oggetti nel client sono stati aggiornati da logica lato origine dei dati, è possibile chiamare il <xref:System.Data.Objects.ObjectContext.Refresh%2A> metodo con il <xref:System.Data.Objects.RefreshMode.StoreWins> valore dopo la chiamata <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Il <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodo opera in una transazione. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> sarà il rollback di tale transazione e genera un'eccezione se uno qualsiasi dei dirty <xref:System.Data.Objects.ObjectStateEntry> oggetti non possono essere persistente.  
  
 Se si è verificata una violazione della concorrenza ottimistica, viene generata un'eccezione <xref:System.Data.OptimisticConcurrencyException>. È possibile risolvere una violazione della concorrenza ottimistica rilevandola, chiamando il metodo <xref:System.Data.Objects.ObjectContext.Refresh%2A> con i valori <xref:System.Data.Objects.RefreshMode.StoreWins> o <xref:System.Data.Objects.RefreshMode.ClientWins> e quindi chiamando nuovamente il metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Per altre informazioni, vedere [procedura: gestire la concorrenza dei dati nel contesto dell'oggetto](http://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Se si è verificata una violazione della concorrenza ottimistica.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando le modifiche vengono salvate nell'origine dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'evento <xref:System.Data.Objects.ObjectContext.SavingChanges> viene generato all'inizio di un'operazione <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> su <xref:System.Data.Objects.ObjectContext>. Questo evento viene generalmente utilizzato per convalidare gli oggetti modificati prima che nuovi valori vengano scritti nel database.  
  
   
  
## Examples  
 Questo esempio è basato il [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Viene registrato un gestore per l'evento <xref:System.Data.Objects.ObjectContext.SavingChanges> che esegue la convalida dello stato dell'entità.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="reader">Oggetto <see cref="T:System.Data.Common.DbDataReader" /> che contiene dati di entità da convertire in oggetti entità.</param>
        <summary>Converte un oggetto <see cref="T:System.Data.Common.DbDataReader" /> che contiene righe di dati di entità in oggetti del tipo di entità richiesto.</summary>
        <returns>Enumerazione di oggetti di tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.Translate%2A> metodo viene utilizzato per convertire i dati di entità da un <xref:System.Data.Common.DbDataReader> in oggetti del tipo richiesto. Questo processo viene eseguito automaticamente quando un <xref:System.Data.Objects.ObjectQuery%601> viene eseguita per restituire i dati di entità. Il <xref:System.Data.Objects.ObjectContext.Translate%2A> metodo consente di eseguire una query ADO.NET standard rispetto a un'origine dati e convertire le righe di dati restituiti in oggetti entità.  
  
 Il parametro fornito <xref:System.Data.Common.DbDataReader> deve contenere dati che esegue il mapping al tipo di entità richiesto.  
  
 Per altre informazioni, vedere:  
  
 [Eseguire direttamente comandi Store](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) e  
  
 [Procedura: eseguire direttamente comandi sull'origine dati](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Quando <paramref name="reader" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="reader">Oggetto <see cref="T:System.Data.Common.DbDataReader" /> che contiene dati di entità da convertire in oggetti entità.</param>
        <param name="entitySetName">Set di entità del tipo <c>TResult</c>.</param>
        <param name="mergeOption">Oggetto <see cref="T:System.Data.Objects.MergeOption" /> da utilizzare quando gli oggetti convertiti vengono aggiunti al contesto dell'oggetto. Il valore predefinito è <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Converte un oggetto <see cref="T:System.Data.Common.DbDataReader" /> che contiene righe di dati di entità in oggetti del tipo di entità richiesto, in un set di entità specifico e con l'opzione di unione specificata.</summary>
        <returns>Enumerazione di oggetti di tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Objects.ObjectContext.Translate%2A> metodo viene utilizzato per convertire i dati di entità da un <xref:System.Data.Common.DbDataReader> in oggetti del tipo richiesto. Questo processo viene eseguito automaticamente quando un <xref:System.Data.Objects.ObjectQuery%601> viene eseguita per restituire i dati di entità. Il <xref:System.Data.Objects.ObjectContext.Translate%2A> metodo consente di eseguire una query ADO.NET standard rispetto a un'origine dati e convertire le righe di dati restituiti in oggetti entità.  
  
 Il parametro fornito <xref:System.Data.Common.DbDataReader> deve contenere dati che esegue il mapping al tipo di entità richiesto.  
  
 Per altre informazioni, vedere:  
  
 [Eseguire direttamente comandi Store](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) e  
  
 [Procedura: eseguire direttamente comandi sull'origine dati](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Quando <paramref name="reader" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Se il parametro <paramref name="mergeOption" /> fornito non è un valore <see cref="T:System.Data.Objects.MergeOption" /> valido.</exception>
        <exception cref="T:System.InvalidOperationException">Se il valore <paramref name="entitySetName" /> fornito non è un set di entità valido per il tipo <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'oggetto da trovare.</param>
        <param name="value">Quando termina, questo metodo contiene l'oggetto.</param>
        <summary>Restituisce un oggetto contenente la chiave di entità specificata.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è stato recuperato correttamente. <see langword="false" /> se <paramref name="key" /> è temporaneo, la connessione è <see langword="null" /> o <paramref name="value" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> tenta di recuperare un oggetto contenente l'oggetto <xref:System.Data.EntityKey> specificato da <xref:System.Data.Objects.ObjectStateManager>. Se l'oggetto non è attualmente caricato nel contesto dell'oggetto, viene eseguita una query nel tentativo di restituire l'oggetto dall'origine dati. Per altre informazioni, vedere [query di oggetto](http://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Utilizzare il metodo <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> per evitare di gestire l'eccezione <xref:System.Data.ObjectNotFoundException> generata da <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> quando non è possibile trovare l'oggetto.  
  
 Questo metodo restituirà gli oggetti che si trovano nello stato <xref:System.Data.EntityState.Deleted>.  
  
 Non è possibile utilizzare una chiave temporanea per restituire un oggetto dall'origine dati.  
  
 Il <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> metodo si applica a .NET standard `TryParse` motivo per il <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> metodo, restituendo `false` quando il <xref:System.Data.ObjectNotFoundException> viene intercettata.  
  
   
  
## Examples  
 L'esempio in questo argomento si basa sul [modello Sales di AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Nell'esempio viene creato un oggetto <xref:System.Data.EntityKey> per un'entità del tipo specificato, quindi viene tentato il recupero di un'entità in base alla chiave.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metadati incompatibili per <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>