<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f752621e9496b0bd55f13fe4c3cb60aecdfbea99" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30391035" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta un tipo di dati Large Object Binary (<see langword="LOB" />) memorizzato su un server Oracle. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.OracleClient.OracleLob> differisce da un <xref:System.Data.OracleClient.OracleBFile> in quanto i dati vengono archiviati nel server anziché in un file fisico nel sistema operativo. Può anche essere un oggetto di lettura / scrittura, a differenza di un <xref:System.Data.OracleClient.OracleBFile>, che è sempre di sola lettura.  
  
 Un <xref:System.Data.OracleClient.OracleLob> può essere uno di questi <xref:System.Data.OracleClient.OracleType> tipi di dati.  
  
|Tipo di dati OracleType|Descrizione|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` tipo di dati che contiene dati binari con dimensioni massime di 4 gigabyte (GB). Esegue il mapping a un oggetto <xref:System.Array> di tipo <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` tipo di dati che contiene i dati di tipo carattere, in base al carattere predefinito impostato nel server, con una dimensione massima di 4 GB. Esegue il mapping a <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` tipo di dati che contiene i dati di tipo carattere, basato sul set nel server con una dimensione massima di 4 GB di caratteri nazionali. Esegue il mapping a <xref:System.String>.|  
  
 Uno sviluppatore di applicazioni .NET può recuperare Oracle `LOB` valori in tipi di dati di base .NET, ad esempio <xref:System.Array> di tipo <xref:System.Byte> e <xref:System.String>, o lo specializzata <xref:System.Data.OracleClient.OracleLob> tipo di dati. Il <xref:System.Data.OracleClient.OracleLob> classe supporta la lettura dei dati e la scrittura in Oracle `LOB` nel database Oracle.  
  
 Di seguito sono le caratteristiche principali di un <xref:System.Data.OracleClient.OracleLob> tipo di dati che distinguono dai tipi di dati .NET di base:  
  
-   Dopo aver recuperato il Oracle `LOB` valore dal database Oracle nel <xref:System.Data.OracleClient.OracleLob> (classe), è possibile modificare il `LOB` dati in una transazione aperta e le modifiche vengono riflesse direttamente al database. Se si recupera il Oracle `LOB` valore in un <xref:System.Array> di tipo <xref:System.Byte> o <xref:System.String> e aggiornare queste matrici, le modifiche non vengono riflesse nel database.  
  
-   Quando si utilizza il <xref:System.Data.OracleClient.OracleLob> classe per accedere a un blocco di un `LOB` valore, solo tale blocco viene passato dal database di Oracle al client. Quando si utilizza il <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> per accedere a un blocco di un `LOB` valore, l'intero contenuto del valore viene passato dal database di Oracle al client.  
  
 Per ottenere un <xref:System.Data.OracleClient.OracleLob> dell'oggetto, chiamare il <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> metodo.  
  
 È possibile costruire un <xref:System.Data.OracleClient.OracleLob> null con questo formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Questa tecnica viene utilizzata principalmente per verificare se un `LOB` restituito dal server è NULL, come illustrato in questo esempio:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valore NULL `LOB` si comporta in modo analogo a zero byte `LOB` in <xref:System.Data.OracleClient.OracleLob.Read%2A> ha esito positivo e restituisce sempre zero byte.  
  
 Selezionando un `LOB` colonna che contiene un valore null restituisce <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 È necessario avviare una transazione prima di ottenere una password temporanea `LOB`. In caso contrario, il <xref:System.Data.OracleClient.OracleDataReader> potrebbe non riuscire ottenere i dati in un secondo momento.  
  
 È inoltre possibile aprire una memoria temporanea `LOB` in Oracle chiamando il DBMS_LOB. Sistema CREATETEMPORARY stored procedure e associazione un `LOB` parametro di output. Sul lato client, una password temporanea `LOB` si comporta come una tabella basata su `LOB`. Ad esempio, per aggiornare il file temporaneo `LOB`, deve essere incluso in una transazione.  
  
 Nell'esempio c# seguente viene illustrato come aprire una memoria temporanea `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  Ereditato <xref:System.IO.Stream.WriteByte%2A> metodo ha esito negativo se usato con dati di tipo carattere e un <xref:System.InvalidOperationException> viene generata un'eccezione. Al suo posto usa il metodo <xref:System.Data.OracleClient.OracleLob.Write%2A>.  
>   
>  Temporaneo `LOB`s vengono chiusi solo quando la connessione viene chiusa, ma con il pool di carico temporaneo `LOB`s non si chiude. Questo può essere risolto eliminando il file temporaneo `LOB`, richiamando `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">Tipo di dati <see langword="LOB" /> da cui aggiungere i dati.</param>
        <summary>Aggiunge i dati dal tipo di dati <see langword="LOB" /> specificato al tipo di dati <see langword="LOB" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
 Tutti i dati dall'origine `LOB` viene aggiunto alla fine dell'oggetto corrente `LOB`. La posizione di entrambi `LOB` venga valutato o modificata durante questo processo.  
  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se proviene da un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di origine è null.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di origine è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Impedisce l'attivazione di trigger lato server durante l'esecuzione di più operazioni di scrittura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Impedisce l'attivazione di trigger lato server durante l'esecuzione di più operazioni di lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Apre il `LOB` in <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> modalità; pertanto, il `LOB` possono solo essere letti da, non scritto, fino alla chiamata corrispondente a <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Per eseguire operazioni di scrittura batch di `LOB`, chiamare <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> con <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 La chiamata <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> più di una volta all'interno della stessa transazione attualmente genera Oracle "ORA-22293: LOB già aperto nella stessa transazione" errore. Inoltre, se si ottiene il `LOB` utilizzando un altro <xref:System.Data.OracleClient.OracleDataReader>, e il chiamante originale non ha chiamato il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> (metodo), lo stesso errore viene generato. Pertanto, è necessario chiamare il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> metodo dopo aver terminato usando il <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Modalità (uno dei valori di <see cref="T:System.Data.OracleClient.OracleLobOpenMode" />) con cui è possibile accedere al tipo di dati <see langword="LOB" /> tra questa chiamata <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> e la chiamata corrispondente <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" />.</param>
        <summary>Impedisce l'attivazione di trigger lato server durante l'esecuzione di più operazioni di lettura e di scrittura nella modalità di accesso specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
 La chiamata <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> più di una volta all'interno della stessa transazione attualmente genera Oracle "ORA-22293: LOB già aperto nella stessa transazione" errore. Inoltre, se si ottiene il `LOB` utilizzando un altro <xref:System.Data.OracleClient.OracleDataReader>, e il chiamante originale non ha chiamato il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> (metodo), lo stesso errore viene generato. Pertanto, è necessario chiamare il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> metodo dopo aver terminato usando il <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile leggere il flusso del tipo di dati <see langword="LOB" />.</summary>
        <value>
          <see langword="true" /> se il flusso di dati <see langword="LOB" /> supporta la lettura; in caso contrario, <see langword="false" /> se un tipo di dati <see langword="LOB" /> è stato chiuso o eliminato.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile eseguire operazioni di ricerca avanti e indietro.</summary>
        <value>
          <see langword="false" /> se un tipo di dati <see langword="LOB" /> è stato chiuso o eliminato; in caso contrario, <see langword="true" />. Sempre <see langword="true" /> per il campo <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce sempre true, indipendentemente dal fatto che il tipo di dati <see langword="LOB" /> supporti o meno la scrittura.</summary>
        <value>Restituisce sempre <see langword="true" />, indipendentemente dal fatto che un tipo di dati <see langword="LOB" /> aperto o non eliminato supporti la scrittura; <see langword="false" /> se un tipo di dati <see langword="LOB" /> è stato chiuso o eliminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT ed è necessario avere avviato una transazione locale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica il numero minimo di byte da recuperare da o inviare al server durante un'operazione di lettura/scrittura.</summary>
        <value>Il numero minimo di byte da recuperare o inviare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito dal <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> proprietà non è un'impostazione del Provider di dati .NET Framework per Oracle. In alternativa, è il valore che viene utilizzata l'interfaccia OCI (Oracle Call Interface) durante la comunicazione con il server. Utilizzare <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> per garantire che i blocchi lato client sono le stesse dimensioni. Lettura o scrittura in blocchi più piccoli non memorizzare dati nella cache e provoca un con ottimizzazione per la minore di round trip al server, perché non ha ricevuto o inviato un pacchetto completo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> che fa riferimento allo stesso tipo di dati <see langword="LOB" /> Oracle come oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di origine.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> che fa riferimento allo stesso tipo di dati <see langword="LOB" /> Oracle come oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le proprietà del nuovo <xref:System.Data.OracleClient.OracleLob> oggetto inizialmente sono associati gli stessi valori dell'oggetto originale. Tuttavia, dopo il <xref:System.Data.OracleClient.OracleLob.Clone%2A> è stata completata, ogni <xref:System.Data.OracleClient.OracleLob> è indipendente da altro oggetto. Ad esempio, la modifica del valore del <xref:System.Data.OracleClient.OracleLob.Position%2A> proprietà originale <xref:System.Data.OracleClient.OracleLob> non modifica il valore di <xref:System.Data.OracleClient.OracleLob.Position%2A> sulla copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.OracleClient.OracleConnection" /> utilizzato da questa istanza dell'oggetto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Connessione a un'origine dati.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente di copiare da questo oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> a un oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di destinazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">Il <see cref="T:System.Data.OracleClient.OracleLob" /> di destinazione.</param>
        <summary>Consente di copiare da questo oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> a un oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di destinazione.</summary>
        <returns>Numero di byte copiati. Sono esclusi i byte riempiti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se si sta copiando un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se l'offset di destinazione è oltre la fine della destinazione `LOB`, `LOB` a cui vengono copiati i dati estesi. Lo spazio tra la fine di `LOB` e l'offset di destinazione oltre la fine verrà anteposti tanti zeri per `BLOB` tipi di dati e gli spazi per `CLOB` e `NCLOB` tipi di dati.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` verrà aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
>   
>  Il `CopyTo` metodo cancella il contenuto della destinazione `OracleLob` prima di eseguire l'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> specificato nel parametro <paramref name="destination" /> è null.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">Oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di destinazione</param>
        <param name="destinationOffset">Offset in cui copiare. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" /> deve trattarsi di un numero pari di byte.</param>
        <summary>Consente di copiare dall'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> a un oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di destinazione con la quantità specificata di dati.</summary>
        <returns>Numero di byte copiati. Sono esclusi i byte riempiti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se si sta copiando un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se l'offset di destinazione è oltre la fine della destinazione `LOB`, `LOB` a cui vengono copiati i dati estesi. Lo spazio tra la fine del `LOB` e offset oltre la fine di destinazione verranno aggiunti degli zeri per `BLOB` tipi di dati e gli spazi per `CLOB` e `NCLOB` tipi di dati.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
>   
>  Il `CopyTo` metodo cancella il contenuto della destinazione `OracleLob` prima di eseguire l'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> specificato nel parametro <paramref name="destination" /> è null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valore specificato nel parametro <paramref name="destinationOffset" /> è minore di zero o maggiore di 4 GB.  
  
 oppure  
  
 Un valore specificato nel parametro <paramref name="destinationOffset" /> per un tipo di dati <see langword="CLOB" /> o <see langword="NCLOB" /> non è pari.  
  
 oppure  
  
 È necessario specificare i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" /> come un numero pari di byte.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">Offset da cui copiare. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <param name="destination">Elemento <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" /> di destinazione.</param>
        <param name="destinationOffset">Offset di destinazione della copia. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <param name="amount">Quantità di dati in byte da copiare. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <summary>Consente di copiare dall'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> a un oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> di destinazione con la quantità specificata di dati e l'offset di origine.</summary>
        <returns>Numero di byte copiati. Sono esclusi i byte riempiti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se si sta copiando un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se l'offset di destinazione è oltre la fine della destinazione `LOB`, `LOB` a cui vengono copiati i dati estesi. Lo spazio tra la fine del `LOB` e offset oltre la fine di destinazione verranno aggiunti degli zeri per `BLOB` tipi di dati e gli spazi per `CLOB` e `NCLOB` tipi di dati.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
>   
>  Il `CopyTo` metodo cancella il contenuto della destinazione `OracleLob` prima di eseguire l'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> specificato nel parametro <paramref name="destination" /> è null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valore specificato nel parametro <paramref name="amount" />, <paramref name="sourceOffset" /> o <paramref name="destinationOffset" /> è minore di zero o maggiore di 4 GB.  
  
 oppure  
  
 Un valore specificato nel parametro <paramref name="amount" />, <paramref name="sourceOffset" /> o <paramref name="destinationOffset" /> per un tipo di dati <see langword="CLOB" /> o <see langword="NCLOB" /> non è pari.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di riprendere l'attivazione di trigger lato server dopo l'esecuzione di più operazioni di scrittura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> metodo prima di iniziare l'esecuzione di operazioni di scrittura su di <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente di cancellare i dati da questo oggetto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di cancellare tutti i dati da questo oggetto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Numero di byte cancellati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> non comporta il troncamento dei dati. Il `LOB` lunghezza rimane invariato per un `BLOB` tipo di dati e i dati cancellati vengono sostituiti da 0x00. `CLOB` e `NCLOB` tipi di dati vengono sostituiti da spazi.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Offset da cui cancellare. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <param name="amount">Quantità di dati in byte da cancellare. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <summary>Consente di cancellare la quantità specificata di dati da questo oggetto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Numero di byte cancellati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La somma dei valori di `offset` e `amount` parametri possono essere maggiori di quello delle dimensioni del <xref:System.Data.OracleClient.OracleLob>. Pertanto, specificando un valore maggiore di quello restituito dal <xref:System.Data.OracleClient.OracleLob.Length%2A> proprietà ha esito positivo; tuttavia <xref:System.Data.OracleClient.OracleLob.Erase%2A> solo fino alla fine del <xref:System.Data.OracleClient.OracleLob>. (In modo analogo, se viene passato un valore negativo `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> esito positivo, ma cancellare solo a partire dall'inizio del <xref:System.Data.OracleClient.OracleLob>.) Questo comportamento è diverso da quello del <xref:System.Data.OracleClient.OracleLob.Read%2A> e <xref:System.Data.OracleClient.OracleLob.Write%2A> metodi e offre il vantaggio di essere in grado di eliminare tutti i dati dal valore specificato da `offset` senza un round trip aggiuntivo al server per verificare le dimensioni effettive.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> non comporta il troncamento dei dati. Il `LOB` lunghezza rimane invariato per un `BLOB` tipo di dati e i dati cancellati vengono sostituiti da 0x00. `CLOB` e `NCLOB` tipi di dati vengono sostituiti da spazi.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Non è attualmente supportato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questa versione, questo metodo non è funzionale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è stato chiamato il metodo <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />.</summary>
        <value>
          <see langword="true" /> se è stato chiamato il metodo <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza un server Oracle 8.0.5, Oracle "ORA-00600: codice di errore interno" viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è un flusso <see cref="F:System.Data.OracleClient.OracleBFile.Null" />.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è un flusso <see cref="F:System.Data.OracleClient.OracleBFile.Null" />; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è un tipo di dati <see langword="LOB" /> temporaneo.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è un tipo di dati <see langword="LOB" /> temporaneo, altrimenti <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'esempio riportato di seguito viene illustrato come creare una password temporanea `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che restituisce le dimensioni dell'oggetto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Dimensioni dell'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dimensioni del <xref:System.Data.OracleClient.OracleLob> viene sempre restituito in byte per tutti i tipi di dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che restituisce il tipo di dati <see langword="LOB" />.</summary>
        <value>Uno del <see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" /> tipi di dati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.OracleClient.OracleLob> può essere uno dei seguenti <xref:System.Data.OracleClient.OracleType> tipi di dati.  
  
|Tipo di dati OracleType|Descrizione|  
|--------------------------|-----------------|  
|`Blob`|Tipo di dati `BLOB` Oracle in cui sono contenuti dati binari per una dimensione massima di 4 GB. Esegue il mapping a un oggetto <xref:System.Array> di tipo <xref:System.Byte>.|  
|`Clob`|Tipo di dati `CLOB` Oracle in cui sono contenuti dati carattere, basato sul set di caratteri predefinito sul server, per una dimensione massima di 4 GB. Esegue il mapping a <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` tipo di dati che contiene i dati di tipo carattere, basato sul set nel server con una dimensione massima di 4 GB di caratteri nazionali. Esegue il mapping a <xref:System.String>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta un oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> null.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile costruire un <xref:System.Data.OracleClient.OracleLob> null con questo formato:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Questa tecnica viene utilizzata principalmente per verificare se un `LOB` restituito dal server è NULL, come illustrato in questo esempio:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valore NULL `LOB` presenta un comportamento simile a un byte zero `LOB` in <xref:System.Data.OracleClient.OracleLob.Read%2A> ha esito positivo e restituisce sempre zero byte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la posizione di lettura corrente nel flusso <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Posizione corrente all'interno del flusso <see cref="T:System.Data.OracleClient.OracleLob" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il flusso deve supportare la ricerca ottenere o impostare la posizione. Utilizzare il <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> proprietà per determinare se il flusso supporta la ricerca.  
  
 La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata. La ricerca in una posizione dispari per `CLOB` e `NCLOB` è supportato anche i tipi di dati. Per ulteriori informazioni, vedere la sezione Note della <xref:System.Data.OracleClient.OracleLob.Read%2A> proprietà.  
  
 Il <xref:System.Data.OracleClient.OracleLob.Position%2A> proprietà non tiene traccia del numero di byte del flusso che sono stati usati, ignorato, o entrambi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte. Quando il metodo termina, il buffer contiene la matrice di byte specificata, con i valori compresi tra <c>offset</c> e (<c>offset</c> + <c>count</c>) sostituiti dai byte letti dall'origine corrente.</param>
        <param name="offset">Offset dei byte in base zero in <c>buffer</c> in corrispondenza del quale iniziare l'archiviazione dei dati letti dal flusso corrente. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <param name="count">Numero massimo di byte da leggere dal flusso corrente. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <summary>Consente di leggere una sequenza di byte dal flusso <see cref="T:System.Data.OracleClient.OracleLob" /> corrente e di passare alla posizione successiva all'interno del flusso in base al numero di byte letti.</summary>
        <returns>Numero complessivo di byte letti nel buffer. È possibile che questo numero sia inferiore a quello dei byte richiesti se la quantità di byte disponibili è minore oppure che corrisponda a zero se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.OracleClient.OracleLob.Read%2A> metodo legge un numero massimo di `count` flusso di byte dall'oggetto corrente e li archivia in `buffer` a partire da `offset`. La posizione corrente all'interno del flusso viene anticipata per il numero di byte letti. Tuttavia, se si verifica un'eccezione, la posizione corrente all'interno del flusso non subisce modifiche. <xref:System.Data.OracleClient.OracleLob.Read%2A> Restituisce il numero di byte letti. Il valore restituito è zero solo se la posizione si trova alla fine del flusso. <xref:System.Data.OracleClient.OracleLob.Read%2A> verrà bloccata finché non è possibile leggere almeno un byte di dati, nel caso in cui non sono disponibili dati.<xref:System.Data.OracleClient.OracleLob.Read%2A> Restituisce 0 se si tenta di leggere da un `LOB` quando la posizione corrente è alla fine di `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> può restituire un numero di byte rispetto a quello richiesto, anche se non è stata raggiunta la fine del flusso.  
  
 Il Provider di dati .NET Framework per Oracle gestisce tutto `CLOB` e `NCLOB` dati in formato Unicode. Pertanto, quando si accede a `CLOB` e `NCLOB` tipi di dati, è sempre correlato con il numero di byte, dove ogni carattere è 2 byte. Ad esempio, se una stringa di testo che contiene tre caratteri viene salvata come un `NCLOB` su un server Oracle in cui il set di caratteri è 4 byte per carattere e esegue un `Read` operazione, specificare la lunghezza della stringa pari a 6 byte, anche se è memorizzata come 12 byte sul server.  
  
 Nell'esempio c# seguente viene illustrato come leggere <xref:System.Data.OracleClient.OracleLob> oggetti.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 È possibile costruire un <xref:System.Data.OracleClient.OracleLob> null con questo formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Questa tecnica viene utilizzata principalmente per verificare se un `LOB` restituito dal server è NULL, come illustrato nell'esempio seguente.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valore NULL `LOB` presenta un comportamento simile a un byte zero `LOB` in <xref:System.Data.OracleClient.OracleLob.Read%2A> ha esito positivo e restituisce sempre zero byte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="buffer" /> è un riferimento null (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valore nel parametro <paramref name="offset" /> o <paramref name="count" /> non è positivo.  
  
 oppure  
  
 La somma dei parametri di offset e conteggio è maggiore della lunghezza del buffer.  
  
 oppure  
  
 Un valore specificato nel parametro <paramref name="amount" /> o <paramref name="offset" /> è minore di zero o maggiore di 4 GB.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Offset dei byte relativo all'origine. Se <c>offset</c> è negativo, la nuova posizione precede quella specificata da <c>origin</c> in base al numero di byte specificato da <c>offset</c>. Se <c>offset</c> è uguale a zero, la nuova posizione è quella specificata da <c>origin</c>. Se <c>offset</c> è positivo, la nuova posizione segue quella specificata da <c>origin</c> in base al numero di byte specificato da <c>offset</c>.</param>
        <param name="origin">Valore di tipo <see cref="T:System.IO.SeekOrigin" /> che indica il punto di riferimento usato per ottenere la nuova posizione.</param>
        <summary>Imposta la posizione sul flusso <see cref="T:System.Data.OracleClient.OracleLob" /> corrente.</summary>
        <returns>Nuova posizione all'interno del flusso corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `offset` è negativo, la nuova posizione deve precedere la posizione specificata da `origin` per il numero di byte specificato da `offset`. Se `offset` è zero, la nuova posizione deve essere una posizione specificata da `origin`. Se `offset` è positivo, la nuova posizione deve seguire la posizione specificata da `origin` per il numero di byte specificato da `offset`.  
  
 La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata. La ricerca in una posizione dispari per `CLOB` e `NCLOB` è supportato anche i tipi di dati. Per ulteriori informazioni, vedere la sezione Note della <xref:System.Data.OracleClient.OracleLob.Read%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="origin" /> non contiene un valore valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La posizione risultante va oltre la lunghezza del valore.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Lunghezza desiderata del flusso <see cref="T:System.Data.OracleClient.OracleLob" /> corrente in byte. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <summary>Imposta la lunghezza del flusso <see cref="T:System.Data.OracleClient.OracleLob" /> su un valore inferiore alla lunghezza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tentativo di aumentare la lunghezza del <xref:System.Data.OracleClient.OracleLob> ha esito negativo di flusso e restituisce "messaggio: ORA-22926: specificato trim lunghezza è superiore alla lunghezza del valore LOB corrente" dal server Oracle.  
  
 Un flusso deve supportare sia la ricerca per la scrittura <xref:System.Data.OracleClient.OracleLob.SetLength%2A> alla funzione.  
  
 Il Provider di dati .NET Framework per Oracle gestisce tutto `CLOB` e `NCLOB` dati in formato Unicode. Pertanto, quando si accede a `CLOB` e `NCLOB` tipi di dati, è sempre correlato con il numero di byte, dove ogni carattere è 2 byte. Ad esempio, se una stringa di testo che contiene tre caratteri viene salvata come un `NCLOB` su un server Oracle in cui il set di caratteri è 4 byte per carattere e esegue un `SetLength` operazione, specificare la lunghezza della stringa pari a 6 byte, anche se è memorizzata come 12 byte sul server.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  Un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valore specificato nel parametro <paramref name="value" /> per un tipo di dati <see langword="CLOB" /> o <see langword="NCLOB" /> non è pari.  
  
 oppure  
  
 Un valore specificato nel parametro <paramref name="value" /> è minore di zero o maggiore di 4 GB.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore del flusso di runtime del linguaggio comune equivalente al valore sottostante.</summary>
        <value>Per il campo <see cref="F:System.Data.OracleClient.OracleType.Blob" />, una matrice di tipo <see langword="Byte[]" />. Per i campi <see cref="F:System.Data.OracleClient.OracleType.Clob" /> e <see cref="F:System.Data.OracleClient.OracleType.NClob" />, un oggetto <see langword="String" />. Per i dati null, <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per <xref:System.Data.OracleClient.OracleType.Blob> tipi di dati, <xref:System.Data.OracleClient.OracleLob.Value%2A> restituisce tutti i dati sottostanti come una matrice di tipo contigua `Byte[]`. Per <xref:System.Data.OracleClient.OracleType.Clob> e <xref:System.Data.OracleClient.OracleType.NClob> tipi di dati, <xref:System.Data.OracleClient.OracleLob.Value%2A> restituisce tutti i dati come un `String` tipo di dati. Per i dati null, <xref:System.Data.OracleClient.OracleLob.Value%2A> restituisce <xref:System.DBNull>. Confrontando i valori restituiti, è possibile distinguere tra i dati vuoti, null e dati.  
  
> [!NOTE]
>  Un vantaggio dell'utilizzo `LOB` tipi di dati è la possibilità di recuperare grandi quantità di dati in blocchi client. Tuttavia, quando si usa <xref:System.Data.OracleClient.OracleLob.Value%2A>, ottenere tutti i dati per il `LOB` colonna come blocco contiguo, condizione che aumenta notevolmente il sovraccarico dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte. Questo metodo consente di copiare il numero di byte specificato nel parametro <c>count</c> dal parametro <c>buffer</c> al flusso corrente.</param>
        <param name="offset">Offset di byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso corrente. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <param name="count">Numero di byte da scrivere nel flusso corrente. Per i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" />, deve trattarsi di un numero pari.</param>
        <summary>Consente di scrivere una sequenza di byte nel flusso <see cref="T:System.Data.OracleClient.OracleLob" /> corrente e di fare avanzare la posizione corrente all'interno di questo flusso del numero di byte scritti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione di scrittura ha esito positivo, fa avanzare la posizione all'interno del flusso del numero di byte scritti. Se si verifica un'eccezione, la posizione all'interno del flusso rimane invariata.  
  
 Scrittura oltre la fine di `LOB` è consentito e aumenta la `LOB` per il numero di byte scritti.  
  
 Il Provider di dati .NET Framework per Oracle gestisce tutto `CLOB` e `NCLOB` dati in formato Unicode. Pertanto, quando si accede a `CLOB` e `NCLOB` tipi di dati, è sempre correlato con il numero di byte, dove ogni carattere è 2 byte. Ad esempio, se una stringa di testo che contiene tre caratteri viene salvata come un `NCLOB` su un server Oracle in cui il set di caratteri è 4 byte per carattere e esegue un `Write` operazione, specificare la lunghezza della stringa pari a 6 byte, anche se è memorizzata come 12 byte sul server.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
 Nell'esempio c# seguente viene illustrato come scrivere <xref:System.Data.OracleClient.OracleLob> oggetti.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  Un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è un riferimento null (in Visual Basic <see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valore nel parametro <paramref name="offset" /> o <paramref name="count" /> non è positivo.  
  
 oppure  
  
 La somma dei parametri <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del parametro<paramref name="buffer" />.  
  
 oppure  
  
 Un valore specificato nel parametro <paramref name="count" /> o <paramref name="offset" /> è minore di zero o maggiore di 4 GB.  
  
 oppure  
  
 È necessario specificare i tipi di dati <see langword="CLOB" /> e <see langword="NCLOB" /> come un numero pari di byte.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è presente all'interno di una transazione, l'oggetto <see cref="T:System.Data.OracleClient.OracleLob" /> è null oppure la connessione è chiusa.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso o eliminato.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Si è verificato un errore Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Byte da scrivere nel flusso.</param>
        <summary>Scrive un byte nella posizione corrente del flusso <see cref="T:System.Data.OracleClient.OracleLob" /> e sposta in avanti di un byte la posizione all'interno del flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione di scrittura ha esito positivo, fa avanzare la posizione all'interno del flusso di un byte. Se si verifica un'eccezione, la posizione all'interno del flusso rimane invariata.  
  
 Scrittura oltre la fine del `LOB` è consentito e aumenta la `LOB` di un byte.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  Un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` sul server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>