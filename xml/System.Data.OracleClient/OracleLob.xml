<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69379b993f96f3e6579fc6f1fe9d4d03c40dd835" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36684338" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a large object binary (<see langword="LOB" />) data type stored on an Oracle server. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un' <xref:System.Data.OracleClient.OracleLob> differisce da un <xref:System.Data.OracleClient.OracleBFile> in quanto i dati vengono archiviati nel server anziché in un file fisico nel sistema operativo. Può anche essere un oggetto di lettura / scrittura, a differenza di un <xref:System.Data.OracleClient.OracleBFile>, che è sempre di sola lettura.  
  
 Un' <xref:System.Data.OracleClient.OracleLob> può essere uno di questi <xref:System.Data.OracleClient.OracleType> tipi di dati.  
  
|Tipo di dati OracleType|Descrizione|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` tipo di dati che contiene dati binari con dimensioni massime di 4 gigabyte (GB). Esegue il mapping a un <xref:System.Array> di tipo <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` tipo di dati che contiene dati di tipo carattere, in base al carattere predefinito impostato nel server, con una dimensione massima di 4 GB. Esegue il mapping a <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` tipo di dati che contiene dati di tipo carattere, basato sul set nel server con una dimensione massima di 4 GB di caratteri nazionali. Esegue il mapping a <xref:System.String>.|  
  
 Uno sviluppatore di applicazioni .NET può recuperare Oracle `LOB` dei valori in tipi di dati di base .NET, ad esempio <xref:System.Array> di tipo <xref:System.Byte> e <xref:System.String>, o lo specializzata <xref:System.Data.OracleClient.OracleLob> tipo di dati. Il <xref:System.Data.OracleClient.OracleLob> classe supporta la lettura dei dati e la scrittura in Oracle `LOB` nel database Oracle.  
  
 Di seguito sono le caratteristiche principali di un <xref:System.Data.OracleClient.OracleLob> tipo di dati che distinguono dai tipi di dati .NET di base:  
  
-   Dopo aver recuperato il Oracle `LOB` valore dal database Oracle nel <xref:System.Data.OracleClient.OracleLob> (classe), è possibile modificare il `LOB` i dati in una transazione aperta e le modifiche si riflettono direttamente al database. Se si recupera il Oracle `LOB` valore in un <xref:System.Array> di tipo <xref:System.Byte> o <xref:System.String> e aggiornare queste matrici, le modifiche non verranno riflesse nel database.  
  
-   Quando si usa il <xref:System.Data.OracleClient.OracleLob> classe per accedere a un blocco di un `LOB` valore, solo tale blocco viene passato dal database Oracle al client. Quando si usa il <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> per accedere a un blocco di un `LOB` valore, l'intero contenuto del valore viene passato dal database Oracle al client.  
  
 Per ottenere un <xref:System.Data.OracleClient.OracleLob> dell'oggetto, chiamare il <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> metodo.  
  
 È possibile costruire un <xref:System.Data.OracleClient.OracleLob> null con questo formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Questa tecnica viene utilizzata principalmente per verificare se un `LOB` restituito dal server è NULL, come illustrato in questo esempio:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valore NULL `LOB` si comporta in modo analogo a un byte zero `LOB` in quanto <xref:System.Data.OracleClient.OracleLob.Read%2A> ha esito positivo e restituisce sempre zero byte.  
  
 Selezione di un `LOB` colonna che contiene un valore null restituisce <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 È necessario iniziare una transazione prima di ottenere una password temporanea `LOB`. In caso contrario, il <xref:System.Data.OracleClient.OracleDataReader> potrebbe non riuscire ottenere i dati in un secondo momento.  
  
 È inoltre possibile aprire una memoria temporanea `LOB` in Oracle chiamando il DBMS_LOB. Sistema CREATETEMPORARY stored procedure e associazione un `LOB` parametro di output. Sul lato client, una password temporanea `LOB` si comporta come una tabella basata `LOB`. Ad esempio, per aggiornare il file temporaneo `LOB`, deve essere incluso in una transazione.  
  
 Nell'esempio c# seguente viene illustrato come aprire una memoria temporanea `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  Ereditato <xref:System.IO.Stream.WriteByte%2A> metodo ha esito negativo se usato con dati di tipo carattere e un <xref:System.InvalidOperationException> viene generata un'eccezione. Al suo posto usa il metodo <xref:System.Data.OracleClient.OracleLob.Write%2A>.  
>   
>  Temporaneo `LOB`s vengono chiusi solo quando la connessione viene chiusa, ma con il pool di carico temporaneo `LOB`s non si chiude. Ciò può essere risolto eliminando il file temporaneo `LOB`, richiamando `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">The <see langword="LOB" /> from which to append data.</param>
        <summary>Appends data from the specified <see langword="LOB" /> to the current <see langword="LOB" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
 Tutti i dati dall'origine `LOB` viene aggiunto alla fine dell'oggetto corrente `LOB`. La posizione di nessuno dei due `LOB` venga valutato o modificata durante questo processo.  
  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se proviene da un' <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple write operations.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple read operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Apre il `LOB` in <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> modalità; pertanto, la `LOB` possono solo essere letti da, non scritto, fino alla chiamata corrispondente a <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Per eseguire scritture di batch per il `LOB`, chiamare <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> con <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 La chiamata <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> più di una volta all'interno della stessa transazione attualmente genera Oracle "ORA-22293: LOB già aperto nella stessa transazione" errore. Inoltre, se si ottiene il `LOB` utilizzando un altro <xref:System.Data.OracleClient.OracleDataReader>, e il chiamante originale non è chiamato il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> (metodo), lo stesso errore viene generato. Pertanto, è necessario chiamare il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> metodo dopo averli completati utilizzando il <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Mode (one of the <see cref="T:System.Data.OracleClient.OracleLobOpenMode" /> values) in which the <see langword="LOB" /> can be accessed between this <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> call and the corresponding <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> call.</param>
        <summary>Prevents server-side triggers from firing while performing multiple read and write operations in the specified access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
 La chiamata <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> più di una volta all'interno della stessa transazione attualmente genera Oracle "ORA-22293: LOB già aperto nella stessa transazione" errore. Inoltre, se si ottiene il `LOB` utilizzando un altro <xref:System.Data.OracleClient.OracleDataReader>, e il chiamante originale non è chiamato il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> (metodo), lo stesso errore viene generato. Pertanto, è necessario chiamare il <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> metodo dopo averli completati utilizzando il <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see langword="LOB" /> stream can be read.</summary>
        <value>
          <see langword="true" /> Se il <see langword="LOB" /> flusso supporta la lettura, in caso contrario <see langword="false" /> se un <see langword="LOB" /> viene chiusa o eliminata.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether forward and backward seek operations can be performed.</summary>
        <value>
          <see langword="false" /> Se un <see langword="LOB" /> viene chiusa o eliminata, in caso contrario <see langword="true" />. Sempre <see langword="true" /> per <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Always returns true, regardless of whether the <see langword="LOB" /> supports writing or not.</summary>
        <value>Restituisce sempre <see langword="true" />, indipendentemente dal fatto che un aperta o non eliminato <see langword="LOB" /> supporta o meno, la scrittura <see langword="false" /> se un <see langword="LOB" /> viene chiusa o eliminata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT ed è necessario avere avviato una transazione locale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating the minimum number of bytes to retrieve from or send to the server during a read/write operation.</summary>
        <value>Il numero minimo di byte da recuperare o inviare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito dal <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> proprietà non è un'impostazione del Provider di dati .NET Framework per Oracle. Al contrario, è il valore usata l'interfaccia OCI (Oracle Call Interface) durante la comunicazione con il server. Utilizzare <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> per garantire che i blocchi lato client abbiano la stessa dimensione. Durante la lettura o scrittura in blocchi più piccoli non memorizza nella cache i dati e provoca un round trip meno ottimizzato per il server, perché non ha ricevuto o inviato un pacchetto completo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <returns>A new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le proprietà del nuovo <xref:System.Data.OracleClient.OracleLob> oggetto inizialmente sono associati gli stessi valori dell'oggetto originale. Tuttavia, dopo il <xref:System.Data.OracleClient.OracleLob.Clone%2A> è stata completata, ogni <xref:System.Data.OracleClient.OracleLob> oggetto è indipendente da altro. Ad esempio, la modifica del valore del <xref:System.Data.OracleClient.OracleLob.Position%2A> proprietà originale <xref:System.Data.OracleClient.OracleLob> non modifica il valore di <xref:System.Data.OracleClient.OracleLob.Position%2A> sulla copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.OracleClient.OracleConnection" /> used by this instance of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Connessione a un'origine dati.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se si sta copiando un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se l'offset di destinazione è oltre la fine della destinazione `LOB`, il `LOB` viene esteso a cui vengono copiati i dati. Lo spazio tra la fine di `LOB` e l'offset di destinazione oltre la fine verrà anteposti tanti zeri per `BLOB` i tipi di dati e gli spazi per `CLOB` e `NCLOB` tipi di dati.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non verranno aggiornate la `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` verrà aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
>   
>  Il `CopyTo` metodo non cancella il contenuto della destinazione `OracleLob` prima di eseguire l'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is null.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" /></param>
        <param name="destinationOffset">The offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number of bytes.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se si sta copiando un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se l'offset di destinazione è oltre la fine della destinazione `LOB`, il `LOB` viene esteso a cui vengono copiati i dati. Lo spazio tra la fine della `LOB` e offset di destinazione oltre la fine vengono anteposti tanti zeri per `BLOB` i tipi di dati e gli spazi per `CLOB` e `NCLOB` tipi di dati.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
>   
>  Il `CopyTo` metodo non cancella il contenuto della destinazione `OracleLob` prima di eseguire l'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">The offset from which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="destination">The destination <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">The destination offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data, and the source offset.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi di dati sottostante devono essere sempre lo stesso. Ad esempio, se si sta copiando un <xref:System.Data.OracleClient.OracleType.NClob>, la destinazione <xref:System.Data.OracleClient.OracleLob> deve essere anche un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se l'offset di destinazione è oltre la fine della destinazione `LOB`, il `LOB` viene esteso a cui vengono copiati i dati. Lo spazio tra la fine della `LOB` e offset di destinazione oltre la fine vengono anteposti tanti zeri per `BLOB` i tipi di dati e gli spazi per `CLOB` e `NCLOB` tipi di dati.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
>   
>  Il `CopyTo` metodo non cancella il contenuto della destinazione `OracleLob` prima di eseguire l'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows server-side triggers to resume firing after performing multiple write operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> metodo prima di iniziare l'esecuzione di operazioni di scrittura sul <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erases data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erases all data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> non comporta il troncamento dei dati. Il `LOB` lunghezza viene mantenuta per un `BLOB` tipo di dati e i dati cancellati vengono sostituiti da 0x00. `CLOB` e `NCLOB` tipi di dati vengono sostituiti da spazi.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">The offset from which to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Erases the specified amount of data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La somma dei valori di `offset` e `amount` parametri possono essere maggiori di quello delle dimensioni del <xref:System.Data.OracleClient.OracleLob>. Pertanto, specificando un valore superiore a quella restituita dal <xref:System.Data.OracleClient.OracleLob.Length%2A> proprietà ha esito positivo; tuttavia <xref:System.Data.OracleClient.OracleLob.Erase%2A> solo fino alla fine del <xref:System.Data.OracleClient.OracleLob>. (In modo analogo, se viene passato un valore negativo alla `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> esito positivo, ma cancellare solo a partire dall'inizio del <xref:System.Data.OracleClient.OracleLob>.) Questo comportamento è diverso da quello del <xref:System.Data.OracleClient.OracleLob.Read%2A> e <xref:System.Data.OracleClient.OracleLob.Write%2A> metodi e offre il vantaggio di essere in grado di eliminare tutti i dati dal valore specificato da `offset` senza un round trip aggiuntivo al server per verificare le dimensioni effettive.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> non comporta il troncamento dei dati. Il `LOB` lunghezza viene mantenuta per un `BLOB` tipo di dati e i dati cancellati vengono sostituiti da 0x00. `CLOB` e `NCLOB` tipi di dati vengono sostituiti da spazi.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  In questa versione, un'operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Not currently supported.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questa versione, questo metodo non funziona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether an application called the <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> method.</summary>
        <value>
          <see langword="true" /> Se l'applicazione ha chiamato la <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> metodo, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza un server Oracle 8.0.5, Oracle "ORA-00600: codice di errore interno" generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> stream.</summary>
        <value>
          <see langword="true" /> Se il <see cref="T:System.Data.OracleClient.OracleLob" /> è un <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> flusso, in caso contrario <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a temporary <see langword="LOB" />.</summary>
        <value>
          <see langword="true" /> Se il <see cref="T:System.Data.OracleClient.OracleLob" /> temporaneo <see langword="LOB" />in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'esempio seguente viene illustrato come creare una password temporanea `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the size of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Le dimensioni del <see cref="T:System.Data.OracleClient.OracleLob" /> in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dimensioni del <xref:System.Data.OracleClient.OracleLob> viene sempre restituito in byte per tutti i tipi di dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the <see langword="LOB" /> data type.</summary>
        <value>Uno del <see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" /> tipi di dati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un' <xref:System.Data.OracleClient.OracleLob> può essere uno dei seguenti <xref:System.Data.OracleClient.OracleType> tipi di dati.  
  
|Tipo di dati OracleType|Descrizione|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` tipo di dati che contiene dati binari con dimensioni massime di 4 GB. Esegue il mapping a un <xref:System.Array> di tipo <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` tipo di dati che contiene dati di tipo carattere, in base al carattere predefinito impostato nel server, con dimensioni massime di 4 GB. Esegue il mapping a <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` tipo di dati che contiene dati di tipo carattere, basato sul set nel server con una dimensione massima di 4 GB di caratteri nazionali. Esegue il mapping a <xref:System.String>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a null <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile costruire un <xref:System.Data.OracleClient.OracleLob> null con questo formato:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Questa tecnica viene utilizzata principalmente per verificare se un `LOB` restituito dal server è NULL, come illustrato in questo esempio:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valore NULL `LOB` si comporta in modo analogo a un byte zero `LOB` in quanto <xref:System.Data.OracleClient.OracleLob.Read%2A> ha esito positivo e restituisce sempre zero byte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current read position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <value>La posizione corrente all'interno di <see cref="T:System.Data.OracleClient.OracleLob" /> flusso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il flusso deve supportare la ricerca ottenere o impostare la posizione. Utilizzare il <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> proprietà per determinare se il flusso supporta la ricerca.  
  
 La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata. La ricerca in una posizione per dispari `CLOB` e `NCLOB` è supportata anche tipi di dati. Per altre informazioni, vedere la sezione Note del <xref:System.Data.OracleClient.OracleLob.Read%2A> proprietà.  
  
 Il <xref:System.Data.OracleClient.OracleLob.Position%2A> proprietà non tiene traccia del numero di byte dal flusso che sono stati usati, ignorato, o entrambi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c>) replaced by the bytes read from the current source.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The maximum number of bytes to be read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Reads a sequence of bytes from the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream and advances the position within the stream by the number of bytes read.</summary>
        <returns>The total number of bytes read into the buffer. This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.OracleClient.OracleLob.Read%2A> metodo legge un numero massimo di `count` flusso di byte dall'oggetto corrente e li archivia in `buffer` iniziando `offset`. La posizione corrente all'interno del flusso viene anticipata per il numero di byte letti. Tuttavia, se si verifica un'eccezione, la posizione corrente all'interno del flusso non subisce modifiche. <xref:System.Data.OracleClient.OracleLob.Read%2A> Restituisce il numero di byte letti. Il valore restituito è zero solo se la posizione si trova alla fine del flusso. <xref:System.Data.OracleClient.OracleLob.Read%2A> verrà bloccata finché non è possibile leggere almeno 1 byte di dati, nel caso in cui non sono disponibili dati.<xref:System.Data.OracleClient.OracleLob.Read%2A> Restituisce 0 se si tenta di leggere da un `LOB` quando la posizione corrente è alla fine di `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> può restituire un numero di byte rispetto a quella richiesta, anche se non è stata raggiunta la fine del flusso.  
  
 Il Provider di dati .NET Framework per Oracle gestisce tutto `CLOB` e `NCLOB` dati in formato Unicode. Pertanto, quando si accede a `CLOB` e `NCLOB` tipi di dati, è sempre correlato con il numero di byte, in cui ogni carattere è 2 byte. Se, ad esempio, una stringa di testo che contiene tre caratteri viene salvata come un `NCLOB` su un server Oracle in cui il set di caratteri è 4 byte per carattere e esegue un `Read` operazione, specificare la lunghezza della stringa come 6 byte, anche se è archiviato come 12 byte nei server.  
  
 Nell'esempio c# seguente viene illustrato come leggere <xref:System.Data.OracleClient.OracleLob> oggetti.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 È possibile costruire un <xref:System.Data.OracleClient.OracleLob> null con questo formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Questa tecnica viene utilizzata principalmente per verificare se un `LOB` restituito dal server è NULL, come illustrato nell'esempio seguente.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valore NULL `LOB` si comporta in modo analogo a un byte zero `LOB` in quanto <xref:System.Data.OracleClient.OracleLob.Read%2A> ha esito positivo e restituisce sempre zero byte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the offset and count parameters is larger than the buffer length.  -or-  A value specified in the <paramref name="amount" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A byte offset relative to origin. If <c>offset</c> is negative, the new position precedes the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>. If <c>offset</c> is zero, the new position is the position specified by <c>origin</c>. If <c>offset</c> is positive, the new position follows the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>.</param>
        <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</param>
        <summary>Sets the position on the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <returns>The new position within the current stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `offset` è negativo, la nuova posizione deve precedere la posizione specificata dal `origin` per il numero di byte specificati dalla `offset`. Se `offset` è uguale a zero, la nuova posizione deve essere la posizione specificata dal `origin`. Se `offset` è un valore positivo, la nuova posizione deve seguire la posizione specificata dal `origin` per il numero di byte specificati dalla `offset`.  
  
 La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata. La ricerca in una posizione per dispari `CLOB` e `NCLOB` è supportata anche tipi di dati. Per altre informazioni, vedere la sezione Note del <xref:System.Data.OracleClient.OracleLob.Read%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="origin" /> parameter does not contain a valid value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting position is beyond the length of the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The desired length of the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream in bytes. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Sets the length of the <see cref="T:System.Data.OracleClient.OracleLob" /> stream to a value less than the current length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tentativo di aumento della lunghezza del <xref:System.Data.OracleClient.OracleLob> flusso ha esito negativo e viene restituito "messaggio: ORA 22926: specificato trim lunghezza è superiore alla lunghezza del valore LOB corrente" dal server Oracle.  
  
 Un flusso deve supportare sia la ricerca per la scrittura <xref:System.Data.OracleClient.OracleLob.SetLength%2A> alla funzione.  
  
 Il Provider di dati .NET Framework per Oracle gestisce tutto `CLOB` e `NCLOB` dati in formato Unicode. Pertanto, quando si accede a `CLOB` e `NCLOB` tipi di dati, è sempre correlato con il numero di byte, in cui ogni carattere è 2 byte. Se, ad esempio, una stringa di testo che contiene tre caratteri viene salvata come un `NCLOB` su un server Oracle in cui il set di caratteri è 4 byte per carattere e esegue un `SetLength` operazione, specificare la lunghezza della stringa come 6 byte, anche se è archiviato come 12 byte nei server.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  Operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="value" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  A value specified in the <paramref name="value" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the common language runtime stream value equivalent of the underlying value.</summary>
        <value>Per <see cref="F:System.Data.OracleClient.OracleType.Blob" />, una matrice di tipo <see langword="Byte[]" />. Per <see cref="F:System.Data.OracleClient.OracleType.Clob" /> e <see cref="F:System.Data.OracleClient.OracleType.NClob" />, un <see langword="String" />. Per i dati null, <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per <xref:System.Data.OracleClient.OracleType.Blob> tipi di dati <xref:System.Data.OracleClient.OracleLob.Value%2A> restituisce tutti i dati sottostanti come una matrice di tipo contigua `Byte[]`. Per <xref:System.Data.OracleClient.OracleType.Clob> e <xref:System.Data.OracleClient.OracleType.NClob> tipi di dati <xref:System.Data.OracleClient.OracleLob.Value%2A> restituisce tutti i dati come un `String` tipo di dati. Per i dati null, <xref:System.Data.OracleClient.OracleLob.Value%2A> restituisce <xref:System.DBNull>. Confrontando i valori restituiti, è possibile distinguere tra i dati vuoti, null e dati.  
  
> [!NOTE]
>  Un vantaggio dell'utilizzo `LOB` tipi di dati è la possibilità di recuperare grandi quantità di dati in blocchi client. Tuttavia, quando si usa <xref:System.Data.OracleClient.OracleLob.Value%2A>, ottenere tutti i dati per il `LOB` colonna come un blocco contiguo, che consente di aumentare notevolmente il sovraccarico dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. This method copies the number of bytes specified in <c>count</c> from <c>buffer</c> to the current stream.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The number of bytes to be written to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Writes a sequence of bytes to the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the current position within this stream by the number of bytes written.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione di scrittura ha esito positivo, fa avanzare la posizione all'interno del flusso del numero di byte scritti. Se si verifica un'eccezione, la posizione all'interno del flusso non subisce modifiche.  
  
 La scrittura oltre la fine della `LOB` è consentito e consente di ingrandire il `LOB` per il numero di byte scritti.  
  
 Il Provider di dati .NET Framework per Oracle gestisce tutto `CLOB` e `NCLOB` dati in formato Unicode. Pertanto, quando si accede a `CLOB` e `NCLOB` tipi di dati, è sempre correlato con il numero di byte, in cui ogni carattere è 2 byte. Se, ad esempio, una stringa di testo che contiene tre caratteri viene salvata come un `NCLOB` su un server Oracle in cui il set di caratteri è 4 byte per carattere e esegue un `Write` operazione, specificare la lunghezza della stringa come 6 byte, anche se è archiviato come 12 byte nei server.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
 Nell'esempio c# seguente viene illustrato come scrivere in <xref:System.Data.OracleClient.OracleLob> oggetti.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  Operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the <paramref name="offset" /> and <paramref name="count" /> parameters is larger than the <paramref name="buffer" /> length.  -or-  A value specified in the <paramref name="count" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the position within the stream by one byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione di scrittura ha esito positivo, fa avanzare la posizione all'interno del flusso di un byte. Se si verifica un'eccezione, la posizione all'interno del flusso non subisce modifiche.  
  
 La scrittura oltre la fine del `LOB` è consentito e consente di ingrandire il `LOB` di un byte.  
  
 Per scrivere il `LOB`, è necessario aver recuperato il `LOB` mediante la clausola FOR UPDATE nell'istruzione SQL SELECT e si deve avere una transazione locale avviata.  
  
> [!NOTE]
>  Operazione di scrittura a sola lettura `LOB` potrebbe avere esito positivo, ma non aggiorna il `LOB` nel server. In questo caso, tuttavia, la copia locale del `LOB` viene aggiornato. Pertanto, operazioni di lettura successive sul <xref:System.Data.OracleClient.OracleLob> oggetto potrebbe restituire i risultati dell'operazione di scrittura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>