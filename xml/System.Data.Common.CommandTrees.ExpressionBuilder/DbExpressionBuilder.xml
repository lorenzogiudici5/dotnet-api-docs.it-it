<Type Name="DbExpressionBuilder" FullName="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="359071078d3c8e16b6368e2fd2700ff8109ec910" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30381795" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class DbExpressionBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DbExpressionBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Module DbExpressionBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbExpressionBuilder abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un'API per creare <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> e consente di accedere a tale API come metodi di estensione sul tipo di espressione stesso.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate (function As EdmFunction, argument As DbExpression) As DbFunctionAggregate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionAggregate ^ Aggregate(System::Data::Metadata::Edm::EdmFunction ^ function, System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Funzione che definisce l'operazione di aggregazione.</param>
        <param name="argument">Argomento in base a cui viene calcolata la funzione di aggregazione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" />.</summary>
        <returns>Nuova aggregazione di funzioni con un riferimento alla funzione e all'argomento specificati. La proprietà Distinct della funzione di aggregazione avrà il valore <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> o <paramref name="argument" /> null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> non è una funzione di aggregazione o dispone di più di un argomento oppure il tipo di risultato di <paramref name="argument" /> non è uguale né promuovibile al tipo di parametro di <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateDistinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AggregateDistinct (function As EdmFunction, argument As DbExpression) As DbFunctionAggregate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionAggregate ^ AggregateDistinct(System::Data::Metadata::Edm::EdmFunction ^ function, System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Funzione che definisce l'operazione di aggregazione.</param>
        <param name="argument">Argomento in base a cui viene calcolata la funzione di aggregazione.</param>
        <summary>Crea un nuovo <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" /> applicato in modo diverso.</summary>
        <returns>Nuova aggregazione di funzioni con un riferimento alla funzione e all'argomento specificati. La proprietà Distinct della funzione di aggregazione avrà il valore <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> o <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> non è una funzione di aggregazione o dispone di più di un argomento oppure il tipo di risultato di <paramref name="argument" /> non è uguale né promuovibile al tipo di parametro di <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="All">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> che determina se il predicato specificato vale per qualsiasi elemento del set di input.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ All(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="predicate">Metodo che rappresenta un predicato da valutare per ogni membro del set di input.    Questo metodo deve produrre un'espressione con un tipo di risultato booleano che fornisce la logica predicativa.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> che determina se il predicato specificato vale per qualsiasi elemento del set di input.</summary>
        <returns>Nuovo DbQuantifierExpression che rappresenta l'operazione All.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="predicate" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="Predicate" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All (input As DbExpressionBinding, predicate As DbExpression) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ All(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Associazione a un'espressione che specifica il set di input.</param>
        <param name="predicate">Espressione che rappresenta un predicato da valutare per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> che determina se il predicato specificato vale per qualsiasi elemento del set di input.</summary>
        <returns>Nuovo DbQuantifierExpression che rappresenta l'operazione All.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="predicate" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" /> non contiene un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbAndExpression And (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbAndExpression And(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function And (left As DbExpression, right As DbExpression) As DbAndExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbAndExpression ^ And(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbAndExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione booleana che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione booleana che specifica l'argomento a destra.</param>
        <summary>Crea un oggetto <see cref="T:System.Data.Common.CommandTrees.DbAndExpression" /> che esegue l'operazione AND logica degli argomenti a sinistra e a destra.</summary>
        <returns>Nuovo DbAndExpression con gli argomenti specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" /> e <paramref name="right" /> non contengono un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che determina se l'argomento di set specificato è non vuoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Any (this System.Data.Common.CommandTrees.DbExpression source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Any(class System.Data.Common.CommandTrees.DbExpression source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (source As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Any(System::Data::Common::CommandTrees::DbExpression ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che determina se l'argomento di set specificato è non vuoto.</summary>
        <returns>Nuovo <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> applicato al nuovo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> con l'argomento specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ Any(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="predicate">Metodo che rappresenta il predicato da valutare per ogni membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato booleano che fornisce la logica predicativa.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> che determina se il predicato specificato vale per qualsiasi elemento del set di input.</summary>
        <returns>Nuovo DbQuantifierExpression che rappresenta l'operazione Any.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="predicate" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="predicate" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (input As DbExpressionBinding, predicate As DbExpression) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ Any(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Associazione a un'espressione che specifica il set di input.</param>
        <param name="predicate">Espressione che rappresenta un predicato da valutare per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> che determina se il predicato specificato vale per qualsiasi elemento del set di input.</summary>
        <returns>Nuovo DbQuantifierExpression che rappresenta l'operazione Any.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="predicate" /> è null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="predicate" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="As">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce gli argomenti specificati come oggetto della coppia chiave/valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt; As (this System.Data.Common.CommandTrees.DbAggregate value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt; As(class System.Data.Common.CommandTrees.DbAggregate value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbAggregate,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function As (value As DbAggregate, alias As String) As KeyValuePair(Of String, DbAggregate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbAggregate ^&gt; As(System::Data::Common::CommandTrees::DbAggregate ^ value, System::String ^ alias);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbAggregate" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valore nella coppia chiave/valore.</param>
        <param name="alias">Chiave nella coppia chiave/valore.</param>
        <summary>Restituisce gli argomenti specificati come oggetto della coppia chiave/valore.</summary>
        <returns>Oggetto della coppia chiave/valore.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt; As (this System.Data.Common.CommandTrees.DbExpression value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt; As(class System.Data.Common.CommandTrees.DbExpression value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function As (value As DbExpression, alias As String) As KeyValuePair(Of String, DbExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt; As(System::Data::Common::CommandTrees::DbExpression ^ value, System::String ^ alias);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valore nella coppia chiave/valore.</param>
        <param name="alias">Chiave nella coppia chiave/valore.</param>
        <summary>Restituisce gli argomenti specificati come oggetto della coppia chiave/valore.</summary>
        <returns>Oggetto della coppia chiave/valore.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding Bind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding Bind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Bind (input As DbExpression) As DbExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpressionBinding ^ Bind(System::Data::Common::CommandTrees::DbExpression ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Espressione da associare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che associa l'espressione specificata mediante un nome di variabile generato.</summary>
        <returns>Nuova associazione di espressioni con l'espressione specificata e un nome di variabile generato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> non dispone di un risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding BindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding BindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BindAs (input As DbExpression, varName As String) As DbExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpressionBinding ^ BindAs(System::Data::Common::CommandTrees::DbExpression ^ input, System::String ^ varName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Espressione da associare.</param>
        <param name="varName">Nome di variabile da utilizzare per l'associazione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che associa l'espressione specificata mediante un nome di variabile specificato.</summary>
        <returns>Nuova associazione di espressioni con l'espressione specificata e un nome di variabile.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="varName" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> non dispone di un risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Case">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCaseExpression Case (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, System.Data.Common.CommandTrees.DbExpression elseExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCaseExpression Case(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, class System.Data.Common.CommandTrees.DbExpression elseExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Function Case (whenExpressions As IEnumerable(Of DbExpression), thenExpressions As IEnumerable(Of DbExpression), elseExpression As DbExpression) As DbCaseExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbCaseExpression ^ Case(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ whenExpressions, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ thenExpressions, System::Data::Common::CommandTrees::DbExpression ^ elseExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCaseExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="whenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="thenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="elseExpression" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="whenExpressions">Elenco di espressioni che forniscono la logica condizionale di ogni caso.</param>
        <param name="thenExpressions">Elenco di espressioni che forniscono il risultato di ogni caso.</param>
        <param name="elseExpression">Espressione che definisce il risultato in assenza di corrispondenza con i casi elencati.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbCaseExpression" />.</summary>
        <returns>Nuovo DbCaseExpression con i casi specificati e il risultato predefinito.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="whenExpressions" /> o <paramref name="thenExpressions" /> è null, contiene null oppure <paramref name="elseExpression" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="whenExpressions" /> o <paramref name="thenExpressions" /> è vuoto o <paramref name="whenExpressions" /> contiene un'espressione con un tipo di risultato non booleano oppure non esiste alcun tipo di risultato comune per tutte le espressioni in <paramref name="thenExpressions" /> e <paramref name="elseExpression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CastTo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCastExpression CastTo (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage toType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCastExpression CastTo(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage toType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CastTo (argument As DbExpression, toType As TypeUsage) As DbCastExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbCastExpression ^ CastTo(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ toType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCastExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="toType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Argomento a cui applicare il cast.</param>
        <param name="toType">Metadati di Type che specificano il tipo a cui eseguire il cast.</param>
        <summary>Crea una nuova espressione <see cref="T:System.Data.Common.CommandTrees.DbCastExpression" /> che applica un'operazione di cast a un argomento polimorfico.</summary>
        <returns>Nuovo DbCastExpression con l'argomento e il tipo di destinazione specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> o <paramref name="toType" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Il cast specificato non è valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Constant (value As Object) As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valore costante da rappresentare.</param>
        <summary>Crea un nuovo <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con il valore costante specificato.</summary>
        <returns>Nuovo DbConstantExpression con il valore dato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un'istanza di un tipo di costante valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (this System.Data.Metadata.Edm.TypeUsage constantType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(class System.Data.Metadata.Edm.TypeUsage constantType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Data.Metadata.Edm.TypeUsage,System.Object)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Constant (constantType As TypeUsage, value As Object) As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbConstantExpression ^ Constant(System::Data::Metadata::Edm::TypeUsage ^ constantType, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constantType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="constantType">Tipo del valore costante.</param>
        <param name="value">Valore costante da rappresentare.</param>
        <summary>Crea una nuova espressione <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> del tipo primitivo specificato con il valore costante indicato.</summary>
        <returns>Nuovo DbConstantExpression con il valore specificato e un tipo di risultato <paramref name="constantType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> o <paramref name="constantType" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un'istanza di un tipo di costante valido, <paramref name="constantType" /> non rappresenta un tipo primitivo o <paramref name="value" /> è di un tipo primitivo diverso da quello rappresentato da <paramref name="constantType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRef">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica di un tipo specificato in base a valori chiave.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Set di entità che contiene l'elemento a cui si fa riferimento.</param>
        <param name="keyValues">Raccolta di oggetti <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che forniscono i valori di chiave. Queste espressioni devono corrispondere (in numero, tipo e ordine) alle proprietà di chiave del tipo di entità a cui si fa riferimento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica in base a valori chiave.</summary>
        <returns>Nuovo DbRefExpression che fa riferimento all'elemento con i valori della chiave specificati nel set di entità specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> è Null oppure <paramref name="keyValues" /> è Null o contiene Null.</exception>
        <exception cref="T:System.ArgumentException">Il conteggio di <paramref name="keyValues" /> non corrisponde al conteggio dei membri principali dichiarati dal tipo di elemento di <paramref name="entitySet" /> oppure in <paramref name="keyValues" /> è contenuta un'espressione con un tipo di risultato che è incompatibile con il tipo di membro principale corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Set di entità che contiene l'elemento a cui si fa riferimento.</param>
        <param name="keyValues">Raccolta di oggetti <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che forniscono i valori di chiave. Queste espressioni devono corrispondere (in numero, tipo e ordine) alle proprietà di chiave del tipo di entità a cui si fa riferimento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica in base a valori chiave.</summary>
        <returns>Nuovo DbRefExpression che fa riferimento all'elemento con i valori della chiave specificati nel set di entità specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> è Null oppure <paramref name="keyValues" /> è Null o contiene Null.</exception>
        <exception cref="T:System.ArgumentException">Il conteggio di <paramref name="keyValues" /> non corrisponde al conteggio dei membri principali dichiarati dal tipo di elemento di <paramref name="entitySet" /> oppure in <paramref name="keyValues" /> è contenuta un'espressione con un tipo di risultato che è incompatibile con il tipo di membro principale corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Metadata::Edm::EntityType ^ entityType, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Set di entità che contiene l'elemento a cui si fa riferimento.</param>
        <param name="entityType">Tipo specifico dell'entità a cui si fa riferimento. Deve essere un tipo di entità della stessa gerarchia del tipo di elemento del set di entità.</param>
        <param name="keyValues">Raccolta di oggetti <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che forniscono i valori di chiave. Queste espressioni devono corrispondere (in numero, tipo e ordine) alle proprietà di chiave del tipo di entità a cui si fa riferimento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica di un tipo specificato in base a valori chiave.</summary>
        <returns>Nuovo DbRefExpression che fa riferimento all'elemento con i valori della chiave specificati nel set di entità specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> o <paramref name="entityType" /> è null, oppure <paramref name="keyValues" /> è null o contiene null.</exception>
        <exception cref="T:System.ArgumentException">Il conteggio di <paramref name="keyValues" /> non corrisponde al conteggio dei membri principali dichiarati dal tipo di elemento di <paramref name="entitySet" /> oppure in <paramref name="keyValues" /> è contenuta un'espressione con un tipo di risultato che è incompatibile con il tipo di membro principale corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Metadata::Edm::EntityType ^ entityType, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Set di entità che contiene l'elemento a cui si fa riferimento.</param>
        <param name="entityType">Tipo specifico dell'entità a cui si fa riferimento. Deve essere un tipo di entità della stessa gerarchia del tipo di elemento del set di entità.</param>
        <param name="keyValues">Raccolta di oggetti <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che forniscono i valori di chiave. Queste espressioni devono corrispondere (in numero, tipo e ordine) alle proprietà di chiave del tipo di entità a cui si fa riferimento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica di un tipo specificato in base a valori chiave.</summary>
        <returns>Nuovo DbRefExpression che fa riferimento all'elemento con i valori della chiave specificati nel set di entità specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> o <paramref name="entityType" /> è null, oppure <paramref name="keyValues" /> è null o contiene null.</exception>
        <exception cref="T:System.ArgumentException">Il conteggio di <paramref name="keyValues" /> non corrisponde al conteggio dei membri principali dichiarati dal tipo di elemento di <paramref name="entitySet" /> oppure in <paramref name="keyValues" /> è contenuta un'espressione con un tipo di risultato che è incompatibile con il tipo di membro principale corrispondente.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CrossApply">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossApply (source As DbExpression, apply As Func(Of DbExpression, KeyValuePair(Of String, DbExpression))) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ CrossApply(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ apply);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica il set di input.</param>
        <param name="apply">Metodo che specifica la logica da valutare una volta per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply. Le righe in cui <paramref name="apply" /> restituisce un set vuoto non vengono incluse.</summary>
        <returns>Nuovo DbApplyExpression con l'input specificato e applica le associazioni e un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il risultato di <paramref name="apply" /> contiene un nome o un'espressione null.</exception>
        <exception cref="T:System.ArgumentException">Il risultato dell'operazione di <paramref name="apply" /> contiene un nome o un'espressione non valido in un'associazione di espressioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossApply (input As DbExpressionBinding, apply As DbExpressionBinding) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ CrossApply(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpressionBinding ^ apply);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica il set di input.</param>
        <param name="apply">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica la logica da valutare una volta per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply. Le righe in cui <paramref name="apply" /> restituisce un set vuoto non vengono incluse.</summary>
        <returns>Nuovo DbApplyExpression con l'input specificato e applica le associazioni e un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="apply" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpressionBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Function CrossJoin (inputs As IEnumerable(Of DbExpressionBinding)) As DbCrossJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbCrossJoinExpression ^ CrossJoin(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpressionBinding ^&gt; ^ inputs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCrossJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Elenco di associazioni a un'espressione che specifica i set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbCrossJoinExpression" /> che crea un join incondizionato dei set specificati dall'elenco di associazioni a un'espressione di input.</summary>
        <returns>Nuovo DbCrossJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di CrossJoin, che rappresenta un'operazione join non condizionale dei set di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputs" /> è null o contiene un elemento null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputs" /> contiene meno di 2 associazioni all'espressione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deref">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDerefExpression Deref (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDerefExpression Deref(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deref (argument As DbExpression) As DbDerefExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbDerefExpression ^ Deref(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDerefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che fornisce il riferimento. Questa espressione deve presentare un tipo di riferimento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression" /> che recupera un'entità specifica in funzione di una determinata espressione di riferimento.</summary>
        <returns>Nuovo DbDerefExpression che consente di recuperare l'entità specificata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultato riferimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDistinctExpression Distinct (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDistinctExpression Distinct(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct (argument As DbExpression) As DbDistinctExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbDistinctExpression ^ Distinct(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDistinctExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che definisce il set su cui eseguire l'operazione di distinzione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbDistinctExpression" /> che rimuove i duplicati dall'argomento di set specificato.</summary>
        <returns>Nuovo DbDistinctExpression che rappresenta l'operazione distinta applicata all'argomento impostato specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Divide (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Divide(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Divide (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Divide(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che divide l'argomento a sinistra per l'argomento a destra.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione di divisione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico comune tra <paramref name="left" /> o <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbElementExpression Element (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbElementExpression Element(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Element (argument As DbExpression) As DbElementExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbElementExpression ^ Element(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbElementExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica il set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbElementExpression" /> che converte un set in un singleton.</summary>
        <returns>Oggetto DbElementExpression che rappresenta la conversione dell'argomento impostato in un singleton.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression Equal (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression Equal(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equal (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ Equal(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> che verifica l'uguaglianza fra l'argomento a sinistra e quello a destra.</summary>
        <returns>Nuovo DbComparisonExpression che rappresenta il confronto di uguaglianza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato confrontabile in termini di uguaglianza comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExceptExpression Except (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExceptExpression Except(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (left As DbExpression, right As DbExpression) As DbExceptExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExceptExpression ^ Except(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExceptExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che definisce l'argomento di set a sinistra.</param>
        <param name="right">Espressione che definisce l'argomento di set a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExceptExpression" /> che calcola la sottrazione dell'argomento di set a destra dall'argomento di set a sinistra.</summary>
        <returns>Nuovo oggetto DbExceptExpression che rappresenta la differenza tra l'argomento a sinistra e quella a destra.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultati della raccolta comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Exists (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Exists(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Exists (argument As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Exists(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica il set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che determina se l'argomento di set specificato è non vuoto.</summary>
        <returns>Nuovo <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> applicato al nuovo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> con l'argomento specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="False">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression False { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression False" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property False As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Data::Common::CommandTrees::DbConstantExpression ^ False { System::Data::Common::CommandTrees::DbConstantExpression ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con il valore booleano <see langword="false" />.</summary>
        <value>Oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con il valore booleano <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Filter (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Filter(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Filter (input As DbExpressionBinding, predicate As DbExpression) As DbFilterExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFilterExpression ^ Filter(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Associazione a un'espressione che specifica il set di input.</param>
        <param name="predicate">Espressione che rappresenta un predicato da valutare per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> che filtra gli elementi nel set di input specificato tramite il predicato specificato.</summary>
        <returns>Nuovo DbFilterExpression che produce il set filtrato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="predicate" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" /> non contiene un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FullOuterJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che unisce i set specificati dalle espressioni sinistra e destra, sulla condizione di join specificata, usando FullOuterJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FullOuterJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ FullOuterJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set sinistro.</param>
        <param name="right">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set destro.</param>
        <param name="joinCondition">Metodo che rappresenta la condizione su cui creare un join. Questo metodo deve generare un'espressione con un tipo di risultato Boolean che fornisca la logica della condizione di join.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che unisce i set specificati dalle espressioni sinistra e destra, sulla condizione di join specificata, usando FullOuterJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo oggetto DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> equivalente a FullOuterJoin, che rappresenta l'operazione full outer join applicata ai set di input sinistro e destro nella condizione di join specificata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="joinCondition" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="joinCondition" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FullOuterJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ FullOuterJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica l'argomento di set a sinistra.</param>
        <param name="right">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica l'argomento di set a destra.</param>
        <param name="joinCondition">Espressione che specifica la condizione in base a cui creare il join.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle associazioni a un'espressione a sinistra e a destra, utilizzando FullOuterJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo oggetto DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> equivalente a FullOuterJoin, che rappresenta l'operazione full outer join applicata ai set di input sinistro e destro nella condizione di join specificata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> o <paramref name="joinCondition" /> è null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="joinCondition" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntityRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEntityRef (argument As DbExpression) As DbEntityRefExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbEntityRefExpression ^ GetEntityRef(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbEntityRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che fornisce l'entità. Questa espressione deve presentare un tipo di risultato di entità.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression" /> che recupera il riferimento dell'entità specificata in forma strutturale.</summary>
        <returns>Nuovo DbEntityRefExpression che consente di recuperare un riferimento all'entità specificata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultato entità.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRefKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetRefKey (argument As DbExpression) As DbRefKeyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefKeyExpression ^ GetRefKey(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefKeyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che fornisce il riferimento. Questa espressione deve presentare un tipo di riferimento con un tipo di elemento di entità.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression" /> che recupera i valori di chiave del riferimento specificato in forma strutturale.</summary>
        <returns>Nuovo DbRefKeyExpression che recupera i valori di chiave del riferimento specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultato riferimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GreaterThan (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ GreaterThan(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> che determina se l'argomento a sinistra è maggiore di quello a destra.</summary>
        <returns>Nuovo DbComparisonExpression che rappresenta di tipo maggiore di.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato confrontabile in termini di ordinamento comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GreaterThanOrEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ GreaterThanOrEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> che determina se l'argomento a sinistra è maggiore o uguale a quello a destra.</summary>
        <returns>Nuovo DbComparisonExpression che rappresenta di tipo maggiore di o uguale a.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato confrontabile in termini di ordinamento comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBind (input As DbExpression) As DbGroupExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ GroupBind(System::Data::Common::CommandTrees::DbExpression ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Espressione da associare.</param>
        <summary>Crea una nuova associazione a un'espressione di gruppo che utilizza nomi generati di variabile e di variabile di gruppo per associare l'espressione specificata.</summary>
        <returns>Nuova associazione di gruppi con l'espressione specificata, un nome di variabile generato e un nome di variabile di gruppo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs(System.Data.Common.CommandTrees.DbExpression,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBindAs (input As DbExpression, varName As String, groupVarName As String) As DbGroupExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ GroupBindAs(System::Data::Common::CommandTrees::DbExpression ^ input, System::String ^ varName, System::String ^ groupVarName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
        <Parameter Name="groupVarName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Espressione da associare.</param>
        <param name="varName">Nome di variabile da utilizzare per l'associazione.</param>
        <param name="groupVarName">Nome di variabile da utilizzare per fare riferimento al gruppo quando la nuova associazione a un'espressione di gruppo viene utilizzata in un'espressione di raggruppamento.</param>
        <summary>Crea una nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> che utilizza il nome di variabile e i nomi di variabile di gruppo specificati per associare l'espressione specificata.</summary>
        <returns>Nuova associazione di gruppi con l'espressione specificata, un nome di variabile e un nome di variabile di gruppo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="varName" /> o <paramref name="groupVarName" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupByExpression GroupBy (this System.Data.Common.CommandTrees.DbGroupExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupByExpression GroupBy(class System.Data.Common.CommandTrees.DbGroupExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy(System.Data.Common.CommandTrees.DbGroupExpressionBinding,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbAggregate}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy (input As DbGroupExpressionBinding, keys As IEnumerable(Of KeyValuePair(Of String, DbExpression)), aggregates As IEnumerable(Of KeyValuePair(Of String, DbAggregate))) As DbGroupByExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupByExpression ^ GroupBy(System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ keys, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbAggregate ^&gt;&gt; ^ aggregates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupByExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbGroupExpressionBinding" RefType="this" />
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
        <Parameter Name="aggregates" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> che specifica il set di input.</param>
        <param name="keys">Elenco di coppie stringa/espressione che definiscono le colonne di raggruppamento.</param>
        <param name="aggregates">Elenco di espressioni che specificano le aggregazioni da applicare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbGroupByExpression" /> che raggruppa gli elementi del set di input in base alle chiavi di gruppo specificate e applica le aggregazioni specificate.</summary>
        <returns>Nuovo DbGroupByExpression con il set di input specificato, le chiavi di raggruppamento e gli aggregati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbGroupByExpression consente l'elenco di chiavi o l'elenco di aggregazioni sia vuoto, ma non entrambi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="keys" /> o <paramref name="aggregates" /> è Null, <paramref name="keys" /> contiene una chiave o un'espressione della colonna Null oppure <paramref name="aggregates" /> contiene un nome o un'aggregazione della colonna aggregata Null.</exception>
        <exception cref="T:System.ArgumentException">Sia <paramref name="keys" /> sia <paramref name="aggregates" /> sono vuoti o è stato specificato un nome della colonna non valido o duplicato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="InnerJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle espressioni a sinistra e a destra, utilizzando InnerJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InnerJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ InnerJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set sinistro.</param>
        <param name="right">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set destro.</param>
        <param name="joinCondition">Metodo che rappresenta la condizione su cui creare un join. Questo metodo deve generare un'espressione con un tipo di risultato Boolean che fornisca la logica della condizione di join.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle espressioni a sinistra e a destra, utilizzando InnerJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di InnerJoin, che rappresenta l'operazione di join interna completa applicata ai set di input sinistro e destro nella condizione specificata di join.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="joinCondition" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="joinCondition" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InnerJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ InnerJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica l'argomento di set a sinistra.</param>
        <param name="right">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica l'argomento di set a destra.</param>
        <param name="joinCondition">Espressione che specifica la condizione in base a cui creare il join.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle associazioni a un'espressione a sinistra e a destra, utilizzando InnerJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di InnerJoin, che rappresenta l'operazione di join interna completa applicata ai set di input sinistro e destro nella condizione specificata di join.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> o <paramref name="joinCondition" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" /> non contiene un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIntersectExpression Intersect (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIntersectExpression Intersect(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect (left As DbExpression, right As DbExpression) As DbIntersectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIntersectExpression ^ Intersect(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIntersectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che definisce l'argomento di set a sinistra.</param>
        <param name="right">Espressione che definisce l'argomento di set a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbIntersectExpression" /> che calcola l'intersezione degli argomenti di set a sinistra e a destra.</summary>
        <returns>Nuovo oggetto DbIntersectExpression che rappresenta l'intersezione degli argomenti a sinistra e a destra.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultati della raccolta comune tra <paramref name="left" /> o <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> che rappresenta l'applicazione della funzione lambda specificata agli argomenti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (lambda As DbLambda, arguments As IEnumerable(Of DbExpression)) As DbLambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLambdaExpression ^ Invoke(System::Data::Common::CommandTrees::DbLambda ^ lambda, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="lambda">Istanza di <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> che rappresenta la funzione lambda da applicare.</param>
        <param name="arguments">Elenco di espressioni che forniscono gli argomenti.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> che rappresenta l'applicazione della funzione lambda specificata agli argomenti.</summary>
        <returns>Nuovo DbLambdaExpression che rappresenta l'applicazione della funzione Lambda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> o <paramref name="arguments" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Il conteggio di <paramref name="arguments" /> non corrisponde al numero di variabili dichiarato da <paramref name="lambda" /> oppure <paramref name="arguments" /> contiene un'espressione con un tipo di risultato che non è uguale o promuovibile al tipo di variabile corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (lambda As DbLambda, ParamArray arguments As DbExpression()) As DbLambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLambdaExpression ^ Invoke(System::Data::Common::CommandTrees::DbLambda ^ lambda, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="lambda">Istanza di <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> che rappresenta la funzione lambda da applicare.</param>
        <param name="arguments">Espressioni che forniscono gli argomenti.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> che rappresenta l'applicazione della funzione lambda specificata agli argomenti.</summary>
        <returns>Nuovo DbLambdaExpression che rappresenta l'applicazione della funzione Lambda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> o <paramref name="arguments" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Il conteggio di <paramref name="arguments" /> non corrisponde al numero di variabili dichiarato da <paramref name="lambda" /> oppure <paramref name="arguments" /> contiene un'espressione con un tipo di risultato che non è uguale o promuovibile al tipo di variabile corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (function As EdmFunction, arguments As IEnumerable(Of DbExpression)) As DbFunctionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionExpression ^ Invoke(System::Data::Metadata::Edm::EdmFunction ^ function, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Metadati per la funzione da richiamare.</param>
        <param name="arguments">Elenco di espressioni che forniscono gli argomenti alla funzione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" /> che rappresenta la chiamata alla funzione specificata con gli argomenti definiti.</summary>
        <returns>Un nuovo oggetto DbFunctionExpression che rappresenta la chiamata alla funzione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> è Null oppure <paramref name="arguments" /> è Null o contiene Null.</exception>
        <exception cref="T:System.ArgumentException">Il numero di <paramref name="arguments" /> non corrisponde al numero di parametri dichiarati da <paramref name="function" /> oppure <paramref name="arguments" /> contiene un'espressione che ha un tipo di risultato diverso o promuovibile al tipo di parametro di funzione corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (function As EdmFunction, ParamArray arguments As DbExpression()) As DbFunctionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionExpression ^ Invoke(System::Data::Metadata::Edm::EdmFunction ^ function, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="function">Metadati per la funzione da richiamare.</param>
        <param name="arguments">Espressioni che forniscono gli argomenti alla funzione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" /> che rappresenta la chiamata alla funzione specificata con gli argomenti definiti.</summary>
        <returns>Un nuovo oggetto DbFunctionExpression che rappresenta la chiamata alla funzione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> è Null oppure <paramref name="arguments" /> è Null o contiene Null.</exception>
        <exception cref="T:System.ArgumentException">Il numero di <paramref name="arguments" /> non corrisponde al numero di parametri dichiarati da <paramref name="function" /> oppure <paramref name="arguments" /> contiene un'espressione che ha un tipo di risultato diverso o promuovibile al tipo di parametro di funzione corrispondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsEmpty (argument As DbExpression) As DbIsEmptyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsEmptyExpression ^ IsEmpty(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsEmptyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica il set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> che determina se l'argomento di set specificato è un set vuoto.</summary>
        <returns>Nuovo DbIsEmptyExpression con l'argomento specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non contiene un tipo di risultato della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsNullExpression IsNull (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsNullExpression IsNull(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNull (argument As DbExpression) As DbIsNullExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsNullExpression ^ IsNull(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica l'argomento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression" /> che determina se l'argomento specificato è null.</summary>
        <returns>Nuovo DbIsNullExpression con l'argomento specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> dispone di un tipo di risultati della raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOf">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOf (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOf(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOf (argument As DbExpression, type As TypeUsage) As DbIsOfExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsOfExpression ^ IsOf(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica l'istanza.</param>
        <param name="type">Metadati di tipo che specificano il tipo con cui deve essere confrontato il tipo di risultato dell'istanza.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> che determina se l'argomento specificato è del tipo specificato o di un sottotipo.</summary>
        <returns>Nuovo DbIsOfExpression con l'istanza e il tipo specificati e DbExpressionKind IsOf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario che DbIsOfExpression `argument` dispone di un tipo di risultato polimorfico e che `type` è un tipo appartenente alla stessa gerarchia di tipo di tale tipo di risultato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non si trova nella stessa gerarchia dei tipi del tipo di risultato di <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOfOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOfOnly (argument As DbExpression, type As TypeUsage) As DbIsOfExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsOfExpression ^ IsOfOnly(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica l'istanza.</param>
        <param name="type">Metadati di tipo che specificano il tipo con cui deve essere confrontato il tipo di risultato dell'istanza.</param>
        <summary>Crea una nuova espressione <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> che determina se l'argomento specificato è del tipo specificato ed esclusivamente di tale tipo (non di un sottotipo).</summary>
        <returns>Nuovo DbIsOfExpression con l'istanza e il tipo specificati e DbExpressionKind IsOfOnly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario che DbIsOfExpression `argument` dispone di un tipo di risultato polimorfico e che `type` è un tipo appartenente alla stessa gerarchia di tipo di tale tipo di risultato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non si trova nella stessa gerarchia dei tipi del tipo di risultato di <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression Join (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression Join(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join (outer As DbExpression, inner As DbExpression, outerKey As Func(Of DbExpression, DbExpression), innerKey As Func(Of DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ Join(System::Data::Common::CommandTrees::DbExpression ^ outer, System::Data::Common::CommandTrees::DbExpression ^ inner, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ outerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ innerKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="outer">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set esterno.</param>
        <param name="inner">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set interno.</param>
        <param name="outerKey">Metodo che specifica come derivare il valore esterno della chiave da un elemento del set esterno.</param>
        <param name="innerKey">Metodo che specifica come derivare il valore interno della chiave da un elemento del set interno.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che unisce in join i set specificati dalle espressioni esterne e interne, in base a una condizione di uguaglianza tra le chiavi esterne e interne specificate, usando InnerJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo oggetto DbJoinExpression, con un'enumerazione <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di InnerJoin, che rappresenta l'operazione di inner join applicata ai set di input a sinistra e a destra in una condizione di join che confronta i valori di chiave esterni e interni per verificarne l'uguaglianza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="outerKey" /> o <paramref name="innerKey" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Le espressioni generate da <paramref name="outerKey" /> e <paramref name="innerKey" /> non possono essere confrontate per verificarne l'uguaglianza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join``1(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TSelector) (outer As DbExpression, inner As DbExpression, outerKey As Func(Of DbExpression, DbExpression), innerKey As Func(Of DbExpression, DbExpression), selector As Func(Of DbExpression, DbExpression, TSelector)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSelector&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Join(System::Data::Common::CommandTrees::DbExpression ^ outer, System::Data::Common::CommandTrees::DbExpression ^ inner, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ outerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ innerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, TSelector&gt; ^ selector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Il tipo di <c>selettore</c>.</typeparam>
        <param name="outer">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set esterno.</param>
        <param name="inner">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set interno.</param>
        <param name="outerKey">Metodo che specifica come derivare il valore esterno della chiave da un elemento del set esterno.</param>
        <param name="innerKey">Metodo che specifica come derivare il valore interno della chiave da un elemento del set interno.</param>
        <param name="selector">Metodo che specifica come derivare un elemento del set ottenuto da elementi di set interni ed esterni. Questo metodo deve generare un'istanza di un tipo che sia compatibile con Join e risolvibile in un oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. I requisiti di compatibilità per <c>TSelector</c> sono descritti nelle note.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> che proietta il selettore indicato sui set specificati dalle espressioni esterne e interne, unite in join in una condizione di uguaglianza tra le chiavi esterne e interne specificate, usando InnerJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo oggetto DbProjectExpression con il selettore specificato come proiezione e nuovo oggetto DbJoinExpression come input. L'oggetto di input DbJoinExpression viene creato con un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di InnerJoin, che rappresenta l'operazione di inner join applicata ai set di input sinistri e destri in una condizione di join che confronta i valori di chiave esterni e interni per verificarne l'uguaglianza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per essere compatibile con Join, `TSelector` deve essere derivato da <xref:System.Data.Common.CommandTrees.DbExpression>, o deve essere un tipo anonimo con proprietà derivate da DbExpression. Di seguito sono riportati esempi di tipi supportati per `TSelector`:  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => o.Property("Name"))  
```  
  
 (`TSelector` è <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => new { OName = o.Property("Name"), IName = i.Property("Name") })  
```  
  
 (`TSelector` è un tipo anonimo con proprietà derivate da DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il risultato di <paramref name="selector" /> è null dopo la conversione in DbExpression.</exception>
        <exception cref="T:System.ArgumentException">Il risultato di <paramref name="Selector" /> non è compatibile con SelectMany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> con l'implementazione della funzione lambda inline e i parametri formali specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbVariableReferenceExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function Lambda (body As DbExpression, variables As IEnumerable(Of DbVariableReferenceExpression)) As DbLambda" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbLambda ^ Lambda(System::Data::Common::CommandTrees::DbExpression ^ body, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbVariableReferenceExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Espressione che definisce la logica della funzione lambda.</param>
        <param name="variables">Raccolta di <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> che rappresenta i parametri formali per la funzione lambda. Queste variabili sono valide per essere usate nell'espressione <c>corpo</c>.</param>
        <summary>Crea un oggetto <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> con l'implementazione della funzione lambda inline e i parametri formali specificati.</summary>
        <returns>Nuovo DbLambda che descrive una funzione lambda in linea con il corpo e i parametri formali specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" /> è null, contiene null oppure <paramref name="body" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" /> contiene più di un elemento con lo stesso nome di variabile.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, params System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbVariableReferenceExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Lambda (body As DbExpression, ParamArray variables As DbVariableReferenceExpression()) As DbLambda" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbLambda ^ Lambda(System::Data::Common::CommandTrees::DbExpression ^ body, ... cli::array &lt;System::Data::Common::CommandTrees::DbVariableReferenceExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Data.Common.CommandTrees.DbVariableReferenceExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Espressione che definisce la logica della funzione lambda.</param>
        <param name="variables">Raccolta di <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> che rappresenta i parametri formali per la funzione lambda. Queste variabili sono valide per essere usate nell'espressione <c>corpo</c>.</param>
        <summary>Crea un oggetto <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> con l'implementazione della funzione lambda inline e i parametri formali specificati.</summary>
        <returns>Nuovo DbLambda che descrive una funzione lambda in linea con il corpo e i parametri formali specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" /> è null, contiene null oppure <paramref name="body" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" /> contiene più di un elemento con lo stesso nome di variabile.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftOuterJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle espressioni a sinistra e a destra, utilizzando LeftOuterJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LeftOuterJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ LeftOuterJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set sinistro.</param>
        <param name="right">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica l'argomento del set destro.</param>
        <param name="joinCondition">Metodo che rappresenta la condizione su cui creare un join. Questo metodo deve generare un'espressione con un tipo di risultato Boolean che fornisca la logica della condizione di join.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle espressioni a sinistra e a destra, utilizzando LeftOuterJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di LeftOuterJoin, che rappresenta l'operazione di join sinistra completa applicata ai set di input sinistro e destro nella condizione specificata di join.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="joinCondition" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="joinCondition" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LeftOuterJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ LeftOuterJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica l'argomento di set a sinistra.</param>
        <param name="right">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica l'argomento di set a destra.</param>
        <param name="joinCondition">Espressione che specifica la condizione in base a cui creare il join.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> che, in base alla condizione di join specificata, crea un join dei set specificati dalle associazioni a un'espressione a sinistra e a destra, utilizzando LeftOuterJoin come <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuovo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di LeftOuterJoin, che rappresenta l'operazione di join sinistra completa applicata ai set di input sinistro e destro nella condizione specificata di join.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> o <paramref name="joinCondition" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" /> non contiene un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LessThan (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ LessThan(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> che determina se l'argomento a sinistra è minore di quello a destra.</summary>
        <returns>Nuovo DbComparisonExpression che rappresenta il confronto di tipo minore di.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato confrontabile in termini di ordinamento comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LessThanOrEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ LessThanOrEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> che determina se l'argomento a sinistra è minore o uguale a quello a destra.</summary>
        <returns>Nuovo DbComparisonExpression che rappresenta il confronto di tipo minore di o uguale a.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato comune che sia confrontabile in termini di uguaglianza e di ordinamento tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Like">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> che confronta la stringa di input specificata con il modello specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Like (argument As DbExpression, pattern As DbExpression) As DbLikeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLikeExpression ^ Like(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica la stringa di input.</param>
        <param name="pattern">Espressione che specifica la stringa modello.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> che confronta la stringa di input specificata con il modello specificato.</summary>
        <returns>Nuovo DbLikeExpression con l'input specificato, il modello e una escape null.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> o <paramref name="pattern" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="Argument" /> o <paramref name="pattern" /> non dispone di un tipo di risultato stringa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern, System.Data.Common.CommandTrees.DbExpression escape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern, class System.Data.Common.CommandTrees.DbExpression escape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Like (argument As DbExpression, pattern As DbExpression, escape As DbExpression) As DbLikeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLikeExpression ^ Like(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ pattern, System::Data::Common::CommandTrees::DbExpression ^ escape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="escape" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica la stringa di input.</param>
        <param name="pattern">Espressione che specifica la stringa modello.</param>
        <param name="escape">Espressione facoltativa che specifica la stringa di escape.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> che confronta la stringa di input specificata con il modello specificato utilizzando l'escape facoltativa.</summary>
        <returns>Nuovo DbLikeExpression con l'input specificato, il modello e una escape.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" />,   <paramref name="pattern" /> o <paramref name="escape" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />, <paramref name="pattern" /> o <paramref name="escape" /> non dispone di un tipo di risultato stringa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Limit">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Limit (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Limit(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Limit (argument As DbExpression, count As DbExpression) As DbLimitExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLimitExpression ^ Limit(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica la raccolta di input.</param>
        <param name="count">Espressione che specifica il valore del limite.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> che limita il numero di elementi della raccolta Argument al valore di limite di conteggio specificato. I risultati correlati non sono inclusi nell'output.</summary>
        <returns>Nuovo DbLimitExpression con l'argomento specificato e valori limite di conteggio che non includono i risultati associati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="count" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultati della raccolta o <paramref name="count" /> non dispone di un tipo di risultato uguale o promuovibile a un tipo Integer a 64 bit.</exception>
      </Docs>
    </Member>
    <Member MemberName="Minus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Minus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Minus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Minus (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Minus(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che sottrae l'argomento a destra dall'argomento a sinistra.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione di sottrazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Modulo (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Modulo(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Modulo (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Modulo(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che calcola il resto ottenuto dividendo l'argomento a sinistra per l'argomento a destra.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione modulo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Multiply (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Multiply(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Multiply (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Multiply(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che moltiplica l'argomento a sinistra per l'argomento a destra.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione di moltiplicazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> che rappresenta la navigazione di una composizione o relazione di associazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Common.CommandTrees.DbExpression navigateFrom, System.Data.Metadata.Edm.RelationshipEndMember fromEnd, System.Data.Metadata.Edm.RelationshipEndMember toEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Common.CommandTrees.DbExpression navigateFrom, class System.Data.Metadata.Edm.RelationshipEndMember fromEnd, class System.Data.Metadata.Edm.RelationshipEndMember toEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Navigate (navigateFrom As DbExpression, fromEnd As RelationshipEndMember, toEnd As RelationshipEndMember) As DbRelationshipNavigationExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRelationshipNavigationExpression ^ Navigate(System::Data::Common::CommandTrees::DbExpression ^ navigateFrom, System::Data::Metadata::Edm::RelationshipEndMember ^ fromEnd, System::Data::Metadata::Edm::RelationshipEndMember ^ toEnd);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="fromEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
        <Parameter Name="toEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="navigateFrom">Espressione che specifica l'istanza da cui eseguire la navigazione.</param>
        <param name="fromEnd">Metadati per la proprietà che rappresenta l'estremità della relazione da cui deve verificarsi la navigazione.</param>
        <param name="toEnd">Metadati per la proprietà che rappresenta l'estremità della relazione verso cui deve verificarsi la navigazione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> che rappresenta la navigazione di una composizione o relazione di associazione.</summary>
        <returns>Nuovo DbRelationshipNavigationExpression che rappresenta la navigazione delle estremità della relazione da e a specificata del tipo di relazione specificato dall'istanza della sorgente di navigazione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression> richiede che sempre navigazione venga avviata da un riferimento e pertanto `navigateFrom` deve sempre avere un tipo di risultato di riferimento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fromEnd" />, <paramref name="toEnd" /> o <paramref name="navigateFrom" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromEnd" /> e <paramref name="toEnd" /> non sono dichiarati dallo stesso tipo di relazione oppure <paramref name="navigateFrom" /> presenta un tipo di risultato che non è compatibile con il tipo di proprietà di <paramref name="fromEnd" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, System.Data.Common.CommandTrees.DbExpression navigateFrom);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, class System.Data.Common.CommandTrees.DbExpression navigateFrom) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Metadata.Edm.RelationshipType,System.String,System.String,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Navigate (type As RelationshipType, fromEndName As String, toEndName As String, navigateFrom As DbExpression) As DbRelationshipNavigationExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRelationshipNavigationExpression ^ Navigate(System::Data::Metadata::Edm::RelationshipType ^ type, System::String ^ fromEndName, System::String ^ toEndName, System::Data::Common::CommandTrees::DbExpression ^ navigateFrom);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.RelationshipType" RefType="this" />
        <Parameter Name="fromEndName" Type="System.String" />
        <Parameter Name="toEndName" Type="System.String" />
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="type">Metadati del tipo di relazione che rappresenta la relazione.</param>
        <param name="fromEndName">Nome della proprietà del tipo di relazione che rappresenta l'estremità della relazione da cui deve essere eseguita la navigazione.</param>
        <param name="toEndName">Nome della proprietà del tipo di relazione che rappresenta l'estremità della relazione verso cui deve essere eseguita la navigazione.</param>
        <param name="navigateFrom">Espressione che specifica l'istanza da cui eseguire la navigazione.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> che rappresenta la navigazione di una composizione o relazione di associazione.</summary>
        <returns>Nuovo DbRelationshipNavigationExpression che rappresenta la navigazione delle estremità della relazione da e a specificata del tipo di relazione specificato dall'istanza della sorgente di navigazione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression> richiede che sempre navigazione venga avviata da un riferimento e pertanto `navigateFrom` deve sempre avere un tipo di risultato di riferimento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />, <paramref name="fromEndName" />, <paramref name="toEndName" /> o <paramref name="navigateFrom" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non è associato all'area di lavoro dei metadati di questo albero dei comandi o <paramref name="navigateFrom" /> è associato a un albero dei comandi diverso o <paramref name="type" /> non dichiara una proprietà finale della relazione con nome <paramref name="toEndName" /> o <paramref name="fromEndName" /> oppure <paramref name="navigateFrom" /> dispone di un tipo di risultati che non è compatibile con il tipo di proprietà della proprietà finale della relazione con nome <paramref name="fromEndName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Negate (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Negate(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Negate (argument As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Negate(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica l'argomento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che nega il valore dell'argomento.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione di negazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico per <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function New (instanceType As TypeUsage, arguments As IEnumerable(Of DbExpression)) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ New(System::Data::Metadata::Edm::TypeUsage ^ instanceType, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="instanceType">Tipo della nuova istanza.</param>
        <param name="arguments">Espressioni che specificano i valori delle nuove istanze, interpretate in base al tipo dell'istanza.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Se l'argomento di tipo è un tipo di insieme, gli argomenti specificano gli elementi dell'insieme. In caso contrario, gli argomenti vengono utilizzati come valori di proprietà o di colonna della nuova istanza.</summary>
        <returns>Nuovo DbNewInstanceExpression con tipo e argomenti specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `instanceType` è un tipo di raccolta, ogni espressione in `arguments` deve avere un tipo di risultato promuovibile al tipo di elemento del `instanceType`. Se `instanceType` è un tipo di riga, `arguments` deve contenere il numero di espressioni sono presenti colonne nel tipo di riga e il tipo di risultato di ogni espressione deve essere uguale o promuovibile al tipo della colonna corrispondente. Un tipo di riga che dichiara alcuna colonna non è valido. Se `instanceType` è un tipo di entità `arguments` devono contenere tante espressioni sono definite dal tipo di proprietà e il tipo di risultato di ogni espressione deve essere uguale o promuovibile al tipo della proprietà corrispondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" /> o <paramref name="arguments" /> è null o <paramref name="arguments" /> contiene un valore null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> è vuoto o i tipi di risultato delle espressioni incluse non corrispondono ai requisiti di <paramref name="instanceType" />, come illustrato nella sezione relativa alle note.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function New (instanceType As TypeUsage, ParamArray arguments As DbExpression()) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ New(System::Data::Metadata::Edm::TypeUsage ^ instanceType, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instanceType">Tipo della nuova istanza.</param>
        <param name="arguments">Espressioni che specificano i valori delle nuove istanze, interpretate in base al tipo dell'istanza.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Se l'argomento di tipo è un tipo di insieme, gli argomenti specificano gli elementi dell'insieme. In caso contrario, gli argomenti vengono utilizzati come valori di proprietà o di colonna della nuova istanza.</summary>
        <returns>Nuovo DbNewInstanceExpression con tipo e argomenti specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `instanceType` è un tipo di raccolta, ogni espressione in `arguments` deve avere un tipo di risultato promuovibile al tipo di elemento del `instanceType`. Se `instanceType` è un tipo di riga, `arguments` deve contenere il numero di espressioni sono presenti colonne nel tipo di riga e il tipo di risultato di ogni espressione deve essere uguale o promuovibile al tipo della colonna corrispondente. Un tipo di riga che dichiara alcuna colonna non è valido. Se `instanceType` è un tipo di entità `arguments` devono contenere tante espressioni sono definite dal tipo di proprietà e il tipo di risultato di ogni espressione deve essere uguale o promuovibile al tipo della proprietà corrispondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" /> o <paramref name="arguments" /> è null o <paramref name="arguments" /> contiene un valore null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> è vuoto o i tipi di risultato delle espressioni incluse non corrispondono ai requisiti di <paramref name="instanceType" />, come illustrato nella sezione relativa alle note.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewCollection">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> che costruisce una raccolta contenente gli elementi specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function NewCollection (elements As IEnumerable(Of DbExpression)) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewCollection(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ elements);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="elements">Elenco di espressioni che forniscono gli elementi dell'insieme.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> che costruisce una raccolta contenente gli elementi specificati. Il tipo dell'insieme si basa sul tipo comune degli elementi. Se non esiste alcun tipo di elemento comune viene generata un'eccezione.</summary>
        <returns>Nuovo DbNewInstanceExpression con tipo di raccolta e argomenti specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" /> è null o contiene un valore null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" /> è vuoto o contiene espressioni per le quali non esiste alcun tipo di risultato comune.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (params System.Data.Common.CommandTrees.DbExpression[] elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Data.Common.CommandTrees.DbExpression[] elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Function NewCollection (ParamArray elements As DbExpression()) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewCollection(... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ elements);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elements">Elenco di espressioni che forniscono gli elementi dell'insieme.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> che costruisce una raccolta contenente gli elementi specificati. Il tipo dell'insieme si basa sul tipo comune degli elementi. Se non esiste alcun tipo di elemento comune viene generata un'eccezione.</summary>
        <returns>Nuovo DbNewInstanceExpression con tipo di raccolta e argomenti specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" /> è null o contiene un valore null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" /> è vuoto o contiene espressioni per le quali non esiste alcun tipo di risultato comune.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewEmptyCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection (this System.Data.Metadata.Edm.TypeUsage collectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection(class System.Data.Metadata.Edm.TypeUsage collectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NewEmptyCollection (collectionType As TypeUsage) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewEmptyCollection(System::Data::Metadata::Edm::TypeUsage ^ collectionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="collectionType">Metadati del tipo della raccolta da creare</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> che costruisce un insieme vuoto del tipo di insieme specificato.</summary>
        <returns>Nuovo DbNewInstanceExpression con il tipo di raccolta specificato e un elenco <paramref name="Arguments" /> vuoto.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionType" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionType" /> non è un tipo di insieme.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow (columnValues As IEnumerable(Of KeyValuePair(Of String, DbExpression))) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewRow(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ columnValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="columnValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="columnValues">Elenco di coppie valore-chiave-DbExpression-stringa che definisce la struttura e i valori della riga.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> che produce una riga con le colonne denominate e i valori indicati, specificati come espressioni.</summary>
        <returns>Nuovo DbNewInstanceExpression che rappresenta la costruzione della riga.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="columnValues" /> è null o contiene un elemento con un nome di colonna o un'espressione.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="columnValues" /> è vuoto o contiene un nome di colonna duplicato o non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNotExpression Not (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNotExpression Not(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Not (argument As DbExpression) As DbNotExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNotExpression ^ Not(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNotExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione booleana che specifica l'argomento.</param>
        <summary>Crea un oggetto <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> che esegue la negazione logica dell'argomento specificato.</summary>
        <returns>Nuovo DbNotExpression con l'argomento specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non contiene un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression NotEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression NotEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NotEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ NotEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> che verifica la diseguaglianza fra l'argomento a sinistra e quello a destra.</summary>
        <returns>Nuovo DbComparisonExpression che rappresenta il confronto di disuguaglianza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato confrontabile in termini di uguaglianza comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNullExpression Null (this System.Data.Metadata.Edm.TypeUsage nullType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNullExpression Null(class System.Data.Metadata.Edm.TypeUsage nullType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Null (nullType As TypeUsage) As DbNullExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNullExpression ^ Null(System::Data::Metadata::Edm::TypeUsage ^ nullType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nullType">Tipo del valore null.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbNullExpression" />che rappresenta un valore null tipizzato.</summary>
        <returns>Istanza di DbNullExpression.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nullType" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfType (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfType(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType (argument As DbExpression, type As TypeUsage) As DbOfTypeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOfTypeExpression ^ OfType(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica il set di input.</param>
        <param name="type">Metadati del tipo che gli elementi del set di input devono presentare per essere inclusi nel set risultante.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> che produce un set di elementi del set di input specificato aventi il tipo specificato.</summary>
        <returns>Nuovo oggetto DbOfTypeExpression con l'argomento e il tipo di set specificati e un oggetto ExpressionKind di <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression richiede che `argument` dispone di una raccolta con un tipo di elemento polimorfico e che tipo di risultato `type` è un tipo appartenente alla stessa gerarchia di tipo come tipo di elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultati della raccolta o <paramref name="type" /> non è un tipo della stessa gerarchia di tipi del tipo di elemento del tipo di risultatati della raccolta di <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfTypeOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfTypeOnly (argument As DbExpression, type As TypeUsage) As DbOfTypeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOfTypeExpression ^ OfTypeOnly(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica il set di input.</param>
        <param name="type">Metadati del tipo a cui il tipo degli elementi del set di input deve corrispondere in modo esatto affinché gli elementi siano inclusi nel set risultante.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> che produce un set di elementi del set di input specificato aventi esattamente il tipo specificato.</summary>
        <returns>Nuovo oggetto DbOfTypeExpression con l'argomento e il tipo di set specificati e un oggetto ExpressionKind di <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfTypeOnly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression richiede che `argument` dispone di una raccolta con un tipo di elemento polimorfico e che tipo di risultato `type` è un tipo appartenente alla stessa gerarchia di tipo come tipo di elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultati della raccolta o <paramref name="type" /> non è un tipo della stessa gerarchia di tipi del tipo di elemento del tipo di risultatati della raccolta di <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOrExpression Or (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOrExpression Or(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Or (left As DbExpression, right As DbExpression) As DbOrExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOrExpression ^ Or(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOrExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione booleana che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione booleana che specifica l'argomento a destra.</param>
        <summary>Crea un oggetto <see cref="T:System.Data.Common.CommandTrees.DbOrExpression" /> che esegue l'operazione OR logica degli argomenti a sinistra e a destra.</summary>
        <returns>Nuovo DbOrExpression con gli argomenti specificati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" /> o <paramref name="right" /> non dispone di un tipo di risultato booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alla chiave di ordinamento specificata in ordine crescente e con le regole di confronto predefinite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderBy(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alla chiave di ordinamento specificata in ordine crescente e con le regole di confronto predefinite.</summary>
        <returns>Nuovo DbSortExpression che rappresenta l'operazione di ordinamento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderBy(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <param name="collation">Regole di confronto da utilizzare per l'ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alla chiave di ordinamento specificata in ordine crescente e con le regole di confronto specificate.</summary>
        <returns>Nuovo DbSortExpression che rappresenta l'operazione di ordinamento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non contiene di un tipo di risultato confrontabile in termini di risultato stringa.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> è vuoto o contiene solo spazi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alla chiave di ordinamento specificata in ordine decrescente e con le regole di confronto predefinite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderByDescending(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alla chiave di ordinamento specificata in ordine decrescente e con le regole di confronto predefinite.</summary>
        <returns>Nuovo DbSortExpression che rappresenta l'operazione di ordinamento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderByDescending(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <param name="collation">Regole di confronto da utilizzare per l'ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alla chiave di ordinamento specificata in ordine decrescente e con le regole di confronto specificate.</summary>
        <returns>Nuovo DbSortExpression che rappresenta l'operazione di ordinamento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non contiene di un tipo di risultato confrontabile in termini di risultato stringa.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> è vuoto o contiene solo spazi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OuterApply">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OuterApply (source As DbExpression, apply As Func(Of DbExpression, KeyValuePair(Of String, DbExpression))) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ OuterApply(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ apply);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica il set di input.</param>
        <param name="apply">Metodo che specifica la logica da valutare una volta per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply. Le righe per cui <paramref name="apply" /> è un set vuoto presentano il valore <see langword="null" /> nella colonna apply.</summary>
        <returns>Nuovo DbApplyExpression con l'input specificato e applica le associazioni e un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il risultato di <paramref name="apply" /> contiene un nome o un'espressione null.</exception>
        <exception cref="T:System.ArgumentException">Il risultato dell'operazione di <paramref name="apply" /> contiene un nome o un'espressione non valido in un'associazione di espressioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OuterApply (input As DbExpressionBinding, apply As DbExpressionBinding) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ OuterApply(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpressionBinding ^ apply);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica il set di input.</param>
        <param name="apply">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> che specifica la logica da valutare una volta per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply. Le righe per cui <paramref name="apply" /> è un set vuoto presentano il valore <see langword="null" /> nella colonna apply.</summary>
        <returns>Nuovo DbApplyExpression con l'input specificato e applica le associazioni e un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="apply" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Parameter (type As TypeUsage, name As String) As DbParameterReferenceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbParameterReferenceExpression ^ Parameter(System::Data::Metadata::Edm::TypeUsage ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbParameterReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del parametro a cui si fa riferimento.</param>
        <param name="name">Nome del parametro a cui si fa riferimento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> che fa riferimento a un parametro avente il nome e il tipo specificati.</summary>
        <returns>DbParameterReferenceExpression che rappresenta un riferimento a un parametro con il nome e il tipo specificato. Il tipo di risultato dell'espressione è uguale a <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Plus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Plus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Plus (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Plus(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che specifica l'argomento a sinistra.</param>
        <param name="right">Espressione che specifica l'argomento a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che aggiunge l'argomento a sinistra all'argomento a destra.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione di addizione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico comune tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Project (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Project(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Project (input As DbExpressionBinding, projection As DbExpression) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Project(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ projection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="projection" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Associazione a un'espressione che specifica il set di input.</param>
        <param name="projection">Espressione da proiettare sul set.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> che proietta l'espressione indicata sul set di input specificato.</summary>
        <returns>Nuovo DbProjectExpression che rappresenta l'operazione di proiezione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="projection" /> è null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> che rappresenta il recupero della proprietà specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.EdmProperty propertyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.EdmProperty propertyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EdmProperty)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, propertyMetadata As EdmProperty) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::EdmProperty ^ propertyMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyMetadata" Type="System.Data.Metadata.Edm.EdmProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Istanza da cui recuperare la proprietà. Può essere null se la proprietà è statica.</param>
        <param name="propertyMetadata">Metadati della proprietà da recuperare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> che rappresenta il recupero della proprietà specificata.</summary>
        <returns>Nuovo DbPropertyExpression che rappresenta la proprietà di navigazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyMetadata" /> è null o <paramref name="instance" /> è null e la proprietà non è statica.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.NavigationProperty navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.NavigationProperty navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.NavigationProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::NavigationProperty ^ navigationProperty);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="navigationProperty" Type="System.Data.Metadata.Edm.NavigationProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Istanza da cui recuperare la proprietà di navigazione.</param>
        <param name="navigationProperty">Metadati della proprietà di navigazione da recuperare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> che rappresenta il recupero della proprietà di navigazione specificata.</summary>
        <returns>Nuovo DbPropertyExpression che rappresenta il recupero della proprietà di navigazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigationProperty" /> o <paramref name="instance" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, relationshipEnd As RelationshipEndMember) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::RelationshipEndMember ^ relationshipEnd);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="relationshipEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="instance">Istanza da cui recuperare il membro finale della relazione.</param>
        <param name="relationshipEnd">Metadati del membro finale della relazione da recuperare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> che rappresenta il recupero del membro finale della relazione specificato.</summary>
        <returns>Nuovo DbPropertyExpression che rappresenta il recupero del membro finale della relazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipEnd" /> è null o <paramref name="instance" /> è null e la proprietà non è statica.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, propertyName As String) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">Istanza da cui recuperare la proprietà.</param>
        <param name="propertyName">Nome della proprietà da recuperare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> che rappresenta il recupero della proprietà di istanza avente il nome specificato dall'istanza specificata.</summary>
        <returns>Nuovo DbPropertyExpression che rappresenta il recupero della proprietà.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyName" /> è null o <paramref name="instance" /> è null e la proprietà non è statica.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nessuna proprietà con il nome specificato viene dichiarata dal tipo di <paramref name="instance" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RefFromKey">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica basata su valori chiave.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ RefFromKey(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Common::CommandTrees::DbExpression ^ keyRow);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="entitySet">Set di entità che contiene l'elemento a cui si fa riferimento.</param>
        <param name="keyRow">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che costruisce un record con le colonne che corrispondono (in numero, tipo e ordine) alle proprietà di chiave del tipo di entità a cui si fa riferimento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica basata su valori chiave.</summary>
        <returns>Nuovo DbRefExpression che fa riferimento all'elemento con i valori della chiave specificati nel set di entità specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow` deve essere impostata un'espressione che specifica i valori di chiave che identifica l'entità a cui fa riferimento all'interno dell'entità specificata. Il tipo di risultato `keyRow` deve contenere una colonna corrispondente per ogni proprietà chiave definita da `entitySet's` tipo di entità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> o <paramref name="keyRow" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyRow" /> non dispone di un tipo di risultati di record che corrisponde alla proprietà dei tasti del tipo di entità del set di entità di riferimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow, System.Data.Metadata.Edm.EntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow, class System.Data.Metadata.Edm.EntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EntityType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ RefFromKey(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Common::CommandTrees::DbExpression ^ keyRow, System::Data::Metadata::Edm::EntityType ^ entityType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
      </Parameters>
      <Docs>
        <param name="entitySet">Set di entità che contiene l'elemento a cui si fa riferimento.</param>
        <param name="keyRow">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che costruisce un record con le colonne che corrispondono (in numero, tipo e ordine) alle proprietà di chiave del tipo di entità a cui si fa riferimento.</param>
        <param name="entityType">Tipo di Entità a cui fare riferimento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> che codifica un riferimento a un'entità specifica basata su valori chiave.</summary>
        <returns>Nuovo DbRefExpression che fa riferimento all'elemento con i valori della chiave specificati nel set di entità specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow` deve essere impostata un'espressione che specifica i valori di chiave che identifica l'entità a cui fa riferimento all'interno dell'entità specificata. Il tipo di risultato `keyRow` deve contenere una colonna corrispondente per ogni proprietà chiave definita da `entitySet's` tipo di entità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />, <paramref name="keyRow" /> o <paramref name="entityType" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entityType" /> non si trova nella stessa gerarchia tipi del tipo di entità del set di entità oppure <paramref name="keyRow" /> non dispone di un tipo di risultato record corrispondente alle proprietà chiave del tipo di entità del set di entità a cui si fa riferimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbScanExpression Scan (this System.Data.Metadata.Edm.EntitySetBase targetSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbScanExpression Scan(class System.Data.Metadata.Edm.EntitySetBase targetSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan(System.Data.Metadata.Edm.EntitySetBase)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Scan (targetSet As EntitySetBase) As DbScanExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbScanExpression ^ Scan(System::Data::Metadata::Edm::EntitySetBase ^ targetSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbScanExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSet" Type="System.Data.Metadata.Edm.EntitySetBase" RefType="this" />
      </Parameters>
      <Docs>
        <param name="targetSet">Metadati del set di entità o di relazioni a cui fare riferimento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbScanExpression" /> che fa riferimento al set di entità o di relazioni specificato.</summary>
        <returns>Nuovo DbScanExpression basato sull'entità o sul set di relazioni specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetSet" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TProjection&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt; projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, !!TProjection&gt; projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TProjection) (source As DbExpression, projection As Func(Of DbExpression, TProjection)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TProjection&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Select(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, TProjection&gt; ^ projection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProjection" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="projection" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProjection">Tipo di risultato del metodo <c>proiezione</c>.</typeparam>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="projection">Metodo che specifica come derivare l'espressione proiettata, in base a un membro del set di input. Questo metodo deve produrre un'istanza che presenti un tipo compatibile con Select e che possa essere risolto in un oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. I requisiti di compatibilità per <c>TProjection</c> sono descritti nelle note.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> che seleziona l'espressione indicata sul set di input specificato.</summary>
        <returns>Nuovo DbProjectExpression che rappresenta l'operazione di selezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per essere compatibile con l'istruzione Select, `TProjection` deve essere derivato da <xref:System.Data.Common.CommandTrees.DbExpression>, o deve essere un tipo anonimo con proprietà derivate da DbExpression. Di seguito sono riportati esempi di tipi supportati per `TProjection`:  
  
```  
source.Select(x => x.Property("Name"))  
```  
  
 `TProjection` è <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.Select(x => new { Name = x.Property("Name") })  
```  
  
 (`TProjection` è un tipo anonimo con una proprietà derivato da DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il risultato della <paramref name="projection" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany (source As DbExpression, apply As Func(Of DbExpression, DbExpression)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ SelectMany(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ apply);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica il set di input.</param>
        <param name="apply">Metodo che rappresenta la logica da valutare una volta per ogni membro del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply. Le righe in cui <paramref name="apply" /> restituisce un set vuoto non vengono incluse. Viene quindi creato un oggetto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> che seleziona la colonna <paramref name="apply" /> da ogni riga, producendo l'insieme complessivo di risultati <paramref name="apply" />.</summary>
        <returns>Nuovo DbProjectExpression che seleziona la colonna di applicazione da un nuovo DbApplyExpression con l'input specificato e applica le associazioni e un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="apply" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="apply" /> non dispone di un tipo di raccolta.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSelector) (source As DbExpression, apply As Func(Of DbExpression, DbExpression), selector As Func(Of DbExpression, DbExpression, TSelector)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSelector&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ SelectMany(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ apply, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, TSelector&gt; ^ selector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Tipo di risultato del metodo <c>selettore</c>.</typeparam>
        <param name="source">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che specifica il set di input.</param>
        <param name="apply">Metodo che rappresenta la logica da valutare una volta per ogni membro del set di input.</param>
        <param name="selector">Metodo che specifica come derivare un elemento del set di risultati dato un elemento dei set relativi all'input e all'espressione apply. Questo metodo deve produrre un'istanza che presenti un tipo compatibile con SelectMany e che possa essere risolto in un oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. I requisiti di compatibilità per <c>TSelector</c> sono descritti nelle note.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> che valuta l'espressione <paramref name="apply" /> specificata una volta per ogni elemento di un set di input specificato e produce una raccolta di righe con colonne corrispondenti relative all'input e all'espressione apply. Le righe in cui <paramref name="apply" /> restituisce un set vuoto non vengono incluse. Viene quindi creato un oggetto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> che seleziona il parametro <paramref name="selector" /> specificato in ogni riga, producendo l'insieme complessivo di risultati.</summary>
        <returns>Nuovo DbProjectExpression che seleziona il risultato del selettore specificato da un nuovo DbApplyExpression con l'input specificato e applica le associazioni e un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> di CrossApply.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per essere compatibile con SelectMany, `TSelector` deve essere derivato da <xref:System.Data.Common.CommandTrees.DbExpression>, o deve essere un tipo anonimo con proprietà derivate da DbExpression. Di seguito sono riportati esempi di tipi supportati per `TSelector`:  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => apply.Property("Name"))  
```  
  
 (`TSelector` è <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => new { SourceName = source.Property("Name"), RelatedName = apply.Property("Name") })  
```  
  
 (`TSelector` è un tipo anonimo con proprietà derivate da DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il risultato di <paramref name="selector" /> è null nella conversione a DbExpression.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="apply" /> non dispone di un tipo di raccolta. non dispone di un tipo di raccolta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Skip">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> che ordina il set di input in base alle specifiche di ordinamento prima di ignorare il numero specificato di elementi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbSortExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbSortExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbSortExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip (argument As DbSortExpression, count As DbExpression) As DbSkipExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSkipExpression ^ Skip(System::Data::Common::CommandTrees::DbSortExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che specifica il set di input ordinato.</param>
        <param name="count">Espressione che specifica il numero di elementi del set ordinato da ignorare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> che ignora il numero specificato di elementi del set di input ordinato.</summary>
        <returns>Nuovo DbSkipExpression che rappresenta l'operazione Skip.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="count" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> non è un oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> o <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> oppure dispone di un tipo di risultato diverso da o non promuovibile a un tipo Integer a 64 bit.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip (input As DbExpressionBinding, sortOrder As IEnumerable(Of DbSortClause), count As DbExpression) As DbSkipExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSkipExpression ^ Skip(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbSortClause ^&gt; ^ sortOrder, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Associazione a un'espressione che specifica il set di input.</param>
        <param name="sortOrder">Elenco di specifiche di ordinamento che determinano come ordinare gli elementi del set di input.</param>
        <param name="count">Espressione che specifica il numero di elementi del set ordinato da ignorare.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> che ordina il set di input in base alle specifiche di ordinamento prima di ignorare il numero specificato di elementi.</summary>
        <returns>Nuovo DbSkipExpression che rappresenta l'operazione Skip.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="sortOrder" /> o <paramref name="count" /> è null o <paramref name="sortOrder" /> contiene un valore null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" /> è vuoto o <paramref name="count" /> non è un oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> o un oggetto <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> oppure dispone di un tipo di risultato diverso da o non promuovibile a un tipo Integer a 64 bit.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression Sort (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression Sort(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sort (input As DbExpressionBinding, sortOrder As IEnumerable(Of DbSortClause)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ Sort(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbSortClause ^&gt; ^ sortOrder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Associazione a un'espressione che specifica il set di input.</param>
        <param name="sortOrder">Elenco di specifiche di ordinamento che determinano come ordinare gli elementi del set di input.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> che ordina il set di input specificato in base alle specifiche di ordinamento specificate.</summary>
        <returns>Nuovo DbSortExpression che rappresenta l'operazione Sort.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="sortOrder" /> è null o <paramref name="sortOrder" /> contiene un valore null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" /> è vuoto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Take (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Take(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take (argument As DbExpression, count As DbExpression) As DbLimitExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLimitExpression ^ Take(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica la raccolta di input.</param>
        <param name="count">Espressione che specifica il valore del limite.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> che limita il numero di elementi della raccolta Argument al valore di limite di conteggio specificato. I risultati correlati non sono inclusi nell'output.</summary>
        <returns>Nuovo DbLimitExpression con l'argomento specificato e valori limite di conteggio che non includono i risultati associati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="count" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> non dispone di un tipo di risultati della raccolta, <paramref name="count" /> non dispone di un tipo di risultato uguale o promuovibile a un tipo Integer a 64 bit.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un ordinamento che include l'ordinamento del set di input nell'ordine specificato insieme alla chiave di ordinamento specificata in ordine crescente e con le regole di confronto predefinite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenBy(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto DbSortExpression che specifica il set di input ordinato.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento aggiuntiva dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un ordinamento che include l'ordinamento del set di input nell'ordine specificato insieme alla chiave di ordinamento specificata in ordine crescente e con le regole di confronto predefinite.</summary>
        <returns>Nuovo DbSortExpression che rappresenta la precedente operazione di ordinamento generale.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortKey" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenBy(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto DbSortExpression che specifica il set di input ordinato.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento aggiuntiva dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <param name="collation">Regole di confronto da utilizzare per l'ordinamento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un ordinamento che include l'ordinamento del set di input nell'ordine indicato insieme alla chiave di ordinamento specificata in ordine crescente e con le regole di confronto specificate.</summary>
        <returns>Nuovo DbSortExpression che rappresenta la precedente operazione di ordinamento generale.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non contiene di un tipo di risultato confrontabile in termini di risultato stringa.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> è vuoto o contiene solo spazi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un ordinamento che include l'ordinamento del set di input nell'ordine indicato insieme alla chiave di ordinamento specificata in ordine decrescente e con le regole di confronto predefinite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenByDescending(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto DbSortExpression che specifica il set di input ordinato.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento aggiuntiva dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un ordinamento che include l'ordinamento del set di input nell'ordine indicato insieme alla chiave di ordinamento specificata in ordine decrescente e con le regole di confronto predefinite.</summary>
        <returns>Nuovo DbSortExpression che rappresenta la precedente operazione di ordinamento generale.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenByDescending(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto DbSortExpression che specifica il set di input ordinato.</param>
        <param name="sortKey">Metodo che specifica come derivare l'espressione della chiave di ordinamento aggiuntiva dato un membro del set di input. Questo metodo deve produrre un'espressione con un tipo di risultato confrontabile in termini di ordinamento che fornisce la definizione della chiave di ordinamento.</param>
        <param name="collation">Regole di confronto da utilizzare per l'ordinamento.</param>
        <summary>Crea un nuovo elemento <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un ordinamento che include l'ordinamento del set di input nell'ordine indicato insieme alla chiave di ordinamento specificata in ordine decrescente e con le regole di confronto specificate.</summary>
        <returns>Nuovo DbSortExpression che rappresenta la precedente operazione di ordinamento generale.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="sortKey" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione prodotta da <paramref name="sortKey" /> non contiene di un tipo di risultato confrontabile in termini di risultato stringa.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> è vuoto o contiene solo spazi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToSortClause">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un ordinamento crescente e con le regole di confronto predefinite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClause (key As DbExpression) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClause(System::Data::Common::CommandTrees::DbExpression ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Espressione che definisce la chiave di ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un ordinamento crescente e con le regole di confronto predefinite.</summary>
        <returns>Nuova clausola di ordinamento con chiave di ordinamento data e ordine di ordinamento ascendente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClause (key As DbExpression, collation As String) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClause(System::Data::Common::CommandTrees::DbExpression ^ key, System::String ^ collation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Espressione che definisce la chiave di ordinamento.</param>
        <param name="collation">Regole di confronto da utilizzare per l'ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un ordinamento crescente e con le regole di confronto specificate.</summary>
        <returns>Nuova clausola di ordinamento con chiave di ordinamento e regole di confronto date e ordine di ordinamento ascendente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> è vuoto o contiene solo spazi.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToSortClauseDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un ordinamento decrescente e con le regole di confronto predefinite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClauseDescending (key As DbExpression) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClauseDescending(System::Data::Common::CommandTrees::DbExpression ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Espressione che definisce la chiave di ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un ordinamento decrescente e con le regole di confronto predefinite.</summary>
        <returns>Nuova clausola di ordinamento con chiave di ordinamento data e ordine di ordinamento discendente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClauseDescending (key As DbExpression, collation As String) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClauseDescending(System::Data::Common::CommandTrees::DbExpression ^ key, System::String ^ collation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Espressione che definisce la chiave di ordinamento.</param>
        <param name="collation">Regole di confronto da utilizzare per l'ordinamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un ordinamento decrescente e con le regole di confronto specificate.</summary>
        <returns>Nuova clausola di ordinamento con chiave di ordinamento e regole di confronto date e ordine di ordinamento discendente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> è vuoto o contiene solo spazi.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> non dispone di un tipo di risultato confrontabile in termini di ordinamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="TreatAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbTreatExpression TreatAs (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage treatType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbTreatExpression TreatAs(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage treatType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TreatAs (argument As DbExpression, treatType As TypeUsage) As DbTreatExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbTreatExpression ^ TreatAs(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ treatType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbTreatExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="treatType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica l'istanza.</param>
        <param name="treatType">Metadati del tipo da utilizzare come modello di trattamento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression" />.</summary>
        <returns>Nuovo DbTreatExpression con l'argomento e il tipo di destinazione specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario che DbTreatExpression `argument` dispone di un tipo di risultato polimorfico e che `treatType` è un tipo appartenente alla stessa gerarchia di tipo di tale tipo di risultato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="treatType" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="treatType" /> non si trova nella stessa gerarchia dei tipi del tipo di risultato di <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="True">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression True { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression True" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property True As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Data::Common::CommandTrees::DbConstantExpression ^ True { System::Data::Common::CommandTrees::DbConstantExpression ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con il valore booleano <see langword="true" />.</summary>
        <value>Oggetto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con il valore booleano <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnaryMinus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UnaryMinus (argument As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ UnaryMinus(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Espressione che specifica l'argomento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> che nega il valore dell'argomento.</summary>
        <returns>Nuovo DbArithmeticExpression che rappresenta l'operazione di negazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultato numerico per <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Union (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Union(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union (left As DbExpression, right As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Union(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che definisce l'argomento di set a sinistra.</param>
        <param name="right">Espressione che definisce l'argomento di set a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> che calcola l'unione degli argomenti di set a sinistra e a destra rimuovendone i duplicati.</summary>
        <returns>Nuovo DbExpression che calcola l'unione, senza duplicati, degli argomenti a sinistra e a destra.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultati della raccolta comune con un tipo di elemento confrontabile in termini di uguaglianza tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnionAll">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UnionAll (left As DbExpression, right As DbExpression) As DbUnionAllExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbUnionAllExpression ^ UnionAll(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbUnionAllExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Espressione che definisce l'argomento di set a sinistra.</param>
        <param name="right">Espressione che definisce l'argomento di set a destra.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbUnionAllExpression" /> che calcola l'unione degli argomenti di set a sinistra e a destra senza rimuoverne i duplicati.</summary>
        <returns>Nuovo DbUnionAllExpression che unisce gli argomenti a sinistra e a destra, inclusi i duplicati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Non esiste alcun tipo di risultati della raccolta comune con un tipo di elemento confrontabile in termini di uguaglianza tra <paramref name="left" /> e <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Variable (type As TypeUsage, name As String) As DbVariableReferenceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbVariableReferenceExpression ^ Variable(System::Data::Metadata::Edm::TypeUsage ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbVariableReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo della variabile a cui si fa riferimento.</param>
        <param name="name">Nome della variabile a cui si fa riferimento.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> che fa riferimento a una variabile avente il nome e il tipo specificati.</summary>
        <returns>DbVariableReferenceExpression che rappresenta un riferimento a una variabile con il nome e il tipo specificato. Il tipo di risultato dell'espressione è uguale a <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Where (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Where(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbFilterExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFilterExpression ^ Where(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Espressione che specifica il set di input.</param>
        <param name="predicate">Metodo che rappresenta il predicato da valutare per ogni membro del set di input.    Questo metodo deve produrre un'espressione con un tipo di risultato booleano che fornisce la logica predicativa.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> che filtra gli elementi nel set di input specificato tramite il predicato specificato.</summary>
        <returns>Nuovo DbQuantifierExpression che rappresenta l'operazione Any.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'espressione generata da <paramref name="predicate" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">L'espressione generata da <paramref name="predicate" /> non ha un tipo di risultato Boolean.</exception>
      </Docs>
    </Member>
  </Members>
</Type>