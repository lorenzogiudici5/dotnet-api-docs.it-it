<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c517974716d9aca4ce942d8903397dfbf421327a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36657139" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce l'accesso alle notifiche degli eventi di sistema. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:Microsoft.Win32.SystemEvents> classe offre la possibilità di rispondere a specifici tipi di eventi di sistema.  
  
 Quando viene generato un evento di sistema, i delegati associati all'evento vengono chiamati tramite il thread che esegue il monitoraggio per gli eventi di sistema. Pertanto, è consigliabile apportare tutte le chiamate dai gestori eventi thread-safe. Se è necessario chiamare un evento di sistema che non è esposta come un membro di questa classe, è possibile utilizzare il <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> metodo.  
  
> [!CAUTION]
>  Non eseguire l'elaborazione richiede molto tempo sul thread che genera un gestore di eventi di sistema perché potrebbero impedire il funzionamento di altre applicazioni.  
  
> [!NOTE]
>  Alcuni eventi di sistema potrebbero non essere generati in [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Verificare che l'applicazione funzioni come previsto in [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Questa sezione sono riportati due esempi. Nel primo esempio viene illustrato come utilizzare gli eventi di sistema in un'applicazione normale e il secondo esempio viene illustrato come utilizzare gli eventi di sistema in un servizio Windows.  
  
 **Esempio 1**  
  
 Esempio di codice seguente registra l'interesse in alcuni eventi di sistema e quindi attende che uno di questi eventi si verifichi. L'output visualizzato si verifica se l'utente modifica la risoluzione dello schermo.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente viene illustrato un servizio Windows molto semplice che gestisce il <xref:Microsoft.Win32.SystemEvents.TimeChanged> e <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> eventi. L'esempio include un servizio denominato `SimpleService`, un form denominato `HiddenForm`e un programma di installazione. Il form fornisce il ciclo di messaggi richiesto da eventi di sistema.  
  
> [!NOTE]
>  Servizi non sono in cicli di messaggi, a meno che non possono interagire con il desktop. Se il ciclo di messaggi non viene fornito da un form nascosto, come in questo esempio, il servizio deve essere eseguito con l'account sistema locale e per consentire l'interazione con il desktop è richiesto l'intervento manuale. Vale a dire, l'amministratore deve controllare manualmente i **Consenti al servizio di interagire col desktop** casella di controllo il **Accedi** scheda della finestra di dialogo proprietà del servizio. In tal caso, viene fornito automaticamente un ciclo di messaggi. Questa opzione è disponibile solo quando il servizio viene eseguito con l'account sistema locale. L'interazione con il desktop non può essere abilitata a livello di codice.  
  
 Il servizio in questo esempio viene avviato un thread che esegue un'istanza di `HiddenForm`. Gli eventi sono agganciati e gestiti nel modulo. Gli eventi devono essere associati nell'evento di caricamento del modulo, per assicurarsi che il form sia stato completamente caricato per primo. in caso contrario, gli eventi non verrà generati.  
  
> [!NOTE]
>  Nell'esempio viene tutto il codice necessario, incluso il codice di inizializzazione di form in genere generato dalle finestre di progettazione di Visual Studio. Se si sviluppa il servizio in Visual Studio, è possibile omettere la seconda classe parziale e usare la **delle proprietà** finestra per impostare l'altezza e la larghezza del form nascosto a zero, lo stile del bordo per <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>e lo stato della finestra per <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Per eseguire l'esempio:  
  
1.  Compilare il codice dalla riga di comando. Il nome utilizzato per il file di origine non è importante.  
  
2.  Installare il servizio dalla riga di comando mediante il [Installutil.exe (strumento programma di installazione)](~/docs/framework/tools/installutil-exe-installer-tool.md) utilità. Ad esempio `InstallUtil example.exe` se il nome del file di origine `example.cs` o `example.vb`. È necessario essere un amministratore per installare il servizio.  
  
3.  Utilizzare la console servizi per avviare il servizio.  
  
4.  Modificare l'ora di sistema o modificare le preferenze dell'utente, ad esempio le proprietà del mouse.  
  
5.  Visualizzare i messaggi nel **applicazione** categoria del Visualizzatore eventi.  
  
6.  Utilizzare la console servizi per arrestare il servizio.  
  
7.  Disinstallare il servizio dalla riga di comando utilizzando il `/u` opzione. Ad esempio `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">per l'accesso completo alle risorse di sistema. Valori richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Stato associato:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Specifica l'intervallo tra le notifiche del timer, in millisecondi.</param>
        <summary>Crea un nuovo timer di finestra associato alla finestra degli eventi di sistema.</summary>
        <returns>ID del nuovo timer.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">L'intervallo è minore o uguale a zero.</exception>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare il timer o un thread per la finestra degli eventi di sistema non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente modifica le impostazioni di visualizzazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come monitorare la <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> evento. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato durante la modifica delle impostazioni di visualizzazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato prima che venga terminato il thread che attende gli eventi di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato quando il thread in attesa di eventi di sistema sta per essere terminato. I delegati di eventi di sistema vengono richiamati tramite il thread in attesa di eventi di sistema.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente aggiunge o rimuove dei tipi di carattere dal sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegato da richiamare utilizzando il thread che attende gli eventi di sistema.</param>
        <summary>Richiama il delegato specificato utilizzando il thread che attende gli eventi di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questo metodo ogni volta che è necessario gestire un evento di sistema che non è esposta in caso contrario, per il <xref:Microsoft.Win32.SystemEvents> classe.  
  
 Quando si chiama questo metodo, il delegato specificato verrà richiamato dal thread nell'applicazione viene utilizzata per elaborare gli eventi di sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">ID del timer da terminare.</param>
        <summary>Termina il timer specificato dall'ID fornito.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di terminare il timer o di creare un thread per la finestra degli eventi di sistema non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando il sistema sta esaurendo la memoria RAM disponibile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento esegue il wrapping del messaggio WM_COMPACTING. Questo messaggio viene inviato a tutte le finestre di primo livello quando il sistema rileva più di 12,5% dell'ora di sistema in un intervallo di tempo da 30 a 60 secondi viene impiegato per la compattazione della memoria. Ciò indica che la memoria di sistema è bassa.  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <block subset="none" type="usage">
          <para>Questo messaggio viene fornito solo per compatibilità con le applicazioni basate su Windows a 16 bit.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente passa a un'applicazione che utilizza una tavolozza diversa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come monitorare la <xref:Microsoft.Win32.SystemEvents.PaletteChanged> evento. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente sospende o riavvia il sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente si disconnette o arresta il sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente tenta di disconnettersi o di arrestare il sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un evento annullabile. Impostazione di <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> proprietà `true` richiede che la sessione rimane in esecuzione. Non fornisce alcuna garanzia che non termina la sessione.  
  
 Se si utilizza <xref:Microsoft.Win32.SystemEvents.SessionEnding> in un Windows form per rilevare un disconnessione dal sistema o un riavvio, non è deterministico per decidere se il <xref:System.Windows.Forms.Form.Closing> prima di questo evento viene generato l'evento.  
  
 Se si desidera eseguire alcune attività speciale prima <xref:System.Windows.Forms.Form.Closing> è generato, è necessario assicurarsi che <xref:Microsoft.Win32.SystemEvents.SessionEnding> viene attivato prima <xref:System.Windows.Forms.Form.Closing>. A tale scopo, è necessario intercettare il `WM_QUERYENDSESSION` del modulo eseguendo l'override di `WndProc` (funzione).  In questo esempio viene illustrato come eseguire questa operazione.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Applicazioni console non generano il <xref:Microsoft.Win32.SystemEvents.SessionEnding> evento.  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando cambia l'utente connesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando l'utente modifica l'ora nell'orologio di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando scade un intervallo di timer delle finestre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando viene modificata una preferenza utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato durante la modifica di una preferenza utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo evento viene generato solo se è in esecuzione il message pump. In un servizio di Windows, a meno che non viene utilizzato un form nascosto o il message pump avviato manualmente, questo evento non essere generato. Per un esempio di codice che illustra come gestire gli eventi di sistema tramite un form nascosto in un servizio Windows, vedere il <xref:Microsoft.Win32.SystemEvents> classe.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stata eliminata o perdite di memoria, verranno generato.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come monitorare la <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> evento. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:Microsoft.Win32.SystemEvents> classe.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le notifiche degli eventi di sistema non sono supportate nel contesto corrente. I processi server, ad esempio, potrebbero non supportare le notifiche degli eventi di sistema globali.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Il tentativo di creare un thread della finestra degli eventi di sistema non è riuscito.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>