<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e375cff6d3f3621aa35b61963b8d8aa09e4f97b6" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691820" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an HTTP-specific implementation of the <see cref="T:System.Net.WebRequest" /> class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest> classe offre supporto per le proprietà e metodi definiti in <xref:System.Net.WebRequest> e per le proprietà e metodi che consentono all'utente di interagire direttamente con i server tramite HTTP.  
  
 Non utilizzare il <xref:System.Net.HttpWebRequest.%23ctor%2A> costruttore. Utilizzare il <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> metodo per inizializzare nuovi <xref:System.Net.HttpWebRequest> oggetti. Se lo schema per l'identificatore URI (Uniform Resource) è `http://` o `https://`, <xref:System.Net.WebRequest.Create%2A> restituisce un <xref:System.Net.HttpWebRequest> oggetto.  
  
 Il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo effettua una richiesta sincrona alla risorsa specificata nel <xref:System.Net.HttpWebRequest.RequestUri%2A> proprietà e restituisce un <xref:System.Net.HttpWebResponse> che contiene l'oggetto risposta. I dati di risposta possono essere ricevuti tramite il flusso restituito da <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Se l'oggetto risposta o nel flusso di risposta è chiusa, i dati rimanenti andranno persi. I dati rimanenti verranno vengano svuotati e socket verrà nuovamente usato per le successive richieste quando si chiude l'oggetto di risposta o di un flusso, se contengono le condizioni seguenti: si tratta di una richiesta di keep-alive o pipeline, solo una piccola quantità di dati deve essere ricevuto, o i dati rimanenti ricevuto in un breve intervallo di tempo. Se nessuna delle condizioni di cui tenere o è stato superato il tempo di svuotamento, il socket verrà chiusa. Per le connessioni keep-alive o pipeline, è consigliabile che l'applicazione legge flussi finché EOF. In questo modo si garantisce che il socket verrà nuovamente usato per le richieste successive risultante un miglioramento delle prestazioni e le risorse utilizzate.  
  
 Quando si desidera inviare i dati alla risorsa, il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo restituisce un <xref:System.IO.Stream> oggetto da usare per inviare i dati. Il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodi forniscono accesso asincrono al flusso di dati di trasmissione.  
  
 Per l'autenticazione client con <xref:System.Net.HttpWebRequest>, il certificato client deve essere installato nell'archivio certificati personali dell'utente corrente.  
  
 Il <xref:System.Net.HttpWebRequest> classe genera un <xref:System.Net.WebException> quando si verificano errori durante l'accesso a una risorsa. Il <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> proprietà contiene un <xref:System.Net.WebExceptionStatus> valore che indica l'origine dell'errore. Quando <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> è <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> proprietà contiene il <xref:System.Net.HttpWebResponse> ricevuti dalla risorsa.  
  
 <xref:System.Net.HttpWebRequest> espone i valori di intestazione HTTP comuni inviati alla risorsa Internet come proprietà impostate dai metodi o dal sistema. Nella tabella seguente contiene un elenco completo. È possibile impostare altre intestazioni <xref:System.Net.HttpWebRequest.Headers%2A> proprietà come coppie nome/valore. Si noti che i server e memorizza nella cache può modificare o aggiungere intestazioni durante la richiesta.  
  
 Nella tabella seguente sono elencate le intestazioni HTTP che vengono impostate in base alle proprietà o metodi o il sistema.  
  
|Header|L'impostazione|  
|------------|------------|  
|Accettare|L'impostazione di <xref:System.Net.HttpWebRequest.Accept%2A> proprietà.|  
|Connessione|L'impostazione di <xref:System.Net.HttpWebRequest.Connection%2A> proprietà <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà.|  
|Lunghezza del contenuto|L'impostazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà.|  
|Content-Type|L'impostazione di <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà.|  
|Previsto|L'impostazione di <xref:System.Net.HttpWebRequest.Expect%2A> proprietà.|  
|Data|Impostare il sistema alla data corrente.|  
|Host|L'impostazione di sistema per informazioni sull'host corrente.|  
|If-Modified-Since|L'impostazione di <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà.|  
|Intervallo|L'impostazione di <xref:System.Net.HttpWebRequest.AddRange%2A> metodo.|  
|Referer|L'impostazione di <xref:System.Net.HttpWebRequest.Referer%2A> proprietà.|  
|Codifica di trasferimento|L'impostazione di <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà (il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà deve essere `true`).|  
|Agente utente|L'impostazione di <xref:System.Net.HttpWebRequest.UserAgent%2A> proprietà.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> viene registrato automaticamente. Non è necessario chiamare il <xref:System.Net.WebRequest.RegisterPrefix%2A> metodo registrare <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> prima di utilizzare URI a partire da `http://` o `https://`.  
  
 Il computer locale o un file config dell'applicazione può specificare che un proxy predefinito da utilizzare. Se il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà viene specificata, quindi le impostazioni del proxy dal <xref:System.Net.HttpWebRequest.Proxy%2A> override di proprietà, il computer locale o un file config dell'applicazione e <xref:System.Net.HttpWebRequest> istanza utilizzerà le impostazioni proxy specificate. Se viene specificato alcun proxy in un file di configurazione e <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà non è specificata, il <xref:System.Net.HttpWebRequest> classe utilizza le impostazioni del proxy ereditate da Internet Explorer nel computer locale. Se non sono presenti impostazioni proxy in Internet Explorer, la richiesta viene inviata direttamente al server.  
  
 La <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione proxy con caratteri jolly ereditati da Internet Explorer in modo diverso rispetto all'elenco di esclusione analizzato direttamente da Internet Explorer. Ad esempio, la <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione di "nt *" di Internet Explorer come un'espressione regolare di "nt. $". Questo comportamento è diverso dal comportamento nativo di Internet Explorer. Pertanto, un URL di "`http://intxxxxx`" potrebbero ignorare il proxy utilizzando la <xref:System.Net.HttpWebRequest> classe, ma non ignora il proxy utilizzando Internet Explorer.  
  
> [!NOTE]
>  Il Framework memorizza nella cache le sessioni SSL quando vengono creati e tenta di riutilizzare una sessione memorizzati nella cache per una nuova richiesta, se possibile. Durante il tentativo di riutilizzare una sessione SSL, il Framework utilizza il primo elemento della <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se è presente uno), o tenta di riutilizzare una sessione anonima se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> è vuoto.  
  
> [!NOTE]
>  Per motivi di sicurezza, i cookie sono disattivati per impostazione predefinita. Se si desidera utilizzare i cookie, utilizzare il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà per abilitare i cookie.  
  
 .NET Framework 4.6 include una nuova funzionalità di sicurezza che blocca i pacchetti di crittografia non protetti e gli algoritmi per le connessioni di hash. Le applicazioni tramite TLS/SSL tramite le API, ad esempio HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, e così via e destinato a .NET Framework 4.6 ottenere il comportamento più sicure per impostazione predefinita.  
  
 Gli sviluppatori potrebbero voler rifiutare esplicitamente questo comportamento per mantenere la compatibilità con i servizi esistenti SSL3 o TLS con servizi RC4. [In questo articolo](https://support.microsoft.com/kb/3069494) viene illustrato come modificare il codice in modo che il nuovo comportamento è disabilitato.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un' <xref:System.Net.HttpWebRequest> per l'URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Per accedere all'URI richiesto o qualsiasi URI a cui viene reindirizzata la richiesta. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. These constructors are obsolete; see the Remarks section for details.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Entrambi <xref:System.Net.HttpWebRequest> costruttori sono obsoleti e non deve essere utilizzati. Chiamare il <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> metodo per inizializzare nuovi <xref:System.Net.HttpWebRequest> oggetti.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. This constructor is obsolete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes. This constructor is obsolete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione deve essere eseguita in modalità di attendibilità quando si usa la serializzazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Per l'accesso illimitato alle risorse di rete. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels a request to an Internet resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Abort%2A> metodo annulla una richiesta a una risorsa. Dopo una richiesta di annullamento, la chiamata di <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodo provoca un <xref:System.Net.WebException> con il <xref:System.Net.WebException.Status%2A> proprietà impostata su <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Il <xref:System.Net.HttpWebRequest.Abort%2A> metodo verrà eseguito in modo sincrono il callback specificato per il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodi se il <xref:System.Net.HttpWebRequest.Abort%2A> metodo viene chiamato durante una di queste operazioni sono in attesa. Questo può causare problemi di deadlock.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Nel caso di richieste asincrone, è responsabilità dell'applicazione client per implementare un proprio meccanismo di timeout. Esempio di codice seguente viene illustrato come eseguire questa operazione.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Accept" /> HTTP header.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Accept" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per cancellare il `Accept` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.Accept%2A> proprietà `null`.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.Accept%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a range header to the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che richiede al server di inviare i primi 100 byte (dall'inizio alla posizione di byte 99) potrebbe essere la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Range. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge un'intestazione di intervallo alla richiesta.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che richiede al server di inviare i primi 100 byte (dall'inizio alla posizione di byte 99) potrebbe essere la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Range. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che i primi 100 byte richieste sarebbe potrebbe essere la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `from` parametro verrebbe specificato come 0 e `to` parametro verrebbe specificato come 99. L'identificatore di intervallo viene impostato automaticamente come "byte" da questo metodo.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Range. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge un'intestazione di intervallo alla richiesta.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che i primi 100 byte richieste sarebbe potrebbe essere la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `from` parametro verrebbe specificato come 0 e `to` parametro verrebbe specificato come 99. L'identificatore di intervallo viene impostato automaticamente come "byte" da questo metodo.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Range. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo alla richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` verrebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto per gli identificatori di intervallo personalizzata diversi da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che i primi 100 byte richieste sarebbe potrebbe essere la seguente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro verrebbe specificato come "byte" e `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo alla richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server dovrebbe iniziare l'invio dei dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` verrebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto per gli identificatori di intervallo personalizzata diversi da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che i primi 100 byte richieste sarebbe potrebbe essere la seguente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro verrebbe specificato come "byte" e `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo alla richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` verrebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto per gli identificatori di intervallo personalizzata diversi da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che i primi 100 byte richieste sarebbe potrebbe essere la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro verrebbe specificato come "byte", il `from` parametro deve essere 0 e `to` parametro sarebbe 99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La stringa specificata nell'intestazione Accept-Ranges è l'identificatore di intervallo che verrebbe da specificato nella `rangeSpecifier` parametro per questo metodo.  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo alla richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessario supportare le operazioni di intervallo di byte.  
  
 L'intestazione di intervallo in una richiesta consente al client di richiedere che desidera ricevere solo alcune parti dell'intervallo specificato di byte in un'entità HTTP. Server non è necessario per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` verrebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto per gli identificatori di intervallo personalizzata diversi da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che i primi 100 byte richieste sarebbe potrebbe essere la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro verrebbe specificato come "byte", il `from` parametro deve essere 0 e `to` parametro sarebbe 99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Come indicato di seguito è riportato un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La stringa specificata nell'intestazione Accept-Ranges è l'identificatore di intervallo che verrebbe da specificato nella `rangeSpecifier` parametro per questo metodo.  
  
 Se un'intestazione Accept-Range non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. È un esempio di intestazione Accept-Ranges da un server che non supporta gli intervalli, ma riconosce l'intestazione Accept-Range, come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e rese disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Le intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) of the Internet resource that actually responds to the request.</summary>
        <value>Oggetto <see cref="T:System.Uri" /> che identifica la risorsa Internet che risponde effettivamente alla richiesta. L'impostazione predefinita è l'URI usato dal metodo <see cref="M:System.Net.WebRequest.Create(System.String)" /> per inizializzare la richiesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Address%2A> proprietà è impostata per l'URI di una volta completati tutti i reindirizzamenti che si verificano durante la richiesta.  
  
 L'URI della richiesta originale viene mantenuto nel <xref:System.Net.HttpWebRequest.RequestUri%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene verificato se il <xref:System.Net.HttpWebRequest> oggetto `req` è stato reindirizzato a un altro percorso per soddisfare la richiesta e imposta il valore della `hasChanged` variabile `true` se è stata reindirizzata la richiesta; incasocontrario`hasChanged`è impostato su `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the request should follow redirection responses.</summary>
        <value>
          <see langword="true" /> Se la richiesta deve seguire automaticamente le risposte di reindirizzamento dalla risorsa Internet; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> per `true` se si desidera che la richiesta deve seguire automaticamente le intestazioni di reindirizzamento HTTP per il nuovo percorso della risorsa. È impostato il numero massimo di reindirizzamenti da seguire la <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> proprietà.  
  
 Se <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> è impostato su `false`, tutte le risposte con codice di stato HTTP da 300 e 399 viene restituito all'applicazione.  
  
 L'intestazione di autorizzazione viene cancellata reindirizzamenti automatici e <xref:System.Net.HttpWebRequest> tenta automaticamente di nuovo l'autenticazione nel percorso reindirizzato. In pratica, ciò significa che un'applicazione non è possibile inserire le informazioni di autenticazione personalizzato nell'intestazione dell'autorizzazione se è possibile riscontrare il reindirizzamento. Al contrario, l'applicazione deve implementare e registrare un modulo di autenticazione personalizzato. Il <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> e la classe correlata vengono utilizzate per implementare un modulo di autenticazione personalizzato. Il <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> metodo registra un modulo di autenticazione personalizzato.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> proprietà per consentire la richiesta deve seguire le risposte di reindirizzamento.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the received from the Internet resource.</summary>
        <value>
          <see langword="true" /> per abilitare il buffering dei dati ricevuti dalla risorsa Internet; <see langword="false" /> per disabilitare il buffering. Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the data sent to the Internet resource.</summary>
        <value>
          <see langword="true" /> Per abilitare il buffering dei dati inviati alla risorsa Internet; <see langword="false" /> per disabilitare il buffering. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> è `true`, i dati viene memorizzato nel buffer in memoria, è quindi pronto per essere nuovamente inviati in caso di reindirizzamenti o l'autenticazione di richieste.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> proprietà per disabilitare il buffering dei dati.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L'impostazione <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a <see langword="true" /> potrebbe causare problemi di prestazioni durante il caricamento di grandi set di dati perché il buffer dei dati potrebbe utilizzare tutta la memoria disponibile.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression that is used.</summary>
        <value>Oggetto <see cref="T:System.Net.DecompressionMethods" /> oggetto che indica il tipo di decompressione Usato.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The object's current state does not allow this property to be set.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo avvia una richiesta asincrona di un flusso usato per inviare i dati il <xref:System.Net.HttpWebRequest>. Il metodo di callback asincrono utilizza il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> per restituire il flusso effettivo.  
  
 Il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo richiede alcune attività di impostazione sincrona a completare (risoluzione DNS, il rilevamento del proxy e la connessione socket TCP, ad esempio) prima di questo metodo diventa asincrono. Di conseguenza, questo metodo non dovrebbe mai essere chiamato su un thread dell'interfaccia utente perché potrebbe richiedere molto tempo (fino a diversi minuti a seconda delle impostazioni di rete) per completare le attività di configurazione sincrono iniziale prima di un'eccezione per viene generato un errore o il metodo ha esito positivo.  
  
 Per ulteriori informazioni sul pool di thread, vedere [il Pool di Thread gestiti](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (metodo), è necessario utilizzare il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo per effettuare una richiesta asincrona di un'istanza del flusso.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The stream is being used by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request to an Internet resource.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request for a response.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo avvia una richiesta asincrona di una risposta dalla risorsa Internet. Il metodo di callback asincrono utilizza il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> per restituire l'effettivo <xref:System.Net.WebResponse>.  
  
 Oggetto <xref:System.Net.ProtocolViolationException> viene generata in molti casi, quando le proprietà impostate la <xref:System.Net.HttpWebRequest> classe sono in conflitto. Questa eccezione si verifica se un'applicazione imposta la <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà e <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true`e quindi invia una richiesta HTTP GET. Questa eccezione si verifica se un'applicazione tenta di inviare dati in blocchi a un server che supporta solo il protocollo HTTP 1.0, in cui non è supportato. Questa eccezione si verifica se un'applicazione tenta di inviare i dati senza impostare il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà o <xref:System.Net.HttpWebRequest.SendChunked%2A> è `false` quando il buffer è disabilitato e in una connessione keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà `true`)`.`  
  
 Se un <xref:System.Net.WebException> viene generata, utilizzare il <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> le proprietà dell'eccezione per determinare la risposta dal server.  
  
 Il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo richiede alcune attività di impostazione sincrona a completare (risoluzione DNS, il rilevamento del proxy e la connessione socket TCP, ad esempio) prima di questo metodo diventa asincrono. Di conseguenza, questo metodo non dovrebbe mai essere chiamato su un thread dell'interfaccia utente perché potrebbe richiedere molto tempo (fino a diversi minuti a seconda delle impostazioni di rete) per completare le attività di configurazione sincrono iniziale prima di un'eccezione per viene generato un errore o il metodo ha esito positivo.  
  
 Per ulteriori informazioni sul pool di thread, vedere [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (metodo), è necessario utilizzare il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo per effettuare una richiesta asincrona di una risorsa Internet.  
  
> [!NOTE]
>  Nel caso di richieste asincrone, è responsabilità dell'applicazione client per implementare un proprio meccanismo di timeout. Esempio di codice seguente viene illustrato come eseguire l'operazione.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" /> and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the collection of security certificates that are associated with this request.</summary>
        <value>Classe <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenente i certificati di sicurezza associati a questa richiesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può aggiungere un certificato a una raccolta, ma non dispone di diritti ad accedervi. Per utilizzare un certificato contenuto nella raccolta, l'applicazione deve avere gli stessi diritti di accesso dell'entità che ha emesso il certificato.  
  
> [!NOTE]
>  Il Framework memorizza nella cache le sessioni SSL quando vengono creati e tenta di riutilizzare una sessione memorizzati nella cache per una nuova richiesta, se possibile. Durante il tentativo di riutilizzare una sessione SSL, il Framework utilizza il primo elemento della <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se è presente uno), o tenta di riutilizzare una sessione anonima se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> è vuoto.  
  
> [!NOTE]
>  Per motivi di prestazioni, non è possibile aggiungere un certificato client per un <xref:System.Net.HttpWebRequest> a meno che non si conosce il server è richiesto.  
>   
>  Per un esempio di codice che illustra come enumerare i certificati nell'archivio certificati client, vedere la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value specified for a set operation is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Connection" /> HTTP header.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Connection" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invia la richiesta di <xref:System.Net.HttpWebRequest.Connection%2A> proprietà della risorsa Internet come il `Connection` intestazione HTTP. Se il valore della <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà `true`, il valore "Keep-alive" viene aggiunto alla fine del `Connection` intestazione.  
  
 Per cancellare il `Connection` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.Connection%2A> proprietà `null`.  
  
 Modifica il <xref:System.Net.HttpWebRequest.Connection%2A> proprietà dopo la richiesta è stata avviata chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.Connection%2A> proprietà per impostare il valore dell'intestazione HTTP Connection.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of <see cref="P:System.Net.HttpWebRequest.Connection" /> is set to Keep-alive or Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the connection group for the request.</summary>
        <value>Nome del gruppo di connessione per la richiesta. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> proprietà consente di associare una richiesta a un gruppo di connessione. Ciò è utile quando l'applicazione effettua richieste a un server per utenti diversi, ad esempio un sito Web che recupera le informazioni cliente da un server di database.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare le informazioni utente in modo da formare un gruppo di connessione, presupponendo che le variabili `username`, `password`, e `domain` vengono impostate dall'applicazione prima di chiamare questo codice.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ogni gruppo di connessione consente di creare connessioni aggiuntive per un server. Questo può comportare il superamento del numero di connessioni impostate dal <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> proprietà per il server.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Content-length" /> HTTP header.</summary>
        <value>Numero di byte di dati da inviare alla risorsa Internet. Il valore predefinito è -1. Questo valore indica che la proprietà non è stata impostata e che non vi sono dati di richiesta da inviare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà contiene il valore da inviare come il `Content-length` intestazione HTTP con la richiesta.  
  
 Qualsiasi valore diverso da -1 nel <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà indica che la richiesta caricherà i dati e che solo i metodi di caricamento dati sono consentiti da impostare nella <xref:System.Net.HttpWebRequest.Method%2A> proprietà.  
  
 Dopo il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà è impostata su un valore, tale numero di byte deve essere scritto nel flusso di richiesta che viene restituito chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo o entrambi i <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodi.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà alla lunghezza della stringa da inviare.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The new <see cref="P:System.Net.HttpWebRequest.ContentLength" /> value is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Content-type" /> HTTP header.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Content-type" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà contiene il tipo di supporto della richiesta. I valori assegnati al <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà sostituiscono qualsiasi contenuto esistente quando si invia la richiesta di `Content-type` intestazione HTTP.  
  
 Per cancellare il `Content-type` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà `null`.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato <xref:System.Net.WebHeaderCollection> . Se <xref:System.Net.WebHeaderCollection> è impostata, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate method called when an HTTP 100-continue response is received from the Internet resource.</summary>
        <value>Delegato che implementa il metodo di callback eseguito quando dalla risorsa Internet viene restituita una risposta 100-Continue HTTP. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> proprietà specifica il metodo di callback da chiamare quando il client riceve un 100-risposta di continuare.  
  
 Quando il <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> è impostata, il client chiama il delegato del protocollo ogni volta che le risposte di tipo <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) vengono ricevuti. Ciò è utile se si desidera che il client per visualizzare lo stato dei dati ricevuti dalla risorsa Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a timeout, in milliseconds, to wait until the 100-Continue is received from the server.</summary>
        <value>Valore di timeout in millisecondi di attesa dopo la ricezione di 100-Continue dal server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le 100-continuare risposta viene ricevuta prima della scadenza del timeout, il corpo dell'entità può essere inviato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cookies associated with the request.</summary>
        <value>Oggetto <see cref="T:System.Net.CookieContainer" /> contenente i cookie associati a questa richiesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà fornisce un'istanza di <xref:System.Net.CookieContainer> classe che contiene i cookie associati alla richiesta.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> è `null` per impostazione predefinita. È necessario assegnare un <xref:System.Net.CookieContainer> oggetto alla proprietà per i cookie restituiti nel <xref:System.Net.HttpWebResponse.Cookies%2A> proprietà del <xref:System.Net.HttpWebResponse> restituito dal <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo.  
  
> [!NOTE]
>  Per motivi di sicurezza, i cookie sono disattivati per impostazione predefinita. Se si desidera utilizzare i cookie, utilizzare il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà per abilitare i cookie.  
  
   
  
## Examples  
 Esempio di codice seguente invia una richiesta a un URL e visualizza i cookie restituiti nella risposta.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information for the request.</summary>
        <value>Oggetto <see cref="T:System.Net.ICredentials" /> contenente le credenziali di autenticazione associate alla richiesta. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Credentials%2A> proprietà contiene informazioni di autenticazione per identificare l'autore della richiesta. Il <xref:System.Net.HttpWebRequest.Credentials%2A> proprietà può essere un <xref:System.Net.NetworkCredential>, nel qual caso l'utente, password e informazioni di dominio contenuti nel <xref:System.Net.NetworkCredential> oggetto viene usato per autenticare la richiesta oppure può essere un <xref:System.Net.CredentialCache>, nel qual caso l'Uniform Resource Identificatore (URI) della richiesta viene usato per determinare l'utente, password e informazioni di dominio da utilizzare per autenticare la richiesta.  
  
 Nella maggior parte degli scenari client, è necessario utilizzare il <xref:System.Net.CredentialCache.DefaultCredentials%2A> proprietà, che contiene le credenziali dell'utente attualmente connesso. A tale scopo, impostare il <xref:System.Net.WebClient.UseDefaultCredentials%2A> proprietà `true` anziché l'impostazione di questa proprietà.  
  
 Se il <xref:System.Net.HttpWebRequest> classe viene utilizzata in un'applicazione di livello intermedio, ad esempio un'applicazione ASP.NET, le credenziali di <xref:System.Net.CredentialCache.DefaultCredentials%2A> proprietà appartenere all'account di esecuzione della pagina ASP (credenziali sul lato server). In genere, impostare questa proprietà per le credenziali del client per il quale viene effettuata la richiesta.  
  
> [!NOTE]
>  Lo schema di autenticazione NTLM non può essere utilizzato per rappresentare un altro utente. Kerberos deve essere configurata appositamente per supportare la rappresentazione.  
  
 Per limitare HttpWebRequest a uno o più metodi di autenticazione, utilizzare la <xref:System.Net.CredentialCache> classe e associare le credenziali a uno o più schemi di autenticazione  
  
 Schemi di autenticazione supportati includono Digest, Negotiate, Kerberos, NTLM e Basic.  
  
 Per motivi di sicurezza quando segue automaticamente i reindirizzamenti, archiviare le credenziali che si desidera includere nel reindirizzamento in un <xref:System.Net.CredentialCache> e assegnarla a questa proprietà. Questa proprietà imposterà automaticamente su `null` al reindirizzamento se contiene un valore diverso da un <xref:System.Net.CredentialCache>. Con il valore della proprietà impostata automaticamente su `null` in tali condizioni impediscono credenziali inviati a qualsiasi destinazione impreviste.
  
## Examples  
 Esempio di codice seguente imposta le credenziali per una richiesta.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the <see langword="Date" /> HTTP header value to use in an HTTP request.</summary>
        <value>Il valore dell'intestazione relativa alla data nella richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'intestazione Data `null`, il valore restituito verrà impostato su <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Il <xref:System.Net.HttpWebRequest.Date%2A> proprietà è uno standard <xref:System.DateTime?displayProperty=nameWithType> dell'oggetto e può contenere un <xref:System.DateTimeKind?displayProperty=nameWithType> campo <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualsiasi tipo di ora possibile impostare quando si utilizza il <xref:System.Net.HttpWebRequest.Date%2A> proprietà. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> è impostata o recuperata, la <xref:System.Net.HttpWebRequest.Date%2A> proprietà si presuppone che sia <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (ora locale).  
  
 Le classi di <xref:System.Net> dello spazio dei nomi sempre scriverlo il <xref:System.Net.HttpWebRequest.Date%2A> proprietà in transito durante la trasmissione standard utilizzando il formato GMT (Utc).  
  
 Se il <xref:System.Net.HttpWebRequest.Date%2A> è impostata su <xref:System.DateTime.MinValue?displayProperty=nameWithType>, quindi il `Date` intestazione HTTP viene rimosso dal <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e <xref:System.Net.WebHeaderCollection>.  
  
 Se il <xref:System.Net.HttpWebRequest.Date%2A> proprietà <xref:System.DateTime.MinValue?displayProperty=nameWithType>, ciò indica che il `Date` intestazione HTTP non è incluso nel <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e il <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
 Se il <xref:System.Net.HttpWebRequest.Date%2A> è impostato e viene effettuato un tentativo di inviare un <xref:System.Net.HttpWebRequest> senza il corpo, quindi un <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> verrà generata dal <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, e <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cache policy for this request.</summary>
        <value>Oggetto <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> che specifica i criteri della cache attivi per questa richiesta quando non è possibile applicare altri criteri.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione di questa proprietà Registra i criteri specificati per gli schemi HTTP e HTTPS. Questo criterio viene utilizzato per la richiesta se:  
  
 Non esiste alcun <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> proprietà specificata per la richiesta.  
  
 \- oppure -  
  
 La configurazione di computer e di applicazione i file non si specificano un criterio di cache che è applicabile per l'identificatore URI (Uniform Resource) utilizzato per creare questa richiesta.  
  
 I criteri della cache determinano se la risorsa richiesta può essere ottenuta da una cache anziché inviare la richiesta al computer host risorse.  
  
 Una copia di una risorsa viene aggiunta solo alla cache se il flusso di risposta per la risorsa viene recuperato e leggere fino alla fine del flusso. Un'altra richiesta per la stessa risorsa potrebbe usare una copia memorizzata nella cache, a seconda del livello di criteri di cache per la richiesta.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Per l'accesso illimitato alle risorse di rete. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default maximum length of an HTTP error response.</summary>
        <value>Lunghezza massima predefinita di una risposta di errore HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default for the <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> property.</summary>
        <value>Lunghezza espressa in kilobyte (1024 byte) del valore massimo predefinito per le intestazioni di risposta ricevute. Nel file di configurazione predefinito questo valore viene impostato su 64 KB.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza dell'intestazione di risposta ricevuto la riga dello stato di risposta e caratteri di controllo aggiuntivi che vengono ricevuti come parte del protocollo HTTP. Il valore-1 indica che nessun limite imposto sulle intestazioni di risposta ricevute un valore pari a 0 indica che non soddisfano tutte le richieste.  
  
 Questo valore può essere modificato anche nel file di configurazione. L'impatto di questa proprietà può essere sottoposto a override impostando il <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> proprietà in un'istanza del <xref:System.Net.HttpWebRequest> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not equal to -1 and is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> una richiesta asincrona per un flusso che è stata avviata dal completamento del metodo di <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo. Dopo il <xref:System.IO.Stream> restituito oggetto, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> utilizzando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metodo.  
  
> [!NOTE]
>  È necessario impostare il valore di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà prima di scrivere dati nel flusso.  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso causa all'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodo per terminare una richiesta asincrona di un'istanza del flusso.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodo completa una richiesta asincrona per un flusso che è stato avviato dal <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (metodo) e output di <xref:System.Net.TransportContext> associato al flusso. Dopo il <xref:System.IO.Stream> restituito oggetto, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> utilizzando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metodo.  
  
 Potrebbe essere necessario essere in grado di eseguire una query sul livello di trasporto utilizzato da alcune applicazioni che utilizzano l'autenticazione integrata di Windows con protezione estesa <xref:System.Net.HttpWebRequest> per recuperare il token di associazione di canale (CBT) dal canale TLS sottostante. Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo fornisce l'accesso a queste informazioni per i metodi HTTP che hanno un corpo della richiesta (`POST` e `PUT` richieste). È necessario solo se l'applicazione sta implementando l'autenticazione e deve avere accesso a CBT.  
  
> [!NOTE]
>  Se è necessario impostare il valore di un'applicazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà, tale operazione deve essere eseguita prima del recupero del flusso e di scrittura dei dati.  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso causa all'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a response.</param>
        <summary>Ends an asynchronous request to an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodo completa una richiesta asincrona di una risorsa Internet che è stata avviata chiamando il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo.  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.Net.HttpWebResponse.Close%2A> metodo per chiudere il flusso e rilasciare la connessione. In caso contrario, potrebbe essere l'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodo per terminare una richiesta asincrona di una risorsa Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult." />  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> property is greater than 0 but the data has not been written to the request stream.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Expect" /> HTTP header.</summary>
        <value>Il contenuto dell'intestazione HTTP <see langword="Expect" />. Il valore predefinito è <see langword="null" />.  
  
 <block subset="none" type="note"><para> Il valore di questa proprietà è archiviato <see cref="T:System.Net.WebHeaderCollection" />. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> is set to a string that contains "100-continue" as a substring.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data required to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli oggetti inclusi nel <xref:System.Runtime.Serialization.SerializationInfo> vengono automaticamente rilevati e serializzati dal formattatore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> il metodo restituisce un flusso da utilizzare per inviare dati per il <xref:System.Net.HttpWebRequest>. Dopo il <xref:System.IO.Stream> restituito oggetto, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> utilizzando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metodo.  
  
 Se è necessario impostare il valore di un'applicazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà, tale operazione deve essere eseguita prima del recupero del flusso.  
  
 È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso causa all'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (metodo), è necessario utilizzare il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> per restituire un'istanza del flusso.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">The <see cref="T:System.Net.TransportContext" /> for the <see cref="T:System.IO.Stream" />.</param>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> il metodo restituisce un flusso da utilizzare per inviare dati per il <xref:System.Net.HttpWebRequest> e restituisce il <xref:System.Net.TransportContext> associato al flusso. Dopo il <xref:System.IO.Stream> restituito oggetto, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> utilizzando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metodo.  
  
 Potrebbe essere necessario essere in grado di eseguire una query sul livello di trasporto utilizzato da alcune applicazioni che utilizzano l'autenticazione integrata di Windows con protezione estesa <xref:System.Net.HttpWebRequest> per recuperare il token di associazione di canale (CBT) dal canale TLS sottostante. Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo fornisce l'accesso a queste informazioni per i metodi HTTP che hanno un corpo della richiesta (`POST` e `PUT` richieste). È necessario solo se l'applicazione sta implementando l'autenticazione e deve avere accesso a CBT.  
  
 Se è necessario impostare il valore di un'applicazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà, tale operazione deve essere eseguita prima del recupero del flusso.  
  
 È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso causa all'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (metodo), è necessario utilizzare il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method was unable to obtain the <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a response from an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo restituisce un <xref:System.Net.WebResponse> oggetto che contiene la risposta dalla risorsa Internet. L'istanza effettiva restituito è un <xref:System.Net.HttpWebResponse>e può essere eseguito un cast di tale classe di proprietà di accesso specifiche di HTTP.  
  
 Oggetto <xref:System.Net.ProtocolViolationException> viene generata in molti casi, quando le proprietà impostate la <xref:System.Net.HttpWebRequest> classe sono in conflitto. Questa eccezione si verifica se un'applicazione imposta la <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà e <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true`e quindi invia una richiesta HTTP GET. Questa eccezione si verifica se un'applicazione tenta di inviare dati in blocchi a un server che supporta solo il protocollo HTTP 1.0, in cui non è supportato. Questa eccezione si verifica se un'applicazione tenta di inviare i dati senza impostare il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà o <xref:System.Net.HttpWebRequest.SendChunked%2A> è `false` quando il buffer è disabilitato e in una connessione keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà `true`)`.`  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.Net.HttpWebResponse.Close%2A> metodo per chiudere il flusso e rilasciare la connessione. In caso contrario, potrebbe essere l'applicazione di esaurire le connessioni.  
  
 Quando si utilizza il metodo POST, è necessario ottenere il flusso di richiesta, scrivere i dati da registrare e chiudere il flusso. Questo metodo si blocca in attesa per il contenuto registrare; Se non è impostato alcun timeout e non si fornisce contenuto, il blocco del thread chiamante per un periodo illimitato.  
  
> [!NOTE]
>  Più chiamate al metodo <xref:System.Net.HttpWebRequest.GetResponse%2A> restituiscono lo stesso oggetto risposta; la richiesta non è stata rilasciata.  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (metodo), è necessario utilizzare il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Se un <xref:System.Net.WebException> viene generata, utilizzare il <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> le proprietà dell'eccezione per determinare la risposta dal server.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per ulteriori informazioni, vedere [traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Per motivi di sicurezza, i cookie sono disattivati per impostazione predefinita. Se si desidera utilizzare i cookie, utilizzare il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà per abilitare i cookie.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene la risposta per una richiesta.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater or equal to zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, this request includes data to be sent to the server. Requests that send data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a response has been received from an Internet resource.</summary>
        <value>
          <see langword="true" /> Se è stata ricevuta una risposta; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice viene controllato il <xref:System.Net.HttpWebRequest.HaveResponse%2A> proprietà per determinare se è stata ricevuta una risposta da una risorsa Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a collection of the name/value pairs that make up the HTTP headers.</summary>
        <value>Oggetto <see cref="T:System.Net.WebHeaderCollection" /> contenente le coppie nome/valore che compongono le intestazioni della richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Headers%2A> raccolta contiene intestazioni di protocollo associate alla richiesta. Nella tabella seguente sono elencate le intestazioni HTTP che non sono archiviate nel <xref:System.Net.HttpWebRequest.Headers%2A> insieme ma vengono impostate dal sistema o da proprietà o metodi.  
  
|Header|L'impostazione|  
|------------|------------|  
|Accettare|L'impostazione di <xref:System.Net.HttpWebRequest.Accept%2A> proprietà.|  
|Connessione|L'impostazione di <xref:System.Net.HttpWebRequest.Connection%2A> proprietà e <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà.|  
|Lunghezza del contenuto|L'impostazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà.|  
|Content-Type|L'impostazione di <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà.|  
|Previsto|L'impostazione di <xref:System.Net.HttpWebRequest.Expect%2A> proprietà.|  
|Data|L'impostazione di <xref:System.Net.HttpWebRequest.Date%2A> proprietà.|  
|Host|L'impostazione di <xref:System.Net.HttpWebRequest.Host%2A> proprietà.|  
|If-Modified-Since|L'impostazione di <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà.|  
|Intervallo|L'impostazione di <xref:System.Net.HttpWebRequest.AddRange%2A> metodo.|  
|Referer|L'impostazione di <xref:System.Net.HttpWebRequest.Referer%2A> proprietà.|  
|Codifica di trasferimento|L'impostazione di <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà (il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà deve essere true).|  
|Agente utente|L'impostazione di <xref:System.Net.HttpWebRequest.UserAgent%2A> proprietà.|  
  
 Il <xref:System.Net.WebHeaderCollection.Add%2A> metodo genera un <xref:System.ArgumentException> se si tenta di impostare una di queste intestazioni protette.  
  
 Modifica il <xref:System.Net.HttpWebRequest.Headers%2A> proprietà dopo la richiesta è stata avviata chiamando <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>.  
  
 Non si deve presupporre che i valori di intestazione rimane invariati, poiché le cache e i server Web possono modificare o aggiungere intestazioni a una richiesta Web.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.Headers%2A> proprietà per stampare le coppie nome/valore di intestazione HTTP alla console.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the Host header value to use in an HTTP request independent from the request URI.</summary>
        <value>Il valore dell'intestazione relativa all'host nella richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Host%2A> proprietà può essere utilizzata per impostare l'Host del valore dell'intestazione da utilizzare in una richiesta HTTP indipendente dall'URI della richiesta. Il <xref:System.Net.HttpWebRequest.Host%2A> può essere costituiti da proprietà di un nome host e un numero di porta facoltativo. Un'intestazione Host senza informazioni sulla porta implica la porta predefinita per il servizio richiesto (porta 80 per un URL HTTP, ad esempio).  
  
 Il formato per specificare un host e porta deve seguire le regole nella sezione 14.23 di RFC2616 pubblicate da IETF. Un esempio soddisfa tali requisiti che specifica una porta 8080 sarebbe il seguente valore per il <xref:System.Net.HttpWebRequest.Host%2A> proprietà:  
  
 `www.contoso.com:8080`  
  
 Utilizzo di <xref:System.Net.HttpWebRequest.Host%2A> proprietà per specificare in modo esplicito un valore dell'intestazione Host personalizzata influisce anche sulla memorizzazione nella cache, i cookie e l'autenticazione. Quando un'applicazione fornisce le credenziali per un prefisso URI specifico, le applicazioni devono assicurarsi di usare l'URI contenente il valore dell'intestazione Host, non il server di destinazione nell'URI. La chiave utilizzata per memorizzare nella cache le risorse, viene utilizzato il valore dell'intestazione Host, anziché l'URI della richiesta. I cookie vengono memorizzati un <xref:System.Net.CookieContainer> e sono raggruppati logicamente dal nome di dominio del server. Se l'applicazione specifica di un'intestazione Host, questo valore verrà utilizzato come dominio.  
  
 Se il <xref:System.Net.HttpWebRequest.Host%2A> proprietà non è impostata, il valore dell'intestazione Host da utilizzare in una richiesta HTTP è basato sull'URI della richiesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The Host header cannot be set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The Host header cannot be set to an invalid value.</exception>
        <exception cref="T:System.InvalidOperationException">The Host header cannot be set after the <see cref="T:System.Net.HttpWebRequest" /> has already started to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="If-Modified-Since" /> HTTP header.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> in cui è presente il contenuto dell'intestazione HTTP <see langword="If-Modified-Since" />. Il valore predefinito è la data e l'ora corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà è uno standard <xref:System.DateTime?displayProperty=nameWithType> dell'oggetto e può contenere un <xref:System.DateTimeKind?displayProperty=nameWithType> campo <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualsiasi tipo di ora possibile impostare quando si utilizza il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> è impostata o recuperata, la <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà si presuppone che sia <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (ora locale).  
  
 Le classi di <xref:System.Net> dello spazio dei nomi sempre scriverlo il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà in transito durante la trasmissione standard utilizzando il formato GMT (Utc).  
  
 Se il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> è impostata su <xref:System.DateTime.MinValue?displayProperty=nameWithType>, quindi il `If-Modified-Since` intestazione HTTP viene rimosso dal <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e <xref:System.Net.WebHeaderCollection>.  
  
 Se il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà <xref:System.DateTime.MinValue?displayProperty=nameWithType>, ciò indica che il `If-Modified-Since` intestazione HTTP non è incluso nel <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e il <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene controllato il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make a persistent connection to the Internet resource.</summary>
        <value>
          <see langword="true" /> Se la richiesta alla risorsa Internet deve contenere un <see langword="Connection" /> intestazione HTTP con il valore Keep-alive; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `true` per inviare un `Connection` intestazione HTTP con il valore Keep-alive. Un'applicazione utilizza <xref:System.Net.HttpWebRequest.KeepAlive%2A> per indicare una preferenza per le connessioni permanenti. Quando il <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà `true`, l'applicazione effettua connessioni permanenti ai server che li supportano.  
  
> [!NOTE]
>  Quando si utilizza HTTP/1.1, Keep-Alive è attivato per impostazione predefinita. Impostazione <xref:System.Net.HttpWebRequest.KeepAlive%2A> a `false` può comportare l'invio di un `Connection: Close` intestazione al server.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà `false` per evitare di stabilire una connessione permanente alla risorsa Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of redirects that the request follows.</summary>
        <value>Il numero massimo di risposte di reindirizzamento che la richiesta segue. Il valore predefinito è 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> proprietà imposta il numero massimo di reindirizzamenti che la richiesta deve seguire se i <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> proprietà `true`.  
  
   
  
## Examples  
 Esempio di codice seguente imposta il valore di questa proprietà.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is set to 0 or less.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowed length of the response headers.</summary>
        <value>Lunghezza espressa in kilobyte (1024 byte) delle intestazioni di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza dell'intestazione della risposta include la riga dello stato di risposta e caratteri di controllo aggiuntivi che vengono ricevuti come parte del protocollo HTTP. Il valore-1 indica che nessun limite imposto sulle intestazioni di risposta; un valore pari a 0 indica che non soddisfano tutte le richieste.  
  
 Se il <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> proprietà non è impostata in modo esplicito, assume il valore di <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> proprietà.  
  
 Se la lunghezza dell'intestazione di risposta ricevuto supera il valore della <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> proprietà, il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> metodi genererà un <xref:System.Net.WebException> con il <xref:System.Net.WebException.Status%2A> proprietà impostata su <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Esempio di codice seguente imposta il valore di questa proprietà.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after the request has already been submitted.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the media type of the request.</summary>
        <value>Il tipo di supporto della richiesta. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Net.HttpWebRequest.MediaType%2A> influisce sulle proprietà di <xref:System.Net.HttpWebResponse.CharacterSet%2A> proprietà. Quando si imposta la <xref:System.Net.HttpWebRequest.MediaType%2A> nella richiesta, viene scelto il tipo di supporto corrispondente dall'elenco di set di caratteri restituiti nella risposta `Content-type` intestazione HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the method for the request.</summary>
        <value>Il metodo di richiesta da usare per contattare la risorsa Internet. Il valore predefinito è GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Method%2A> proprietà può essere impostata su uno dei verbi di protocollo HTTP 1.1: GET, HEAD, POST, PUT, DELETE, TRACE oppure opzioni.  
  
 Se il <xref:System.Net.HttpWebRequest.ContentLength%2A> è impostata su qualsiasi valore diverso da -1, il <xref:System.Net.HttpWebRequest.Method%2A> proprietà deve essere impostata su una proprietà del protocollo che consente di caricare dati.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.Method%2A> proprietà POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No method is supplied.  -or-  The method string contains invalid characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</summary>
        <value>
          <see langword="true" /> Se la richiesta deve essere canalizzata; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione utilizza il <xref:System.Net.HttpWebRequest.Pipelined%2A> proprietà per indicare una preferenza per le connessioni pipeline. Quando <xref:System.Net.HttpWebRequest.Pipelined%2A> è `true`, un'applicazione stabilisce le connessioni pipeline ai server che li supportano.  
  
 Le connessioni pipeline vengono eseguite solo quando il <xref:System.Net.HttpWebRequest.KeepAlive%2A> anche la proprietà è `true`.  
  
   
  
## Examples  
 Esempio di codice seguente stampa il valore di <xref:System.Net.HttpWebRequest.Pipelined%2A> proprietà nella console.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send an Authorization header with the request.</summary>
        <value>
          <see langword="true" /> Per inviare un'intestazione autorizzazione HTTP con le richieste una volta eseguita l'autenticazione; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una richiesta client per uno specifico <xref:System.Uri> viene autenticato correttamente, se <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> è `true` e vengono fornite credenziali, l'intestazione di autorizzazione viene inviato con ogni richiesta a qualsiasi <xref:System.Uri> che corrisponde a specifici <xref:System.Uri>fino all'ultima barra. Pertanto, se la richiesta del client autenticato a una specifica <xref:System.Uri> che contiene quanto segue:  
  
 `http://www.contoso.com/firstpath/`  
  
 L'intestazione di autorizzazione per la preautenticazione verrà inviate con ogni richiesta a una delle seguenti <xref:System.Uri> istanze:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Tuttavia, l'intestazione di autorizzazione non viene inviato con le richieste a una delle seguenti <xref:System.Uri> istanze:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Se la richiesta del client a uno specifico <xref:System.Uri> è non è autenticata correttamente, la richiesta Usa le procedure di autenticazione standard.  
  
 Fatta eccezione per la prima richiesta, il <xref:System.Net.WebRequest.PreAuthenticate%2A> proprietà indica se inviare informazioni di autenticazione con le richieste successive a un <xref:System.Uri> corrispondente specifico <xref:System.Uri> fino all'ultima barra senza in attesa di essere richiesta dal server.  
  
 Finestra di dialogo tra client e server seguente viene illustrato l'effetto di questa proprietà. La finestra di dialogo si presuppone che l'autenticazione di base è in uso.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> è `false`:  
  
 Client: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Client: GET con le intestazioni di autorizzazione  
  
 Server: 200 OK  
  
 Client: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Client: GET con le intestazioni di autorizzazione  
  
 Server: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> è `true`:  
  
 Client: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Client: GET con le intestazioni di autorizzazione  
  
 Server: 200 OK  
  
 Client: Ottenere someUrl con le intestazioni di autorizzazione  
  
 Se lo schema di autenticazione non supporta la preautenticazione, il valore di questa proprietà viene ignorato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version of HTTP to use for the request.</summary>
        <value>La versione di HTTP da usare per la richiesta. Il valore predefinito è <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.HttpWebRequest> classe supporta solo le versioni 1.0 e 1.1 del protocollo HTTP. Impostazione <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> a una versione diversa genera un'eccezione.  
  
> [!NOTE]
>  Per impostare la versione HTTP della richiesta corrente, utilizzare il <xref:System.Net.HttpVersion.Version10> e <xref:System.Net.HttpVersion.Version11> campi del <xref:System.Net.HttpVersion> classe.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The HTTP version is set to a value other than 1.0 or 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets proxy information for the request.</summary>
        <value>Oggetto <see cref="T:System.Net.IWebProxy" /> da usare per il proxy della richiesta. Il valore predefinito viene impostato chiamando la proprietà <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà identifica il <xref:System.Net.WebProxy> oggetto da utilizzare per elaborare le richieste alle risorse Internet. Per specificare che deve essere utilizzato alcun proxy, impostare il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà per l'istanza del proxy restituito dal <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> metodo.  
  
 Il computer locale o un file config dell'applicazione può specificare che un proxy predefinito da utilizzare. Se il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà viene specificata, quindi le impostazioni del proxy dal <xref:System.Net.HttpWebRequest.Proxy%2A> override di proprietà, il computer locale o un file config dell'applicazione e <xref:System.Net.HttpWebRequest> istanza utilizzerà le impostazioni proxy specificate. Se viene specificato alcun proxy in un file di configurazione e <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà non è specificata, il <xref:System.Net.HttpWebRequest> classe utilizza le impostazioni del proxy ereditate da Internet Explorer nel computer locale. Se non sono presenti impostazioni proxy in Internet Explorer, la richiesta viene inviata direttamente al server.  
  
 La <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione proxy con caratteri jolly ereditati da Internet Explorer lo stesso come elenco di esclusione analizzato direttamente da Internet Explorer. Ad esempio, il <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione di "nt *" di Internet Explorer come un'espressione regolare di "nt.\*". Pertanto, un URL di "`http://nt.com`" potrebbero ignorare il proxy utilizzando la <xref:System.Net.HttpWebRequest> classe e l'utilizzo di Internet Explorer.  
  
 La <xref:System.Net.HttpWebRequest> classe supporta ignorare il proxy locale. La classe considera una destinazione è locale se viene soddisfatta una delle condizioni seguenti:  
  
-   La destinazione contiene un nome semplice (nessuna punti nell'URL).  
  
-   La destinazione contiene un indirizzo di loopback (<xref:System.Net.IPAddress.Loopback> o <xref:System.Net.IPAddress.IPv6Loopback>) o la destinazione contiene un <xref:System.Net.IPAddress> assegnato al computer locale.  
  
-   Il suffisso del dominio di destinazione corrisponde a suffisso di dominio del computer locale (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Modifica il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà dopo la richiesta è stata avviata chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>. Per informazioni sull'elemento proxy vedere [ \&lt; defaultProxy\&gt; Elemento (impostazioni di rete)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.Proxy%2A> metodo per ottenere le informazioni sul proxy per la richiesta.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> is set to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.WebPermission">Per ottenere o impostare il <see cref="P:System.Net.HttpWebRequest.Proxy" /> proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a time-out in milliseconds when writing to or reading from a stream.</summary>
        <value>Il numero di millisecondi prima che si verifichi il timeout di scrittura o di lettura. Il valore predefinito è 300.000 millisecondi (5 minuti).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> proprietà viene utilizzata durante la scrittura nel flusso restituito dal <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo o la lettura dal flusso restituito dal <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metodo.  
  
 In particolare, il <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> proprietà controlla il timeout per il <xref:System.IO.Stream.Read%2A> metodo, che viene utilizzato per leggere il flusso restituito dal <xref:System.Net.HttpWebResponse.GetResponseStream%2A> (metodo) e per il <xref:System.IO.Stream.Write%2A> metodo, che viene utilizzato per scrivere nel flusso restituito dal <xref:System.Net.HttpWebRequest.GetRequestStream%2A>metodo.  
  
 Per specificare la quantità di tempo di attesa di completamento della richiesta, utilizzare il <xref:System.Net.HttpWebRequest.Timeout%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come impostare la proprietà <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has already been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than or equal to zero and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Referer" /> HTTP header.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Referer" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> proprietà `true`, <xref:System.Net.HttpWebRequest.Referer%2A> proprietà viene impostata automaticamente quando la richiesta viene reindirizzata a un altro sito.  
  
 Per cancellare il `Referer` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.Referer%2A> proprietà `null`.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.Referer%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the original Uniform Resource Identifier (URI) of the request.</summary>
        <value>Oggetto <see cref="T:System.Uri" /> contenente l'URI della risorsa Internet passata al metodo <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri> oggetto passato a <xref:System.Net.HttpWebRequest> dalla chiamata a <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Dopo un reindirizzamento intestazione non modifica la <xref:System.Net.HttpWebRequest.RequestUri%2A> proprietà. Per ottenere l'URI effettivo che ha risposto alla richiesta, esaminare il <xref:System.Net.HttpWebRequest.Address%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene verificato se il <xref:System.Net.HttpWebRequest> oggetto `req` è stato reindirizzato a un altro percorso per soddisfare la richiesta e imposta il valore della `hasChanged` variabile `true` se la richiesta viene reindirizzato; in caso contrario, `hasChanged` è impostato su `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send data in segments to the Internet resource.</summary>
        <value>
          <see langword="true" /> Per inviare dati alla risorsa Internet in segmenti; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.SendChunked%2A> è `true`, la richiesta invia i dati alla risorsa Internet in segmenti. La risorsa Internet deve supportare la ricezione di dati in blocchi.  
  
 Modifica il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà dopo la richiesta è stata avviata chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true` in modo che i dati possono essere inviati in segmenti alla risorsa Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback function to validate the server certificate.</summary>
        <value>Una chiamata di callback per convalidare il certificato server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito è che non è impostata alcuna funzione di callback e <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> proprietà `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service point to use for the request.</summary>
        <value>Oggetto <see cref="T:System.Net.ServicePoint" /> che rappresenta la connessione di rete alla risorsa Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> proprietà può essere diversa da <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> se la richiesta viene reindirizzata.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request provides support for a <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> Se la richiesta fornisce supporto per un <see cref="T:System.Net.CookieContainer" />; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli oggetti inclusi nel <xref:System.Runtime.Serialization.SerializationInfo> vengono automaticamente rilevati e serializzati dal formattatore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value in milliseconds for the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> and <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> methods.</summary>
        <value>Tempo di attesa espresso in millisecondi prima che si verifichi il timeout della richiesta. Il valore predefinito è 100.000 millisecondi (100 secondi).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> è il numero di millisecondi che una richiesta sincrona successive effettuata con il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo attende una risposta e <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo attende per un flusso. Il <xref:System.Net.HttpWebRequest.Timeout%2A> riguarda l'intera richiesta e risposta, non singolarmente la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> e <xref:System.Net.HttpWebRequest.GetResponse%2A> chiamate al metodo. Se la risorsa non viene restituita il periodo di timeout, la richiesta genera un <xref:System.Net.WebException> con il <xref:System.Net.WebException.Status%2A> proprietà impostata su <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Il <xref:System.Net.HttpWebRequest.Timeout%2A> deve essere impostata prima di <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo viene chiamato. Modifica il <xref:System.Net.HttpWebRequest.Timeout%2A> dopo la chiamata di <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo non ha alcun effetto  
  
 Il <xref:System.Net.HttpWebRequest.Timeout%2A> proprietà ha effetto sulle richieste asincrone effettuate con il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo.  
  
> [!CAUTION]
>  Nel caso di richieste asincrone, l'applicazione client implementa un proprio meccanismo di timeout. Fare riferimento all'esempio di <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo.  
  
 Per specificare la quantità di tempo di attesa prima di un'operazione di lettura o scrittura Timeout operazione, utilizzare il <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> proprietà.  
  
 Una query di sistema DNS (Domain Name) può richiedere fino a 15 secondi o il timeout. Se la richiesta contiene un nome host che richiede la risoluzione e si imposta <xref:System.Net.FileWebRequest.Timeout%2A> su un valore inferiore a 15 secondi, potrebbe richiedere più di 15 secondi prima di un <xref:System.Net.WebException> viene generata per indicare un timeout della richiesta.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.Timeout%2A> proprietà del <xref:System.Net.HttpWebRequest> oggetto.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Transfer-encoding" /> HTTP header.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Transfer-encoding" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima di poter impostare il <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà, è innanzitutto necessario impostare il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true`. Cancellazione <xref:System.Net.HttpWebRequest.TransferEncoding%2A> impostandolo su `null` non ha alcun effetto sul valore di <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 I valori assegnati al <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà sostituiscono qualsiasi contenuto esistente.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set when <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to the value "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</summary>
        <value>
          <see langword="true" /> per tenere aperta la connessione autenticata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito per questa proprietà è `false`, che comporta la connessione corrente essere chiusa al termine di una richiesta. Ogni volta che genera una nuova richiesta, l'applicazione deve passare attraverso la sequenza di autenticazione.  
  
 Se questa proprietà è impostata su `true`, la connessione utilizzata per recuperare la risposta rimane aperta dopo l'autenticazione è stata eseguita. In questo caso, altre richieste che dispongono di questa proprietà è impostata su `true` possono utilizzare la connessione senza riautenticazione. In altre parole, se una connessione è stata autenticata per l'utente, l'utente B può usufruire della connessione. per soddisfare la richiesta dell'utente B in base alle credenziali dell'utente A.  
  
> [!CAUTION]
>  Poiché è possibile che un'applicazione può utilizzare la connessione senza autenticazione, è necessario assicurarsi che non vi sia alcuna vulnerabilità di amministrazione del sistema quando si imposta questa proprietà su `true`. Se l'applicazione invia le richieste per più utenti (rappresenta più account utente) e si basa sull'autenticazione per proteggere le risorse, non impostare questa proprietà su `true` a meno di utilizzare gruppi di connessione come descritto di seguito.  
  
 Si consiglia di prendere in considerazione l'abilitazione di questo meccanismo se i problemi di prestazioni e l'applicazione è in esecuzione in un server Web con autenticazione integrata di Windows.  
  
 Se si abilita questa impostazione consente di aprire il sistema a rischi di sicurezza. Se si imposta la <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> proprietà `true` assicurarsi di prendere le precauzioni seguenti:  
  
-   Utilizzare il <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> proprietà per gestire le connessioni per utenti diversi. Consente di evitare l'uso potenziale della connessione dalle applicazioni non autenticato. Ad esempio, l'utente deve avere un nome di gruppo di connessione univoco che è diverso dall'utente B. Ciò fornisce un livello di isolamento per ogni account utente.  
  
-   Eseguire l'applicazione in un ambiente protetto per evitare possibili utilizzi della connessione.  
  
 Se si ha il controllo il server back-end, in alternativa è possibile disattivare la persistenza dell'autenticazione. Ciò migliora le prestazioni a un livello inferiore, ma è più sicuro. Per ulteriori informazioni, cercare AuthPersistence in MSDN all'indirizzo [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Se entrambi <xref:System.Net.WebRequest.PreAuthenticate%2A> e <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> sono impostate su `true`, ogni richiesta viene inviata utilizzando una connessione da un pool unsafe, ma con un'intestazione di autorizzazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Autorizzazione senza restrizioni di Web è necessario impostare questa proprietà.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether default credentials are sent with requests.</summary>
        <value>
          <see langword="true" /> se vengono usate le credenziali predefinite; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `true` quando le richieste effettuate da questo <xref:System.Net.HttpWebRequest> oggetto deve, se richiesto dal server, essere autenticato utilizzando le credenziali dell'utente attualmente connesso. Per le applicazioni client, questo è il comportamento desiderato nella maggior parte degli scenari. Per le applicazioni di livello intermedio, ad esempio le applicazioni ASP.NET, anziché utilizzare questa proprietà, in genere è necessario impostare il <xref:System.Net.HttpWebRequest.Credentials%2A> proprietà per le credenziali del client per il quale viene effettuata la richiesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You attempted to set this property after the request was sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="User-agent" /> HTTP header.</summary>
        <value>Valore dell'intestazione HTTP <see langword="User-agent" />. Il valore predefinito è <see langword="null" />.  
  
 <block subset="none" type="note"><para> Il valore di questa proprietà è archiviato <see cref="T:System.Net.WebHeaderCollection" />. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Net.HttpWebRequest.UserAgent%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>