<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="515efa6088e6de06e83414dc2e4783331a04cad0" />
    <Meta Name="ms.sourcegitcommit" Value="996ba67625b61917bcf75bfefe6dcb016019c2d8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/02/2018" />
    <Meta Name="ms.locfileid" Value="50965565" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce un'implementazione specifica di HTTP della classe <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

>  [!IMPORTANT]
>  Non è consigliabile usare `HttpWebRequest` per i nuovi sviluppi. Usare invece il <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> classe.

 Il <xref:System.Net.HttpWebRequest> classe offre supporto per le proprietà e metodi definiti in <xref:System.Net.WebRequest> e per le proprietà e metodi che consentono all'utente di interagire direttamente con i server tramite HTTP.  
  
 Non usare il <xref:System.Net.HttpWebRequest.%23ctor%2A> costruttore. Usare la <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> metodo per inizializzare nuove <xref:System.Net.HttpWebRequest> oggetti. Se lo schema per l'identificatore URI (Uniform Resource) è `http://` oppure `https://`, <xref:System.Net.WebRequest.Create%2A> restituisce un <xref:System.Net.HttpWebRequest> oggetto.  
  
 Il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo effettua una richiesta sincrona per la risorsa specificata nel <xref:System.Net.HttpWebRequest.RequestUri%2A> proprietà e restituisce un <xref:System.Net.HttpWebResponse> che contiene l'oggetto risposta. I dati di risposta possono essere ricevuti tramite il flusso restituito da <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Se l'oggetto risposta o se il flusso di risposta è chiusa, i dati rimanenti andranno persi. I dati rimanenti verranno esaurirsi e il socket verrà nuovamente usato per le richieste successive quando si chiude il flusso o oggetto risposta se contengono le condizioni seguenti: è una richiesta tramite pipeline o keep-alive, solo una piccola quantità di dati deve essere ricevuto, o i dati rimanenti viene ricevuto in un breve intervallo di tempo. Se nessuna delle condizioni menzionate custodiscono o viene superato il tempo di svuotamento, il socket verrà chiusa. Per le connessioni di keep-alive o tramite pipeline, è consigliabile che l'applicazione legge i flussi fino alla fine del file. Ciò garantisce che il socket verrà nuovamente usato per le richieste successive risultante offre prestazioni migliori e meno risorse usate.  
  
 Quando si desidera inviare dati alla risorsa, il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo restituisce un <xref:System.IO.Stream> oggetto da utilizzare per inviare i dati. Il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodi forniscono l'accesso asincrono al flusso di dati di trasmissione.  
  
 Per l'autenticazione client con <xref:System.Net.HttpWebRequest>, il certificato client deve essere installato nell'archivio certificati personali dell'utente corrente.  
  
 Il <xref:System.Net.HttpWebRequest> classe genera un <xref:System.Net.WebException> quando si verificano errori durante l'accesso a una risorsa. Il <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> proprietà contiene un <xref:System.Net.WebExceptionStatus> valore che indica l'origine dell'errore. Quando <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> viene <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, il <xref:System.Net.WebException.Response%2A> proprietà contiene il <xref:System.Net.HttpWebResponse> ricevuti dalla risorsa.  
  
 <xref:System.Net.HttpWebRequest> espone i valori di intestazione HTTP comuni inviati alla risorsa Internet come proprietà impostate dai metodi o impostato dal sistema. Nella tabella seguente contiene un elenco completo. È possibile impostare altre intestazioni nel <xref:System.Net.HttpWebRequest.Headers%2A> proprietà come coppie nome/valore. Si noti che i server e le cache possono modificare o aggiungere le intestazioni durante la richiesta.  
  
 Nella tabella seguente sono elencate le intestazioni HTTP che vengono impostate le proprietà o metodi o il sistema.  
  
|Header|L'impostazione|  
|------------|------------|  
|Accettare|L'impostazione di <xref:System.Net.HttpWebRequest.Accept%2A> proprietà.|  
|Connessione|L'impostazione di <xref:System.Net.HttpWebRequest.Connection%2A> proprietà, <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà.|  
|Content-Length|L'impostazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà.|  
|Content-Type|L'impostazione di <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà.|  
|Previsto|L'impostazione di <xref:System.Net.HttpWebRequest.Expect%2A> proprietà.|  
|Data|Impostare il sistema alla data corrente.|  
|Host|Impostata dal sistema per informazioni sull'host corrente.|  
|If-Modified-Since|L'impostazione di <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà.|  
|Intervallo|L'impostazione di <xref:System.Net.HttpWebRequest.AddRange%2A> (metodo).|  
|Referer|L'impostazione di <xref:System.Net.HttpWebRequest.Referer%2A> proprietà.|  
|Codifica di trasferimento|L'impostazione di <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà (la <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà deve essere `true`).|  
|Agente utente|L'impostazione di <xref:System.Net.HttpWebRequest.UserAgent%2A> proprietà.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> viene registrato automaticamente. Non è necessario chiamare il <xref:System.Net.WebRequest.RegisterPrefix%2A> metodo per registrare <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> prima di utilizzare gli URI che iniziano con `http://` o `https://`.  
  
 Il computer locale o un file di configurazione dell'applicazione può specificare che un proxy predefinito da utilizzare. Se il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà viene specificata, quindi le impostazioni del proxy dal <xref:System.Net.HttpWebRequest.Proxy%2A> override di proprietà, il computer locale o un file di configurazione dell'applicazione e il <xref:System.Net.HttpWebRequest> istanza utilizzerà le impostazioni proxy specificate. Se viene specificato alcun proxy in un file di configurazione e il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà non è specificata, il <xref:System.Net.HttpWebRequest> classe vengono utilizzate le impostazioni di proxy ereditate da Internet Explorer nel computer locale. Se non sono previste impostazioni di proxy in Internet Explorer, la richiesta viene inviata direttamente al server.  
  
 Il <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione proxy con caratteri jolly ereditati da Internet Explorer in modo diverso rispetto all'elenco di esclusione viene analizzato direttamente da Internet Explorer. Ad esempio, il <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione del "nt *" da Internet Explorer come un'espressione regolare di "nt. $". Questo comportamento è diverso dal comportamento nativo di Internet Explorer. Pertanto, un URL di "`http://intxxxxx`", ignora il proxy usando il <xref:System.Net.HttpWebRequest> classe, ma non ignora il proxy utilizzando Internet Explorer.  
  
> [!NOTE]
>  Il Framework memorizza nella cache le sessioni SSL man mano che vengono creati e tenta di riutilizzare una sessione nella cache per una nuova richiesta, se possibile. Quando si tenta di riutilizzare una sessione SSL, il Framework utilizza il primo elemento della <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se è presente uno), o è stato eseguito un tentativo di riutilizzare una sessione anonima se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> è vuoto.  
  
> [!NOTE]
>  Per motivi di sicurezza, i cookie sono disabilitati per impostazione predefinita. Se si desidera utilizzare i cookie, usare il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà per abilitare i cookie.  
  
 .NET Framework 4.6 include una nuova funzionalità di sicurezza che blocca i pacchetti di crittografia non sicuri e gli algoritmi per le connessioni di hash. Le applicazioni tramite TLS/SSL tramite le API, ad esempio HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, e così via e destinate a .NET Framework 4.6 ottenere il comportamento più sicure per impostazione predefinita.  
  
 Gli sviluppatori potrebbero voler rifiutare questo comportamento per mantenere l'interoperabilità con i propri servizi SSL3 esistenti o TLS con servizi RC4. [Questo articolo](https://support.microsoft.com/kb/3069494) viene spiegato come modificare il codice in modo che il nuovo comportamento è disabilitato.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Net.HttpWebRequest> per l'URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Per accedere a qualsiasi URI che la richiesta viene reindirizzata a o l'URI richiesto. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
    <related type="Article" href="http://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Modifiche all'autenticazione NTLM per HTTPWebRequest nella versione 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.HttpWebRequest" />. Questi costruttori sono obsoleti. Per dettagli, vedere la sezione relativa alle osservazioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Entrambi <xref:System.Net.HttpWebRequest> costruttori sono obsoleti e non deve essere utilizzati. Chiamare il <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> metodo per inizializzare nuove <xref:System.Net.HttpWebRequest> oggetti.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.HttpWebRequest" />. Questo costruttore è obsoleto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni richieste per serializzare il nuovo oggetto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato al nuovo oggetto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.HttpWebRequest" /> dalle istanze specificate delle classi <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />. Questo costruttore è obsoleto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione deve essere eseguita in modalità di attendibilità quando si usa la serializzazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">per l'accesso illimitato alle risorse di rete. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializzazione SOAP e XML</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla una richiesta a una risorsa Internet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Abort%2A> metodo annulla una richiesta a una risorsa. Una richiesta viene annullata, la chiamata di <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodo provoca un <xref:System.Net.WebException> con il <xref:System.Net.WebException.Status%2A> proprietà impostata su <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Il <xref:System.Net.HttpWebRequest.Abort%2A> metodo eseguirà in modo sincrono il callback specificato per il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodi se il <xref:System.Net.HttpWebRequest.Abort%2A> metodo viene chiamato mentre una di queste operazioni sono in attesa. Questo può causare potenziali problemi di deadlock.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Nel caso di richieste asincrone, è responsabilità dell'applicazione client per implementare un proprio meccanismo di timeout. Esempio di codice seguente viene illustrato come eseguire questa operazione.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Accept" />.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Accept" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per cancellare il `Accept` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.Accept%2A> proprietà `null`.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.Accept%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un'intestazione di intervallo alla richiesta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Punto iniziale o finale dell'intervallo.</param>
        <summary>Aggiunge un'intestazione di intervallo di byte a una richiesta per un intervallo specifico, a partire dall'inizio o dalla fine dei dati richiesti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server deve iniziare a inviare i dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server deve iniziare a inviare i dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che richiede al server di inviare i primi 100 byte (dall'inizio alla posizione di byte 99) sarà la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In questo esempio il `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge un'intestazione di intervallo per la richiesta.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Punto iniziale o finale dell'intervallo.</param>
        <summary>Aggiunge un'intestazione di intervallo di byte a una richiesta per un intervallo specifico, a partire dall'inizio o dalla fine dei dati richiesti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server deve iniziare a inviare i dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server deve iniziare a inviare i dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che richiede al server di inviare i primi 100 byte (dall'inizio alla posizione di byte 99) sarà la seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In questo esempio il `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Posizione in cui avviare l'invio dei dati.</param>
        <param name="to">Posizione in cui arrestare l'invio dei dati.</param>
        <summary>Aggiunge un'intestazione di intervallo di byte alla richiesta per un intervallo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che potrebbero essere i primi 100 byte richieste sarà il seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `from` parametro viene specificato come 0 e il `to` parametro verrà specificato come 99. L'identificatore di intervallo viene impostato automaticamente come "byte" da questo metodo.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge un'intestazione di intervallo per la richiesta.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> è maggiore di <paramref name="to" />  
  
oppure 
 <paramref name="from" /> o <paramref name="to" /> è minore di 0.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Posizione in cui avviare l'invio dei dati.</param>
        <param name="to">Posizione in cui arrestare l'invio dei dati.</param>
        <summary>Aggiunge un'intestazione di intervallo di byte alla richiesta per un intervallo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo di byte alla richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che potrebbero essere i primi 100 byte richieste sarà il seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `from` parametro viene specificato come 0 e il `to` parametro verrà specificato come 99. L'identificatore di intervallo viene impostato automaticamente come "byte" da questo metodo.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> è maggiore di <paramref name="to" />  
  
oppure 
 <paramref name="from" /> o <paramref name="to" /> è minore di 0.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descrizione dell'intervallo.</param>
        <param name="range">Punto iniziale o finale dell'intervallo.</param>
        <summary>Aggiunge un'intestazione relativa all'intervallo a una richiesta per un intervallo specifico, a partire dall'inizio o dalla fine dei dati richiesti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo per la richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server deve iniziare a inviare i dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server deve iniziare a inviare i dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` sarebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto di identificatori di intervallo personalizzata diverso da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che potrebbero essere i primi 100 byte richieste sarà il seguente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro potrebbe essere specificato come "byte" e il `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descrizione dell'intervallo.</param>
        <param name="range">Punto iniziale o finale dell'intervallo.</param>
        <summary>Aggiunge un'intestazione relativa all'intervallo a una richiesta per un intervallo specifico, a partire dall'inizio o dalla fine dei dati richiesti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo per la richiesta.  
  
 Se `range` è positivo, il `range` parametro specifica il punto iniziale dell'intervallo. Il server deve iniziare a inviare i dati dal `range` parametro specificato alla fine dei dati dell'entità HTTP.  
  
 Se `range` è negativo, il `range` parametro specifica il punto finale dell'intervallo. Il server deve iniziare a inviare i dati dall'inizio dei dati dell'entità HTTP per il `range` parametro specificato.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` sarebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto di identificatori di intervallo personalizzata diverso da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che potrebbero essere i primi 100 byte richieste sarà il seguente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro potrebbe essere specificato come "byte" e il `range` parametro sarebbe -99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descrizione dell'intervallo.</param>
        <param name="from">Posizione in cui avviare l'invio dei dati.</param>
        <param name="to">Posizione in cui arrestare l'invio dei dati.</param>
        <summary>Aggiunge un'intestazione di intervallo di byte a una richiesta per un intervallo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo per la richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` sarebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto di identificatori di intervallo personalizzata diverso da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che potrebbero essere i primi 100 byte richieste sarà il seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro viene specificato come "byte", il `from` parametro deve essere 0 e il `to` parametro sarebbe 99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La stringa specificata nell'intestazione Accept-Ranges è l'identificatore di intervallo che verrà specificato nel `rangeSpecifier` parametro per questo metodo.  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> è maggiore di <paramref name="to" />  
  
oppure 
 <paramref name="from" /> o <paramref name="to" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Descrizione dell'intervallo.</param>
        <param name="from">Posizione in cui avviare l'invio dei dati.</param>
        <param name="to">Posizione in cui arrestare l'invio dei dati.</param>
        <summary>Aggiunge un'intestazione di intervallo di byte a una richiesta per un intervallo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> metodo aggiunge un'intestazione di intervallo per la richiesta.  
  
 Poiché tutte le entità HTTP sono rappresentate nei messaggi HTTP come sequenze di byte, il concetto di un intervallo di byte è significativo per qualsiasi entità HTTP. Tuttavia, non tutti i client e server necessari supportare le operazioni di intervalli di byte.  
  
 L'intestazione di intervallo in una richiesta consente a un client di richiedere che si desidera solo ricevere alcune parti dell'intervallo specificato di byte in un'entità HTTP. Non sono necessari server per supportare le richieste di intestazione di intervallo.  
  
 Il `rangeSpecifier` sarebbe in genere essere specificato come "byte", poiché questo è l'unico identificatore di intervallo riconosciuto dalla maggior parte dei server HTTP. L'impostazione di `rangeSpecifier` parametro a un'altra stringa consente il supporto di identificatori di intervallo personalizzata diverso da byte (l'identificatore di intervallo di byte definito in RFC 2616 da IETF).  
  
 Un esempio di un'intestazione di intervallo in una richiesta di protocollo HTTP che potrebbero essere i primi 100 byte richieste sarà il seguente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Per questo esempio, il `rangeSpecifier` parametro viene specificato come "byte", il `from` parametro deve essere 0 e il `to` parametro sarebbe 99.  
  
 Un server HTTP indica il supporto per le intestazioni di intervallo con l'intestazione Accept-Ranges nella risposta. Un esempio di intestazione Accept-Ranges da un server che supporta gli intervalli di byte sarebbe come indicato di seguito:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La stringa specificata nell'intestazione Accept-Ranges è l'identificatore di intervallo che verrà specificato nel `rangeSpecifier` parametro per questo metodo.  
  
 Se un'intestazione Accept-Ranges non viene ricevuta nell'intestazione della risposta dal server, il server non supporta le intestazioni di intervallo. Un esempio dell'intestazione Accept-Ranges da un server che non supportano gli intervalli, ma riconosce l'intestazione Accept-Ranges, sarebbe come indicato di seguito:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Quando si riceve la risposta da una richiesta di intervallo, solo le intestazioni HTTP associate alla richiesta intera vengono analizzate e resi disponibili tramite la proprietà di <xref:System.Net.HttpWebResponse> classe. Intestazioni associate a ogni intervallo vengono restituite nella risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> è maggiore di <paramref name="to" />  
  
oppure 
 <paramref name="from" /> o <paramref name="to" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stato possibile aggiungere l'intestazione di intervallo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'URI della risorsa Internet che risponde effettivamente alla richiesta.</summary>
        <value>Oggetto <see cref="T:System.Uri" /> che identifica la risorsa Internet che risponde effettivamente alla richiesta. L'impostazione predefinita è l'URI usato dal metodo <see cref="M:System.Net.WebRequest.Create(System.String)" /> per inizializzare la richiesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Address%2A> proprietà viene impostata per l'URI dopo i reindirizzamenti che si verificano durante la richiesta sono stati completati.  
  
 L'URI della richiesta originale viene mantenuta nel <xref:System.Net.HttpWebRequest.RequestUri%2A> proprietà.  
  
   
  
## Examples  
 Il codice seguente viene controllato per verificare se il <xref:System.Net.HttpWebRequest> oggetto `req` è stato reindirizzato a un altro percorso per soddisfare la richiesta e imposta il valore della `hasChanged` variabile `true` se è stata reindirizzata la richiesta; in caso contrario, `hasChanged`è impostato su `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la richiesta deve seguire le risposte di reindirizzamento.</summary>
        <value>
          <see langword="true" /> se la richiesta deve seguire automaticamente le risposte di reindirizzamento dalla risorsa Internet; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> a `true` se si desidera che la richiesta deve seguire automaticamente le intestazioni di reindirizzamento HTTP per il nuovo percorso della risorsa. Il numero massimo di reindirizzamenti da seguire è impostato il <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> proprietà.  
  
 Se <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> è impostata su `false`, tutte le risposte con codice di stato HTTP da 300 a 399 viene restituito all'applicazione.  
  
 L'intestazione dell'autorizzazione viene cancellato su reindirizzamenti automatici e <xref:System.Net.HttpWebRequest> tenta automaticamente di ripetere l'autenticazione nel percorso reindirizzato. In pratica, ciò significa che un'applicazione non è possibile inserire le informazioni di autenticazione personalizzata nell'intestazione dell'autorizzazione se è possibile riscontrare il reindirizzamento. Al contrario, l'applicazione deve implementare e registrare un modulo di autenticazione personalizzato. Il <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> e classe correlata vengono usate per implementare un modulo di autenticazione personalizzato. Il <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> metodo registra un modulo di autenticazione personalizzato.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> proprietà per consentire la richiesta deve seguire le risposte di reindirizzamento.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se memorizzare nel buffer i dati ricevuti dalla risorsa Internet.</summary>
        <value>
          <see langword="true" /> per abilitare il buffering dei dati ricevuti dalla risorsa Internet; <see langword="false" /> per disabilitare il buffering. Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se memorizzare nel buffer i dati inviati alla risorsa Internet.</summary>
        <value>
          <see langword="true" /> per abilitare il buffering dei dati inviati alla risorsa Internet; <see langword="false" /> per disabilitare il buffering. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> è `true`, i dati viene memorizzato nel buffer in memoria affinché sia pronto per essere inviato di nuovo in caso di operazioni di reindirizzamento o l'autenticazione delle richieste.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> proprietà per disabilitare il buffering dei dati.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L'impostazione <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a <see langword="true" /> potrebbe causare problemi di prestazioni durante il caricamento di grandi set di dati perché il buffer dei dati può usare tutta la memoria disponibile.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di decompressione usato.</summary>
        <value>Oggetto <see cref="T:System.Net.DecompressionMethods" /> oggetto che indica il tipo di decompressione Usato.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Lo stato corrente dell'oggetto non consente di impostare questa proprietà.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto di stato per la richiesta.</param>
        <summary>Avvia una richiesta asincrona per un oggetto <see cref="T:System.IO.Stream" /> da usare per la scrittura dei dati.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla richiesta asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo avvia una richiesta asincrona di un flusso usato per inviare i dati il <xref:System.Net.HttpWebRequest>. Il metodo di callback asincrono Usa la <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> per restituire il flusso effettivo.  
  
 Il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo richiede alcune attività di impostazione sincrona per il completamento (la risoluzione DNS, il rilevamento del proxy e connessione socket TCP, ad esempio) prima che questo metodo è asincrono. Di conseguenza, questo metodo non dovrebbe mai essere chiamato su un thread dell'interfaccia utente poiché potrebbe richiedere molto tempo (fino a diversi minuti a seconda delle impostazioni di rete) per completare le attività di impostazione sincrona iniziale prima di un'eccezione per viene generato un errore o il metodo ha esito positivo.  
  
 Per altre informazioni sui pool di thread, vedere [pool di thread gestiti](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo, è necessario usare il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo per effettuare una richiesta asincrona di un'istanza del flusso.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">La proprietà <see cref="P:System.Net.HttpWebRequest.Method" /> è GET o HEAD.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> è <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> è <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> è POST o PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è usato da una chiamata precedente a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> è impostato su un valore e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" />.  
  
oppure 
Thread in esaurimento sul pool di thread.</exception>
        <exception cref="T:System.NotSupportedException">Il validator della cache delle richieste ha indicato che la risposta per questa richiesta può essere fornita dalla cache, ma le richieste che scrivono dati non usano la cache. Questa eccezione può verificarsi se si usa un validator della cache personalizzato che è implementato in modo non corretto.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.</exception>
        <exception cref="T:System.ObjectDisposedException">In un'applicazione .NET Compact Framework un flusso di richiesta di lunghezza del contenuto pari a zero non è stato ottenuto ed è stato chiuso correttamente. Per altre informazioni sulla gestione di richieste di lunghezza del contenuto pari a zero, vedere [Programmazione di rete in .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto di stato per la richiesta.</param>
        <summary>Avvia una richiesta asincrona a una risorsa Internet.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla richiesta asincrona per una risposta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo avvia una richiesta asincrona di una risposta dalla risorsa Internet. Il metodo di callback asincrono Usa la <xref:System.Net.HttpWebRequest.EndGetResponse%2A> per restituire l'oggetto effettivo <xref:System.Net.WebResponse>.  
  
 Oggetto <xref:System.Net.ProtocolViolationException> generata in diversi casi quando le proprietà impostate per il <xref:System.Net.HttpWebRequest> classe sono in conflitto. Questa eccezione si verifica se un'applicazione imposta il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà e i <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true`e quindi invia una richiesta HTTP GET. Questa eccezione si verifica se un'applicazione prova a inviare dati in blocchi in un server che supporta solo il protocollo HTTP 1.0, in cui questo non è supportato. Questa eccezione si verifica se un'applicazione prova a inviare i dati senza impostare il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà o il <xref:System.Net.HttpWebRequest.SendChunked%2A> viene `false` quando il buffer è disabilitato e in una connessione di keepalive (il <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà è `true`)`.`  
  
 Se un <xref:System.Net.WebException> viene generata un'eccezione, usare il <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> le proprietà dell'eccezione per determinare la risposta dal server.  
  
 Il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo richiede alcune attività di impostazione sincrona per il completamento (la risoluzione DNS, il rilevamento del proxy e connessione socket TCP, ad esempio) prima che questo metodo è asincrono. Di conseguenza, questo metodo non dovrebbe mai essere chiamato su un thread dell'interfaccia utente poiché potrebbe richiedere molto tempo (fino a diversi minuti a seconda delle impostazioni di rete) per completare le attività di impostazione sincrona iniziale prima di un'eccezione per viene generato un errore o il metodo ha esito positivo.  
  
 Per altre informazioni sui pool di thread, vedere [pool di thread gestiti](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metodo, è necessario usare il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo per effettuare una richiesta asincrona per una risorsa Internet.  
  
> [!NOTE]
>  Nel caso di richieste asincrone, è responsabilità dell'applicazione client per implementare un proprio meccanismo di timeout. Esempio di codice seguente viene illustrato come eseguire questa operazione.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso è già usato da una chiamata precedente a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> è impostato su un valore e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" />.  
  
oppure 
Thread in esaurimento sul pool di thread.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> è GET o HEAD e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> maggiore di zero oppure <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="true" />.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> è <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> è <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> è POST o PUT.  
  
oppure 
L'oggetto <see cref="T:System.Net.HttpWebRequest" /> ha un corpo entità, ma il metodo <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> viene chiamato senza chiamare il metodo <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
oppure 
L'oggetto <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è maggiore di zero, ma l'applicazione non scrive tutti i dati promessi.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la raccolta dei certificati di sicurezza associati alla richiesta.</summary>
        <value>Classe <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenente i certificati di sicurezza associati a questa richiesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può aggiungere un certificato a una raccolta, ma non disponga di diritti ad accedervi. Per usare un certificato contenuto nella raccolta, l'applicazione deve avere gli stessi diritti di accesso dell'entità che ha emesso il certificato.  
  
> [!NOTE]
>  Il Framework memorizza nella cache le sessioni SSL man mano che vengono creati e tenta di riutilizzare una sessione nella cache per una nuova richiesta, se possibile. Quando si tenta di riutilizzare una sessione SSL, il Framework utilizza il primo elemento della <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se è presente uno), o è stato eseguito un tentativo di riutilizzare una sessione anonima se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> è vuoto.  
  
> [!NOTE]
>  Per motivi di prestazioni, è consigliabile non aggiungere un certificato client da un <xref:System.Net.HttpWebRequest> a meno che non si conosce il server è richiesto.  
>   
>  Per un esempio di codice che illustra come enumerare i certificati nell'archivio certificati client, vedere il <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore specificato per un'operazione set è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Connection" />.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Connection" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invia la richiesta di <xref:System.Net.HttpWebRequest.Connection%2A> proprietà nella risorse Internet come il `Connection` intestazione HTTP. Se il valore della <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà è `true`, il valore "Keep-alive" viene aggiunto alla fine del `Connection` intestazione.  
  
 Per cancellare il `Connection` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.Connection%2A> proprietà `null`.  
  
 Modifica il <xref:System.Net.HttpWebRequest.Connection%2A> proprietà dopo che la richiesta è stata avviata chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.Connection%2A> proprietà per impostare il valore dell'intestazione HTTP Connection.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <see cref="P:System.Net.HttpWebRequest.Connection" /> è impostato su Keep-alive o Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del gruppo di connessione per la richiesta.</summary>
        <value>Nome del gruppo di connessione per la richiesta. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> proprietà consente di associare una richiesta a un gruppo di connessione. Ciò è utile quando l'applicazione effettua richieste per un server per utenti diversi, ad esempio un sito Web che recupera le informazioni dei clienti da un server di database.  
  
   
  
## Examples  
 Esempio di codice seguente mostra come usare le informazioni utente in modo da formare un gruppo di connessione, supponendo che le variabili `username`, `password`, e `domain` vengono impostate dall'applicazione prima che questo codice viene chiamato.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ogni gruppo di connessione consente di creare connessioni aggiuntive per un server. Questo può comportare il superamento del numero di connessioni impostata dal <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> proprietà per il server.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Raggruppamento delle connessioni</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intestazione HTTP di <see langword="Content-length" />.</summary>
        <value>Numero di byte di dati da inviare alla risorsa Internet. Il valore predefinito è -1. Questo valore indica che la proprietà non è stata impostata e che non vi sono dati di richiesta da inviare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà contiene il valore da inviare come il `Content-length` intestazione HTTP con la richiesta.  
  
 Qualsiasi valore diverso da -1 nel <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà indica che la richiesta carica i dati e che sono consentiti solo i metodi di caricare i dati vengano impostati nel <xref:System.Net.HttpWebRequest.Method%2A> proprietà.  
  
 Dopo il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà è impostata su un valore, tale numero di byte deve essere scritto nel flusso di richiesta che viene restituito chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo o entrambi i <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodi.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà alla lunghezza della stringa da inviare.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La richiesta è stata avviata chiamando il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il nuovo valore <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è minore di 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Content-type" />.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Content-type" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà contiene il tipo di supporto della richiesta. I valori assegnati al <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà sostituire qualsiasi contenuto esistente quando si invia la richiesta di `Content-type` intestazione HTTP.  
  
 Per cancellare il `Content-type` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà `null`.  
  
> [!NOTE]
>  Il valore di questa proprietà viene archiviato <xref:System.Net.WebHeaderCollection> . Se <xref:System.Net.WebHeaderCollection> è impostato, il valore della proprietà viene perso.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il metodo delegato chiamato quando da una risorsa Internet viene ricevuta una risposta 100-Continue HTTP.</summary>
        <value>Delegato che implementa il metodo di callback eseguito quando dalla risorsa Internet viene restituita una risposta 100-Continue HTTP. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> proprietà specifica il metodo di callback da chiamare quando il client riceve un 100-continuare risposta.  
  
 Quando la <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> è impostata, il client chiama il delegato del protocollo ogni volta che le risposte di tipo <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) vengono ricevuti. Ciò è utile se si desidera che il client per visualizzare lo stato dei dati ricevuti dalla risorsa Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore di timeout in millisecondi di attesa dopo la ricezione di 100-Continue dal server.</summary>
        <value>Valore di timeout in millisecondi di attesa dopo la ricezione di 100-Continue dal server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le 100-continuare risposta viene ricevuta prima che il timeout scade, il corpo dell'entità può essere inviato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i cookie associati alla richiesta.</summary>
        <value>Oggetto <see cref="T:System.Net.CookieContainer" /> contenente i cookie associati a questa richiesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà fornisce un'istanza del <xref:System.Net.CookieContainer> classe che contiene i cookie associati alla richiesta.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> è `null` per impostazione predefinita. È necessario assegnare un <xref:System.Net.CookieContainer> oggetto per la proprietà affinché includa i cookie restituiti nel <xref:System.Net.HttpWebResponse.Cookies%2A> proprietà delle <xref:System.Net.HttpWebResponse> restituito dal <xref:System.Net.HttpWebRequest.GetResponse%2A> (metodo).  
  
> [!NOTE]
>  Per motivi di sicurezza, i cookie sono disabilitati per impostazione predefinita. Se si desidera utilizzare i cookie, usare il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà per abilitare i cookie.  
  
   
  
## Examples  
 Esempio di codice seguente invia una richiesta a un URL e visualizza i cookie restituiti nella risposta.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni sull'autenticazione per la richiesta.</summary>
        <value>Oggetto <see cref="T:System.Net.ICredentials" /> contenente le credenziali di autenticazione associate alla richiesta. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Credentials%2A> proprietà contiene le informazioni di autenticazione per identificare l'autore della richiesta. Il <xref:System.Net.HttpWebRequest.Credentials%2A> proprietà può essere un <xref:System.Net.NetworkCredential>nel quale caso l'utente, password e informazioni di dominio contenuti nel <xref:System.Net.NetworkCredential> oggetto viene usato per autenticare la richiesta oppure può essere un <xref:System.Net.CredentialCache>, nel qual caso l'Uniform Resource Identificatore (URI) della richiesta viene usato per determinare l'utente, password e le informazioni sul dominio da usare per autenticare la richiesta.  
  
 Nella maggior parte degli scenari di client, è consigliabile utilizzare il <xref:System.Net.CredentialCache.DefaultCredentials%2A> proprietà, che contiene le credenziali dell'utente attualmente connesso. A questo scopo, impostare il <xref:System.Net.WebClient.UseDefaultCredentials%2A> proprietà `true` invece di impostare questa proprietà.  
  
 Se il <xref:System.Net.HttpWebRequest> classe viene utilizzata in un'applicazione di livello intermedio, ad esempio un'applicazione ASP.NET, le credenziali nel <xref:System.Net.CredentialCache.DefaultCredentials%2A> proprietà appartenere all'account di esecuzione della pagina ASP (credenziali sul lato server). In genere, impostare questa proprietà per le credenziali del client per il quale viene effettuata la richiesta.  
  
> [!NOTE]
>  Lo schema di autenticazione NTLM non può essere utilizzato per rappresentare un altro utente. Kerberos deve essere configurato in modo specifico per supportare la rappresentazione.  
  
 Per limitare HttpWebRequest a uno o più metodi di autenticazione, usare il <xref:System.Net.CredentialCache> classe e associare le credenziali a uno o più schemi di autenticazione  
  
 Schemi di autenticazione supportati includono Digest, Negotiate, Kerberos, NTLM e Basic.  
  
 Per motivi di sicurezza quando automaticamente seguito reindirizzamenti, archiviare le credenziali che si desidera includere nel reindirizzamento in un <xref:System.Net.CredentialCache> e assegnarla a questa proprietà. Questa proprietà è imposterà automaticamente su `null` durante il reindirizzamento se contiene qualsiasi elemento tranne una <xref:System.Net.CredentialCache>. Questo valore di proprietà impostato automaticamente su `null` in tali condizioni impedisce le credenziali vengano inviate a qualunque destinazione impreviste.
  
## Examples  
 Esempio di codice seguente imposta le credenziali per una richiesta.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Date" /> da usare in una richiesta HTTP.</summary>
        <value>Il valore dell'intestazione relativa alla data nella richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'intestazione Data `null`, il valore restituito verrà impostato su <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Il <xref:System.Net.HttpWebRequest.Date%2A> proprietà è uno standard <xref:System.DateTime?displayProperty=nameWithType> dell'oggetto e può contenere un <xref:System.DateTimeKind?displayProperty=nameWithType> campo <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualsiasi tipo di tempo può essere impostata quando si usa il <xref:System.Net.HttpWebRequest.Date%2A> proprietà. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> è impostato o recuperato, il <xref:System.Net.HttpWebRequest.Date%2A> proprietà si presuppone che sia <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (ora locale).  
  
 Le classi dei <xref:System.Net> dello spazio dei nomi sempre lo scriverà il <xref:System.Net.HttpWebRequest.Date%2A> proprietà in transito durante la trasmissione in formato standard usando il formato GMT (Utc).  
  
 Se il <xref:System.Net.HttpWebRequest.Date%2A> è impostata su <xref:System.DateTime.MinValue?displayProperty=nameWithType>, il `Date` intestazione HTTP viene rimosso dal <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e il <xref:System.Net.WebHeaderCollection>.  
  
 Se il <xref:System.Net.HttpWebRequest.Date%2A> proprietà è <xref:System.DateTime.MinValue?displayProperty=nameWithType>, questo indica che il `Date` intestazione HTTP non è incluso nel <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e il <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
 Se il <xref:System.Net.HttpWebRequest.Date%2A> è impostata e viene effettuato un tentativo di inviare un <xref:System.Net.HttpWebRequest> senza corpo, un <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> verrà generata dal <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, e <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i criteri predefiniti della cache per la richiesta.</summary>
        <value>Oggetto <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> che specifica i criteri della cache attivi per questa richiesta quando non è possibile applicare altri criteri.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione di questa proprietà Registra i criteri specificati per gli schemi HTTP e HTTPS. Questo criterio viene usato per questa richiesta se:  
  
 È presente alcun <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> proprietà specificata per questa richiesta.  
  
 \- oppure -  
  
 La configurazione di computer e dell'applicazione i file non si specificano un criterio di cache è applicabile per l'identificatore URI (Uniform Resource) usato per creare questa richiesta.  
  
 I criteri di cache determinano se la risorsa richiesta può essere ottenuta da una cache anziché inviare la richiesta nel computer host di risorse.  
  
 Una copia di una risorsa viene aggiunto alla cache solo se il flusso di risposta per la risorsa viene recuperato e leggere fino alla fine del flusso. In modo da un'altra richiesta per la stessa risorsa potrebbe usare una copia memorizzata nella cache, a seconda del livello di criteri di cache per questa richiesta.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">per l'accesso illimitato alle risorse di rete. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la lunghezza massima predefinita di una risposta di errore HTTP.</summary>
        <value>Lunghezza massima predefinita di una risposta di errore HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore è minore di 0 e non è uguale a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore predefinito per la proprietà <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />.</summary>
        <value>Lunghezza espressa in kilobyte (1024 byte) del valore massimo predefinito per le intestazioni di risposta ricevute. Nel file di configurazione predefinito questo valore viene impostato su 64 KB.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza dell'intestazione di risposta ricevuto la riga dello stato di risposta e caratteri di controllo aggiuntivi che vengono ricevuti come parte del protocollo HTTP. Un valore-1 indica che nessun limite imposto sulle intestazioni di risposta ricevute; un valore pari a 0 indica che tutte le richieste hanno esito negativo.  
  
 Questo valore può essere modificato anche nel file di configurazione. L'impatto di questa proprietà può essere sottoposto a override impostando il <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> proprietà in un'istanza del <xref:System.Net.HttpWebRequest> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore non è uguale a -1 ed è inferiore a zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termina una richiesta asincrona per un oggetto <see cref="T:System.IO.Stream" /> da usare per la scrittura dei dati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Richiesta in sospeso per un flusso.</param>
        <summary>Termina una richiesta asincrona per un oggetto <see cref="T:System.IO.Stream" /> da usare per la scrittura dei dati.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> una richiesta asincrona di un flusso che è stata avviata dal completamento del metodo di <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (metodo). Dopo il <xref:System.IO.Stream> oggetto è stato restituito, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> usando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (metodo).  
  
> [!NOTE]
>  È necessario impostare il valore della <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà prima della scrittura dei dati nel flusso.  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso fa in modo che l'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodo per terminare una richiesta asincrona di un'istanza del flusso.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">La richiesta non è stata completata e non è disponibile alcun flusso.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito dall'istanza corrente di una chiamata a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questo metodo è stato chiamato in precedenza usando <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.  
  
oppure 
Si è verificato un errore durante l'elaborazione della richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Richiesta in sospeso per un flusso.</param>
        <param name="context">Oggetto <see cref="T:System.Net.TransportContext" /> per l'oggetto <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">Oggetto <see cref="T:System.Net.TransportContext" /> per l'oggetto <see cref="T:System.IO.Stream" />.</param>
        <summary>Termina una richiesta asincrona per un oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere dati e restituisce l'oggetto <see cref="T:System.Net.TransportContext" /> associato al flusso.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> una richiesta asincrona di un flusso che è stata avviata dal completamento del metodo il <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (metodo) e gli output di <xref:System.Net.TransportContext> associato al flusso. Dopo il <xref:System.IO.Stream> oggetto è stato restituito, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> usando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (metodo).  
  
 Potrebbe essere necessario essere in grado di eseguire una query sul livello di trasporto utilizzato da alcune applicazioni che utilizzano l'autenticazione integrata di Windows con protezione estesa <xref:System.Net.HttpWebRequest> per poter recuperare il token di associazione di canale (CBT) dal canale TLS sottostante. Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo offre l'accesso a queste informazioni per i metodi HTTP che hanno un corpo della richiesta (`POST` e `PUT` richieste). Questo è necessario solo se l'applicazione sta implementando la propria autenticazione e deve accedere al token CBT.  
  
> [!NOTE]
>  Se è necessario impostare il valore di un'applicazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà, tale operazione deve essere eseguita prima del recupero del flusso e la scrittura dei dati.  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso fa in modo che l'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito dall'istanza corrente di una chiamata a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questo metodo è stato chiamato in precedenza usando <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">La richiesta non è stata completata e non è disponibile alcun flusso.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.  
  
oppure 
Si è verificato un errore durante l'elaborazione della richiesta.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticazione di Windows integrata con Protezione estesa</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">La richiesta in sospeso per una risposta.</param>
        <summary>Termina una richiesta asincrona a una risorsa Internet.</summary>
        <returns>Oggetto <see cref="T:System.Net.WebResponse" /> contenente la risposta dalla risorsa Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodo viene completata una richiesta asincrona per una risorsa Internet che è stata avviata chiamando il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> (metodo).  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.Net.HttpWebResponse.Close%2A> metodo per chiudere il flusso e rilasciare la connessione. In caso contrario, potrebbe essere l'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodo per terminare una richiesta asincrona per una risorsa Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questo metodo è stato chiamato in precedenza usando <paramref name="asyncResult." />  
  
oppure 
La proprietà <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è maggiore di 0 ma i dati non sono stati scritti nel flusso delle richieste.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.  
  
oppure 
Si è verificato un errore durante l'elaborazione della richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito dall'istanza corrente di una chiamata a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Expect" />.</summary>
        <value>Il contenuto dell'intestazione HTTP <see langword="Expect" />. Il valore predefinito è <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Il valore di questa proprietà è archiviato in <see cref="T:System.Net.WebHeaderCollection" />. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> è impostato su una stringa che contiene "100-continue" come sottostringa.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> da popolare con i dati.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> che specifica la destinazione per la serializzazione.</param>
        <summary>Popola un oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con i dati richiesti per serializzare l'oggetto di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli oggetti inclusi nel <xref:System.Runtime.Serialization.SerializationInfo> vengono automaticamente rilevati e serializzato dal formattatore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo restituisce un flusso da usare per inviare i dati il <xref:System.Net.HttpWebRequest>. Dopo il <xref:System.IO.Stream> oggetto è stato restituito, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> usando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (metodo).  
  
 Se è necessario impostare il valore di un'applicazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà, tale operazione deve essere eseguita prima del recupero del flusso.  
  
 È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso fa in modo che l'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo, è necessario usare il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> per restituire un'istanza del flusso.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">La proprietà <see cref="P:System.Net.HttpWebRequest.Method" /> è GET o HEAD.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> è <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> è <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> è POST o PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> viene chiamato più volte.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> è impostato su un valore e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Il validator della cache delle richieste ha indicato che la risposta per questa richiesta può essere fornita dalla cache, ma le richieste che scrivono dati non usano la cache. Questa eccezione può verificarsi se si usa un validator della cache personalizzato che è implementato in modo non corretto.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.  
  
oppure 
Il periodo di timeout per la richiesta è scaduto.  
  
oppure 
Si è verificato un errore durante l'elaborazione della richiesta.</exception>
        <exception cref="T:System.ObjectDisposedException">In un'applicazione .NET Compact Framework un flusso di richiesta di lunghezza del contenuto pari a zero non è stato ottenuto ed è stato chiuso correttamente. Per altre informazioni sulla gestione di richieste di lunghezza del contenuto pari a zero, vedere [Programmazione di rete in .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">Oggetto <see cref="T:System.Net.TransportContext" /> per l'oggetto <see cref="T:System.IO.Stream" />.</param>
        <summary>Ottiene un oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta e restituisce l'oggetto <see cref="T:System.Net.TransportContext" /> associato al flusso.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> da usare per scrivere i dati della richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo restituisce un flusso da usare per inviare i dati il <xref:System.Net.HttpWebRequest> e restituisce il <xref:System.Net.TransportContext> associato al flusso. Dopo il <xref:System.IO.Stream> oggetto è stato restituito, è possibile inviare i dati con il <xref:System.Net.HttpWebRequest> usando il <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (metodo).  
  
 Potrebbe essere necessario essere in grado di eseguire una query sul livello di trasporto utilizzato da alcune applicazioni che utilizzano l'autenticazione integrata di Windows con protezione estesa <xref:System.Net.HttpWebRequest> per poter recuperare il token di associazione di canale (CBT) dal canale TLS sottostante. Il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo offre l'accesso a queste informazioni per i metodi HTTP che hanno un corpo della richiesta (`POST` e `PUT` richieste). Questo è necessario solo se l'applicazione sta implementando la propria autenticazione e deve accedere al token CBT.  
  
 Se è necessario impostare il valore di un'applicazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà, tale operazione deve essere eseguita prima del recupero del flusso.  
  
 È necessario chiamare il <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodo per chiudere il flusso e rilasciare la connessione per il riutilizzo. Errore di chiudere il flusso fa in modo che l'applicazione di esaurire le connessioni.  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo, è necessario usare il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> non è riuscito a ottenere l'oggetto <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> viene chiamato più volte.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> è impostato su un valore e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Il validator della cache delle richieste ha indicato che la risposta per questa richiesta può essere fornita dalla cache, ma le richieste che scrivono dati non usano la cache. Questa eccezione può verificarsi se si usa un validator della cache personalizzato che è implementato in modo non corretto.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">La proprietà <see cref="P:System.Net.HttpWebRequest.Method" /> è GET o HEAD.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> è <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> è <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> è POST o PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.  
  
oppure 
Il periodo di timeout per la richiesta è scaduto.  
  
oppure 
Si è verificato un errore durante l'elaborazione della richiesta.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticazione di Windows integrata con Protezione estesa</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una risposta da una risorsa Internet.</summary>
        <returns>Oggetto <see cref="T:System.Net.WebResponse" /> contenente la risposta dalla risorsa Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo restituisce un <xref:System.Net.WebResponse> oggetto che contiene la risposta dalla risorsa Internet. L'istanza effettiva restituito è un <xref:System.Net.HttpWebResponse>e può eseguire il cast alla classe per accedere alle proprietà specifiche di HTTP.  
  
 Oggetto <xref:System.Net.ProtocolViolationException> generata in diversi casi quando le proprietà impostate per il <xref:System.Net.HttpWebRequest> classe sono in conflitto. Questa eccezione si verifica se un'applicazione imposta il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà e i <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true`e quindi invia una richiesta HTTP GET. Questa eccezione si verifica se un'applicazione prova a inviare dati in blocchi in un server che supporta solo il protocollo HTTP 1.0, in cui questo non è supportato. Questa eccezione si verifica se un'applicazione prova a inviare i dati senza impostare il <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà o il <xref:System.Net.HttpWebRequest.SendChunked%2A> viene `false` quando il buffer è disabilitato e in una connessione di keepalive (il <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà è `true`)`.`  
  
> [!CAUTION]
>  È necessario chiamare il <xref:System.Net.HttpWebResponse.Close%2A> metodo per chiudere il flusso e rilasciare la connessione. In caso contrario, potrebbe essere l'applicazione di esaurire le connessioni.  
  
 Quando si usa il metodo POST, è necessario ottenere il flusso della richiesta, scrivere i dati da pubblicare e chiudere il flusso. Questo metodo si blocca in attesa per il contenuto da pubblicare; Se non è impostato alcun timeout e non si fornisce contenuto, il blocco del thread chiamante per un periodo illimitato.  
  
> [!NOTE]
>  Più chiamate al metodo <xref:System.Net.HttpWebRequest.GetResponse%2A> restituire lo stesso oggetto di risposta; la richiesta non viene riemesso.  
  
> [!NOTE]
>  L'applicazione non è possibile combinare metodi sincroni e asincroni per una particolare richiesta. Se si chiama il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo, è necessario usare il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo per recuperare la risposta.  
  
> [!NOTE]
>  Se un <xref:System.Net.WebException> viene generata un'eccezione, usare il <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> le proprietà dell'eccezione per determinare la risposta dal server.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Per motivi di sicurezza, i cookie sono disabilitati per impostazione predefinita. Se si desidera utilizzare i cookie, usare il <xref:System.Net.HttpWebRequest.CookieContainer%2A> proprietà per abilitare i cookie.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene la risposta per una richiesta.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso è già usato da una chiamata precedente a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> è impostato su un valore e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> è GET o HEAD e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è maggiore o uguale a zero oppure <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="true" />.  
  
oppure 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> è <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> è <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> è POST o PUT.  
  
oppure 
L'oggetto <see cref="T:System.Net.HttpWebRequest" /> ha un corpo entità, ma il metodo <see cref="M:System.Net.HttpWebRequest.GetResponse" /> viene chiamato senza chiamare il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
oppure 
L'oggetto <see cref="P:System.Net.HttpWebRequest.ContentLength" /> è maggiore di zero, ma l'applicazione non scrive tutti i dati promessi.</exception>
        <exception cref="T:System.NotSupportedException">Il validator della cache della richiesta ha indicato che la risposta per questa richiesta può essere soddisfatta dalla cache, tuttavia la richiesta include i dati da inviare al server. Le richieste che inviano i dati non devono usare la cache. Questa eccezione può verificarsi se si usa un validator della cache personalizzato che è implementato in modo non corretto.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> è stato chiamato in precedenza.  
  
oppure 
Il periodo di timeout per la richiesta è scaduto.  
  
oppure 
Si è verificato un errore durante l'elaborazione della richiesta.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se una risposta è stata ricevuta da una risorsa Internet.</summary>
        <value>
          <see langword="true" /> se è stata ricevuta una risposta; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice viene controllato il <xref:System.Net.HttpWebRequest.HaveResponse%2A> proprietà per determinare se è stata ricevuta una risposta da una risorsa Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica una raccolta delle coppie nome/valore che compongono le intestazioni HTTP.</summary>
        <value>Oggetto <see cref="T:System.Net.WebHeaderCollection" /> contenente le coppie nome/valore che compongono le intestazioni della richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Headers%2A> raccolta contiene le intestazioni di protocollo associate alla richiesta. Nella tabella seguente sono elencate le intestazioni HTTP che non sono archiviate nel <xref:System.Net.HttpWebRequest.Headers%2A> raccolta ma che vengono impostate dal sistema o da metodi o proprietà.  
  
|Header|L'impostazione|  
|------------|------------|  
|Accettare|L'impostazione di <xref:System.Net.HttpWebRequest.Accept%2A> proprietà.|  
|Connessione|L'impostazione di <xref:System.Net.HttpWebRequest.Connection%2A> proprietà e <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà.|  
|Content-Length|L'impostazione di <xref:System.Net.HttpWebRequest.ContentLength%2A> proprietà.|  
|Content-Type|L'impostazione di <xref:System.Net.HttpWebRequest.ContentType%2A> proprietà.|  
|Previsto|L'impostazione di <xref:System.Net.HttpWebRequest.Expect%2A> proprietà.|  
|Data|L'impostazione di <xref:System.Net.HttpWebRequest.Date%2A> proprietà.|  
|Host|L'impostazione di <xref:System.Net.HttpWebRequest.Host%2A> proprietà.|  
|If-Modified-Since|L'impostazione di <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà.|  
|Intervallo|L'impostazione di <xref:System.Net.HttpWebRequest.AddRange%2A> (metodo).|  
|Referer|L'impostazione di <xref:System.Net.HttpWebRequest.Referer%2A> proprietà.|  
|Codifica di trasferimento|L'impostazione di <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà (il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà deve essere true).|  
|Agente utente|L'impostazione di <xref:System.Net.HttpWebRequest.UserAgent%2A> proprietà.|  
  
 Il <xref:System.Net.WebHeaderCollection.Add%2A> metodo genera un <xref:System.ArgumentException> se si prova a impostare una di queste intestazioni protette.  
  
 Modifica il <xref:System.Net.HttpWebRequest.Headers%2A> proprietà dopo che la richiesta è stata avviata chiamando <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>.  
  
 Non si deve presupporre che i valori di intestazione rimarrà invariati, poiché le cache e i server Web possono modificare o aggiungere intestazioni a una richiesta Web.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.Headers%2A> proprietà per stampare le coppie nome/valore dell'intestazione HTTP nella console.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La richiesta è stata avviata chiamando il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione relativa all'host da usare in una richiesta HTTP indipendente dall'URI della richiesta.</summary>
        <value>Il valore dell'intestazione relativa all'host nella richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Host%2A> proprietà può essere utilizzata per impostare l'Host come valore dell'intestazione da usare in una richiesta HTTP indipendente dall'URI della richiesta. Il <xref:System.Net.HttpWebRequest.Host%2A> proprietà può essere costituito da un nome host e un numero di porta facoltativo. Un'intestazione Host senza informazioni sulla porta implica la porta predefinita per il servizio richiesto (porta 80 per un URL HTTP, ad esempio).  
  
 Il formato per specificare un host e porta deve seguire le regole nella sezione 14.23 RFC2616 pubblicata da IETF. Un esempio soddisfa tali requisiti che specifica una porta 8080 sarebbe il seguente valore per il <xref:System.Net.HttpWebRequest.Host%2A> proprietà:  
  
 `www.contoso.com:8080`  
  
 Uso di <xref:System.Net.HttpWebRequest.Host%2A> proprietà specificare in modo esplicito un valore dell'intestazione Host personalizzata influisce anche sulla memorizzazione nella cache, i cookie e l'autenticazione. Quando un'applicazione fornisce le credenziali per un determinato prefisso URI, le applicazioni deve assicurarsi di usare l'URI che contiene il valore dell'intestazione Host, non il server di destinazione nell'URI. La chiave utilizzata durante la memorizzazione nella cache le risorse, Usa il valore dell'intestazione Host anziché l'URI della richiesta. I cookie vengono memorizzati un <xref:System.Net.CookieContainer> e logicamente raggruppati per il nome di dominio del server. Se l'applicazione specifica un'intestazione Host, quindi questo valore verrà usato come dominio.  
  
 Se il <xref:System.Net.HttpWebRequest.Host%2A> proprietà non è impostata, il valore dell'intestazione Host da utilizzare in una richiesta HTTP si basa sull'URI della richiesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Impossibile impostare l'intestazione Host su <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Impossibile impostare l'intestazione Host su un valore non valido.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile impostare l'intestazione Host dopo che è già stato avviato l’invio di <see cref="T:System.Net.HttpWebRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="If-Modified-Since" />.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> in cui è presente il contenuto dell'intestazione HTTP <see langword="If-Modified-Since" />. Il valore predefinito è la data e l'ora corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà è uno standard <xref:System.DateTime?displayProperty=nameWithType> dell'oggetto e può contenere un <xref:System.DateTimeKind?displayProperty=nameWithType> campo <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualsiasi tipo di tempo può essere impostata quando si usa il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> è impostato o recuperato, il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà si presuppone che sia <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (ora locale).  
  
 Le classi dei <xref:System.Net> dello spazio dei nomi sempre lo scriverà il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà in transito durante la trasmissione in formato standard usando il formato GMT (Utc).  
  
 Se il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> è impostata su <xref:System.DateTime.MinValue?displayProperty=nameWithType>, il `If-Modified-Since` intestazione HTTP viene rimosso dal <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e il <xref:System.Net.WebHeaderCollection>.  
  
 Se il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà è <xref:System.DateTime.MinValue?displayProperty=nameWithType>, questo indica che il `If-Modified-Since` intestazione HTTP non è incluso nel <xref:System.Net.HttpWebRequest.Headers%2A> proprietà e il <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 Nell'esempio di codice viene controllato il <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se effettuare una connessione permanente alla risorsa Internet.</summary>
        <value>
          <see langword="true" /> se la richiesta alla risorsa Internet deve contenere un'intestazione HTTP <see langword="Connection" /> con il valore Keep-Alive; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `true` per inviare un `Connection` intestazione HTTP con il valore Keep-alive. Un'applicazione utilizza <xref:System.Net.HttpWebRequest.KeepAlive%2A> per indicare una preferenza per le connessioni persistenti. Quando la <xref:System.Net.HttpWebRequest.KeepAlive%2A> è di proprietà `true`, l'applicazione effettua le connessioni persistenti ai server che li supportano.  
  
> [!NOTE]
>  Quando si Usa HTTP/1.1, Keep-Alive è attivata per impostazione predefinita. L'impostazione <xref:System.Net.HttpWebRequest.KeepAlive%2A> al `false` può comportare l'invio di un `Connection: Close` intestazione al server.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.KeepAlive%2A> proprietà `false` per evitare di stabilire una connessione permanente alla risorsa Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero massimo di reindirizzamenti che la richiesta segue.</summary>
        <value>Il numero massimo di risposte di reindirizzamento che la richiesta segue. Il valore predefinito è 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> proprietà imposta il numero massimo di reindirizzamenti che la richiesta da seguire se la <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> è di proprietà `true`.  
  
   
  
## Examples  
 Esempio di codice seguente imposta il valore di questa proprietà.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore è impostato su 0 o un valore inferiore.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la lunghezza massima consentita delle intestazioni di risposta.</summary>
        <value>Lunghezza espressa in kilobyte (1024 byte) delle intestazioni di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza dell'intestazione della risposta include la riga dello stato di risposta e caratteri di controllo aggiuntivi che vengono ricevuti come parte del protocollo HTTP. Un valore-1 indica che nessun limite imposto sulle intestazioni di risposta; un valore pari a 0 indica che tutte le richieste hanno esito negativo.  
  
 Se il <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> proprietà non è impostata in modo esplicito, assume il valore della <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> proprietà.  
  
 Se la lunghezza dell'intestazione di risposta ricevuto supera il valore del <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> proprietà, il <xref:System.Net.HttpWebRequest.EndGetResponse%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> metodi genererà una <xref:System.Net.WebException> con il <xref:System.Net.WebException.Status%2A> impostata su <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Esempio di codice seguente imposta il valore di questa proprietà.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà viene impostata dopo l'invio della richiesta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore è minore di 0 e non è uguale a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di supporto della richiesta.</summary>
        <value>Il tipo di supporto della richiesta. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Net.HttpWebRequest.MediaType%2A> influisce sulle proprietà di <xref:System.Net.HttpWebResponse.CharacterSet%2A> proprietà. Quando si impostano i <xref:System.Net.HttpWebRequest.MediaType%2A> nella richiesta, viene scelto il tipo di supporto corrispondente nell'elenco di set di caratteri restituiti nella risposta `Content-type` intestazione HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il metodo per la richiesta.</summary>
        <value>Il metodo di richiesta da usare per contattare la risorsa Internet. Il valore predefinito è GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Method%2A> proprietà può essere impostata su uno dei verbi di protocollo HTTP 1.1: GET, HEAD, POST, PUT, DELETE, oppure le opzioni di traccia.  
  
 Se il <xref:System.Net.HttpWebRequest.ContentLength%2A> è impostata su qualsiasi valore diverso da -1, il <xref:System.Net.HttpWebRequest.Method%2A> proprietà deve essere impostata su una proprietà di protocollo che consente di caricare i dati.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.Method%2A> proprietà al POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non viene fornito alcun metodo.  
  
oppure 
Il nome della stringa contiene caratteri non validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se inviare la richiesta tramite pipeline alla risorsa Internet.</summary>
        <value>
          <see langword="true" /> se è previsto l'invio della richiesta tramite pipeline; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione utilizza il <xref:System.Net.HttpWebRequest.Pipelined%2A> proprietà per indicare una preferenza per le connessioni pipeline. Quando <xref:System.Net.HttpWebRequest.Pipelined%2A> è `true`, un'applicazione stabilisce le connessioni pipeline per i server che li supportano.  
  
 Le connessioni pipeline vengono effettuate solo quando la <xref:System.Net.HttpWebRequest.KeepAlive%2A> anche la proprietà è `true`.  
  
   
  
## Examples  
 Esempio di codice seguente viene stampato il valore della <xref:System.Net.HttpWebRequest.Pipelined%2A> proprietà nella console.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se inviare un'intestazione di autorizzazione con la richiesta.</summary>
        <value>
          <see langword="true" /> per inviare un'intestazione Autorizzazione HTTP con le richieste una volta eseguita l'autenticazione; in caso contrario <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una richiesta client per uno specifico <xref:System.Uri> viene autenticato correttamente, se <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> viene `true` e vengono fornite credenziali, l'intestazione dell'autorizzazione viene inviato con ogni richiesta a qualsiasi <xref:System.Uri> che corrisponde alla specifica <xref:System.Uri>fino alla barra ultimo. Pertanto, se la richiesta del client autenticato correttamente in uno specifico <xref:System.Uri> che contiene gli elementi seguenti:  
  
 `http://www.contoso.com/firstpath/`  
  
 L'intestazione dell'autorizzazione per la preautenticazione verrà inviati con ogni richiesta a uno dei seguenti <xref:System.Uri> istanze:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Tuttavia, l'intestazione dell'autorizzazione non viene inviato con le richieste a uno dei seguenti <xref:System.Uri> istanze:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Se la richiesta del client a uno specifico <xref:System.Uri> è non correttamente l'autenticazione, la richiesta Usa le procedure di autenticazione standard.  
  
 Fatta eccezione per la prima richiesta, il <xref:System.Net.WebRequest.PreAuthenticate%2A> proprietà indica se inviare informazioni di autenticazione con le richieste successive a un <xref:System.Uri> che corrisponde alla specifica <xref:System.Uri> fino alla barra ultimo senza in attesa di essere richiesta dal server.  
  
 Finestra di dialogo seguente tra client e server viene illustrato l'effetto di questa proprietà. La finestra di dialogo si presuppone che l'autenticazione di base è in uso.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> è `false`:  
  
 Client: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Client: Il ottenere con le intestazioni di autorizzazione  
  
 Server: 200 OK  
  
 Client: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Client: Il ottenere con le intestazioni di autorizzazione  
  
 Server: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> è `true`:  
  
 Client: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Client: Il ottenere con le intestazioni di autorizzazione  
  
 Server: 200 OK  
  
 Client: Il ottenere someUrl con le intestazioni di autorizzazione  
  
 Se lo schema di autenticazione non supporta l'autenticazione preliminare, il valore di questa proprietà viene ignorato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la versione di HTTP da usare per la richiesta.</summary>
        <value>La versione di HTTP da usare per la richiesta. Il valore predefinito è <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest> classe supporta solo le versioni 1.0 e 1.1 del protocollo HTTP. Impostazione <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> genera un'eccezione a una versione diversa.  
  
> [!NOTE]
>  Per impostare la versione HTTP della richiesta corrente, usare il <xref:System.Net.HttpVersion.Version10> e <xref:System.Net.HttpVersion.Version11> i campi del <xref:System.Net.HttpVersion> classe.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La versione HTTP è impostata su un valore diverso da 1.0 o 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni sul proxy per la richiesta.</summary>
        <value>Oggetto <see cref="T:System.Net.IWebProxy" /> da usare per il proxy della richiesta. Il valore predefinito viene impostato chiamando la proprietà <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.Proxy%2A> identificata dalla proprietà di <xref:System.Net.WebProxy> oggetto da utilizzare per elaborare le richieste alle risorse Internet. Per specificare che non deve essere utilizzato alcun proxy, impostare il <xref:System.Net.HttpWebRequest.Proxy%2A> all'istanza del proxy restituito dalla proprietà di <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> (metodo).  
  
 Il computer locale o un file di configurazione dell'applicazione può specificare che un proxy predefinito da utilizzare. Se il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà viene specificata, quindi le impostazioni del proxy dal <xref:System.Net.HttpWebRequest.Proxy%2A> override di proprietà, il computer locale o un file di configurazione dell'applicazione e il <xref:System.Net.HttpWebRequest> istanza utilizzerà le impostazioni proxy specificate. Se viene specificato alcun proxy in un file di configurazione e il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà non è specificata, il <xref:System.Net.HttpWebRequest> classe vengono utilizzate le impostazioni di proxy ereditate da Internet Explorer nel computer locale. Se non sono previste impostazioni di proxy in Internet Explorer, la richiesta viene inviata direttamente al server.  
  
 Il <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione proxy con caratteri jolly ereditate da Internet Explorer lo stesso esempio direttamente da Internet Explorer viene analizzato l'elenco di esclusione. Ad esempio, il <xref:System.Net.HttpWebRequest> classe analizza un elenco di esclusione del "nt *" da Internet Explorer come un'espressione regolare di "nt.\*". Quindi, un URL di "`http://nt.com`", ignora il proxy usando le <xref:System.Net.HttpWebRequest> classe e usa Internet Explorer.  
  
 Il <xref:System.Net.HttpWebRequest> classe supporta l'elenco di esclusione proxy locale. La classe prende in considerazione una destinazione siano locali se viene soddisfatta una delle condizioni seguenti:  
  
-   La destinazione contiene un nome semplice (nessuna punti nell'URL).  
  
-   La destinazione contiene un indirizzo di loopback (<xref:System.Net.IPAddress.Loopback> oppure <xref:System.Net.IPAddress.IPv6Loopback>) o la destinazione contiene un <xref:System.Net.IPAddress> assegnato al computer locale.  
  
-   Il suffisso del dominio di destinazione corrisponda al suffisso del dominio del computer locale (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Modifica il <xref:System.Net.HttpWebRequest.Proxy%2A> proprietà dopo che la richiesta è stata avviata chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>. Per informazioni sull'elemento proxy visualizzare [ \&lt; defaultProxy\&gt; (Impostazioni di rete)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpWebRequest.Proxy%2A> metodo per ottenere le informazioni sul proxy per la richiesta.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> è impostato su <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La richiesta è stata avviata chiamando <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione per l'operazione richiesta.</exception>
        <permission cref="T:System.Net.WebPermission">Per ottenere o impostare il <see cref="P:System.Net.HttpWebRequest.Proxy" /> proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (impostazioni di rete)</related>
        <related type="Article" href="http://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">configurazione di applicazioni Internet</related>
        <related type="Article" href="http://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Configurazione proxy</related>
        <related type="Article" href="http://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Rilevamento automatico proxy</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un timeout in millisecondi quando si scrive in o si legge da un flusso.</summary>
        <value>Il numero di millisecondi prima che si verifichi il timeout di scrittura o di lettura. Il valore predefinito è 300.000 millisecondi (5 minuti).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> proprietà viene usata durante la scrittura nel flusso restituito dal <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo o la lettura dal flusso restituito dal <xref:System.Net.HttpWebResponse.GetResponseStream%2A> (metodo).  
  
 In particolare, il <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> proprietà controlla il timeout per il <xref:System.IO.Stream.Read%2A> metodo, che viene usato per leggere il flusso restituito dal <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metodo e per il <xref:System.IO.Stream.Write%2A> metodo, che consente di scrivere nel flusso restituito dal <xref:System.Net.HttpWebRequest.GetRequestStream%2A>metodo.  
  
 Per specificare la quantità di tempo di attesa del completamento della richiesta, usare il <xref:System.Net.HttpWebRequest.Timeout%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come impostare la proprietà <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La richiesta è già stata inviata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione set è minore o uguale a zero e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Referer" />.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Referer" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> proprietà viene `true`, il <xref:System.Net.HttpWebRequest.Referer%2A> proprietà viene impostata automaticamente quando la richiesta viene reindirizzata a un altro sito.  
  
 Per cancellare il `Referer` intestazione HTTP, impostare il <xref:System.Net.HttpWebRequest.Referer%2A> proprietà `null`.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.Referer%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'URI originale della richiesta.</summary>
        <value>Oggetto <see cref="T:System.Uri" /> contenente l'URI della risorsa Internet passata al metodo <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri> oggetto passato al <xref:System.Net.HttpWebRequest> dalla chiamata al metodo <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 In seguito un reindirizzamento di intestazione non modifica il <xref:System.Net.HttpWebRequest.RequestUri%2A> proprietà. Per ottenere l'URI effettivo che ha risposto alla richiesta, esaminare il <xref:System.Net.HttpWebRequest.Address%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio di codice viene controllato per verificare se il <xref:System.Net.HttpWebRequest> oggetto `req` è stato reindirizzato a un altro percorso per soddisfare la richiesta e imposta il valore della `hasChanged` variabile `true` se la richiesta viene reindirizzato; in caso contrario, `hasChanged` è impostata su `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se inviare i dati in segmenti alla risorsa Internet.</summary>
        <value>
          <see langword="true" /> per inviare i dati alla risorsa Internet in segmenti; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.SendChunked%2A> è `true`, la richiesta invia i dati alla risorsa Internet in segmenti. La risorsa Internet deve supportare la ricezione dei dati in blocchi.  
  
 Modifica il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà dopo che la richiesta è stata avviata chiamando il <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodo genera un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true` in modo che possano essere inviati i dati in segmenti alla risorsa Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La richiesta è stata avviata chiamando il metodo <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> o <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una chiamata di callback per convalidare il certificato server.</summary>
        <value>Una chiamata di callback per convalidare il certificato server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito è che viene impostata alcuna funzione di callback e il <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> è di proprietà `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il punto di servizio da usare per la richiesta.</summary>
        <value>Oggetto <see cref="T:System.Net.ServicePoint" /> che rappresenta la connessione di rete alla risorsa Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> proprietà può essere diversa da <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> se la richiesta viene reindirizzata.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la richiesta fornisce supporto per un oggetto <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> se la richiesta fornisce il supporto per un oggetto <see cref="T:System.Net.CookieContainer" />; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> da popolare con i dati.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> che specifica la destinazione per la serializzazione.</param>
        <summary>Popola un oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con i dati necessari per serializzare l'oggetto di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli oggetti inclusi nel <xref:System.Runtime.Serialization.SerializationInfo> vengono automaticamente rilevati e serializzato dal formattatore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di timeout in millisecondi per i metodi <see cref="M:System.Net.HttpWebRequest.GetResponse" /> e <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>Tempo di attesa espresso in millisecondi prima che si verifichi il timeout della richiesta. Il valore predefinito è 100.000 millisecondi (100 secondi).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> è il numero di millisecondi che ha effettuata una richiesta sincrona successiva con il <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo attende una risposta e il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodo attende per un flusso. Il <xref:System.Net.HttpWebRequest.Timeout%2A> si applica l'intera richiesta e risposta, non singolarmente per il <xref:System.Net.HttpWebRequest.GetRequestStream%2A> e <xref:System.Net.HttpWebRequest.GetResponse%2A> chiamate al metodo. Se la risorsa non viene restituita entro il periodo di timeout, la richiesta genera un <xref:System.Net.WebException> con il <xref:System.Net.WebException.Status%2A> impostata su <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Il <xref:System.Net.HttpWebRequest.Timeout%2A> deve essere impostata prima di <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> viene chiamato il metodo. Modifica il <xref:System.Net.HttpWebRequest.Timeout%2A> dopo la chiamata di <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> metodo non ha alcun effetto  
  
 Il <xref:System.Net.HttpWebRequest.Timeout%2A> proprietà non ha alcun effetto sulle richieste asincrone effettuate con il <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (metodo).  
  
> [!CAUTION]
>  In caso di richieste asincrone, l'applicazione client implementa un proprio meccanismo di timeout. Fare riferimento all'esempio di <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> (metodo).  
  
 Per specificare la quantità di tempo di attesa prima di un'operazione di lettura o scrittura Timeout operazione, usare il <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> proprietà.  
  
 Una query di sistema DNS (Domain Name) può richiedere fino a 15 secondi per restituire o il timeout. Se la richiesta contiene un nome host che richiede la risoluzione e si imposta <xref:System.Net.FileWebRequest.Timeout%2A> su un valore inferiore a 15 secondi, potrebbe richiedere 15 secondi o più prima che un <xref:System.Net.WebException> generata per indicare un timeout della richiesta.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.Timeout%2A> proprietà del <xref:System.Net.HttpWebRequest> oggetto.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato è minore di zero e non è <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="Transfer-encoding" />.</summary>
        <value>Valore dell'intestazione HTTP <see langword="Transfer-encoding" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima di poter impostare il <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà, è innanzitutto necessario impostare la <xref:System.Net.HttpWebRequest.SendChunked%2A> proprietà `true`. La cancellazione <xref:System.Net.HttpWebRequest.TransferEncoding%2A> impostandolo su `null` non ha alcun effetto sul valore di <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 I valori assegnati al <xref:System.Net.HttpWebRequest.TransferEncoding%2A> proprietà sostituire qualsiasi contenuto esistente.  
  
> [!NOTE]
>  Il valore di questa proprietà è archiviato in <xref:System.Net.WebHeaderCollection>. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> viene impostata quando <see cref="P:System.Net.HttpWebRequest.SendChunked" /> è <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> viene impostata sul valore "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se consentire la condivisione di connessione con autenticazione NTLM ad alta velocità.</summary>
        <value>
          <see langword="true" /> per tenere aperta la connessione autenticata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito per questa proprietà è `false`, in modo che la connessione corrente essere chiuso dopo che è stata completata una richiesta. L'applicazione deve passare attraverso la sequenza di autenticazione ogni volta che viene inviata una nuova richiesta.  
  
 Se questa proprietà è impostata su `true`, la connessione utilizzata per recuperare la risposta rimane aperta dopo l'autenticazione è stata eseguita. In questo caso, altre richieste in cui questa proprietà è impostata su `true` senza ripetere l'autenticazione è possibile utilizzare la connessione. In altre parole, se una connessione è stata autenticata per l'utente, l'utente B può usufruire della connessione. richiesta dell'utente B viene acquisito in base alle credenziali dell'utente A.  
  
> [!CAUTION]
>  Poiché è possibile che un'applicazione usare la connessione senza autenticazione, è necessario assicurarsi che non vi sia alcuna vulnerabilità amministrativi nel sistema quando si imposta questa proprietà su `true`. Se l'applicazione invia le richieste per più utenti (rappresenta più account utente) e si basa sull'autenticazione per proteggere le risorse, non impostare questa proprietà su `true` a meno che non si usano i gruppi di connessione come descritto di seguito.  
  
 È possibile prendere in considerazione l'abilitazione di questo meccanismo se i problemi di prestazioni e l'applicazione è in esecuzione in un server Web con l'autenticazione integrata di Windows.  
  
 Abilitazione di questa impostazione consente di aprire il sistema a rischi di sicurezza. Se si impostano i <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> proprietà `true` assicurarsi di prendere le precauzioni seguenti:  
  
-   Usare il <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> proprietà per gestire le connessioni per diversi utenti. Questo evita l'utilizzo potenziale della connessione dalle applicazioni non autenticati. Ad esempio, l'utente deve avere un nome univoco della connessione che è diverso dall'utente B. Ciò fornisce un livello di isolamento per ogni account utente.  
  
-   Eseguire l'applicazione in un ambiente protetto per evitare possibili utilizzi della connessione.  
  
 Se si controlla il server back-end, in alternativa è possibile disattivare la persistenza dell'autenticazione. Miglioramento delle prestazioni a un livello inferiore, ma è più sicuro. Per altri dettagli, cercare in MSDN library all'indirizzo AuthPersistence [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Se entrambe <xref:System.Net.WebRequest.PreAuthenticate%2A> e <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> sono impostati su `true`, ogni richiesta viene inviato tramite una connessione dal pool di tipo unsafe, ma con un'intestazione di autorizzazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Autorizzazione senza restrizioni Web è necessario impostare questa proprietà.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che controlla se le credenziali predefinite sono inviate con le richieste.</summary>
        <value>
          <see langword="true" /> se vengono usate le credenziali predefinite; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `true` quando le richieste effettuate da questa <xref:System.Net.HttpWebRequest> oggetto deve, se richiesto dal server, essere autenticato utilizzando le credenziali dell'utente attualmente connesso. Per le applicazioni client, questo è il comportamento desiderato nella maggior parte degli scenari. Per le applicazioni di livello intermedio, ad esempio le applicazioni ASP.NET, invece di usare questa proprietà, in genere è necessario impostare il <xref:System.Net.HttpWebRequest.Credentials%2A> proprietà alle credenziali del client per il quale viene effettuata la richiesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si è provato a impostare questa proprietà dopo che la richiesta è stata inviata.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione HTTP <see langword="User-agent" />.</summary>
        <value>Valore dell'intestazione HTTP <see langword="User-agent" />. Il valore predefinito è <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Il valore di questa proprietà è archiviato in <see cref="T:System.Net.WebHeaderCollection" />. Se è impostato WebHeaderCollection, il valore della proprietà viene perso.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.HttpWebRequest.UserAgent%2A> proprietà.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>