<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e88ba57dbda4386b2b36295ceaee5985d31eb0c0" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52231473" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce un listener semplice del protocollo HTTP controllato a livello di codice. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uso di <xref:System.Net.HttpListener> (classe), è possibile creare un listener del protocollo HTTP semplice che risponde alle richieste HTTP. Il listener è attivo per la durata del <xref:System.Net.HttpListener> oggetto e viene eseguito all'interno dell'applicazione con le relative autorizzazioni.
   
 Per usare <xref:System.Net.HttpListener>, creare una nuova istanza della classe utilizzando il <xref:System.Net.HttpListener> costruttore e usare il <xref:System.Net.HttpListener.Prefixes%2A> proprietà per ottenere l'accesso alla raccolta che contiene le stringhe che specificano quali identificatore URI (Uniform Resource) prefissi il <xref:System.Net.HttpListener>deve elaborare.
  
 Una stringa di prefisso URI è costituita da uno schema (http o https), un host, una porta facoltativa e un percorso facoltativo. È un esempio di stringa di prefisso completa *http://www.contoso.com:8080/customerData/*. I prefissi devono terminare con una barra rovesciata ("/"). Il <xref:System.Net.HttpListener> oggetto con il prefisso che rispecchia meglio un URI di richiesto risponde alla richiesta. Più <xref:System.Net.HttpListener> gli oggetti non è possibile aggiungere lo stesso prefisso, un' <xref:System.ComponentModel.Win32Exception> eccezione generata se un <xref:System.Net.HttpListener> aggiunge un prefisso che è già in uso.
  
 Quando viene specificata una porta, l'elemento host può essere sostituito con "\*" per indicare che il <xref:System.Net.HttpListener> accetta le richieste inviate alla porta, se l'URI richiesto non corrisponde a qualsiasi altro prefisso. Ad esempio, per ricevere tutte le richieste inviate alla porta 8080 quando l'URI richiesto non è gestito da qualsiasi <xref:System.Net.HttpListener>, è il prefisso *http://\*: 8080 /*. Analogamente, per specificare che il <xref:System.Net.HttpListener> accetta tutte le richieste inviate a una porta, sostituire l'elemento host con il carattere "+". Ad esempio: *https://+:8080*. Il "\*" e "+" caratteri possono essere presenti nei prefissi che includono i percorsi.
  
 A partire da .NET Core 2.0 o .NET Framework 4.6 in Windows 10, sottodomini con carattere jolly sono supportati nei prefissi URI vengono gestiti da un <xref:System.Net.HttpListener> oggetto. Per specificare un sottodominio con caratteri jolly, usare il "\*" carattere come parte del nome host in un prefisso URI. Ad esempio, *http://\*.foo.com/*. Passare la variabile come argomento per il <xref:System.Net.HttpListenerPrefixCollection.Add%2A> (metodo). Questo procedimento funziona a partire da .NET Core 2.0 o .NET Framework 4.6 in Windows 10; nelle versioni precedenti, verrà generato un <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Le associazioni di primo livello con caratteri jolly (*http://\*: 8080 /* e *http://+:8080*) dovrebbe **non** utilizzabile. poiché possono introdurre vulnerabilità a livello di sicurezza nell'app. Questo concetto vale sia per i caratteri jolly sicuri che vulnerabili. Usare nomi host espliciti al posto di caratteri jolly. L'associazione con caratteri jolly del sottodominio (ad esempio, `*.mysub.com`) non costituisce un rischio per la sicurezza se viene controllato l'intero dominio padre (a differenza di `*.com`, che è vulnerabile). Vedere la [sezione 5.4 di RFC7230](https://tools.ietf.org/html/rfc7230#section-5.4) per altre informazioni.
  
 Per iniziare ad ascoltare le richieste provenienti dai client, aggiungere i prefissi URI per la raccolta e chiamare il <xref:System.Net.HttpListener.Start%2A> (metodo). <xref:System.Net.HttpListener> offre modelli sincroni e asincroni per l'elaborazione delle richieste client. Le richieste e le relative risposte associate sono accessibili tramite il <xref:System.Net.HttpListenerContext> oggetto restituito dal <xref:System.Net.HttpListener.GetContext%2A> metodo o le relative controparti asincrone e il <xref:System.Net.HttpListener.BeginGetContext%2A> e <xref:System.Net.HttpListener.EndGetContext%2A> metodi.
  
 Il modello sincrono è appropriato se l'applicazione dovrebbe bloccarsi durante l'attesa di una richiesta del client e, se si desidera elaborare solo una richiesta alla volta. Usa il modello sincrono, chiamare il <xref:System.Net.HttpListener.GetContext%2A> metodo, che è in attesa di un client di inviare una richiesta. Il metodo restituisce un <xref:System.Net.HttpListenerContext> all'utente dell'oggetto per l'elaborazione quando un si verifica.
  
 Nel modello di asincrone più complesso, l'applicazione non si blocca durante l'attesa per le richieste e ogni richiesta viene elaborata nel proprio thread di esecuzione. Usare il <xref:System.Net.HttpListener.BeginGetContext%2A> metodo per specificare un metodo definito dall'applicazione di essere chiamato per ogni richiesta in ingresso. All'interno di tale metodo, chiamare il <xref:System.Net.HttpListener.EndGetContext%2A> metodo per ottenere la richiesta, elaborarlo e rispondere.
  
 In entrambi i modelli, le richieste in ingresso sono accessibili tramite il <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> proprietà e sono rappresentati da <xref:System.Net.HttpListenerRequest> oggetti. Analogamente, le risposte sono accessibili tramite il <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> proprietà e sono rappresentati da <xref:System.Net.HttpListenerResponse> oggetti. Tali oggetti condividono alcune funzionalità con il <xref:System.Net.HttpWebRequest> e <xref:System.Net.HttpWebResponse> oggetti, ma gli oggetti di quest'ultimi non possono essere utilizzato in combinazione con <xref:System.Net.HttpListener> poiché implementano client, non da server, i comportamenti.
  
 Un <xref:System.Net.HttpListener> possono richiedere l'autenticazione client. È possibile specificare uno schema specifico da utilizzare per l'autenticazione oppure è possibile specificare un delegato che determina lo schema da usare. È necessario richiedere qualche forma di autenticazione per ottenere informazioni sull'identità del client. Per altre informazioni, vedere la <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, e <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> proprietà.
  
> [!NOTE]
> Se si crea un <xref:System.Net.HttpListener> usa https, è necessario selezionare un certificato del Server per il listener. In caso contrario, un <xref:System.Net.HttpWebRequest> sottoquery di questo <xref:System.Net.HttpListener> avrà esito negativo con una chiusura imprevista della connessione.
  
> [!NOTE]
> È possibile configurare i certificati del Server e altre opzioni di listener tramite Network Shell (netsh.exe). Visualizzare [Network Shell (Netsh)](/windows-server/networking/technologies/netsh/netsh) per altri dettagli. Il file eseguibile ha iniziato a spedizioni con Windows Server 2008 e Windows Vista.
  
> [!NOTE]
> Se si specificano più schemi di autenticazione per il <xref:System.Net.HttpListener>, il listener richiederà i client nell'ordine seguente: `Negotiate`, `NTLM`, `Digest`e quindi `Basic`.
  
   
  
## Examples
 Esempio di codice seguente viene illustrato come utilizzare un <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Modifiche all'autenticazione NTLM per HTTPWebRequest nella versione 3.5 SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima di usare l'istanza restituita da questo costruttore, è necessario richiamare relativo <xref:System.Net.HttpListener.Start%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Net.HttpListener> costruttore per creare un nuovo <xref:System.Net.HttpListener> oggetto. Per un esempio completo, vedere il <xref:System.Net.HttpListener> argomento relativo alla classe.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La classe non può essere utilizzata nel sistema operativo corrente. Per utilizzare le istanze di questa classe è necessario Windows Server 2003 o Windows XP SP2.</exception>
        <block subset="none" type="usage">
          <para>Nota: Questo membro genera informazioni di traccia quando si abilita la traccia di rete nell'applicazione. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta immediatamente l'oggetto <see cref="T:System.Net.HttpListener" /> annullando tutte le richieste correntemente accodate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo elimina tutte le risorse utilizzate da questo listener. Le richieste in sospeso non riesce a completare.  
  
 Dopo aver chiamato questo metodo, si riceverà un <xref:System.ObjectDisposedException> se si prova a usare questo <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare questo metodo.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo schema usato per autenticare i client.</summary>
        <value>Combinazione bit per bit dei valori dell'enumerazione <see cref="T:System.Net.AuthenticationSchemes" /> che indica come autenticare i client. Il valore predefinito è <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpListener> Usa lo schema specificato per l'autenticazione di tutte le richieste in ingresso. Il <xref:System.Net.HttpListener.GetContext%2A> e <xref:System.Net.HttpListener.EndGetContext%2A> metodi restituiscono una richiesta client in ingresso solo se il <xref:System.Net.HttpListener> autentica la richiesta.  
  
 È possibile interrogare l'identità di un client autenticato correttamente usando il <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> proprietà.  
  
 Se si desidera che un <xref:System.Net.HttpListener> oggetto da utilizzare meccanismi di autenticazione diverso in base alle caratteristiche delle richieste riceve (ad esempio, della richiesta <xref:System.Net.HttpListenerRequest.Url%2A> o <xref:System.Net.HttpListenerRequest.UserHostName%2A> proprietà), è necessario implementare un metodo che sceglie il schema di autenticazione. Per istruzioni su come eseguire questa operazione, vedere il <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> documentazione relativa alla proprietà.  
  
> [!NOTE]
>  Per impostare questa proprietà per abilitare Digest, NTLM o Negotiate richiede la <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di <xref:System.Net.HttpListener.AuthenticationSchemes%2A> proprietà per specificare uno schema di autenticazione.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il delegato chiamato per determinare il protocollo usato per autenticare i client.</summary>
        <value>Delegato <see cref="T:System.Net.AuthenticationSchemeSelector" /> che richiama il metodo usato per selezionare un protocollo di autenticazione. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se si desidera che lo stesso protocollo di autenticazione da utilizzare per tutte le richieste gestite da un'istanza specifica di <xref:System.Net.HttpListener>, non è necessario impostare questa proprietà. Per specificare un protocollo da usare per tutte le richieste client, usare il <xref:System.Net.HttpListener.AuthenticationSchemes%2A> proprietà.  
  
 Se il client non ha specificato le informazioni di autenticazione nelle relative intestazioni, le <xref:System.Net.HttpListener> chiama il delegato specificato per ogni richiesta in ingresso non autenticato determinare il protocollo, se presente, da usare per autenticare il client. Il <xref:System.Net.HttpListener.GetContext%2A> e <xref:System.Net.HttpListener.EndGetContext%2A> metodi restituiscono una richiesta in ingresso solo se il <xref:System.Net.HttpListener> autenticato correttamente la richiesta. Se non viene autenticata una richiesta, il <xref:System.Net.HttpListener> invia una risposta 401. È possibile ottenere l'identità di un client autenticato correttamente usando il <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> proprietà.  
  
 La possibilità di delegare la scelta del protocollo di autenticazione a un metodo specifico dell'applicazione è utile se si desidera che un'istanza di <xref:System.Net.HttpListener> usi i protocolli di autenticazione diversi a seconda delle caratteristiche delle richieste riceve (per esempio, la richiesta <xref:System.Net.HttpListenerRequest.Url%2A> o <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> proprietà).  
  
> [!NOTE]
>  Per impostare questa proprietà per abilitare Digest, NTLM o Negotiate richiede la <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Esempio di codice seguente imposta il valore di questa proprietà.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 Esempio di codice seguente fornisce un'implementazione di un metodo richiamato da un <xref:System.Net.AuthenticationSchemeSelector> delegare.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare quando è disponibile una richiesta del client.</param>
        <param name="state">Oggetto definito dall'utente che contiene informazioni sull'operazione. Questo oggetto viene passato al delegato <paramref name="callback" /> al completamento dell'operazione.</param>
        <summary>Inizia il recupero di una richiesta in ingresso in modo asincrono.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpListener.BeginGetContext%2A> metodo avvia una chiamata asincrona (non di blocco) per ricevere le richieste client in ingresso. Prima di chiamare questo metodo, è necessario chiamare il <xref:System.Net.HttpListener.Start%2A> (metodo) e aggiungere almeno un prefisso di Uniform Resource Identifier (URI) per l'ascolto aggiungendo le stringhe di URI per il <xref:System.Net.HttpListenerPrefixCollection> restituiti dai <xref:System.Net.HttpListener.Prefixes%2A> proprietà.  
  
 Deve essere completata l'operazione asincrona chiamando il <xref:System.Net.HttpListener.EndGetContext%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per ottenere una richiesta in ingresso e blocco fino al completamento dell'operazione, chiamare il <xref:System.Net.HttpListener.GetContext%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di <xref:System.Net.HttpListener.BeginGetContext%2A> metodo per specificare un metodo di callback che gestirà le richieste client in ingresso.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 L'esempio di codice seguente implementa un metodo di callback.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Errore di una chiamata di funzione Win32. Verificare la proprietà <see cref="P:System.Net.HttpListenerException.ErrorCode" /> dell'eccezione per determinare la causa dell'eccezione.</exception>
        <exception cref="T:System.InvalidOperationException">Questo oggetto non è stato avviato o è attualmente interrotto.</exception>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è chiuso.</exception>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver chiamato questo metodo, non sarà più possibile usare il <xref:System.Net.HttpListener> oggetto. Per sospendere temporaneamente un' <xref:System.Net.HttpListener> dell'oggetto, usare il <xref:System.Net.HttpListener.Stop%2A> (metodo).  
  
 Questo metodo arresta downs il <xref:System.Net.HttpListener> oggetto senza l'elaborazione delle richieste in coda. Le richieste in sospeso non riesce a completare.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare questo metodo.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un elenco predefinito di nomi di provider di servizi come determinato dai prefissi registrati.</summary>
        <value>Oggetto <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> che contiene un elenco di nomi di provider di servizi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpListener.DefaultServiceNames%2A> proprietà viene utilizzata con l'autenticazione integrata di Windows per fornire protezione estesa. L'elenco dei nomi dell'entità servizio viene inizializzato dal <xref:System.Net.HttpListener.Prefixes%2A> proprietà accessibili e cancellata quando si aggiungono nuovi prefissi per il <xref:System.Net.HttpListener.Prefixes%2A> proprietà.  
  
 Il <xref:System.Net.HttpListener.DefaultServiceNames%2A> proprietà viene utilizzata se un'applicazione non imposta il <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> proprietà sui relativi criteri di protezione estesa.  
  
 Il <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> che viene recuperata con il <xref:System.Net.HttpListener.DefaultServiceNames%2A> progettata per proprietà di <xref:System.Net.HttpListener.Prefixes%2A> proprietà in base alle regole seguenti:  
  
1.  Se il nome host è "+", "*", o un valore letterale IPv4 o IPv6 (equivalente a "\*" ma è limitato a una specifica interfaccia locale), viene aggiunto il nome SPN seguente:  
  
 `"HTTP/"` seguito dal nome di dominio completo del computer.  
  
1.  Se il nome host non contiene punti (non domini o diversi sottodomini), viene effettuato un tentativo di risolvere il nome di dominio completo usando DNS (lo stesso comportamento utilizzato da <xref:System.Net.HttpWebRequest>). Se il nome di dominio completo può essere risolto, vengono aggiunti i seguenti SPN:  
  
 `"HTTP/"` Oltre al nome host (il nome breve).  
  
 `"HTTP/"` seguito dal nome di dominio completo per il nome host.  
  
1.  Se il nome host contiene non sui puntini di sospensione (non domini o diversi sottodomini) e un nome di dominio completo non può essere risolto, viene aggiunto il nome SPN seguente:  
  
 `"HTTP/"` Oltre al nome host.  
  
1.  Se il nome host contengono punti (domini o diversi sottodomini), viene aggiunto il nome SPN seguente:  
  
 `"HTTP/"` Oltre al nome host.  
  
 Il <xref:System.Net.HttpListener.DefaultServiceNames%2A> proprietà può essere utilizzata da un'applicazione per esaminare l'elenco di nomi SPN predefiniti che verrà usato per l'autenticazione se viene fornito alcun elenco personalizzato. Se sono necessari altri nomi dell'entità servizio, un'applicazione possibile aggiungerle usando uno del <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> metodi.  
  
 Non è sicuro quando si usa la protezione estesa per prendere decisioni sui criteri basati sull'URL richiesto, poiché ciò può essere soggetti a spoofing. Piuttosto, le applicazioni devono basarsi sulle <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> o <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> proprietà da prendere tali decisioni sui criteri.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticazione di Windows integrata con Protezione estesa</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> ottenuto all'avvio dell'operazione asincrona.</param>
        <summary>Completa un'operazione asincrona per recuperare una richiesta del client in ingresso.</summary>
        <returns>Oggetto <see cref="T:System.Net.HttpListenerContext" /> che rappresenta la richiesta del client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpListener.EndGetContext%2A> metodo viene chiamato, in genere all'interno di un metodo di callback definita dall'applicazione da un delegato, per ottenere il <xref:System.Net.HttpListenerContext> oggetto che contiene una richiesta client in ingresso e la relativa risposta associata. Questo metodo completa un'operazione avviata in precedenza chiamando il <xref:System.Net.HttpListener.BeginGetContext%2A> (metodo). Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene.  
  
 Poiché se si chiama il <xref:System.Net.HttpListener.EndGetContext%2A> metodo richiede la <xref:System.Net.HttpListener> dell'oggetto, questo oggetto è in genere passato a un metodo di callback usando l'oggetto di stato passato il <xref:System.Net.HttpListener.BeginGetContext%2A> (metodo). È possibile ottenere questo oggetto stato usando il <xref:System.IAsyncResult.AsyncState%2A> proprietà del `asyncResult` oggetto.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'implementazione di un metodo di callback che chiama il <xref:System.Net.HttpListener.EndGetContext%2A> (metodo).  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato ottenuto chiamando il metodo <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> era già stato chiamato per l'oggetto <paramref name="asyncResult" /> specificato.</exception>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è chiuso.</exception>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> da usare per la protezione estesa di una sessione.</summary>
        <value>Oggetto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> che specifica i criteri da usare per la protezione estesa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> proprietà viene utilizzata con l'autenticazione integrata di Windows per fornire protezione estesa. Il <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> proprietà consente la configurazione dei criteri di protezione estesa per l'intero <xref:System.Net.HttpListener> sessione. Il <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> proprietà consente la configurazione dei criteri di protezione estesa per ogni singola richiesta.  
  
 La proprietà <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> deve essere impostata su `null`. Il <xref:System.Net.HttpListener> istanza Ottiene la Channel Binding Token CBT () direttamente da una sessione TLS se presente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è tentato di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />, ma la proprietà <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Si è tentato di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> su <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Si è tentato di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> dopo la chiamata al metodo <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La proprietà <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> è stata impostata su <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> in una piattaforma che non supporta la protezione estesa.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticazione di Windows integrata con Protezione estesa</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il delegato chiamato per determinare l'oggetto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> da usare per ogni richiesta.</summary>
        <value>Oggetto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> che specifica i criteri da usare per la protezione estesa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> proprietà viene utilizzata con l'autenticazione integrata di Windows per fornire protezione estesa. Il <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> proprietà consente la configurazione dei criteri di protezione estesa per l'intero <xref:System.Net.HttpListener> sessione. Il <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> proprietà consente la configurazione dei criteri di protezione estesa per ogni singola richiesta.  
  
 La proprietà <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> deve essere impostata su `null`. Il <xref:System.Net.HttpListener> istanza Ottiene la Channel Binding Token CBT () direttamente da una sessione TLS se presente.  
  
 Per ogni richiesta, il delegato può scegliere le impostazioni che il <xref:System.Net.HttpListener> istanza verrà utilizzato per fornire protezione estesa.  
  
 Se restituisce un delegato `null` per questa proprietà, il valore rappresenta un <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> quali le <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> impostata su <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è tentato di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />, ma la proprietà <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Si è tentato di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> su <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Si è tentato di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> dopo la chiamata al metodo <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">È stato eseguito un tentativo di impostare la proprietà <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> su una piattaforma che non supporta la protezione estesa.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticazione di Windows integrata con Protezione estesa</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attende una richiesta in ingresso e restituisce un risultato quando ne viene ricevuta una.</summary>
        <returns>Oggetto <see cref="T:System.Net.HttpListenerContext" /> che rappresenta una richiesta del client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima di chiamare questo metodo, è necessario chiamare il <xref:System.Net.HttpListener.Start%2A> (metodo) e aggiungere almeno un prefisso URI per l'ascolto aggiungendo le stringhe di URI per il <xref:System.Net.HttpListenerPrefixCollection> restituiti dai <xref:System.Net.HttpListener.Prefixes%2A> proprietà. Per una descrizione dettagliata dei prefissi, vedere il <xref:System.Net.HttpListener> Cenni preliminari sulla classe.  
  
 Questo metodo si blocca durante l'attesa di una richiesta in ingresso. Se si desidera che le richieste in ingresso da elaborare in modo asincrono (su thread separati) in modo che non blocca l'applicazione, usare il <xref:System.Net.HttpListener.BeginGetContext%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare questo metodo.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Errore di una chiamata di funzione Win32. Verificare la proprietà <see cref="P:System.Net.HttpListenerException.ErrorCode" /> dell'eccezione per determinare la causa dell'eccezione.</exception>
        <exception cref="T:System.InvalidOperationException">Questo oggetto non è stato avviato o è attualmente interrotto.  
  
oppure 
La classe <see cref="T:System.Net.HttpListener" /> non dispone di alcun prefisso URI a cui rispondere.</exception>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è chiuso.</exception>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attende una richiesta in ingresso come operazione asincrona.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task`1" />.  
  
Oggetto dell'attività che rappresenta l'operazione asincrona. La proprietà <see cref="P:System.Threading.Tasks.Task`1.Result" /> nell'oggetto attività restituisce un oggetto <see cref="T:System.Net.HttpListenerContext" /> che rappresenta una richiesta del client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa operazione non verrà bloccata. L'oggetto restituito <xref:System.Threading.Tasks.Task%601> oggetto verrà completata quando viene ricevuta la richiesta in ingresso.  
  
 Prima di chiamare questo metodo, è necessario chiamare il <xref:System.Net.HttpListener.Start%2A> (metodo) e aggiungere almeno un prefisso URI per l'ascolto aggiungendo le stringhe di URI per il <xref:System.Net.HttpListenerPrefixCollection> restituiti dai <xref:System.Net.HttpListener.Prefixes%2A> proprietà. Per una descrizione dettagliata dei prefissi, vedere il <xref:System.Net.HttpListener> Cenni preliminari sulla classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se l'applicazione riceve le eccezioni che si verificano quando un oggetto <see cref="T:System.Net.HttpListener" /> invia la risposta al client.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Net.HttpListener" /> non deve restituire eccezioni generate all'invio della risposta al client; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `true` se l'applicazione non richiede che venga completato l'invio di una risposta a ogni client.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'impostazione di questa proprietà.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Net.HttpListener" /> è stato avviato.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Net.HttpListener" /> è stato avviato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per avviare un' <xref:System.Net.HttpListener>, chiamare il <xref:System.Net.HttpListener.Start%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di questa proprietà per determinare lo stato di un'istanza in ascolto.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Net.HttpListener" /> può essere usato con il sistema operativo corrente.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Net.HttpListener" /> è supportato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe è disponibile solo nei computer che eseguono i sistemi operativi Windows XP SP2 o Windows Server 2003.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei <xref:System.Net.HttpListener.IsSupported%2A> proprietà per rilevare se un <xref:System.Net.HttpListener> oggetto può essere utilizzato con il sistema operativo corrente.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i prefissi URI (Uniform Resource Identifier) gestiti dall'oggetto <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Oggetto <see cref="T:System.Net.HttpListenerPrefixCollection" /> che contiene i prefissi URI per la cui gestione è configurato l'oggetto <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I prefissi sono in forma canonica. Per una descrizione dettagliata dei prefissi, vedere il <xref:System.Net.HttpListener> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di <xref:System.Net.HttpListener.Prefixes%2A> proprietà da ottenere e visualizzare i prefissi URI vengono gestiti.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'area di autenticazione, o partizione di risorsa, associata all'oggetto <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Valore <see cref="T:System.String" /> che contiene il nome dell'area di autenticazione associata all'oggetto <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I server usano aree di autenticazione per separare risorse protette; ogni partizione può avere un proprio database lo schema e/o autorizzazione di autenticazione. Le aree vengono usate solo per l'autenticazione di base e digest. Se un client viene autenticato correttamente, l'autenticazione è valida per tutte le risorse in una determinata area. Per una descrizione dettagliata delle aree, vedere RFC 2617 al [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Un'istanza di <xref:System.Net.HttpListener> dispone solo un'area associata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'impostazione di <xref:System.Net.HttpListener.Realm%2A> proprietà.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente a questa istanza di ricevere le richieste in ingresso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere chiamato prima di chiamare il <xref:System.Net.HttpListener.GetContext%2A> o <xref:System.Net.HttpListener.BeginGetContext%2A> (metodo).  
  
 Dopo aver avviato un' <xref:System.Net.HttpListener> dell'oggetto, è possibile usare il <xref:System.Net.HttpListener.Stop%2A> metodo per arrestarlo.  
  
> [!NOTE]
>  Se questa istanza di listener utilizza https, è necessario installare e selezionare un certificato del Server. In caso contrario, un <xref:System.Net.HttpWebRequest> sottoquery di questo <xref:System.Net.HttpListener> avrà esito negativo con una chiusura imprevista della connessione. È possibile configurare i certificati del Server e altre opzioni del listener utilizzando HttpCfg.exe. Visualizzare [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) per altri dettagli.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di <xref:System.Net.HttpListener.Start%2A> metodo per avviare l'elaborazione delle richieste in ingresso.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Errore di una chiamata di funzione Win32. Verificare la proprietà <see cref="P:System.Net.HttpListenerException.ErrorCode" /> dell'eccezione per determinare la causa dell'eccezione.</exception>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è chiuso.</exception>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comporta l'interruzione della ricezione delle richieste in ingresso per questa istanza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questa istanza è già stata arrestata, chiamare questo metodo non ha alcun effetto.  
  
 Dopo aver arrestato un <xref:System.Net.HttpListener> dell'oggetto, è possibile usare il <xref:System.Net.HttpListener.Start%2A> metodo a riavviarlo.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di <xref:System.Net.HttpListener.Stop%2A> metodo che deve interrompere l'elaborazione delle richieste in ingresso.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <block subset="none" type="usage">
          <para>Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse contenute nell'oggetto <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le applicazioni devono utilizzare il <xref:System.Net.HttpListener.Close%2A> metodo invece di chiamare questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gestore di timeout per questa istanza di <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Restituisce <see cref="T:System.Net.HttpListenerTimeoutManager" />.  
  
Gestore di timeout per questa istanza di <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestore di timeout definisce i limiti di timeout di connessione per questo oggetto <xref:System.Net.HttpListener> istanza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che controlla se è necessario autenticare altre richieste che usano la stessa connessione TCP (Transmission Control Protocol), quando viene usato NTLM.</summary>
        <value>
          <see langword="true" /> se l'interfaccia <see cref="T:System.Security.Principal.IIdentity" /> della prima richiesta verrà utilizzata per le richieste successive sulla stessa connessione; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questa proprietà è impostata su `true` e la prima richiesta su una determinata connessione TCP viene autenticata tramite NTLM, le successive richieste sulla stessa connessione TCP vengono elaborate usando le informazioni di autenticazione (<xref:System.Security.Principal.IIdentity>) di iniziale richiesta.  
  
 La proprietà non ha alcun effetto se il protocollo di autenticazione non è NTLM. Quando Negotiate è specificato come il protocollo di autenticazione, questa proprietà ha effetto solo se il protocollo usato per l'autenticazione è NTLM.  
  
> [!NOTE]
>  Sebbene l'impostazione di questa proprietà su `true` aumenta le prestazioni perché il <xref:System.Net.HttpListener> non non invia l'autenticazione NTLM aggiuntive, c'è un rischio di sicurezza di non richiedere tutte le richieste per fornire le informazioni di autenticazione. Occorre quindi stabilire se il miglioramento delle prestazioni giustifica questo rischio.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'impostazione di questa proprietà.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
  </Members>
</Type>