<Type Name="XPathMessageFilterTable&lt;TFilterData&gt;" FullName="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;TFilterData&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ad15c6eb65894b892a5d243c61c84c2a1249adb3" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39810472" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XPathMessageFilterTable&lt;TFilterData&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XPathMessageFilterTable`1&lt;TFilterData&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.IEnumerable, class System.ServiceModel.Dispatcher.IMessageFilterTable`1&lt;!TFilterData&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />
  <TypeSignature Language="VB.NET" Value="Public Class XPathMessageFilterTable(Of TFilterData)&#xA;Implements ICollection(Of KeyValuePair(Of MessageFilter, TFilterData)), IDictionary(Of MessageFilter, TFilterData), IEnumerable(Of KeyValuePair(Of MessageFilter, TFilterData)), IMessageFilterTable(Of TFilterData)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TFilterData&gt;&#xA;public ref class XPathMessageFilterTable : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::ServiceModel::Dispatcher::IMessageFilterTable&lt;TFilterData&gt;" />
  <TypeSignature Language="F#" Value="type XPathMessageFilterTable&lt;'FilterData&gt; = class&#xA;    interface IMessageFilterTable&lt;'FilterData&gt;&#xA;    interface IDictionary&lt;MessageFilter, 'FilterData&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TFilterData" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.Serialization.DataContract</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TFilterData">Tipo di dati del filtro associati a tutti i filtri della tabella.</typeparam>
    <summary>Contiene una raccolta di coppie filtro/dati per una corrispondenza efficiente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601> implementa l'interfaccia <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601>. La tabella è ottimizzata per filtri XPath dichiarativi, pertanto la chiave della tabella è <xref:System.ServiceModel.Dispatcher.XPathMessageFilter>.  
  
 La classe <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601> ottimizza la corrispondenza per un sottoinsieme di XPath che tratta la maggior parte degli scenari di messaggistica e supporta inoltre la grammatica di XPath 1.0 completa. Sono stati ottimizzati algoritmi per una corrispondenza parallela efficiente.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XPathMessageFilterTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XPathMessageFilterTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XPathMessageFilterTable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XPathMessageFilterTable(int capacity);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt; : int -&gt; System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;" Usage="new System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Capacità iniziale della tabella.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> e l'oggetto <paramref name="FilterData" /> associato a <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Add(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As KeyValuePair(Of MessageFilter, TFilterData))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; unit&#xA;override this.Add : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; unit" Usage="xPathMessageFilterTable.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; da aggiungere alla tabella.</param>
        <summary>Aggiunge una coppia filtro/<paramref name="FilterData" /> (chiave/valore) a <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il metodo <xref:System.Collections.Generic.ICollection%601.Add%2A> della classe <xref:System.Collections.Generic.ICollection%601>.  La conversione implicita del parametro `filter` dal tipo <xref:System.ServiceModel.Dispatcher.MessageFilter> in <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> può essere evitata utilizzando l'overload fortemente tipizzato <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Add%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Si è verificato un errore del compilatore.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.ServiceModel.Dispatcher.MessageFilter filter, TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(class System.ServiceModel.Dispatcher.MessageFilter filter, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Add(System.ServiceModel.Dispatcher.MessageFilter,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (filter As MessageFilter, data As TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData data);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; unit&#xA;override this.Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; unit" Usage="xPathMessageFilterTable.Add (filter, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" />
      </Parameters>
      <Docs>
        <param name="filter">Oggetto <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> utilizzato come chiave della coppia aggiunta. Deve essere un'istanza di <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</param>
        <param name="data">
          <c>FilterData</c> associato al filtro usato come valore della coppia aggiunta.</param>
        <summary>Aggiunge una coppia filtro/dati alla tabella dei filtri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La conversione interna del parametro `filter` dal tipo <xref:System.ServiceModel.Dispatcher.MessageFilter> in <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> può essere evitata utilizzando l'overload fortemente tipizzato <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Add%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="filter" /> non è un elemento <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Si è verificato un errore del compilatore.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.ServiceModel.Dispatcher.XPathMessageFilter filter, TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.ServiceModel.Dispatcher.XPathMessageFilter filter, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Add(System.ServiceModel.Dispatcher.XPathMessageFilter,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (filter As XPathMessageFilter, data As TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::ServiceModel::Dispatcher::XPathMessageFilter ^ filter, TFilterData data);" />
      <MemberSignature Language="F#" Value="member this.Add : System.ServiceModel.Dispatcher.XPathMessageFilter * 'FilterData -&gt; unit" Usage="xPathMessageFilterTable.Add (filter, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.XPathMessageFilter" />
        <Parameter Name="data" Type="TFilterData" />
      </Parameters>
      <Docs>
        <param name="filter">Oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> utilizzato come chiave della coppia aggiunta.</param>
        <param name="data">
          <c>FilterData</c> associato al filtro, usato come valore della coppia aggiunta.</param>
        <summary>Aggiunge una coppia filtro/dati alla tabella dei filtri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fornisce un overload fortemente tipizzato per l'aggiunta di un oggetto <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> alla tabella dei filtri che offre prestazioni migliori rispetto all'overload debolmente tipizzato, in quanto evita la conversione implicita del parametro `filter` dal tipo <xref:System.ServiceModel.Dispatcher.MessageFilter> in <xref:System.ServiceModel.Dispatcher.XPathMessageFilter>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Si è verificato un errore del compilatore.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="xPathMessageFilterTable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutte le coppie filtro/dati dalla tabella dei filtri.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Contains(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of MessageFilter, TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;<see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, <c>FilterData</c>&gt; da cercare nella tabella.</param>
        <summary>Determina se la tabella dei filtri contiene un filtro specificato e l'oggetto <paramref name="FilterData" /> associato.</summary>
        <returns>
          <see langword="true" /> se la coppia filtro/*FilterData* è contenuta nella tabella dei filtri; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `false` se il filtro viene trovato ma corrisponde a dati diversi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.ContainsKey(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool&#xA;override this.ContainsKey : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool" Usage="xPathMessageFilterTable.ContainsKey filter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> per il quale eseguire il test.</param>
        <summary>Determina se la tabella dei filtri contiene un filtro specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="filter" /> è contenuto nella tabella dei filtri, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il metodo `ContainsKey` di <xref:System.Collections.Generic.IDictionary%602>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.CopyTo(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of MessageFilter, TFilterData)(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit" Usage="xPathMessageFilterTable.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice di tipo <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; in cui vengono copiate le coppie.</param>
        <param name="arrayIndex">Indice da cui iniziare la copia.</param>
        <summary>Copia la coppia filtro/<paramref name="FilterData" /> in una matrice a partire dall'indice specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di coppie filtro/dati attualmente presenti nella tabella dei filtri.</summary>
        <value>Numero di coppie filtro/dati attualmente presenti nella tabella dei filtri.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of MessageFilter, TFilterData))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;&gt;" Usage="xPathMessageFilterTable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di scorrere la tabella dei filtri.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;KeyValuePair&lt;Filter, FilterData&gt;&gt; che può essere usato per scorrere la tabella dei filtri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa <xref:System.Collections.Generic.SynchronizedCollection%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilter">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un filtro della tabella viene soddisfatto dal messaggio o dal messaggio memorizzato nel buffer specificato e se tale filtro viene restituito in un parametro <see langword="out" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verifica se un messaggio soddisfa con esattezza uno dei filtri contenuti nella tabella dei filtri.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.Message *  -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (message, filter)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da verificare.</param>
        <param name="filter">Parametro <see langword="out" /> in cui è archiviato il filtro soddisfatto da <c>message</c>. Se nessun filtro viene individuato, il parametro viene impostato sul valore predefinito.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un filtro della tabella viene soddisfatto dal messaggio specificato e se tale filtro viene restituito in un parametro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> i cui criteri di query sono soddisfatti dal messaggio, altrimenti <see langword="null" /> se non vengono trovati filtri corrispondenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che un solo filtro corrisponda al messaggio e occorre disporre del filtro corrispondente.  
  
 Questo metodo verifica la corrispondenza con un solo filtro nel bucket di priorità più elevate dei filtri. Ai filtri contenuti nella tabella non è consentito controllare il corpo del messaggio.  
  
 Se si prevede che al messaggio corrisponda più di un filtro, utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="message" /> corrisponde più di un filtro.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Un filtro ha tentato di esaminare il contenuto del corpo del messaggio.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer messageBuffer, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer messageBuffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (messageBuffer, filter)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">Oggetto <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> da verificare.</param>
        <param name="filter">Parametro <see langword="out" /> in cui è archiviato il filtro soddisfatto da <c>message</c>. Se nessun filtro viene individuato, il parametro viene impostato sul valore predefinito.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un filtro della tabella viene soddisfatto dal messaggio o dal messaggio memorizzato nel buffer specificato e se tale filtro viene restituito in un parametro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> i cui criteri di query sono soddisfatti dal messaggio memorizzato nel buffer, altrimenti <see langword="null" /> se non vengono trovati filtri corrispondenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che un solo filtro corrisponda al messaggio memorizzato nel buffer ed è necessario disporre del filtro corrispondente.  
  
 Ai filtri contenuti nella tabella è consentito controllare il corpo del messaggio.  
  
 Se si prevede che al messaggio corrisponda più di un filtro, utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="messageBuffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="messageBuffer" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilter(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Dispatcher.SeekableXPathNavigator,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (navigator As SeekableXPathNavigator, ByRef filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilter : System.ServiceModel.Dispatcher.SeekableXPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (navigator, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> da verificare.</param>
        <param name="filter">Parametro <see langword="out" /> in cui è archiviato il filtro soddisfatto da <c>message</c>. Se nessun filtro viene individuato, il parametro viene impostato sul valore predefinito.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> della tabella viene soddisfatto dal messaggio o dal messaggio memorizzato nel buffer specificato e se tale filtro viene restituito in un parametro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> i cui criteri di query sono soddisfatti dal navigatore, altrimenti <see langword="null" /> se non vengono trovati filtri corrispondenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che un solo filtro corrisponda al messaggio specificato da <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> ed è necessario disporre del filtro corrispondente.  
  
 Se si prevede che al messaggio corrisponda più di un filtro, utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="navigator" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.Xml.XPath.XPathNavigator navigator, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilter(class System.Xml.XPath.XPathNavigator navigator, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.Xml.XPath.XPathNavigator,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (navigator As XPathNavigator, ByRef filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::Xml::XPath::XPathNavigator ^ navigator, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilter : System.Xml.XPath.XPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (navigator, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> da verificare.</param>
        <param name="filter">Parametro <see langword="out" /> in cui è archiviato il filtro soddisfatto da <c>navigator</c>. Se nessun filtro viene individuato, il parametro viene impostato sul valore predefinito.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> della tabella viene soddisfatto dal messaggio o dal messaggio memorizzato nel buffer specificato e se tale filtro viene restituito in un parametro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> i cui criteri di query sono soddisfatti dal navigatore, altrimenti <see langword="null" /> se non vengono trovati filtri corrispondenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che un solo filtro corrisponda al messaggio specificato da <xref:System.Xml.XPath.XPathNavigator> ed è necessario disporre del filtro corrispondente.  
  
 Se si prevede che al messaggio corrisponda più di un filtro, utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="navigator" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilters">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un filtro della tabella viene soddisfatto dal documento XML specificato e aggiunge i filtri corrispondenti a una raccolta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che al messaggio corrisponda più di un filtro e sono necessari i filtri corrispondenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilters(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool&#xA;override this.GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (message, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati gli oggetti <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> che corrispondono in <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filtro&gt;.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> della tabella viene soddisfatto dal messaggio specificato e aggiunge i filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="message" />; <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che al messaggio corrisponda più di un filtro e sono necessari i filtri corrispondenti.  
  
 Ai filtri contenuti nella tabella non è consentito controllare il corpo del messaggio.  
  
 Gli oggetti <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> corrispondenti vengono memorizzati nel parametro `results` di <xref:System.Collections.Generic.ICollection%601>. L'oggetto `FilterData` potrà quindi essere recuperato dalla tabella dei filtri utilizzando questi filtri come chiavi, tramite i metodi forniti da <xref:System.Collections.Generic.IDictionary%602>.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Un filtro ha tentato di esaminare il contenuto del corpo del messaggio.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer messageBuffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer messageBuffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilters(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool&#xA;override this.GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (messageBuffer, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">Oggetto <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati gli oggetti <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> che corrispondono in <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filtro&gt;.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> viene soddisfatto dal messaggio memorizzato nel buffer specificato e aggiunge i filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="messageBuffer" />; <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che più filtri corrispondano al messaggio memorizzato nel buffer ed è necessario disporre dei filtri corrispondenti.  
  
 Ai filtri contenuti nella tabella è consentito controllare il corpo del messaggio.  
  
 Gli oggetti <xref:System.ServiceModel.Dispatcher.MessageFilter> corrispondenti vengono memorizzati nel parametro `results` di <xref:System.Collections.Generic.ICollection%601>. L'oggetto `FilterData` potrà quindi essere recuperato dalla tabella dei filtri utilizzando questi filtri come chiavi, tramite i metodi forniti da <xref:System.Collections.Generic.IDictionary%602>.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilters(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Dispatcher.SeekableXPathNavigator,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilters (navigator As SeekableXPathNavigator, results As ICollection(Of MessageFilter)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilters : System.ServiceModel.Dispatcher.SeekableXPathNavigator * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati gli oggetti <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> che corrispondono in <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filtro&gt;.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> viene soddisfatto dal messaggio memorizzato nel buffer specificato e aggiunge i filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="messageBuffer" />; <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che più filtri corrispondano al navigatore e occorre disporre dei filtri corrispondenti.  
  
 Se si prevede che al messaggio corrisponda un solo filtro, utilizzare il metodo <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.Xml.XPath.XPathNavigator navigator, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilters(class System.Xml.XPath.XPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.Xml.XPath.XPathNavigator,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilters (navigator As XPathNavigator, results As ICollection(Of MessageFilter)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::Xml::XPath::XPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilters : System.Xml.XPath.XPathNavigator * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati gli oggetti <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> che corrispondono in <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filtro&gt;.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> viene soddisfatto dal messaggio memorizzato nel buffer specificato e aggiunge i filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="messageBuffer" />; <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che possano corrispondere più filtri al messaggio specificato da <xref:System.Xml.XPath.XPathNavigator> ed è necessario disporre dei filtri corrispondenti.  
  
 Se si prevede che al messaggio corrisponda un solo filtro, utilizzare il metodo <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="matches" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValue">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> della tabella viene soddisfatto dall'oggetto documento specificato e aggiunge i dati del filtro corrispondenti a una raccolta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare uno di questi quattro metodi quando si prevede che un solo filtro corrisponda all'oggetto documento e deve essere recuperato solo `FilterData` dal filtro corrispondente.  
  
 I primi due metodi sono implementazioni di <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A>.  
  
 Utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A> se non è necessario esaminare il contenuto del corpo. Utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A> se è necessario esaminare il corpo del messaggio.  
  
 I due metodi restanti sono overload specifici di <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>. Per filtrare un documento fornito tramite un navigatore, utilizzare <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A> o <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValue(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.Message *  -&gt; bool&#xA;override this.GetMatchingValue : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (message, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da verificare.</param>
        <param name="data">Parametro <see langword="out" /> in cui è archiviato l'oggetto <c>FilterData</c> per il filtro corrispondente a <c>message</c>.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> della tabella viene soddisfatto dal messaggio specificato e restituisce i dati del filtro corrispondenti.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di un filtro della tabella è soddisfatto dal messaggio, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che un solo filtro corrisponda al messaggio e deve essere recuperato solo `FilterData` dal filtro corrispondente.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="message" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer messageBuffer, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer messageBuffer, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValue(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool&#xA;override this.GetMatchingValue : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (messageBuffer, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">Oggetto <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> da verificare.</param>
        <param name="data">Parametro <see langword="out" /> in cui è archiviato l'oggetto <c>FilterData</c> per il filtro corrispondente a <c>messageBuffer</c>.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> della tabella viene soddisfatto dal messaggio memorizzato nel buffer specificato e restituisce i dati del filtro corrispondenti.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di un filtro della tabella è soddisfatto dal messaggio memorizzato nel buffer, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che un solo filtro corrisponda al messaggio memorizzato nel buffer e deve essere recuperato solo `FilterData` dal filtro corrispondente.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="messageBuffer" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValue(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Dispatcher.SeekableXPathNavigator,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValue (navigator As SeekableXPathNavigator, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValue : System.ServiceModel.Dispatcher.SeekableXPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (navigator, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> da verificare.</param>
        <param name="data">Parametro <see langword="out" /> in cui è archiviato l'oggetto <c>FilterData</c> corrispondente a <c>navigator</c>.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> della tabella viene soddisfatto da <paramref name="navigator" /> e restituisce i dati del filtro corrispondenti in un parametro <see langword="out" />.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di esattamente un filtro nella tabella è soddisfatto da <paramref name="navigator" />, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per specificare una condizione XPath che il messaggio deve soddisfare.  
  
 Questo metodo è simile a <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A>, ad eccezione del fatto che utilizza un oggetto <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> che estende la funzionalità di <xref:System.Xml.XPath.XPathNavigator> in modo da includere metodi che consentono varie ottimizzazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="navigator" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.Xml.XPath.XPathNavigator navigator, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValue(class System.Xml.XPath.XPathNavigator navigator, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.Xml.XPath.XPathNavigator,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValue (navigator As XPathNavigator, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::Xml::XPath::XPathNavigator ^ navigator, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValue : System.Xml.XPath.XPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (navigator, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> da verificare.</param>
        <param name="data">Parametro <see langword="out" /> in cui è archiviato l'oggetto <c>FilterData</c> corrispondente a <c>navigator</c>.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di un oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> della tabella viene soddisfatto da <paramref name="navigator" /> e restituisce i dati del filtro corrispondenti in un parametro <see langword="out" />.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di esattamente un filtro nella tabella è soddisfatto da <paramref name="navigator" />, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per specificare una condizione XPath che il messaggio deve soddisfare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">A <paramref name="navigator" /> corrisponde più di un filtro.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValues">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un filtro della tabella viene soddisfatto dal messaggio o dal messaggio memorizzato nel buffer specificato e aggiunge l'oggetto <paramref name="FilterData" /> dei filtri corrispondenti a una raccolta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che al messaggio o messaggio memorizzato nel buffer corrisponda un solo filtro ed è necessario solo `FilterData`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValues(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool&#xA;override this.GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (message, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati i dati dei filtri corrispondenti in un oggetto <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; generico.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un filtro della tabella viene soddisfatto dal messaggio specificato e aggiunge i dati dei filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="message" />, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che più di un filtro corrisponda al messaggio, se sono necessari solo i dati del filtro e non è necessario controllare il corpo del messaggio.  
  
 I dati filtro degli oggetti <xref:System.ServiceModel.Dispatcher.MessageFilter> corrispondenti vengono memorizzati nel parametro `results` di <xref:System.Collections.Generic.ICollection%601>.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Un filtro ha tentato di esaminare il contenuto del corpo del messaggio.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer messageBuffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer messageBuffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValues(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool&#xA;override this.GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (messageBuffer, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">Oggetto <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati i dati dei filtri corrispondenti in un oggetto <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; generico.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un filtro della tabella viene soddisfatto dal messaggio memorizzato nel buffer specificato e aggiunge i dati dei filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="message" />; <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che più filtri corrispondano al messaggio memorizzato nel buffer e solo i dati del filtro sono necessari.  
  
 I dati filtro degli oggetti <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> corrispondenti vengono memorizzati nel parametro `results`<xref:System.Collections.Generic.ICollection%601>.  
  
 Questo metodo implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValues(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Dispatcher.SeekableXPathNavigator,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValues (navigator As SeekableXPathNavigator, results As ICollection(Of TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValues : System.ServiceModel.Dispatcher.SeekableXPathNavigator * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati i dati dei filtri corrispondenti in un oggetto <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; generico.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un oggetto <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> della tabella viene soddisfatto da <paramref name="navigator" /> e aggiunge i dati dei filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="navigator" />, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che ai criteri di query del documento XML derivato dal navigatore XPath ottimizzato <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> corrisponda più di un filtro e solo i dati del filtro sono necessari.  
  
 I dati filtro degli oggetti <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> corrispondenti vengono memorizzati nel parametro `results` di <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.Xml.XPath.XPathNavigator navigator, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValues(class System.Xml.XPath.XPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.Xml.XPath.XPathNavigator,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValues (navigator As XPathNavigator, results As ICollection(Of TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::Xml::XPath::XPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValues : System.Xml.XPath.XPathNavigator * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">Oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> da verificare.</param>
        <param name="results">Parametro per riferimento in cui sono archiviati i dati dei filtri corrispondenti in un oggetto <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; generico.</param>
        <summary>Restituisce un valore che indica se il criterio di corrispondenza di almeno un oggetto <see cref="T:System.Xml.XPath.XPathNavigator" /> della tabella viene soddisfatto da <paramref name="navigator" /> e aggiunge i dati dei filtri corrispondenti a una raccolta.</summary>
        <returns>
          <see langword="true" /> se il criterio di corrispondenza di almeno un filtro nella tabella è soddisfatto da <paramref name="navigator" />, <see langword="false" /> se nessun filtro è soddisfatto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si prevede che ai criteri di query del documento XML derivato dal navigatore XPath ottimizzato <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> corrisponda più di un filtro e solo i dati del filtro sono necessari.  
  
 I dati filtro degli oggetti <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> corrispondenti vengono memorizzati nel parametro `results` di <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="results" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" /> non è di sola lettura.</summary>
        <value>Restituisce sempre <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TFilterData this[System.ServiceModel.Dispatcher.MessageFilter filter] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TFilterData Item(class System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Item(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(filter As MessageFilter) As TFilterData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TFilterData default[System::ServiceModel::Dispatcher::MessageFilter ^] { TFilterData get(System::ServiceModel::Dispatcher::MessageFilter ^ filter); void set(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData value); };" />
      <MemberSignature Language="F#" Value="member this.Item(System.ServiceModel.Dispatcher.MessageFilter) : 'FilterData with get, set" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFilterData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> associato ai dati del filtro da ottenere o da impostare.</param>
        <summary>Ottiene o imposta i dati del filtro associati all'oggetto <paramref name="filter" /> specificato.</summary>
        <value>Dati del filtro associati a <paramref name="filter" />. Se l'oggetto <paramref name="filter" /> specificato non viene trovato, un'operazione Get genera un'eccezione <see cref="T:System.Collections.Generic.KeyNotFoundException" />, mentre un'operazione Set crea un nuovo elemento dati del filtro con <paramref name="filter" /> specificato come chiave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà `Item` (l'indicizzatore in C#) consente di accedere ai dati del filtro associati a un oggetto `filter` nella raccolta di filtri della tabella utilizzando la sintassi seguente.  
  
```csharp  
myFilters[filter]  
```  
  
```vb  
myFilters(filter)  
```  
  
 È inoltre possibile utilizzare la proprietà `Item` per aggiungere nuovi elementi impostando i valori di coppie `filter`/dati del filtro non esistenti nella tabella dei filtri delle azioni. Se `filter` è tuttavia già presente nella tabella, l'impostazione della proprietà `Item` sovrascrive il vecchio valore. Al contrario, il metodo <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Add%2A> non modifica i dati del filtro di elementi `filter` esistenti.  
  
 L'oggetto `Item` del dizionario è una coppia `filter`/dati del filtro nel caso di <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Si è verificato un errore del compilatore.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Viene recuperata la proprietà e <paramref name="filter" /> non è incluso nella tabella.</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of MessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ Keys { System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di tutti i filtri contenuti in <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <value>
          <see cref="T:System.Collections.Generic.ICollection`1" /> di tutti gli oggetti <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> contenuti nella tabella dei filtri.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà implementa <xref:System.Collections.Generic.IDictionary%602.Keys%2A>. L'oggetto <xref:System.Collections.Generic.IDictionary%602> implementato dalla tabella dei filtri utilizza <xref:System.ServiceModel.Dispatcher.MessageFilter> come chiave e `FilterData` come valore della coppia.  
  
 L'ordine dei filtri restituiti nella raccolta non è specificato, ma è sicuramente identico all'ordine dell'oggetto `FilterData` corrispondente nella raccolta restituita dalla proprietà <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Values%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeQuota">
      <MemberSignature Language="C#" Value="public int NodeQuota { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NodeQuota" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.NodeQuota" />
      <MemberSignature Language="VB.NET" Value="Public Property NodeQuota As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NodeQuota { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.NodeQuota : int with get, set" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.NodeQuota" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero massimo di nodi del documento XML che possono essere esaminati dai singoli filtri durante una sola chiamata a un metodo <see langword="Match" />. Questo valore è valido per tutti i filtri.</summary>
        <value>Numero di nodi che è possibile esaminare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata per alleviare un rischio per la sicurezza. La valutazione di alcuni filtri può risultare estremamente onerosa oppure i filtri possono richiedere tempi di esecuzione particolarmente lunghi. La valutazione di alcuni filtri può risultare estremamente onerosa oppure i filtri possono richiedere tempi di esecuzione particolarmente lunghi. Gli oggetti <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> vengono più spesso valutati a fronte di un documento proveniente da una fonte non attendibile (messaggio SOAP fuori transito) che potrebbe essere dannosa. Poiché i filtri operano su documenti XML, il modo migliore di impostare limiti di calcolo sulle tabelle dei filtri consiste nel definire il numero massimo di nodi da esaminare durante la valutazione di un filtro nella tabella.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove un filtro e i dati associati dalla tabella dei filtri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Remove(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As KeyValuePair(Of MessageFilter, TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool&#xA;override this.Remove : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; da rimuovere dalla tabella.</param>
        <summary>Rimuove un filtro e i dati associati dalla tabella dei filtri.</summary>
        <returns>
          <see langword="true" /> se la coppia filtro/<paramref name="FilterData" /> è stata trovata e rimossa, <see langword="false" /> se non è stata trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la chiave del filtro di `item` è presente ma è associata a dati che differiscono da `FilterData`, non è possibile per il metodo rimuovere il filtro e viene restituito `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Remove(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool&#xA;override this.Remove : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool" Usage="xPathMessageFilterTable.Remove filter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Oggetto <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> da rimuovere.</param>
        <summary>Rimuove un filtro e i dati associati dalla tabella dei filtri.</summary>
        <returns>
          <see langword="true" /> se il filtro è stato trovato e rimosso, in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="filter" /> non è un oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.ServiceModel.Dispatcher.XPathMessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(class System.ServiceModel.Dispatcher.XPathMessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Remove(System.ServiceModel.Dispatcher.XPathMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (filter As XPathMessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(System::ServiceModel::Dispatcher::XPathMessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.ServiceModel.Dispatcher.XPathMessageFilter -&gt; bool" Usage="xPathMessageFilterTable.Remove filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.XPathMessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Oggetto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> da rimuovere.</param>
        <summary>Rimuove <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> e i relativi dati filtro associati dalla tabella dei filtri.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> è stato trovato e rimosso, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non genera un'eccezione se il filtro specificato non esiste nella tabella dei filtri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="filter" /> non è un elemento <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di scorrere la tabella dei filtri.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;KeyValuePair&lt;Filter, FilterData&gt;&gt; che può essere usato per scorrere la tabella dei filtri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa <xref:System.Collections.Generic.SynchronizedCollection%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimToSize();" />
      <MemberSignature Language="F#" Value="member this.TrimToSize : unit -&gt; unit" Usage="xPathMessageFilterTable.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprime la tabella dei filtri, eliminando le allocazioni o i buffer in eccesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è concettualmente equivalente all'impostazione della capacità di una raccolta nel relativo conteggio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (System.ServiceModel.Dispatcher.MessageFilter filter, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(class System.ServiceModel.Dispatcher.MessageFilter filter, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.TryGetValue(System.ServiceModel.Dispatcher.MessageFilter,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (filter As MessageFilter, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(System::ServiceModel::Dispatcher::MessageFilter ^ filter, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : System.ServiceModel.Dispatcher.MessageFilter *  -&gt; bool&#xA;override this.TryGetValue : System.ServiceModel.Dispatcher.MessageFilter *  -&gt; bool" Usage="xPathMessageFilterTable.TryGetValue (filter, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">Chiave per recuperare i dati.</param>
        <param name="data">Il valore di <c>data</c> associato a <c>filter</c> quando questo metodo restituisce <see langword="true" />; in caso contrario, il valore predefinito per il tipo di parametro <c>data</c>.</param>
        <summary>Controlla se un filtro è memorizzato nella tabella dei filtri.</summary>
        <returns>
          <see langword="true" /> se <paramref name="filter" /> è presente nella tabella dei filtri, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo offre una modalità efficiente per controllare se un filtro è presente nella tabella dei filtri perché se il filtro non è presente restituisce `false` anziché generare un'eccezione. Se si tenta di recuperare il filtro dalla tabella utilizzando la proprietà `Item` (l'indicizzatore in C#) e il filtro non è presente, viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TFilterData&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ Values { System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'FilterData&gt;" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TFilterData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di tutti gli oggetti <paramref name="FilterData" /> contenuti in <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <value>
          <see cref="T:System.Collections.Generic.ICollection`1" /> di tutti gli oggetti <paramref name="FilterData" /> contenuti nella tabella dei filtri.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà implementa <xref:System.Collections.Generic.IDictionary%602.Values%2A>. L'oggetto <xref:System.Collections.Generic.IDictionary%602><Filtro, `FilterData`> implementato dalla tabella dei filtri utilizza <xref:System.ServiceModel.Dispatcher.MessageFilter> come chiave e `FilterData` come valore della coppia.  
  
 L'ordine degli oggetti `FilterData` restituiti nella raccolta non è specificato, ma è sicuramente identico all'ordine dei filtri corrispondenti nella raccolta restituita dalla proprietà <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Keys%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>