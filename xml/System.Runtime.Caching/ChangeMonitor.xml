<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84f8a6fb55cf74a47d97cac674e756ad9921ef43" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46692393" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce una classe base per un tipo personalizzato derivato che monitora le modifiche dello stato dei dati da cui dipende un elemento della cache.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.Caching.ChangeMonitor> classe viene utilizzata come classe base per le classi derivate di monitoraggio sono specializzate per le implementazioni della cache particolare. Oggetto <xref:System.Runtime.Caching.ChangeMonitor> istanza consente di monitorare le modifiche dello stato dei dati che dipende da un elemento della cache. Ad esempio, l'elemento può essere un'entità di file o i dati viene memorizzati nella cache il cui contenuto. Se l'entità di file o i dati verrà aggiornato, è necessario modificare anche la voce della cache associata. Gli elementi comuni che possono essere monitorati includono le entità di dati (ad esempio campi di database, i valori, le righe o tabelle), un'altra voce della cache e i file e gli attributi di file.  
  
 Una modifica apportata alla dipendenza è una modifica nello stato di una dipendenza. In un'implementazione tipica della cache dopo un <xref:System.Runtime.Caching.ChangeMonitor> istanza invia una notifica cache che una dipendenza viene modificata, la cache esegue l'azione necessaria, ad esempio invalidazione voce cache inserite.  
  
 Derivato <xref:System.Runtime.Caching.ChangeMonitor> classi possono essere personalizzate per monitorare le modifiche delle dipendenze per gli archivi dati diversi specifici. Ad esempio, sono disponibili implementazioni della cache per un file system, la memoria fisica o un database. Il <xref:System.Runtime.Caching.ChangeMonitor> classe esamina le modifiche apportate all'esterno della cache e quindi genera avvisi per le cache che sono state apportate modifiche.  
  
 Il [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] include le classi seguenti che derivano da <xref:System.Runtime.Caching.ChangeMonitor> classe:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Ognuna di queste classi funziona con diversi tipi di dipendenze. Ad esempio, derivato <xref:System.Runtime.Caching.FileChangeMonitor> classe monitora le modifiche apportate a una cache di dati del file system (file e cartelle) che dipende la voce di cache.  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Se si crea un oggetto personalizzato implementazione della cache o una modifica derivata monitorare il tipo, è necessario seguire determinate linee guida. Nell'elenco seguente sono riepilogate queste linee guida. Per altre informazioni, vedere la documentazione per i singoli metodi o proprietà.  
  
-Il costruttore di una classe derivata deve impostare il <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> proprietà, iniziare a monitorare e chiamare <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metodo prima che il metodo restituisce. Se un costruttore rileva un errore durante le costruzioni e deve avere eliminare le risorse, il costruttore può chiamare solo le <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload dopo il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> viene chiamato perché il <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload genererà un <see cref="T:System.InvalidOperationException" /> eccezione se l'inizializzazione non è stata completata.  
  
-Se si verificano modifiche nei dati che viene monitorati prima che l'inizializzazione è completa, il costruttore deve chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodo prima di chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> (metodo).  
  
-Dopo un oggetto derivato <see cref="T:System.Runtime.Caching.ChangeMonitor" /> viene creata un'istanza di tipo, è necessario inserire il monitoraggio in una classe personalizzata <see cref="T:System.Runtime.Caching.ObjectCache" /> implementazione. O se desidera più utilizzare il monitoraggio delle modifiche, chiamare il <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> (metodo).  
  
-Dopo una <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanza viene inserita in un <see cref="T:System.Runtime.Caching.ObjectCache" /> implementazione, il <see cref="T:System.Runtime.Caching.ObjectCache" /> istanza richiedono che venga eliminato il monitoraggio delle modifiche. Anche se l'inserimento non è valida e genera un'eccezione, il <see cref="T:System.Runtime.Caching.ObjectCache" /> implementazione deve chiamare il <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> rapporto di overload.  
  
-Dopo un monitoraggio delle modifiche derivato viene inserito in una cache, il <see cref="T:System.Runtime.Caching.ObjectCache" /> implementazione deve chiamare <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, passando un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> oggetto. Il <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metodo può essere chiamato solo una volta. Se una modifica apportata alla dipendenza è già verificato, il <see cref="T:System.Runtime.Caching.OnChangedCallback" /> istanza verrà chiamata immediatamente quando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> viene chiamato. In caso contrario, il <see cref="T:System.Runtime.Caching.OnChangedCallback" /> istanza verrà chiamata solo una volta. Questa una volta chiamata si verifica uno quando il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> viene chiamato perché il <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanza ha rilevato una modifica, o quando il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo viene chiamato sul <see cref="T:System.Runtime.Caching.ChangeMonitor" />, qualunque si verifichi prima.  
  
-il <see cref="T:System.Runtime.Caching.OnChangedCallback" /> istanza fornita da un <see cref="T:System.Runtime.Caching.ObjectCache" /> implementazione deve rimuovere la voce della cache associata e specificare un motivo utilizzando il <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumerazione.  
  
-A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanza può chiamare le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodo prima che un'implementazione della cache è chiamato <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> (metodo) o dopo. Se il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodo viene chiamato prima <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> viene chiamato, la base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementazione invierà una notifica cache che ciò è accaduto e attiverà il callback deve essere passato <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> immediatamente quando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> viene richiamato. Dati di stato viene passati al <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> viene salvato il monitoraggio delle modifiche e successivamente passato al metodo il <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metodo quando la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metodo viene richiamato.  
  
-Monitoraggio delle modifiche deve implementare il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> (metodo). Per altre informazioni, vedere la documentazione del metodo <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.  
  
-il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload del metodo deve essere chiamato per smaltire i <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanza. Come indicato di seguito sono riportate le regole per la chiamata a Dispose: 
-Prima di un elemento viene inserito nella cache, è responsabilità del chiamante per eliminare un <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanza.  
  
-Una volta l'elemento della cache e il <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanze che esso associati vengono passate a una cache, il responsabile dell'implementazione della cache deve assicurarsi che che il <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo viene chiamato, anche se l'inserimento ha esito negativo.  
  
-Dopo un elemento e l'identificatore associato <see cref="T:System.Runtime.Caching.ChangeMonitor" /> le istanze sono passate a una cache, il chiamante deve eliminare la dipendenza non perché quando il <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> viene chiamato il metodo, la chiamata viene considerata come se la dipendenza è stato modificato. Di conseguenza, il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodo viene richiamato automaticamente.  
  
-Prendendo in considerazione, queste regole di <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo deve essere chiamato in uno dei modi seguenti: 
-Gli utenti devono chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload del metodo se si decide di non inserire l'istanza di monitoraggio delle modifiche in una cache.  
  
-Se l'implementazione tenta di inserire l'istanza di monitoraggio delle modifiche in una cache oggetti ma ha esito negativo dell'operazione di inserimento, l'implementazione della cache è responsabile della chiamata di <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> rapporto di overload. Quando il tentativo di inserimento provoca un'eccezione, l'implementazione della cache deve eliminare tutte le relative dipendenze.  
  
-Se la voce della cache viene rimosso, l'implementazione della cache deve anche eliminare la dipendenza.  
  
-L'implementazione interna del <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> chiama automaticamente il <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo dopo aver chiamato un callback che viene registrato tramite <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Questa chiamata automatica al metodo dispose durante la generazione dell'evento si verifica solo se l'inizializzazione del <see cref="T:System.Runtime.Caching.ChangeMonitor" /> istanza è stata completata in precedenza.  
  
</para></block>  
  
Quando chiama il costruttore di un monitoraggio delle modifiche derivato il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metodo, se lo stato del monitoraggio delle modifiche è già stato modificato (ovvero, lo stato monitorato già modificato quando il costruttore è stato ancora attivo) il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> verrà (metodo) Elimina automaticamente il monitoraggio delle modifiche.  
  
-il <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> è impostata su <see langword="true" /> dopo il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> viene chiamato dall'istanza di monitoraggio delle modifiche, indipendentemente dal fatto che una <see cref="T:System.Runtime.Caching.OnChangedCallback" /> oggetto è stato impostato da una chiamata al <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> (metodo) o non.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="http://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">La memorizzazione nella cache di ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Questo costruttore viene chiamato da costruttori in classi derivate per inizializzare la classe base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.Caching.ChangeMonitor> classe ha un costruttore predefinito. Tuttavia, le classi che ereditano dalla base <xref:System.Runtime.Caching.ChangeMonitor> classe e definire personalizzato il monitoraggio modifica il comportamento è necessario eseguire l'inizializzazione nel costruttore. Per altre informazioni, vedere la sezione Note per gli eredi.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il costruttore di una classe derivata deve impostare il <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> proprietà, iniziare a monitorare e chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> classe prima della restituzione. Se una dipendenza viene modificata prima dell'inizializzazione è completa (ad esempio, se non viene trovata una chiave di cache dipendente nella cache), è necessario chiamare il costruttore di <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodo prima di chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> (metodo). In questo caso, il costruttore può chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo solo dopo che il <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> viene chiamato il metodo perché il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo genera un'eccezione se non viene completata l'inizializzazione.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo viene utilizzato per rilasciare il <xref:System.Runtime.Caching.ChangeMonitor> istanza e le risorse correlate. Pubblico <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo viene richiamato per coordinare il processo di eliminazione con gli eventi principali del ciclo di vita delle classi di monitoraggio delle modifiche (ad esempio, l'inizializzazione) e per rilasciare il <xref:System.Runtime.Caching.ChangeMonitor> dell'istanza in modo che l'istanza può essere sottoposto a garbage collection. Il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo viene implementato dalle classi di monitoraggio delle modifiche per l'eliminazione delle risorse gestite e non gestite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo richiama il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo delle classi derivate solo una volta, la prima volta che viene chiamato. Le chiamate successive al <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> (metodo) non hanno alcun effetto. Dopo aver chiamato il metodo, il <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> è impostata su `true`.  
  
 Il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload deve essere chiamato per eliminare un <xref:System.Runtime.Caching.ChangeMonitor> istanza. Di seguito sono le regole per la chiamata al metodo dispose:  
  
-   Prima di un elemento viene inserito nella cache, è responsabilità del chiamante per eliminare un <xref:System.Runtime.Caching.ChangeMonitor> istanza.  
  
-   Una volta l'elemento della cache e il <xref:System.Runtime.Caching.ChangeMonitor> istanze che esso associati vengono passate a una cache, il responsabile dell'implementazione della cache che è necessario assicurarsi che <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> viene chiamato, anche se l'inserimento ha esito negativo.  
  
-   Dopo un elemento e l'identificatore associato <xref:System.Runtime.Caching.ChangeMonitor> le istanze sono passate a una cache, il chiamante deve eliminare la dipendenza non perché quando il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> viene chiamato il metodo, la chiamata viene considerata come se la dipendenza è stato modificato. Di conseguenza, il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene richiamato automaticamente.  
  
-   Tenendo conto, queste regole di <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo deve essere chiamato in uno dei modi seguenti:  
  
    -   Gli utenti devono chiamare il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload del metodo se si decide di non inserire l'istanza di monitoraggio delle modifiche in una cache.  
  
    -   L'implementazione della cache è responsabile della chiamata di <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload se l'implementazione tenta di inserire l'istanza di monitoraggio delle modifiche in una cache oggetti ma ha esito negativo dell'operazione di inserimento. Quando il tentativo di inserimento provoca un'eccezione, l'implementazione della cache deve eliminare tutte le relative dipendenze.  
  
    -   Se la voce della cache viene rimosso, l'implementazione della cache deve anche eliminare la dipendenza.  
  
 L'implementazione interna del <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> chiama automaticamente il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo dopo aver chiamato un callback che viene registrato tramite il <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> (metodo).  
  
> [!NOTE]
>  Questa eliminazione automatica durante la generazione dell'evento si verifica solo se l'inizializzazione del <xref:System.Runtime.Caching.ChangeMonitor> istanza è stata completata in precedenza.  
  
 Quando chiama il costruttore di un monitoraggio delle modifiche derivato il <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metodo, se lo stato del monitoraggio delle modifiche è già stato modificato (ovvero, lo stato monitorato già modificata quando il costruttore è stato ancora attivo) quindi <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> verrà (metodo) Elimina automaticamente il monitoraggio delle modifiche.  
  
> [!NOTE]
>  Gli utenti non devono chiamare il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> (metodo). È, tuttavia, non è possibile impedire agli utenti di chiamata al metodo. Pertanto, in caso affermativo, il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene richiamato. In tal caso, la voce della cache viene informata come se la dipendenza è stato modificato.  
  
 Per impedire alle classi derivate di eseguire l'override <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo, il metodo non è un'implementazione esplicita dell'interfaccia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'inizializzazione non è completa nella classe derivata di monitoraggio delle modifiche che ha chiamato il metodo di base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare le risorse gestite e non gestite ed eventuali riferimenti a un'istanza di <see cref="T:System.Runtime.Caching.ChangeMonitor" />. <see langword="false" /> per rilasciare solo le risorse non gestite. Quando viene passato <see langword="false" />, il metodo <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> viene chiamato da un thread <see langword="finalizer" /> e i riferimenti gestiti esterni probabilmente non sono più validi perché sono già stati raccolti nel Garbage Collector.</param>
        <summary>Rilascia tutte le risorse gestite e non gestite ed eventuali riferimenti all'istanza di <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Questo overload deve essere implementato dalle classi derivate di monitoraggio delle modifiche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il valore di `disposing` valore è `true`, tutte le risorse gestite e non gestite vengano eliminate e tutti i riferimenti a questo oggetto vengono rilasciati in modo che l'istanza di monitoraggio delle modifiche può essere sottoposto a garbage collection. Viene garantito che la base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo richiamerà implementato <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo solo una volta.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Monitoraggio delle modifiche deve implementare il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload per rilasciare tutte le risorse gestite e quando il valore di <paramref name="disposing" /> è <see langword="true" />. Il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload del metodo che ha un <paramref name="disposing" /> pari a <see langword="true" /> viene chiamato solo una volta, vale a dire, quando viene eliminata l'istanza per la prima volta. Monitoraggio delle modifiche non deve chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sottoposto a overload direttamente. Monitoraggio delle modifiche derivato può chiamare pubblico senza parametri <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo nella base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> classe.  
  
In alternativa, un monitoraggio delle modifiche può implementare un metodo del finalizzatore. In tal caso, è possibile richiamare il finalizzatore il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> (metodo) e passare un <paramref name="disposing" /> pari a <see langword="false" />. Tuttavia, si tratta in genere non necessario. Il monitoraggio delle modifiche apportate alla dipendenza viene solitamente eseguito da un servizio che mantiene un riferimento all'istanza di monitoraggio delle modifiche. Il riferimento impedisce che l'istanza di garbage collection e di conseguenza rende un metodo del finalizzatore non necessari. Per evitare perdite di memoria, quando viene modificata una dipendenza, il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodo elimina l'istanza di monitoraggio delle modifiche (a meno che l'inizializzazione non completata).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica che lo stato monitorato dalla classe <see cref="T:System.Runtime.Caching.ChangeMonitor" /> è stato modificato.</summary>
        <value>
          <see langword="true" /> se lo stato monitorato dall'istanza di <see cref="T:System.Runtime.Caching.ChangeMonitor" /> è stato modificato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile controllare il valore di questa proprietà in un oggetto derivato <xref:System.Runtime.Caching.ChangeMonitor> classe verificare se è stata modificata una dipendenza.  
  
 Il valore è impostato su `true` quando si verifica una modifica apportata alla dipendenza (vale a dire quando la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> viene chiamato). Dopo il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> viene chiamato dalla classe derivata, il valore della <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> proprietà sarà `true`, indipendentemente dal fatto che una <xref:System.Runtime.Caching.OnChangedCallback> istanza ha ricevuto alcuna notifica tramite una chiamata al <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> (metodo).  
  
> [!NOTE]
>  I chiamanti possono controllare il <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> proprietà per vedere se è stata modificata una dipendenza. Tuttavia, in un ambiente a thread multipli, un approccio più semplice e più facili da gestire è per inserire dati in un'implementazione della cache senza verificare il <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> proprietà. Le implementazioni della cache devono controllare il <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> proprietà per l'utente e non devono eseguire un'istruzione insert o impostare operazione se uno o più dipendenze associate sono già stati modificati.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiamato dal costruttore di classi derivate per indicare che l'inizializzazione è terminata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una dipendenza viene modificata prima l'inizializzazione è completa in una classe derivata, è necessario richiamare il costruttore della classe derivata di <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> (metodo).  
  
 Quando la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene richiamato, il <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> viene impostata automaticamente su `true` dal monitoraggio delle modifiche. Di conseguenza, quando chiama il costruttore del monitoraggio cambia il <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metodo, la classe di base chiama automaticamente il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> (metodo). Se l'inizializzazione è completa, il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo elimina automaticamente l'istanza di monitoraggio delle modifiche.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il costruttore di una classe derivata deve chiamare il metodo base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metodo prima che venga restituito il costruttore. Può chiamare il costruttore di una classe derivata di <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo solo dopo che <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> viene chiamato, perché il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo genera un'eccezione se non viene completata l'inizializzazione.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica che viene eliminata un'istanza derivata di una classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>
          <see langword="true" /> se l'istanza è stata eliminata. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà è impostata su `true` dopo la base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> chiamate al metodo il <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodo in una classe derivata per l'eliminazione dell'istanza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Riferimento a un metodo richiamato quando viene modificata una dipendenza.</param>
        <summary>Chiamato dalle implementazioni della cache per registrare un callback e notificare a un'istanza <see cref="T:System.Runtime.Caching.ObjectCache" /> tramite il delegato <see cref="T:System.Runtime.Caching.OnChangedCallback" /> quando una dipendenza viene modificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I responsabili dell'implementazione della cache usare questo metodo per associarsi a un monitoraggio delle modifiche. Se si associa una o più monitoraggi con l'elemento della cache delle modifiche, si passa un <xref:System.Runtime.Caching.CacheItemPolicy> istanza con una proprietà di monitoraggi di modifica popolato per l'elemento della cache. Un implementatore di cache che supporta i monitoraggi di modifica è responsabile per l'iterazione di <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> proprietà e registrare il <xref:System.Runtime.Caching.OnChangedCallback> delegati con ogni modifica monitoraggio che rileva.  
  
 Poiché il <xref:System.Runtime.Caching.OnChangedCallback> delegato include un parametro di stato facoltative, un'implementazione di monitoraggio concreta modifica può passare informazioni di stato facoltative. Il responsabile dell'implementazione della cache determina se una dipendenza esplicita del tipo di stato che passa un monitoraggio delle modifiche personalizzato come parte del metodo di callback può essere ottenuta.  
  
> [!NOTE]
>  L'API di estendibilità della cache di base non presenta requisiti per la dipendenza esplicita del tipo di stato.  
  
 L'implementazione del <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metodo determina automaticamente se lo stato del monitoraggio è già stato modificato al momento <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> viene chiamato il metodo. Se il <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> proprietà è `true`, quindi il metodo viene chiamato automaticamente le <xref:System.Runtime.Caching.OnChangedCallback> gestore evento, che è stato registrato, tramite il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> (metodo). Ciò si verifica perché è possibile che dal momento in cui che un'implementazione della cache consente di creare un monitoraggio delle modifiche, all'ora di un'implementazione della cache Ottiene il monitoraggio e collega ad esso, lo stato monitorato sottostante è stato modificato. Se lo stato è già stato modificato quindi l'oggetto che viene passato per il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo `null`.  
  
 Il <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metodo può essere richiamato solo una volta e verrà generata un'eccezione per le chiamate successive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo callback è stato già richiamato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> è <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  È necessario chiamare il <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metodo per ricevere una notifica di eventuali modifiche di dipendenza. Se una modifica apportata alla dipendenza è già verificato, il <see cref="T:System.Runtime.Caching.OnChangedCallback" /> istanza verrà chiamata quando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> viene chiamato. In caso contrario, il <see cref="T:System.Runtime.Caching.OnChangedCallback" /> istanza verrà chiamata una sola volta, quando il <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> viene chiamato o quando il <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodo viene chiamato, qualunque si verifichi prima. Il <see cref="T:System.Runtime.Caching.OnChangedCallback" /> istanza fornita dall'implementazione della cache deve rimuovere la voce della cache e se viene richiesto dal chiamante della cache, genera la modifica necessaria o l'evento di aggiornamento al chiamante originale della cache.  
  
2.  L'implementazione della cache oggetti è necessario rimuovere la voce della cache associata a una modifica apportata alla dipendenza.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Dati per l'evento di modifica. Il valore può essere <see langword="null" />.</param>
        <summary>Chiamato dalle classi derivate per generare l'evento quando viene modificata una dipendenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene chiamato quando si verificano modifiche apportate alla dipendenza. Il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene richiamato anche quando viene eliminata un'istanza di monitoraggio delle modifiche, ma l'eliminazione viene eseguita solo se non è già stato richiamato il callback.  
  
 Se il <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene chiamato prima di <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metodo viene chiamato, i dati dello stato della chiamata al <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodo viene salvato dall'implementazione della cache. Inoltre, il callback per il <xref:System.Runtime.Caching.OnChangedCallback> metodo viene richiamato immediatamente quando la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metodo viene richiamato.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta l'istanza della classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>Identificatore di un'istanza di monitoraggio delle modifiche.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> valore della proprietà in genere costituito da dati stringa nomi combinato di dipendenza che identifica in modo univoco gli identificatori di dati che viene monitorati utilizzando un <xref:System.Runtime.Caching.ChangeMonitor> istanza. Il valore della <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> proprietà è una stringa. Il valore della stringa consente di assegnare l'ID univoco del <xref:System.Runtime.Caching.ChangeMonitor> istanza.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Eseguendo l'override della proprietà, è possibile definire un'implementazione personalizzata per il valore di stringa della proprietà per assegnargli un ID univoco.</para>
        </block>
        <block subset="none" type="overrides">
          <para>Nelle classi derivate, è necessario impostare il valore della proprietà nel costruttore.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>