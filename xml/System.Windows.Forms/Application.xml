<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e752222af6c6569cb55bfb9498e89168045d4932" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51870456" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce metodi e proprietà <see langword="static" /> per la gestione di un'applicazione, ad esempio metodi per l'avvio e l'arresto di un'applicazione o per l'elaborazione di messaggi Windows e proprietà per ottenere informazioni su un'applicazione. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Application> classe include metodi per avviare e arrestare le applicazioni e i thread e per elaborare i messaggi di Windows, come indicato di seguito:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> Avvia un ciclo di messaggi dell'applicazione sul thread corrente e, facoltativamente, rende visibile un form.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> o <xref:System.Windows.Forms.Application.ExitThread%2A> interrompe un ciclo di messaggi.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> mentre il programma è in un ciclo, elabora i messaggi.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Aggiunge un filtro messaggi al message pump dell'applicazione per monitorare i messaggi di Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> Consente di interrompere la generazione di un evento o eseguire operazioni speciali prima di richiamare un gestore eventi.  
  
 Questa classe ha <xref:System.Windows.Forms.Application.CurrentCulture%2A> e <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> proprietà da ottenere o impostare informazioni per il thread corrente sulle impostazioni cultura.  
  
 È possibile creare un'istanza di questa classe.  
  
   
  
## Examples  
 Esempio di codice seguente elenca i numeri in una casella di riepilogo in un form. Ogni volta che si fa clic su `button1`, l'applicazione aggiunge un altro numero per l'elenco.  
  
 Il `Main` chiamate al metodo <xref:System.Windows.Forms.Application.Run%2A> per avviare l'applicazione, che crea il formato, `listBox1` e `button1`. Quando l'utente sceglie `button1`, il `button1_Click` metodo visualizza una <xref:System.Windows.Forms.MessageBox>. Se l'utente fa clic `No` nella <xref:System.Windows.Forms.MessageBox>, il `button1_Click` metodo aggiunge un numero all'elenco. Se l'utente sceglie `Yes`, l'applicazione chiama <xref:System.Windows.Forms.Application.Exit%2A> per elaborare i messaggi rimanenti nella coda e terminare l'esecuzione.  
  
> [!NOTE]
>  La chiamata a <xref:System.Windows.Forms.Application.Exit%2A> avrà esito negativo in attendibilità parziale.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementazione dell'interfaccia <see cref="T:System.Windows.Forms.IMessageFilter" /> che si vuole installare.</param>
        <summary>Aggiunge un filtro messaggi per il monitoraggio dei messaggi di Windows al momento dell'indirizzamento alle rispettive destinazioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il filtro messaggi per impedire che vengano generati eventi specifici o per eseguire operazioni speciali per un evento prima che venga passata al gestore eventi. I filtri messaggi sono univoci per un thread specifico.  
  
 Per impedire che un messaggio venga inviato, il `value` istanza del parametro passato a questo metodo deve eseguire l'override di <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> metodo con il codice per gestire il messaggio. Il metodo deve restituire `false`.  
  
> [!CAUTION]
>  Aggiunta di filtri messaggi al message pump per un'applicazione può influire negativamente sulle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente crea un filtro messaggio denominato `TestMessageFilter`. Questo filtro consente di bloccare tutti i messaggi relativi al pulsante sinistro del mouse. Prima è possibile usare un filtro dei messaggi, è necessario fornire un'implementazione per il <xref:System.Windows.Forms.IMessageFilter> interfaccia.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il chiamante può chiudere l'applicazione.</summary>
        <value>
          <see langword="true" /> se il chiamante può chiudere l'applicazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `false` se viene chiamato da un <xref:System.Windows.Forms.Control> ospitati all'interno di un Web browser. Di conseguenza, il <xref:System.Windows.Forms.Control> non è possibile chiudere il <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'applicazione è in fase di chiusura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario collegare i gestori eventi per il <xref:System.Windows.Forms.Application.Exit%2A> eventi per l'esecuzione non gestita, le attività richieste prima dell'arresto dell'applicazione. È possibile chiudere i file aperti da questa applicazione o dispose di oggetti che non è stato recuperato dalla garbage collection.  
  
 Poiché si tratta di un evento statico, è necessario disconnettere eventuali gestori di eventi associati a questo evento nel <xref:System.Windows.Forms.Application.ApplicationExit> stesso gestore eventi. Se non si scollega questi gestori, verranno rimangono collegati all'evento e continuare a consumare memoria.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare due forme e chiude l'applicazione quando entrambe le forme vengono chiusi. Quando l'applicazione viene avviato e viene chiusa, viene memorizzata la posizione di ogni modulo. In questo esempio viene illustrato come utilizzare il <xref:System.Windows.Forms.Application.ApplicationExit> evento sapere quando le posizioni del form devono essere mantenute nel file e quando il `FileStream` deve essere chiuso.  
  
 La classe `MyApplicationContext` eredita da <xref:System.Windows.Forms.ApplicationContext> e tiene traccia di quando ogni form viene chiuso e viene terminato il thread corrente quando entrambi sono. La classe ricorda la posizione di ogni modulo quando viene chiuso. Quando il <xref:System.Windows.Forms.Application.ApplicationExit> evento si verifica, la classe scrive le posizioni della ognuno per l'utente al file. I dati di posizione del form viene archiviati in un file denominato `appdata.txt` creato in una posizione specificata da <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Il `Main` chiamate al metodo `Application.Run(context)` per avviare l'applicazione ha la <xref:System.Windows.Forms.ApplicationContext>.  
  
 Questo codice è tratto dall'esempio illustrato nel <xref:System.Windows.Forms.ApplicationContext> Cenni preliminari sulla classe. Vedere <xref:System.Windows.Forms.ApplicationContext> per il listato di codice completo.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso relativo ai dati dell'applicazione condivisi fra tutti gli utenti.</summary>
        <value>Percorso relativo ai dati dell'applicazione condivisi fra tutti gli utenti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un percorso non esiste, ne viene creato nel formato seguente:  
  
 *Percorso di base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> verifica prima se l'assembly contenente l'eseguibile principale dispone di `AssemblyInformationalVersion` attributo su di esso. Se è presente, questo attributo viene utilizzato per entrambi <xref:System.Windows.Forms.Application.ProductVersion%2A> e <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Se questo attributo non esiste, entrambe le proprietà utilizzano invece la versione del file eseguibile.  
  
 Il percorso sarà diverso a seconda se l'applicazione Windows Forms viene distribuito usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] le applicazioni vengono archiviate in una cache di applicazione per ogni utente in C:\Documents and Settings\\*username* directory. Per altre informazioni, vedere [l'accesso ai dati locali e remoti in applicazioni ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la chiave del Registro di sistema relativa ai dati dell'applicazione condivisi fra tutti gli utenti.</summary>
        <value>Oggetto <see cref="T:Microsoft.Win32.RegistryKey" /> che rappresenta la chiave del Registro di sistema dei dati dell'applicazione condivisi tra tutti gli utenti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la chiave non esiste, viene creato nel formato seguente:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome della società associato all'applicazione.</summary>
        <value>Nome della società.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente ottiene questa proprietà e consente di visualizzare il relativo valore in una casella di testo. Nell'esempio si presuppone che `textBox1` è stato inserito in un form.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni specifiche delle impostazioni cultura per il thread corrente.</summary>
        <value>Oggetto <see cref="T:System.Globalization.CultureInfo" /> che rappresenta le informazioni specifiche delle impostazioni cultura per il thread corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente ottiene questa proprietà e consente di visualizzare il relativo valore in una casella di testo. Nell'esempio si presuppone che `textBox1` è stato inserito in un form.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre impostare questa proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il linguaggio di input corrente per il thread in esecuzione.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.InputLanguage" /> che rappresenta il linguaggio di input corrente per il thread in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente ottiene questa proprietà e consente di visualizzare il relativo valore in una casella di testo. Nell'esempio si presuppone che `textBox1` è stato inserito in un form.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elabora tutti i messaggi di Windows attualmente presenti nella coda di messaggi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si esegue un modulo di Windows, viene creato il nuovo form, quindi rimane in attesa di eventi da gestire. Ogni volta che il modulo gestisce un evento, lo elabora tutto il codice associato all'evento. Tutti gli altri eventi di attesa nella coda. Mentre il codice gestisce l'evento, l'applicazione non risponde. Ad esempio, la finestra non viene aggiornata se un'altra finestra viene trascinata nella parte superiore.  
  
 Se si chiama <xref:System.Windows.Forms.Application.DoEvents%2A> nel codice, l'applicazione può gestire gli altri eventi. Ad esempio, se si dispone di un form che consente di aggiungere dati a un <xref:System.Windows.Forms.ListBox> e aggiungere <xref:System.Windows.Forms.Application.DoEvents%2A> al codice, il form viene ridisegnato quando un'altra finestra viene trascinata su di esso. Se si rimuovono <xref:System.Windows.Forms.Application.DoEvents%2A> dal codice, il form non verrà ridisegnato fino al termine del gestore dell'evento click del pulsante di esecuzione. Per altre informazioni sulla messaggistica, vedere [Input dell'utente in Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 A differenza di Visual Basic 6.0, il <xref:System.Windows.Forms.Application.DoEvents%2A> metodo non chiama il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (metodo).  
  
 In genere, si usa questo metodo in un ciclo per elaborare i messaggi.  
  
> [!CAUTION]
>  Chiamando questo metodo, il thread corrente deve essere sospesa mentre vengono elaborati tutti i messaggi in attesa della finestra. Se un messaggio determina un evento da attivare, quindi possono eseguire altre aree del codice dell'applicazione. Ciò può causare l'applicazione può presentare comportamenti imprevisti difficili da eseguire il debug. Se si eseguono operazioni o i calcoli che richiedono molto tempo, è spesso preferibile eseguire le operazioni in un nuovo thread. Per altre informazioni sulla programmazione asincrona, vedere [Asynchronous Programming Model (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di <xref:System.Windows.Forms.Application.DoEvents%2A> (metodo). Quando si esegue l'esempio, un utente può selezionare i file di grafica da un <xref:System.Windows.Forms.OpenFileDialog>. I file selezionati vengono visualizzati nel form. Il <xref:System.Windows.Forms.Application.DoEvents%2A> metodo impone un aggiornamento del form per ogni file di grafica aperto. Per eseguire questo esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.PictureBox> denominate `PictureBox1`, un <xref:System.Windows.Forms.OpenFileDialog> denominato `OpenFileDialog1`e un pulsante denominato `fileButton`. Chiamare il `InitializePictureBox` e `InitializeOpenFileDialog` metodi dal costruttore del form o `Load` (metodo).  
  
> [!NOTE]
>  In Visual Studio, se si aggiunge un <xref:System.Windows.Forms.OpenFileDialog> al form mediante un'operazione di trascinamento, dovrai modificare quanto segue `InitializeOpenFileDialog` metodo rimuovendo la riga che crea una nuova istanza della <xref:System.Windows.Forms.OpenFileDialog>.  
  
 Si suppone inoltre che il <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> eventi del <xref:System.Windows.Forms.Button> controllo e il <xref:System.Windows.Forms.FileDialog.FileOk> evento del <xref:System.Windows.Forms.OpenFileDialog> connessi ai gestori eventi definiti nell'esempio. Quando si esegue l'esempio, visualizzare la finestra di dialogo facendo clic sul pulsante.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abilita gli stili visivi per l'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente gli stili di visualizzazione per l'applicazione. Stili visivi sono i colori, tipi di carattere e altri elementi visivi che formano un tema del sistema operativo. I controlli verranno disegnati con stili visivi se il controllo e il sistema operativo lo supporta. Per avere un effetto <xref:System.Windows.Forms.Application.EnableVisualStyles> deve essere chiamato prima di creare tutti i controlli nell'applicazione; in genere, <xref:System.Windows.Forms.Application.EnableVisualStyles> è la prima riga nel `Main` (funzione). Un manifesto separato non è necessaria per abilitare gli stili di visualizzazione quando si chiama <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Prima di .NET Framework 2.0, il `FlatStyle` proprietà di alcuni controlli, ad esempio i controlli che derivano dal <xref:System.Windows.Forms.ButtonBase>, doveva essere impostata su <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> affinché i controlli deve essere disegnato con stili visivi. Nelle applicazioni scritte con .NET Framework 2.0, questo è più necessario.  
  
> [!NOTE]
>  Questo metodo non avrà alcun effetto per i controlli ospitati in Internet Explorer.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> nella `Main` funzione per attivare gli stili di visualizzazione per l'applicazione.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'applicazione sta per entrare in uno stato modale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stato eliminato o causerà perdite di memoria.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore dell'evento segnala l'occorrenza del <xref:System.Windows.Forms.Application.EnterThreadModal> evento. Questo report consente di capire quando l'evento si verifica e può agevolare il debug. Per creare report su più eventi o sugli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un controllo Windows Form e verificare che il gestore dell'evento è associato il <xref:System.Windows.Forms.Application.EnterThreadModal> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Richiede <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> dell'autorizzazione per l'ascolto dell'evento.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso del file eseguibile che ha avviato l'applicazione, comprensivo del nome dell'eseguibile.</summary>
        <value>Percorso e nome del file eseguibile che ha avviato l'applicazione.  
  
Questo percorso sarà diverso a seconda dell'implementazione o meno dell'applicazione Windows Forms con l'uso dell'oggetto [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] le applicazioni vengono archiviate in una cache di applicazione per ogni utente in C:\Documents and Settings\\*username* directory. Per altre informazioni, vedere [l'accesso ai dati locali e remoti in applicazioni ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per ottenere il percorso. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica a tutti i message pump di terminare l'esecuzione, quindi, una volta elaborati i messaggi, chiude tutte le finestre dell'applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica a tutti i message pump di terminare l'esecuzione, quindi, una volta elaborati i messaggi, chiude tutte le finestre dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Application.Exit%2A> viene interrotto cicli di messaggi in esecuzione in tutti i thread e chiude tutte le finestre dell'applicazione. Questo metodo non necessariamente forzare la chiusura dell'applicazione. Il <xref:System.Windows.Forms.Application.Exit%2A> metodo viene chiamato in genere da all'interno di un ciclo di messaggi e forza <xref:System.Windows.Forms.Application.Run%2A> da restituire. Per uscire da un ciclo di messaggi solo il thread corrente, chiamare <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> Genera i seguenti eventi ed esegue le azioni condizionali associate:  
  
-   Oggetto <xref:System.Windows.Forms.Form.FormClosing> evento viene generato per ogni form rappresentato dal <xref:System.Windows.Forms.Application.OpenForms%2A> proprietà. Questo evento può essere annullato impostando il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del loro <xref:System.Windows.Forms.FormClosingEventArgs> parametro per `true`.  
  
-   Se uno o più dei gestori di Annulla l'evento, quindi <xref:System.Windows.Forms.Application.Exit%2A> restituisce senza eseguire ulteriori azioni. In caso contrario, un <xref:System.Windows.Forms.Form.FormClosed> evento viene generato per ogni modulo aperto, quindi vengono chiusi tutti i cicli di messaggi in esecuzione e i moduli.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Application.Exit%2A> metodo non genera il <xref:System.Windows.Forms.Form.Closed> e <xref:System.Windows.Forms.Form.Closing> eventi che sono obsoleti in [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 Esempio di codice seguente elenca i numeri in una casella di riepilogo in un form. Ogni volta che si fa clic su `button1`, l'applicazione aggiunge un altro numero per l'elenco.  
  
 Il `Main` chiamate al metodo <xref:System.Windows.Forms.Application.Run%2A> per avviare l'applicazione, che crea il formato, `listBox1`, e `button1`. Quando l'utente sceglie `button1`, il `button1_Click` metodo aggiunge i numeri di uno a tre nella casella di riepilogo e viene visualizzato un <xref:System.Windows.Forms.MessageBox>. Se l'utente fa clic **No** nel <xref:System.Windows.Forms.MessageBox>, il `button1_Click` metodo aggiunge un altro numero per l'elenco. Se l'utente sceglie **Yes**, l'applicazione chiama <xref:System.Windows.Forms.Application.Exit%2A>, per elaborare tutti i messaggi rimanenti nella coda e terminare l'esecuzione.  
  
 Nell'esempio si presuppone che `listBox1` e `button1` siano stati creata un'istanza e inseriti in un form.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Restituisce un valore che indica se l'uscita è stata annullata da un oggetto <see cref="T:System.Windows.Forms.Form" /> qualsiasi all'interno dell'applicazione.</param>
        <summary>Indica a tutti i message pump di terminare l'esecuzione, quindi, una volta elaborati i messaggi, chiude tutte le finestre dell'applicazione.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">L'autorizzazione terminare un in esecuzione il thread dell'applicazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esce dal ciclo di messaggi sul thread corrente e chiude tutte le finestre sul thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per chiudere il ciclo di messaggi del thread corrente. Questo metodo fa in modo che la chiamata a <xref:System.Windows.Forms.Application.Run%2A> per il thread corrente da restituire. Per chiudere l'intera applicazione, chiamare <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio di evento di Windows da filtrare.</param>
        <summary>Esegue eventuali filtri su una finestra di messaggio, quindi restituisce una copia del messaggio modificato.</summary>
        <returns>
          <see langword="True" /> se sono stati elaborati i filtri; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'applicazione conclude l'elaborazione e sta per entrare nello stato inattivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se sono presenti attività che è necessario eseguire prima che il thread diventi inattivo, collegarli a questo evento.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stato eliminato o causerà perdite di memoria.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore dell'evento segnala l'occorrenza del <xref:System.Windows.Forms.Application.Idle> evento. Questo report consente di capire quando l'evento si verifica e può agevolare il debug. Per creare report su più eventi o sugli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un modulo di Windows e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Application.Idle> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'applicazione sta per uscire da uno stato modale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stato eliminato o causerà perdite di memoria.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore dell'evento segnala l'occorrenza del <xref:System.Windows.Forms.Application.LeaveThreadModal> evento. Questo report consente di capire quando l'evento si verifica e può agevolare il debug. Per creare report su più eventi o sugli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un controllo Windows Form e verificare che il gestore dell'evento è associato il <xref:System.Windows.Forms.Application.LeaveThreadModal> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso relativo ai dati dell'applicazione di un utente locale e non comune.</summary>
        <value>Percorso relativo ai dati dell'applicazione di un utente locale con profilo non comune.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un utente locale è uno con profilo utente viene archiviato nel sistema in cui l'utente connesso. Se un percorso non esiste, ne viene creato nel formato seguente:  
  
 *Percorso di base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Un tipico percorso di base è C:\Documents and Settings \\\*username*Settings\Application Data. Questo percorso sarà diverso, tuttavia, se l'applicazione Windows Forms viene distribuita usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Crea una directory di dati dell'applicazione che è isolata da tutte le altre applicazioni. Per altre informazioni, vedere [l'accesso ai dati locali e remoti in applicazioni ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare due forme e chiude l'applicazione quando entrambe le forme vengono chiusi. Quando l'applicazione viene avviato e viene chiusa, viene memorizzata la posizione di ogni modulo. Sebbene questo esempio viene illustrato come utilizzare il <xref:System.Windows.Forms.Application.UserAppDataPath%2A> proprietà per archiviare i dati dell'applicazione per l'utente, il <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> è invece possibile usare.  
  
 Il `MyApplicationContext` classe eredita da <xref:System.Windows.Forms.ApplicationContext> e tiene traccia del momento ogni form viene chiuso e viene terminato il thread corrente quando entrambi sono. La classe archivia le posizioni di ciascun form per l'utente. I dati di posizione del form viene archiviati in un file denominato `Appdata.txt` creato in una posizione specificata da <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Il `Main` chiamate al metodo `Application.Run(context)` per avviare l'applicazione ha la <xref:System.Windows.Forms.ApplicationContext>.  
  
 Questo codice è tratto dall'esempio illustrato nel <xref:System.Windows.Forms.ApplicationContext> Cenni preliminari sulla classe. Codice non viene visualizzato allo scopo di brevità. Vedere <xref:System.Windows.Forms.ApplicationContext> per il listato di codice completo.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se esiste un ciclo di messaggi sul thread corrente.</summary>
        <value>
          <see langword="true" /> se esiste un ciclo di messaggi; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante l'hosting di Windows Form in altri ambienti, ad esempio le applicazioni non gestite, questa proprietà restituirà sempre `false`. Usare <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> per indicare a Windows Form se l'ambiente di hosting dispone ancora di un ciclo di messaggi attivi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizializza OLE sul thread corrente.</summary>
        <returns>Uno dei valori di <see cref="T:System.Threading.ApartmentState" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare qualsiasi `Microsoft.Win32` metodo che richiede OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> controlla innanzitutto se è stato inizializzato OLE sul thread corrente. In caso contrario, inizializza il thread per OLE.  
  
> [!NOTE]
>  A meno che un thread chiama direttamente i metodi OLE, è necessario chiamare questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">Oggetto <see cref="T:System.Exception" /> che rappresenta l'eccezione generata.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Application.ThreadException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.Windows.Forms.Application.OnThreadException%2A> per generare un'eccezione che interrompa l'elaborazione dell'applicazione.  
  
 Il <xref:System.Windows.Forms.Application> classe ha un <xref:System.Windows.Forms.Application.ThreadException> evento. È possibile collegare un gestore eventi all'evento per eseguire qualsiasi elaborazione personalizzata, è necessario per le eccezioni non gestite. Se non si collega un gestore eventi, <xref:System.Windows.Forms.Application.OnThreadException%2A> eseguirà il comportamento predefinito, che comporta la visualizzazione di una finestra di dialogo per informare l'utente che si è verificato un errore.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> implementa il comportamento predefinito dell'eccezione per le eccezioni non gestite che si verificano solo nel thread di Windows Form. Gestione delle eccezioni non gestite in altri thread dal <xref:System.AppDomain.UnhandledException> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di tutti i form aperti che appartengono all'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.FormCollection" /> contenente tutti i form attualmente aperti appartenenti a questa applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Application.OpenForms%2A> proprietà rappresenta una raccolta di sola lettura di moduli di proprietà dell'applicazione. Questa raccolta è possibile eseguire ricerche in base alla posizione di indice o tramite il <xref:System.Windows.Forms.Control.Name%2A> del <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Chiamante deve disporre dell'autorizzazione per accedere a tutte le finestre, come definito dal <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> pari al <see cref="T:System.Security.Permissions.UIPermissionWindow" /> enumerazione.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del prodotto associato all'applicazione.</summary>
        <value>Nome del prodotto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` proviene dai metadati dell'assembly contenente il form principale dell'applicazione corrente. È possibile impostarlo impostando <xref:System.Reflection.AssemblyProductAttribute> all'interno del manifesto dell'assembly. Per altre informazioni, vedere [manifesto dell'Assembly](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 Esempio di codice seguente ottiene questa proprietà e consente di visualizzare il relativo valore in una casella di testo. Nell'esempio si presuppone che `textBox1` è stato inserito in un form.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la versione del prodotto associata all'applicazione.</summary>
        <value>Versione del prodotto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, viene visualizzato un numero di versione come *numero principale*. *numero secondario*. *numero di build*. *numero parte privato*. È possibile impostarlo in modo esplicito impostando la versione dell'assembly all'interno del manifesto dell'assembly. Per altre informazioni, vedere [manifesto dell'Assembly](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> verifica prima se l'assembly contenente l'eseguibile principale dispone di `AssemblyInformationalVersion` attributo su di esso. Se è presente, questo attributo viene utilizzato per entrambi <xref:System.Windows.Forms.Application.ProductVersion%2A> e <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Se questo attributo non esiste, entrambe le proprietà utilizzano invece la versione del file eseguibile.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene questa proprietà e consente di visualizzare il relativo valore in una casella di testo. Nell'esempio si presuppone che `textBox1` è stato inserito in un form.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetti <see cref="T:System.EventArgs" /> da passare all'evento <see cref="E:System.Windows.Forms.Application.Idle" />.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Application.Idle" /> negli scenari inclusi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato durante l'hosting di Windows Form in un altro ambiente, ad esempio un'applicazione non gestita. È necessario chiamare <xref:System.Windows.Forms.Application.RaiseIdle%2A> quando l'applicazione host entra in uno stato di inattività. In questo modo alcuni controlli Windows Form e i componenti per svolgere il lavoro importante in background mentre l'utente non interagisce con l'applicazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metodo da chiamare per la verifica di Windows Form dell'invio di messaggi da parte dell'ambiente di hosting.</param>
        <summary>Registra un callback per verificare se il ciclo di messaggi viene eseguito in ambienti host.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato durante l'hosting di Windows Form in un altro ambiente, ad esempio un'applicazione non gestita. Negli ambienti ospitati il <xref:System.Windows.Forms.Application.MessageLoop%2A> proprietà restituirà sempre false se non elabora i messaggi Windows Form. Usare questo callback per indicare a Windows Form se l'ambiente di hosting sta ancora elaborando i messaggi.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementazione dell'oggetto <see cref="T:System.Windows.Forms.IMessageFilter" /> da rimuovere dall'applicazione.</param>
        <summary>Rimuove un filtro messaggi dal message pump dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile rimuovere un filtro dei messaggi quando non si desidera acquisire i messaggi di Windows prima che vengano inviati.  
  
   
  
## Examples  
 Prima è possibile usare un filtro dei messaggi, è necessario fornire un'implementazione per il <xref:System.Windows.Forms.IMessageFilter> interfaccia. La classe seguente crea un filtro messaggio denominato `TestMessageFilter`. Questo filtro consente di bloccare tutti i messaggi relativi al pulsante sinistro del mouse.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che specifica se l'applicazione corrente sta creando i controlli con gli stili visivi.</summary>
        <value>
          <see langword="true" /> se gli stili visivi sono abilitati per i controlli nell'area client delle finestre dell'applicazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si disegna un controllo personalizzato, usare questa proprietà per decidere se disegnare il controllo con o senza stili di visualizzazione, in modo che il suo aspetto sia coerenza con altri controlli nell'applicazione.  
  
 La tabella seguente illustra le quattro condizioni necessarie affinché <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> da restituire `true`.  
  
|Condizione|Descrizione|  
|---------------|-----------------|  
|Il sistema operativo supporta gli stili di visualizzazione|Per verificare questa condizione separatamente, usare la proprietà <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> della classe <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|L'utente ha abilitato gli stili di visualizzazione nel sistema operativo|Per verificare questa condizione separatamente, usare la proprietà <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> della classe <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Stili di visualizzazione sono abilitati nell'applicazione|Per abilitare gli stili di visualizzazione per un'applicazione, chiamare il metodo <xref:System.Windows.Forms.Application.EnableVisualStyles> o usare un manifesto dell'applicazione in cui si specifica che per disegnare i controlli verrà usata ComCtl32.dll versione 6 o successiva.|  
|Stili di visualizzazione vengono usati per disegnare l'area client delle finestre dell'applicazione|Per verificare questa condizione separatamente, usare la proprietà <xref:System.Windows.Forms.Application.VisualStyleState%2A> della classe <xref:System.Windows.Forms.Application> e verificare che abbia il valore <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> o <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude l'applicazione e avvia immediatamente una nuova istanza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il motivo più comune per la chiamata `Restart` consiste nell'avviare una nuova versione dell'applicazione in cui è stato scaricato tramite [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] usando la `Update` o `UpdateAsync` (metodo).  
  
 Le applicazioni vengono riavviate nel contesto in cui sono stati eseguiti inizialmente. Se l'applicazione è stata avviata tramite un URL che punta direttamente al file eseguibile principale dell'applicazione, verrà riavviata con lo stesso URL. Se l'applicazione è un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] un'applicazione, verrà riavviata con [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Se l'applicazione è stata originariamente fornito le opzioni della riga di comando quando eseguito per primo, <xref:System.Windows.Forms.Application.Restart%2A> verrà avviata l'applicazione con le stesse opzioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il codice non è un'applicazione Windows Form. Non è possibile chiamare questo metodo in questo contesto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Richiede <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> l'autorizzazione.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia l'esecuzione di un ciclo di messaggi dell'applicazione standard sul thread corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'esecuzione di un ciclo di messaggi dell'applicazione standard sul thread corrente senza un form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nei moduli di Windows o basata su Win32 l'applicazione, un ciclo di messaggi è una routine nel codice che elabora eventi utente, ad esempio clic del mouse e sequenze di tasti. Ogni applicazione basata su Windows in esecuzione è necessario un ciclo di messaggi attivi, chiamato il ciclo di messaggi principale. Quando il ciclo di messaggi principale è chiusa, l'applicazione viene chiusa. In Windows Form, il ciclo viene chiuso quando il <xref:System.Windows.Forms.Application.Exit%2A> metodo viene chiamato, o quando il <xref:System.Windows.Forms.Application.ExitThread%2A> viene chiamato sul thread che esegue il ciclo di messaggi principale.  
  
 La maggior parte degli sviluppatori di Windows Form non saranno necessario usare questa versione del metodo. È consigliabile usare il <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> overload per avviare un'applicazione con un form principale, in modo che l'applicazione termina quando viene chiuso il modulo principale. Per tutti gli altri casi, usare il <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> rapporto di overload, che supporta la fornitura di un <xref:System.Windows.Forms.ApplicationContext> oggetto per controllare meglio la durata dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Un ciclo di messaggi principale è già in esecuzione su questo thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">Oggetto <see cref="T:System.Windows.Forms.ApplicationContext" /> nel quale l'applicazione viene eseguita.</param>
        <summary>Avvia l'esecuzione di un ciclo di messaggi dell'applicazione standard sul thread corrente con un oggetto <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il ciclo di messaggi viene eseguita fino al <xref:System.Windows.Forms.Application.Exit%2A> oppure <xref:System.Windows.Forms.Application.ExitThread%2A> viene chiamato o <xref:System.Windows.Forms.Application.ThreadExit> evento viene generato per l'oggetto di contesto.  
  
   
  
## Examples  
 Nell'esempio vengono visualizzati due forme e chiude l'applicazione quando entrambe le forme vengono chiusi. Quando l'applicazione viene avviato e viene chiusa, viene memorizzata la posizione di ogni modulo. In questo esempio illustra come usare un <xref:System.Windows.Forms.ApplicationContext>, insieme al `Application.Run(context)` (metodo), per visualizzare più moduli all'avvio dell'applicazione.  
  
 La classe `MyApplicationContext` eredita da <xref:System.Windows.Forms.ApplicationContext> e tiene traccia del momento ogni form viene chiuso e viene terminato il thread corrente quando entrambi sono. La classe archivia le posizioni di ciascun form per l'utente. I dati di posizione del form viene archiviati in un file denominato `Appdata.txt` creato in una posizione specificata da <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Il `Main` chiamate al metodo `Application.Run(context)` per avviare l'applicazione ha la <xref:System.Windows.Forms.ApplicationContext>.  
  
 Il codice per il `AppForm1` e `AppForm2` form non viene visualizzata allo scopo di brevità. Vedere il <xref:System.Windows.Forms.ApplicationContext> Cenni preliminari sulla classe per il listato di codice completo.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Un ciclo di messaggi principale è già in esecuzione su questo thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">Oggetto <see cref="T:System.Windows.Forms.Form" /> che rappresenta il form da rendere visibile.</param>
        <summary>Avvia l'esecuzione di un ciclo di messaggi dell'applicazione standard sul thread corrente e rende visibile il form specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, la funzione principale di un'applicazione chiama questo metodo e passa a esso la finestra principale dell'applicazione.  
  
 Questo metodo aggiunge un gestore eventi per il `mainForm` parametro per il <xref:System.Windows.Forms.Form.Closed> evento. Chiamate del gestore eventi <xref:System.Windows.Forms.Application.ExitThread%2A> per pulire l'applicazione.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Dispose%2A> metodo di <xref:System.Windows.Forms.Form> classe verrà chiamata prima della restituzione di questo metodo.  
  
   
  
## Examples  
 Esempio di codice seguente elenca i numeri in una casella di riepilogo in un form. Ogni volta che si fa clic su `button1`, l'applicazione aggiunge un altro numero per l'elenco.  
  
 Il `Main` chiamate al metodo <xref:System.Windows.Forms.Application.Run%2A> per avviare l'applicazione, che crea il formato, `listBox1`, e `button1`. Quando l'utente sceglie `button1`, il `button1_Click` metodo aggiunge i numeri di uno a tre nella casella di riepilogo e viene visualizzato un <xref:System.Windows.Forms.MessageBox>. Se l'utente fa clic **No** nel <xref:System.Windows.Forms.MessageBox>, il `button1_Click` metodo aggiunge un altro numero per l'elenco. Se l'utente sceglie **Yes**, l'applicazione chiama <xref:System.Windows.Forms.Application.Exit%2A> per elaborare i messaggi rimanenti nella coda e terminare l'esecuzione.  
  
 Nell'esempio si presuppone che `listBox1` e `button1` siano stati creati e inseriti in un form.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Un ciclo di messaggi principale è già in esecuzione sul thread corrente.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la stringa di formato da applicare ai titoli di finestre di primo livello quando vengono visualizzati con un'intestazione di avviso.</summary>
        <value>Stringa di formato da applicare ai titoli di finestre di primo livello.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre impostare questa proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito da usare per i nuovi controlli. Se <see langword="true" />, i nuovi controlli che supportano <c>UseCompatibleTextRendering</c> usano la classe <see cref="T:System.Drawing.Graphics" /> basata su [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] per il rendering del testo. Se <see langword="false" />, i nuovi controlli usano la classe <see cref="T:System.Windows.Forms.TextRenderer" /> basata su [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)].</param>
        <summary>Imposta il valore predefinito per l'intera applicazione relativo alla proprietà <c>UseCompatibleTextRendering</c> definita su determinati controlli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Determinati controlli Windows Form possono eseguire il rendering del testo utilizzando il <xref:System.Windows.Forms.TextRenderer> (classe), che si basa sul [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] libreria grafica, o il <xref:System.Drawing.Graphics> (classe), in base il [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] libreria grafica. Questa modifica è stata apportata nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] a causa di problemi di prestazioni e la localizzazione con [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Uso <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> per impostare il valore predefinito di `UseCompatibleTextRendering` proprietà per i controlli che lo supportano.  
  
 Il `UseCompatibleTextRendering` proprietà è concepita per offrire compatibilità visiva tra i controlli Windows Form di tale testo rendering tramite il <xref:System.Windows.Forms.TextRenderer> classe e [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] e [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] le applicazioni che eseguono il rendering del testo personalizzato utilizzando il <xref:System.Drawing.Graphics>classe. Nella maggior parte dei casi, se l'applicazione non viene aggiornata dal [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] oppure [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], è consigliabile lasciare `UseCompatibleTextRendering` impostato sul valore predefinito di `false`.  
  
 Il [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basata <xref:System.Windows.Forms.TextRenderer> classe è stata introdotta nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] per migliorare le prestazioni, rendere il testo un aspetto migliore e migliorare il supporto per caratteri internazionali. Nelle versioni precedenti del [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], il [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basato su <xref:System.Drawing.Graphics> classe usata per eseguire tutti i rendering del testo. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Calcola la spaziatura e ritorno a capo automatico in modo diverso da [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. In un'applicazione Windows Forms che utilizza il <xref:System.Drawing.Graphics> classe per il rendering del testo, ciò potrebbe causare il testo per i controlli che utilizzano <xref:System.Windows.Forms.TextRenderer> diversa da altro testo nell'applicazione. Per risolvere problemi di compatibilità, è possibile impostare il `UseCompatibleTextRendering` proprietà `true`. Per impostare `UseCompatibleTextRendering` al `true` per tutti i controlli supportati nell'applicazione, chiamare il <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> con un parametro di metodo `true`.  
  
 Non si deve mai chiamare questo metodo se il codice Windows Form è ospitato in un'altra applicazione, ad esempio Internet Explorer. Chiamare questo metodo solo in applicazioni autonome di Windows Form.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Per impostare il valore predefinito per `UseCompatibleTextRendering` nelle [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] o versione successiva, vedere <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 Nelle [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] o versioni successive, una chiamata a <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> viene generato automaticamente nel file Program.cs. Per modificare il valore predefinito per il rendering di testo, modificare il codice generato.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È possibile chiamare questo metodo solo prima della creazione della prima finestra da parte dell'applicazione Windows Form.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">Oggetto <see cref="T:System.Windows.Forms.PowerState" /> che indica la modalità di alimentazione a cui passare.</param>
        <param name="force">
          <see langword="true" /> per forzare immediatamente la modalità di sospensione; <see langword="false" /> per fare in modo che Windows invii una richiesta di sospensione a ogni applicazione.</param>
        <param name="disableWakeEvent">
          <see langword="true" /> per disabilitare il ripristino dello stato di alimentazione del sistema allo stato attivo su un evento di riattivazione, <see langword="false" /> per abilitare il ripristino dello stato di alimentazione del sistema allo stato attivo su un evento di riattivazione.</param>
        <summary>Sospende o mette in stato di ibernazione il sistema oppure ne richiede la sospensione o l’ibernazione.</summary>
        <returns>
          <see langword="true" /> se il sistema è in fase di sospensione; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un'applicazione non risponde a una richiesta di sospensione entro 20 secondi, Windows determina che è in uno stato non risponde e che l'applicazione può essere inserita in sospensione o terminazione. Una volta che un'applicazione risponde a una richiesta di sospensione, tuttavia, può richiedere tutto il tempo è necessario pulire le risorse e arrestare i processi attivi.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica all'applicazione come comportarsi in caso di eccezioni non gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente imposta i gestori eventi per le eccezioni che si verificano nei thread di Windows Form e le eccezioni che si verificano in altri thread. Imposta <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> in modo che tutte le eccezioni vengono gestite dall'applicazione, indipendentemente dalle impostazioni nel file di configurazione dell'applicazione utente. Usa il <xref:System.Windows.Forms.Application.ThreadException> eventi per gestire le eccezioni di thread dell'interfaccia utente e il <xref:System.AppDomain.UnhandledException> eventi per gestire le eccezioni di thread non dell'interfaccia utente. Poiché <xref:System.AppDomain.UnhandledException> non è possibile impedire a un'applicazione da terminare, nell'esempio viene semplicemente registrato l'errore nel registro eventi dell'applicazione prima della chiusura.  
  
 Questo esempio si presuppone che siano stati definiti due <xref:System.Windows.Forms.Button> controlli `button1` e `button2`via di <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">Valore <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> che descrive il comportamento dell'applicazione nel caso in cui un'eccezione venga generata senza essere rilevata.</param>
        <summary>Indica all'applicazione come comportarsi in caso di eccezioni non gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spesso non è possibile rilevare tutte le eccezioni generate da Windows Form. In questo modo, è possibile indicare all'applicazione se dovrebbe intercettare tutti non gestiti le eccezioni generate dai componenti di Windows Form e continuare a funzionare, o se deve esporli all'utente e interrompere l'esecuzione.  
  
 Chiamare <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> prima che si crea un'istanza del form principale dell'applicazione utilizzando il <xref:System.Windows.Forms.Application.Run%2A> (metodo).  
  
 Per intercettare le eccezioni che si verificano nella creazione di thread e di Windows Form, usare il <xref:System.AppDomain.UnhandledException> gestore dell'evento.  
  
   
  
## Examples  
 Esempio di codice seguente imposta i gestori eventi per le eccezioni che si verificano nei thread di Windows Form e le eccezioni che si verificano in altri thread. Imposta <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> in modo che tutte le eccezioni vengono gestite dall'applicazione, indipendentemente dalle impostazioni nel file di configurazione dell'applicazione utente. Usa il <xref:System.Windows.Forms.Application.ThreadException> eventi per gestire le eccezioni di thread dell'interfaccia utente e il <xref:System.AppDomain.UnhandledException> eventi per gestire le eccezioni di thread non dell'interfaccia utente. Poiché <xref:System.AppDomain.UnhandledException> non è possibile impedire a un'applicazione da terminare, nell'esempio viene semplicemente registrato l'errore nel registro eventi dell'applicazione prima della chiusura.  
  
 Questo esempio si presuppone che siano stati definiti due <xref:System.Windows.Forms.Button> controlli `button1` e `button2`via di <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è possibile impostare una modalità di eccezione successivamente alla creazione della prima finestra da parte dell'applicazione.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">Valore <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> che descrive il comportamento dell'applicazione nel caso in cui un'eccezione venga generata senza essere rilevata.</param>
        <param name="threadScope">
          <see langword="true" /> per impostare la modalità di eccezione del thread; in caso contrario, <see langword="false" />.</param>
        <summary>Indica all'applicazione come rispondere alle eccezioni non gestite, applicando eventualmente il comportamento specifico del thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spesso non è possibile rilevare tutte le eccezioni generate da Windows Form. In questo modo, è possibile indicare all'applicazione se dovrebbe intercettare tutti non gestiti le eccezioni generate dai componenti di Windows Form e continuare a funzionare, o se deve esporli all'utente e interrompere l'esecuzione.  
  
 Chiamare <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> prima che si crea un'istanza del form principale dell'applicazione utilizzando il <xref:System.Windows.Forms.Application.Run%2A> (metodo).  
  
 Quando `threadScope` è `true`, è impostata la modalità di eccezione del thread. La modalità di eccezione thread esegue l'override della modalità di eccezione dell'applicazione se `mode` non è impostata su <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Quando `threadScope` è `false`, la modalità di eccezione dell'applicazione è impostata. La modalità di eccezione dell'applicazione viene usata per tutti i thread che hanno il <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> modalità. Impostazione della modalità di eccezione dell'applicazione non influisce sull'impostazione del thread corrente.  
  
 Per intercettare le eccezioni che si verificano nella creazione di thread e di Windows Form, usare il <xref:System.AppDomain.UnhandledException> gestore dell'evento.  
  
   
  
## Examples  
 Esempio di codice seguente imposta i gestori eventi per le eccezioni che si verificano nei thread di Windows Form e le eccezioni che si verificano in altri thread. Imposta <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> in modo che tutte le eccezioni vengono gestite dall'applicazione, indipendentemente dalle impostazioni nel file di configurazione dell'applicazione utente. Usa il <xref:System.Windows.Forms.Application.ThreadException> eventi per gestire le eccezioni di thread dell'interfaccia utente e il <xref:System.AppDomain.UnhandledException> eventi per gestire le eccezioni di thread non dell'interfaccia utente. Poiché <xref:System.AppDomain.UnhandledException> non è possibile impedire a un'applicazione da terminare, nell'esempio viene semplicemente registrato l'errore nel registro eventi dell'applicazione prima della chiusura.  
  
 Questo esempio si presuppone che siano stati definiti due <xref:System.Windows.Forms.Button> controlli `button1` e `button2`via di <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è possibile impostare una modalità di eccezione successivamente alla creazione della prima finestra da parte dell'applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso del file eseguibile che ha avviato l'applicazione, non comprensivo del nome dell'eseguibile.</summary>
        <value>Percorso del file eseguibile che ha avviato l'applicazione.  
  
Questo percorso sarà diverso a seconda dell'implementazione o meno dell'applicazione Windows Forms con l'uso dell'oggetto [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] le applicazioni vengono archiviate in una cache di applicazione per ogni utente in C:\Documents and Settings\\*username* directory. Per altre informazioni, vedere [l'accesso ai dati locali e remoti in applicazioni ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente ottiene questa proprietà e consente di visualizzare il relativo valore in una casella di testo. Nell'esempio si presuppone che `textBox1` è stato inserito in un form.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per ottenere il percorso. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene generata un'eccezione non intercettata dal thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento consente all'applicazione Windows Forms di gestione in caso contrario non gestita delle eccezioni che si verificano nel thread di Windows Form. Associare i gestori eventi per il <xref:System.Windows.Forms.Application.ThreadException> eventi per gestire queste eccezioni, che lascino l'applicazione in uno stato sconosciuto. Dove possibile, le eccezioni devono essere gestite da un blocco di gestione delle eccezioni strutturata.  
  
 È possibile specificare se questo callback viene usato per le eccezioni di thread di Windows Form impostando <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Per intercettare le eccezioni che si verificano nella creazione di thread e di Windows Form, usare il <xref:System.AppDomain.UnhandledException> gestore dell'evento.  
  
> [!NOTE]
>  Per garantire che nessuna attivazione dell'evento non sono installati, è necessario collegare un gestore, prima di chiamare <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stato eliminato o causerà perdite di memoria.  
  
   
  
## Examples  
 Esempio di codice seguente imposta i gestori eventi per le eccezioni che si verificano nei thread di Windows Form e le eccezioni che si verificano in altri thread. Imposta <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> in modo che tutte le eccezioni vengono gestite dall'applicazione, indipendentemente dalle impostazioni nel file di configurazione dell'applicazione utente. Usa il <xref:System.Windows.Forms.Application.ThreadException> eventi per gestire le eccezioni di thread dell'interfaccia utente e il <xref:System.AppDomain.UnhandledException> eventi per gestire le eccezioni di thread non dell'interfaccia utente. Poiché <xref:System.AppDomain.UnhandledException> non è possibile impedire a un'applicazione da terminare, nell'esempio viene semplicemente registrato l'errore nel registro eventi dell'applicazione prima della chiusura.  
  
 Questo esempio si presuppone che siano stati definiti due <xref:System.Windows.Forms.Button> controlli `button1` e `button2`via di <xref:System.Windows.Forms.Form> classe.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito quando si aggiunge un gestore all'evento. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un thread è in fase di chiusura. Nella fase di chiusura del thread principale di un'applicazione viene generato prima questo evento, quindi l'evento <see cref="E:System.Windows.Forms.Application.ApplicationExit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario collegare i gestori eventi per il <xref:System.Windows.Forms.Application.ThreadExit> evento eseguire nessuna non gestita, le attività richieste prima dell'arresto del thread in esecuzione. Chiudere i file aperti da questo thread, o eliminare oggetti da garbage collector non recuperati.  
  
> [!CAUTION]
>  Poiché si tratta di un evento statico, è necessario disconnettere i gestori eventi quando l'applicazione è stato eliminato o causerà perdite di memoria.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore dell'evento segnala l'occorrenza del <xref:System.Windows.Forms.Application.ThreadExit> evento. Questo report consente di capire quando l'evento si verifica e può agevolare il debug. Per creare report su più eventi o sugli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un controllo Windows Form e verificare che il gestore dell'evento è associato il <xref:System.Windows.Forms.Application.ThreadExit> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla la registrazione del callback del ciclo di messaggi effettuato con l'elemento <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso relativo ai dati dell'applicazione di un utente.</summary>
        <value>Percorso relativo ai dati dell'applicazione di un utente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un percorso non esiste, ne viene creato nel formato seguente:  
  
 *Percorso di base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Dati archiviati nel percorso specificato fa parte del profilo utente che è abilitato per il roaming. Un utente mobile funziona su più di un computer in una rete. Il profilo utente per un utente mobile verrà mantenuto in un server nella rete e viene caricato in un sistema quando l'utente accede. Per un profilo utente da considerare per il roaming, il sistema operativo deve supportare i profili mobili e deve essere abilitata.  
  
 Un tipico percorso di base è C:\Documents and Settings \\\*username*\Application Data. Questo percorso sarà diverso, tuttavia, se l'applicazione Windows Forms viene distribuita usando [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Crea una directory di dati dell'applicazione che è isolata da tutte le altre applicazioni. Per altre informazioni, vedere [l'accesso ai dati locali e remoti in applicazioni ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare due forme e chiude l'applicazione quando entrambe le forme vengono chiusi. Quando l'applicazione viene avviato e viene chiusa, viene memorizzata la posizione di ogni modulo. Questo esempio illustra l'uso di <xref:System.Windows.Forms.Application.UserAppDataPath%2A> proprietà per archiviare i dati dell'applicazione per l'utente.  
  
 La classe `MyApplicationContext` eredita da <xref:System.Windows.Forms.ApplicationContext> e tiene traccia del momento ogni form viene chiuso e viene terminato il thread corrente quando entrambi sono. La classe archivia le posizioni di ciascun form per l'utente. I dati di posizione del form viene archiviati in un file denominato `Appdata.txt` creato in una posizione specificata da <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Il `Main` chiamate al metodo `Application.Run(context)` per avviare l'applicazione ha la <xref:System.Windows.Forms.ApplicationContext>.  
  
 Questo codice è tratto dall'esempio illustrato nel <xref:System.Windows.Forms.ApplicationContext> Cenni preliminari sulla classe. Codice non viene visualizzato allo scopo di brevità. Vedere <xref:System.Windows.Forms.ApplicationContext> per il listato di codice completo.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la chiave del Registro di sistema relativa ai dati dell'applicazione di un utente.</summary>
        <value>Oggetto <see cref="T:Microsoft.Win32.RegistryKey" /> che rappresenta la chiave del Registro di sistema relativa ai dati dell'applicazione specifici dell'utente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la chiave non esiste, viene creato nel formato seguente:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Dati archiviati in questa chiave sono parte del profilo utente che è abilitato per il roaming. Un utente mobile funziona su più di un computer in una rete. Il profilo utente per un utente mobile verrà mantenuto in un server nella rete e viene caricato in un sistema quando l'utente accede. Per un profilo utente da considerare per il roaming, il sistema operativo deve supportare i profili mobili e deve essere abilitata.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta se il cursore di attesa deve essere usato per tutti i form aperti dell'applicazione.</summary>
        <value>
          <see langword="true" /> se viene utilizzato il cursore di attesa per tutti i form aperti; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questa proprietà è impostata su `true`, il <xref:System.Windows.Forms.Control.UseWaitCursor%2A> proprietà di tutti i form aperti dell'applicazione verrà impostata `true`. Questa chiamata non restituirà fino a quando questa proprietà è stata impostata su tutti i form. Utilizzare questa proprietà quando si dispone di un'operazione a esecuzione prolungata e per indicare tutti i form di un'applicazione che sta ancora elaborando l'operazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che specifica il modo in cui applicare gli stili visivi alle finestre dell'applicazione.</summary>
        <value>Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciò <xref:System.Windows.Forms.Application.VisualStyleState%2A> proprietà determina se gli stili di visualizzazione sono abilitati nelle aree di client o non client delle finestre dell'applicazione. In genere, questa proprietà deve essere impostata all'interno del costruttore del form principale o <xref:System.Windows.Forms.Form.Load> gestore dell'evento.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Windows.Forms.Application.VisualStyleState%2A> proprietà su uno del <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> ai valori all'interno di <xref:System.Windows.Forms.Control.Click> gestore eventi per un <xref:System.Windows.Forms.Button> controllo. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> enumerazione.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>