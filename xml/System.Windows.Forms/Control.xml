<Type Name="Control" FullName="System.Windows.Forms.Control">
  <TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit Component&#xA;    interface IDropTarget&#xA;    interface ISynchronizeInvoke&#xA;    interface IWin32Window&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IBindableComponent" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Viene definita la classe base per i controlli, ovvero i componenti con una rappresentazione visiva.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare la propria classe di controllo, ereditare il <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> classi, o da altri moduli di Windows purché i controlli. Per ulteriori informazioni sulla creazione di controlli personalizzati, vedere [lo sviluppo personalizzato controlli Windows Form .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 Il <xref:System.Windows.Forms.Control> classe implementa le funzionalità di base richieste dalle classi che visualizzano le informazioni all'utente. Gestisce l'input dell'utente tramite la tastiera e i dispositivi di puntamento. Gestisce il routing dei messaggi e la sicurezza. Definisce i limiti di un controllo (la posizione e dimensioni), anche se non implementa il disegno. Fornisce un handle di finestra (`hWnd`).  
  
 Controlli Windows Form usare le proprietà di ambiente in modo che i controlli figlio viene visualizzato come ambiente circostante. Un' *proprietà di ambiente* è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Se il controllo non dispone di un <xref:System.Windows.Forms.Control.Parent%2A>e la proprietà non è impostata, il controllo tenta di determinare il valore della proprietà di ambiente tramite il <xref:System.Windows.Forms.Control.Site%2A> proprietà. Se il controllo non viene individuato, se il sito non supporta la proprietà di ambiente o se la proprietà non è impostata sul <xref:System.Windows.Forms.AmbientProperties>, il controllo utilizza i valori predefiniti. In genere, una proprietà di ambiente rappresenta una caratteristica di un controllo, ad esempio <xref:System.Windows.Forms.Control.BackColor%2A>, vale a dire comunicati a un controllo figlio. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Proprietà di ambiente fornita dal <xref:System.Windows.Forms.Control> classe includono: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A>, e <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Per rendere l'applicazione Windows Form supportano gli stili di visualizzazione, assicurarsi di impostare il <xref:System.Windows.Forms.FlatStyle> proprietà `System` e includere un manifesto con il file eseguibile. Un manifesto è un file XML che viene incluso come una risorsa all'interno del file eseguibile dell'applicazione o come file separato che si trova nella stessa directory del file eseguibile. Per un esempio di un manifesto, vedere la sezione esempio del <xref:System.Windows.Forms.FlatStyle> enumerazione. Per ulteriori informazioni sull'utilizzo di stili di visualizzazione, vedere [stili visivi](http://msdn.microsoft.com/library/windows/desktop/bb773187.aspx).  
  
 Windows Form dispone di supporto di accessibilità incorporato e vengono fornite informazioni sull'applicazione che lo abilita all'utilizzo di applicazioni client di accessibilità, ad esempio le utilità di utilità di ingrandimento e schermata, messaggi vocali utilità di input, le tastiere, dispositivi di input alternativi e le utilità di miglioramento della tastiera. In alcuni casi è opportuno fornire informazioni aggiuntive per le applicazioni client di accessibilità. Esistono due modi per fornire queste informazioni aggiuntive. È possibile impostare il <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>, e <xref:System.Windows.Forms.Control.AccessibleRole%2A> i valori delle proprietà che verranno segnalati per le applicazioni client di accessibilità. Questo metodo viene in genere utilizzato per fornire informazioni limitate sull'accessibilità per i controlli esistenti. In alternativa, è possibile scrivere la propria classe che deriva dal <xref:System.Windows.Forms.AccessibleObject> o <xref:System.Windows.Forms.Control.ControlAccessibleObject> classi, che fornisce tutte le informazioni di accessibilità in base alle esigenze.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare le dimensioni di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
> [!NOTE]
>  Non aggiungere associazioni dati per un <xref:System.Windows.Forms.Control> nel relativo costruttore. Questa operazione causerà errori nella generazione del codice e può causare comportamenti indesiderati.  
  
 La maggior parte dei controlli di <xref:System.Windows.Forms> dello spazio dei nomi utilizzare il controllo comune di Windows sottostante come base per compilare in. Per ulteriori informazioni sui controlli comuni di Windows, vedere [riferimento controllo generale](http://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Per identificare i controlli Windows Form da un processo separato, utilizzare uno standard `SendMessage` chiamata per passare il messaggio WM_GETCONTROLNAME. Che è indipendente del linguaggio e della gerarchia di Windows. Per altre informazioni, vedere l'argomento "Soluzione consigliata per Windows Form" nella[automazione di Windows Form](http://msdn.microsoft.com/library/ms996405.aspx).  
  
 Utilizzare il <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà per sincronizzare l'accesso al controllo da più thread. Per altre informazioni sui controlli Windows Form con multithreading, vedere [procedura: effettuare chiamate Thread-Safe a controlli Windows Form](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>Solo i membri seguenti sono thread-safe: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" />, e <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> se è già stato creato l'handle per il controllo. La chiamata <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> con le impostazioni predefinite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Testo visualizzato dal controllo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> con testo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione del <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà per il `text` valore del parametro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta l'elemento padre del controllo.</param>
        <param name="text">Testo visualizzato dal controllo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> come controllo figlio con testo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione del <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà per il `text` valore del parametro. Il costruttore inoltre aggiunto il controllo al controllo padre <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Testo visualizzato dal controllo.</param>
        <param name="left">Posizione <see cref="P:System.Drawing.Point.X" /> del controllo, in pixel, a partire dal bordo sinistro del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Posizione <see cref="P:System.Drawing.Point.Y" /> del controllo, in pixel, a partire dal bordo superiore del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Larghezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Altezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> con testo, dimensioni e posizione specifici.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione del <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà per il `text` valore del parametro. Il primo <xref:System.Windows.Forms.Control.Size%2A> e <xref:System.Windows.Forms.Control.Location%2A> del controllo sono determinati dal `left`, `top`, `width` e `height` i valori dei parametri.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare le dimensioni di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta l'elemento padre del controllo.</param>
        <param name="text">Testo visualizzato dal controllo.</param>
        <param name="left">Posizione <see cref="P:System.Drawing.Point.X" /> del controllo, in pixel, a partire dal bordo sinistro del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Posizione <see cref="P:System.Drawing.Point.Y" /> del controllo, in pixel, a partire dal bordo superiore del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Larghezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Altezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> come controllo figlio con testo, dimensioni e posizione specifici.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione del <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà per il `text` valore del parametro. Il costruttore inoltre aggiunto il controllo al controllo padre <xref:System.Windows.Forms.Control.ControlCollection>. Il primo <xref:System.Windows.Forms.Control.Size%2A> e <xref:System.Windows.Forms.Control.Location%2A> del controllo sono determinati dal `left`, `top`, `width` e `height` i valori dei parametri.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare le dimensioni di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Notifica alle applicazioni client di accessibilità l'oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> da notificare alle applicazioni client di accessibilità.</param>
        <param name="childID">Controllo <see cref="T:System.Windows.Forms.Control" /> figlio cui notificare l'evento accessibile.</param>
        <summary>Notifica alle applicazioni client di accessibilità l'oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> specificato per il controllo figlio specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> metodo per ogni <xref:System.Windows.Forms.AccessibleEvents> le applicazioni client di accessibilità devono essere notificati. Il <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> viene in genere chiamato quando una proprietà è impostata o in un gestore eventi. Ad esempio, è possibile chiamare il <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> metodo e passare un' <xref:System.Windows.Forms.AccessibleEvents> pari a `Hide` all'interno del gestore eventi per il <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType> evento.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la creazione di un grafico di supporto per l'accessibilità controllare, tramite il <xref:System.Windows.Forms.AccessibleObject> e <xref:System.Windows.Forms.Control.ControlAccessibleObject> alle classi di esporre le informazioni accessibili. Il controllo è rappresentata da due curve insieme a una legenda. Il `ChartControlAccessibleObject` classe che deriva da `ControlAccessibleObject`, viene utilizzata la <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo per fornire informazioni accessibili personalizzate per il controllo chart. Poiché la legenda del grafico non è una vera e propria <xref:System.Windows.Forms.Control> -controllo in base al, ma viene disegnata dal controllo chart, non non contiene informazioni accessibili. Per questo motivo, il `ChartControlAccessibleObject` classe esegue l'override di <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> per restituire il `CurveLegendAccessibleObject` che rappresenta le informazioni accessibili per ogni parte della legenda. Quando un'applicazione accessibile riconoscere utilizza questo controllo, il controllo può fornire le informazioni accessibili necessarie.  
  
 Questo estratto di codice viene illustrato come chiamare il <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A> metodo. Vedere il <xref:System.Windows.Forms.AccessibleObject> Cenni preliminari sulla classe per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, objectID, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="objectID" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> da notificare alle applicazioni client di accessibilità.</param>
        <param name="objectID">Identificatore di <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">Controllo <see cref="T:System.Windows.Forms.Control" /> figlio cui notificare l'evento accessibile.</param>
        <summary>Notifica alle applicazioni client di accessibilità l'oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> specificato per il controllo figlio specifico.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> assegnato al controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> assegnato al controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare l'istanza restituita da questo metodo, eseguire l'override di <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo.  
  
 Se al controllo non viene assegnato alcun oggetto <xref:System.Windows.Forms.AccessibleObject>, ne viene creata una nuova istanza.  
  
> [!NOTE]
>  Per ottenere o impostare il <xref:System.Windows.Forms.Control.AccessibilityObject%2A> proprietà, è necessario aggiungere un riferimento al `Accessibility` assembly installato con il[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Per ulteriori informazioni sugli oggetti accessibili, vedere [Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDefaultActionDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la descrizione dell'azione predefinita del controllo usata dalle applicazioni client di accessibilità.</summary>
        <value>Descrizione dell'azione predefinita del controllo usata dalle applicazioni client di accessibilità.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un oggetto <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> proprietà descrive il metodo principale per la modifica da parte dell'utente. Questa proprietà deve essere un verbo o una frase breve del verbo.  
  
> [!NOTE]
>  Non tutti gli oggetti hanno azioni predefinite e alcuni oggetti potrebbero contenere un'azione predefinita che corrisponde alla relativa <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType> proprietà, come illustrato negli esempi seguenti:  
  
-   Una casella di controllo selezionata è l'azione predefinita di "Deselezionare" e il valore "Checked."  
  
-   Una casella di controllo deselezionata ha un'azione predefinita di "Controllo" e il valore "Unchecked."  
  
-   Un pulsante con etichetta "Print" è un'azione predefinita di "Press", non prevede alcun valore.  
  
-   Un'etichetta o un controllo casella di testo che mostra "Printer" non presenta azioni predefinite, ma avrebbe un valore di "Printer".  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere [contenuto delle proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la descrizione del controllo usato dalle applicazioni client di accessibilità.</summary>
        <value>Descrizione del controllo usata dalle applicazioni client di accessibilità. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un oggetto <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà viene fornita una descrizione testuale sull'aspetto visivo dell'oggetto. La descrizione viene utilizzata principalmente per fornire un contesto per gli utenti di problemi di vista o nascosta, ma può anche essere utilizzata per la ricerca rapida o altre applicazioni.  
  
 Il <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà è necessaria se la descrizione non è ovvia o se è ridondante in base all'oggetto <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleRole%2A>, <xref:System.Windows.Forms.AccessibleObject.State%2A>, e <xref:System.Windows.Forms.AccessibleObject.Value%2A> proprietà. Ad esempio, un pulsante "OK" non è necessario informazioni aggiuntive, ma un pulsante che mostra l'immagine di una funzione. Il <xref:System.Windows.Forms.Control.AccessibleName%2A>, e <xref:System.Windows.Forms.Control.AccessibleRole%2A> (ed eventualmente <xref:System.Windows.Forms.AccessibleObject.Help%2A>) le proprietà per la funzione di tale pulsante verrebbero descriverne lo scopo, ma la <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà può contenere informazioni che sono meno tangibile, ad esempio "Un pulsante che mostra l'immagine di una funzione".  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere [contenuto delle proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Esempio di codice seguente crea un'istanza di un <xref:System.Windows.Forms.CheckBox> classe derivata `MyCheckBox`, viene assegnato un <xref:System.Drawing.Image> a relativo <xref:System.Windows.Forms.ButtonBase.Image%2A> proprietà e i set il <xref:System.Windows.Forms.Control.AccessibleName%2A> e <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà, perché il <xref:System.Windows.Forms.Control.Text%2A> proprietà `null`. In questo esempio si suppone una <xref:System.Windows.Forms.Form> denominato `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleName : string with get, set" Usage="System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del controllo usato dalle applicazioni client di accessibilità.</summary>
        <value>Nome del controllo usato dalle applicazioni client di accessibilità. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.AccessibleName%2A> proprietà è un'etichetta che descrive brevemente e identifica l'oggetto all'interno del contenitore, ad esempio il testo in un <xref:System.Windows.Forms.Button>, il nome di un <xref:System.Windows.Forms.MenuItem>, o un'etichetta visualizzata accanto a un <xref:System.Windows.Forms.TextBox> controllo.  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere la "[contenuto della proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Esempio di codice seguente crea un'istanza di un <xref:System.Windows.Forms.CheckBox> classe derivata `MyCheckBox`, viene assegnato un <xref:System.Drawing.Image> a relativo <xref:System.Windows.Forms.ButtonBase.Image%2A> proprietà e i set il <xref:System.Windows.Forms.Control.AccessibleName%2A> e <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà dal <xref:System.Windows.Forms.Control.Text%2A> proprietà è `null`. In questo esempio si suppone una <xref:System.Windows.Forms.Form> denominato `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleRole : System.Windows.Forms.AccessibleRole with get, set" Usage="System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il ruolo accessibile del controllo.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.AccessibleRole" />. Il valore predefinito è <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.Windows.Forms.Control.AccessibleRole%2A> descrive il tipo di elemento dell'interfaccia utente rappresentato da un oggetto. Se non è possibile determinare il ruolo del controllo, la proprietà <xref:System.Windows.Forms.Control.AccessibleRole%2A> è impostata su `Default`.  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere [contenuto delle proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di <see cref="T:System.Windows.Forms.AccessibleRole" />.</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se nel controllo sono consentiti dati trascinati dall'utente.</summary>
        <value><see langword="true" /> se le operazioni di trascinamento sono consentite nel controllo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice esempio seguente viene abilitata all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui viene eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> metodo viene sottoposto a override per ridisegnare l'immagine di ogni volta che viene disegnato il form; in caso contrario, l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati in form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> metodo di gestione eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> può essere creato dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> i valori sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'accesso illimitato negli Appunti impostare questa proprietà su <see langword="true" />. Enumerazione associata: il <see langword="AllClipboard" /> pari a <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.AllowDrop" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.AllowDrop" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.AllowDrop" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberSignature Language="F#" Value="member this.Anchor : System.Windows.Forms.AnchorStyles with get, set" Usage="System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i bordi del contenitore a cui è associato un controllo e determina la modalità con cui un controllo viene ridimensionato con il relativo padre.</summary>
        <value>Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.AnchorStyles" />. Il valore predefinito è <see langword="Top" /> e <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.Anchor%2A> proprietà per definire come un controllo viene ridimensionato automaticamente quando il relativo controllo padre viene ridimensionato. Ancoraggio di un controllo al relativo controllo padre assicura che i bordi ancorati rimangano nella stessa posizione relativi ai bordi del controllo padre quando il controllo padre viene ridimensionato.  
  
 È possibile ancorare un controllo a uno o più bordi del contenitore. Ad esempio, se dispone di un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Button> cui <xref:System.Windows.Forms.Control.Anchor%2A> valore della proprietà è impostato su `Top` e `Bottom`, il <xref:System.Windows.Forms.Button> viene estesa per mantenere la distanza ancorata al bordo superiore e inferiore del <xref:System.Windows.Forms.Form>come il <xref:System.Windows.Forms.Control.Height%2A> del <xref:System.Windows.Forms.Form> viene aumentato.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Anchor%2A> e <xref:System.Windows.Forms.Control.Dock%2A> proprietà si escludono a vicenda. È possibile impostare solo uno alla volta e l'ultimo ha la precedenza.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. Nell'esempio il pulsante nell'angolo in basso a destra del form è ancorato in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> al `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio è necessario un <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Anchor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Anchor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.Anchor" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollOffset : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione di scorrimento del controllo nel metodo <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" />.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Point" /> che specifica la posizione di scorrimento. Il valore predefinito è l'angolo superiore sinistro del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questa proprietà non è pertinente per questa classe.</summary>
        <value><see langword="true" /> se abilitato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questo evento non è pertinente per questa classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il colore di sfondo del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> che rappresenta il colore di sfondo del controllo. Il valore predefinito corrisponde al valore della proprietà <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.BackColor%2A> proprietà non supporta colori trasparenti, a meno che il `SupportsTransparentBackColor` pari a <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> è impostata su `true`.  
  
 Il <xref:System.Windows.Forms.Control.BackColor%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere la <xref:System.Windows.Forms.AmbientProperties> classe o il <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Il codice seguente viene impostata la <xref:System.Windows.Forms.Control.BackColor%2A> e <xref:System.Windows.Forms.Control.ForeColor%2A> dei controlli per i colori di sistema predefiniti. In modo ricorsivo il codice chiama se stessa se il controllo ha eventuali controlli figlio. Questo esempio di codice è necessario un <xref:System.Windows.Forms.Form> con almeno un controllo figlio; tuttavia, un controllo contenitore figlio, ad esempio un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con il proprio elemento figlio controlli verrebbero illustrare meglio la ricorsione.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.BackColor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.BackColor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.BackColor" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackColorChanged : EventHandler " Usage="member this.BackColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackColor" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.BackColor%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome *PropertyName* `Changed` che vengono generati quando corrispondente *PropertyName* modifiche ai valori (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'immagine di sfondo visualizzata nel controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Image" /> che rappresenta l'immagine da visualizzare sullo sfondo del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Utilizzare il <xref:System.Windows.Forms.Control.BackgroundImage%2A> proprietà per inserire un'immagine in un controllo.  
  
> [!NOTE]
>  Le immagini con trasparente o semitrasparente colori non sono supportate dai controlli Windows Form come immagini di sfondo.  
>   
>  Questa proprietà non è supportata nei controlli figlio la cui <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. Nell'esempio il pulsante nell'angolo in basso a destra del form è ancorato in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> al `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio è necessario un <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.BackgroundImage%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome *PropertyName* `Changed` che vengono generati quando corrispondente *PropertyName* modifiche ai valori (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il layout dell'immagine di sfondo definito nell'enumerazione <see cref="T:System.Windows.Forms.ImageLayout" />.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.ImageLayout" /> (<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> o <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />). <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> è il valore predefinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> proprietà per specificare la posizione e il comportamento di un'immagine è stata inserita in un controllo. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> diventa effettivo solo se il <xref:System.Windows.Forms.Control.BackgroundImage%2A> è impostata.  
  
 È possibile migliorare le prestazioni per le immagini di grandi dimensioni se si imposta <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> su un valore diverso da <xref:System.Windows.Forms.ImageLayout.Tile>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore di enumerazione specificato non esiste.</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la proprietà <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> proprietà modificata a livello di codice o dall'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue in modo asincrono un delegato nel thread in cui è stato creato il punto di controllo sottostante del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate -&gt; IAsyncResult" Usage="control.BeginInvoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegato di un metodo che non accetta parametri.</param>
        <summary>Esegue in modo asincrono il delegato specificato nel thread in cui è stato creato il punto di controllo sottostante del controllo.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta il risultato dell'operazione <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato viene chiamato in modo asincrono e questo metodo viene restituito immediatamente. È possibile chiamare questo metodo da un thread qualsiasi, anche il thread proprietario dell'handle del controllo. Se l'handle del controllo non esiste ancora, questo metodo cerca catena padre del controllo fino a individuare un controllo o un form che dispone di un handle di finestra. Se non è possibile trovare alcun handle appropriato, <xref:System.Windows.Forms.Control.BeginInvoke%2A> genererà un'eccezione. Le eccezioni all'interno del metodo delegato sono considerate non intercettate e verrà inviato al gestore dell'eccezione non intercettata dell'applicazione.  
  
 È possibile chiamare <xref:System.Windows.Forms.Control.EndInvoke%2A> per recuperare il valore restituito dal delegato, se necessario, ma questo non è necessaria. <xref:System.Windows.Forms.Control.EndInvoke%2A> verrà bloccata finché non può essere recuperato il valore restituito.  
  
> [!NOTE]
>  La maggior parte dei metodi su un controllo possono essere chiamati solo dal thread in cui è stato creato il controllo. Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo. I metodi invoke richiamano sempre il callback sul thread del controllo.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del <xref:System.Windows.Forms.Control.BeginInvoke%2A> metodo.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare un handle di finestra appropriato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member BeginInvoke : Delegate * obj[] -&gt; IAsyncResult&#xA;override this.BeginInvoke : Delegate * obj[] -&gt; IAsyncResult" Usage="control.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegato di un metodo che accetta parametri dello stesso tipo e numero contenuti nel parametro <c>args</c>.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Se non sono richiesti argomenti, può corrispondere a <see langword="null" />.</param>
        <summary>Esegue in modo asincrono il delegato specificato con gli argomenti specificati nel thread in cui è stato creato il punto di controllo sottostante del controllo.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta il risultato dell'operazione <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato viene chiamato in modo asincrono e questo metodo viene restituito immediatamente. È possibile chiamare questo metodo da un thread qualsiasi, anche il thread proprietario dell'handle del controllo. Se l'handle del controllo non esiste ancora, questo metodo cerca catena padre del controllo fino a individuare un controllo o un form che dispone di un handle di finestra. Se non è possibile trovare alcun handle appropriato, <xref:System.Windows.Forms.Control.BeginInvoke%2A> genererà un'eccezione. Le eccezioni all'interno del metodo delegato sono considerate non intercettate e verrà inviato al gestore dell'eccezione non intercettata dell'applicazione.  
  
 È possibile chiamare <xref:System.Windows.Forms.Control.EndInvoke%2A> per recuperare il valore restituito dal delegato, se necessario, ma questo non è necessaria. <xref:System.Windows.Forms.Control.EndInvoke%2A> verrà bloccata finché non può essere recuperato il valore restituito.  
  
> [!NOTE]
>  La maggior parte dei metodi su un controllo possono essere chiamati solo dal thread in cui è stato creato il controllo. Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo. I metodi invoke richiamano sempre il callback sul thread del controllo.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del <xref:System.Windows.Forms.Control.BeginInvoke%2A> metodo.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare un handle di finestra appropriato.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Forms.BindingContext" /> del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.BindingContext" /> del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.BindingContext> di un <xref:System.Windows.Forms.Control> viene utilizzato per restituire un singolo <xref:System.Windows.Forms.BindingManagerBase> per tutti i controlli associati a dati contenuti il <xref:System.Windows.Forms.Control>. Il <xref:System.Windows.Forms.BindingManagerBase> mantiene tutti i controlli associati alla stessa origine dati sincronizzata. Ad esempio, impostando il <xref:System.Windows.Forms.BindingManagerBase.Position%2A> proprietà del <xref:System.Windows.Forms.BindingManagerBase> specifica l'elemento nell'elenco sottostante a cui fanno riferimento i tutti i controlli associati a dati.  
  
 Per ulteriori informazioni sulla creazione di un nuovo <xref:System.Windows.Forms.BindingContext> e assegnarlo al <xref:System.Windows.Forms.Control.BindingContext%2A> proprietà, vedere il <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
   
  
## Examples  
 L'esempio di codice seguente crea quattro <xref:System.Windows.Forms.Binding> oggetti associare i controlli di cinque, una <xref:System.Windows.Forms.DateTimePicker> e quattro <xref:System.Windows.Forms.TextBox> controlli da diverse origini dati. Il <xref:System.Windows.Forms.BindingContext> viene quindi usata per ottenere il <xref:System.Windows.Forms.BindingManagerBase> per ogni origine dati.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.BindingContext" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.BindingContext" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.BindingContext" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberSignature Language="F#" Value="member this.BindingContextChanged : EventHandler " Usage="member this.BindingContextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="T:System.Windows.Forms.BindingContext" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per aggiungere un nuovo <xref:System.Windows.Forms.BindingContext> per il <xref:System.Windows.Forms.Control> tramite il <xref:System.Windows.Forms.Control.BindingContext%2A> proprietà, vedere il <xref:System.Windows.Forms.BindingContext.%23ctor%2A> costruttore.  
  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.BindingContext%2A> modifica della proprietà viene modificato da una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.EventHandler> delegare il <xref:System.Windows.Forms.Control.BindingContextChanged> evento di un <xref:System.Windows.Forms.TextBox> controllo.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Bottom : int" Usage="System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la distanza in pixel tra il bordo inferiore del controllo e il bordo superiore dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo inferiore del controllo e il bordo superiore dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è uguale alla somma dei valori di <xref:System.Windows.Forms.Control.Top%2A> valore della proprietà e il <xref:System.Windows.Forms.Control.Height%2A> valore della proprietà.  
  
 Il <xref:System.Windows.Forms.Control.Bottom%2A> è una proprietà di sola lettura. È possibile modificare il valore della proprietà modificando il valore della <xref:System.Windows.Forms.Control.Top%2A> o <xref:System.Windows.Forms.Control.Height%2A> proprietà o chiama la <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, o <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodi.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Bottom%2A> proprietà per definire il limite inferiore di un <xref:System.Windows.Forms.TextBox> controllo relativo all'area client del contenitore.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione e la posizione del controllo, compresi i relativi elementi non client relativi al controllo padre, espressi in pixel.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Rectangle" /> in pixel relativo al controllo padre che rappresenta la dimensione e la posizione del controllo, compresi i relativi elementi non client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I limiti del controllo includono gli elementi non client, ad esempio le barre di scorrimento, i bordi, le barre del titolo e menu. Il <xref:System.Windows.Forms.Control.SetBoundsCore%2A> viene chiamato per impostare il <xref:System.Windows.Forms.Control.Bounds%2A> proprietà. Il <xref:System.Windows.Forms.Control.Bounds%2A> proprietà non viene sempre modificata tramite il relativo `set` (metodo), è necessario eseguire l'override il <xref:System.Windows.Forms.Control.SetBoundsCore%2A> metodo per garantire che il codice venga eseguito quando il <xref:System.Windows.Forms.Control.Bounds%2A> è impostata.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> controlli in un form e imposta le dimensioni e posizione utilizzando le varie proprietà correlate alla posizione e dimensioni. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberSignature Language="F#" Value="member this.BringToFront : unit -&gt; unit" Usage="control.BringToFront " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sposta il controllo in primo piano nell'ordine z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo viene spostato all'inizio dello z-order. Se il controllo è un elemento figlio di un altro controllo, il controllo figlio viene spostato all'inizio dello z-order. <xref:System.Windows.Forms.Control.BringToFront%2A> non consente di rendere un controllo dispositivo di primo livello e non genera la <xref:System.Windows.Forms.Control.Paint> evento.  
  
   
  
## Examples  
 Esempio di codice seguente assicura che una <xref:System.Windows.Forms.Label> è visibile chiamando il relativo <xref:System.Windows.Forms.Control.BringToFront%2A> (metodo). In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Panel> denominata `panel1`e un <xref:System.Windows.Forms.Label> denominato `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la proprietà <see cref="P:System.Windows.Forms.Control.ImeMode" /> può essere impostata su un valore attivo, per abilitare il supporto IME.</summary>
        <value><see langword="true" /> in tutti i casi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate possono eseguire l'override di questa proprietà per restituire `false` se IME non è supportata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFocus : bool" Usage="System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo può ricevere lo stato attivo.</summary>
        <value><see langword="true" /> se il controllo può ricevere lo stato attivo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affinché un controllo riceve lo stato attivo di input, il controllo deve avere un handle assegnato e il <xref:System.Windows.Forms.Control.Visible%2A> e <xref:System.Windows.Forms.Control.Enabled%2A> delle proprietà devono essere impostate entrambi su `true` per il controllo e tutti i controlli padre e il controllo deve essere un form o il elemento padre più esterno del controllo deve essere un form.  
  
   
  
## Examples  
 Esempio di codice seguente imposta lo stato attivo sull'oggetto specificato <xref:System.Windows.Forms.Control>, se può ricevere lo stato attivo.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRaiseEvents : bool" Usage="System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se è possibile generare eventi sul controllo.</summary>
        <value><see langword="true" /> se il controllo viene incluso come controllo ActiveX in cui gli eventi sono bloccati; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo controllo è ospitato come controllo ActiveX, questa proprietà restituirà `false` se il controllo ActiveX gli eventi è bloccati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSelect : bool" Usage="System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo può essere selezionato.</summary>
        <value><see langword="true" /> se il controllo può essere selezionato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `true` se il `Selectable` pari a <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> è impostata su `true`è contenuto in un altro controllo, il controllo stesso è visibile e abilitato e tutti i controlli padre siano visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili e verrà restituito un valore di `false` per il <xref:System.Windows.Forms.Control.CanSelect%2A> proprietà. I controlli derivati da questi controlli non sono selezionabili.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
   
  
## Examples  
 L'esempio di codice seguente seleziona specificato <xref:System.Windows.Forms.Control>, se è selezionabile.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Capture : bool with get, set" Usage="System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo ha ricevuto l'input del mouse.</summary>
        <value><see langword="true" /> se il controllo ha ricevuto l'input del mouse; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un controllo ha acquisito il mouse, riceve l'input del mouse o meno il cursore si trova all'interno dei bordi. Il puntatore del mouse in genere viene acquisito solo durante le operazioni di trascinamento.  
  
 Solo la finestra di primo piano è possibile acquisire il mouse. Quando una finestra di sfondo tenta di eseguire questa operazione, la finestra riceve i messaggi solo per gli eventi del mouse che si verificano quando il cursore si trova all'interno della parte visibile della finestra. Inoltre, anche se la finestra di primo piano ha acquisito il mouse, l'utente può comunque fare clic su un'altra finestra, portarla in primo piano.  
  
 Quando il mouse viene rilevato, non devono usare i tasti di scelta rapida.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.Capture%2A> proprietà. Per eseguire questo esempio, incollare il seguente codice in un form contenente un <xref:System.Windows.Forms.Label> denominato label1 e due <xref:System.Windows.Forms.ListBox> controlli denominati listbox1 e listbox2. Verificare che il form e dei controlli <xref:System.Windows.Forms.Control.MouseDown> evento è associato il metodo in questo esempio.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre impostare il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CausesValidation : bool with get, set" Usage="System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se viene eseguita la convalida di tutti i controlli per cui è richiesta quando il controllo riceve lo stato attivo.</summary>
        <value><see langword="true" /> se viene eseguita la convalida di tutti i controlli per cui è richiesta quando il controllo riceve lo stato attivo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Il <xref:System.Windows.Forms.Control.CausesValidation%2A> valore della proprietà in genere è impostato su `false` per i controlli, ad esempio un pulsante della Guida.  
  
   
  
## Examples  
 Esempio di codice seguente usa la classe derivata <xref:System.Windows.Forms.TextBox> e convalida un indirizzo di posta elettronica immessi dall'utente. Se l'indirizzo di posta elettronica non è nel formato standard (che contiene "@" and "."), la convalida non riesce, un <xref:System.Windows.Forms.ErrorProvider> viene visualizzata l'icona e l'evento viene annullato. Uno dei pulsanti nel form è relativa <xref:System.Windows.Forms.Control.CausesValidation%2A> impostata su `false`. Facendo clic o impostando lo stato attivo su questo pulsante non attiva la convalida. Questo esempio si presuppone che un <xref:System.Windows.Forms.TextBox>, una <xref:System.Windows.Forms.ErrorProvider> (controllo) e un <xref:System.Windows.Forms.Button> sono stati creati in un form.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberSignature Language="F#" Value="member this.CausesValidationChanged : EventHandler " Usage="member this.CausesValidationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.CausesValidation" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.CausesValidation%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberSignature Language="F#" Value="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " Usage="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando lo stato attivo o i tasti di scelta rapida dell'interfaccia utente vengono modificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.ChangeUICues> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.ChangeUICues> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckForIllegalCrossThreadCalls : bool with get, set" Usage="System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se intercettare le chiamate sul thread errato che accedono a una proprietà <see cref="P:System.Windows.Forms.Control.Handle" /> del controllo se è in corso il debug dell'applicazione.</summary>
        <value><see langword="true" /> se le chiamate sul thread sbagliato vengono intercettate; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un thread diverso da quello di creazione di un controllo tenta di accedere a uno dei metodi o proprietà del controllo, tale operazione comporta spesso a risultati imprevedibili. Una comune attività del thread non valida è una chiamata sul thread errato che accede al controllo <xref:System.Windows.Forms.Control.Handle%2A> proprietà. Impostare <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> a `true` per individuare e diagnosticare più facilmente questa attività dei thread durante il debug.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa clic sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Click> evento passa un <xref:System.EventArgs> per il gestore eventi, pertanto solo indica che si è verificato un clic. Se sono necessarie informazioni più specifiche di mouse (pulsante, numero di clic, alla rotazione della rotellina o percorso), utilizzare il <xref:System.Windows.Forms.Control.MouseClick> evento. Tuttavia, il <xref:System.Windows.Forms.Control.MouseClick> evento non verrà generato se il clic è determinato dall'azione diverso da quello del puntatore del mouse, ad esempio premendo il tasto INVIO.  
  
 Un doppio clic è determinato dalle impostazioni relative al mouse del sistema operativo dell'utente. L'utente può impostare un intervallo tra i clic effettuati con un pulsante del mouse in modo che debbano essere considerati come un doppio clic anziché come due clic distinti. Il <xref:System.Windows.Forms.Control.Click> evento viene generato ogni volta che un controllo viene fatto doppio clic. Ad esempio, se si dispongono di gestori eventi per il <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> gli eventi di un <xref:System.Windows.Forms.Form>, il <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> eventi vengono generati quando viene fatto doppio clic sul form ed entrambi i metodi vengono chiamati. Se il controllo è fatto doppio clic e che il controllo non supporta il <xref:System.Windows.Forms.Control.DoubleClick> evento, il <xref:System.Windows.Forms.Control.Click> evento potrebbe essere generato due volte.  
  
 È necessario impostare il `StandardClick` pari a <xref:System.Windows.Forms.ControlStyles> a `true` per questo evento da generare.  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato il <xref:System.Windows.Forms.Control.Click> evento in un gestore eventi.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Eredità da un controllo Windows Form standard e la modifica di <see langword="StandardClick" /> o <see langword="StandardDoubleClick" /> valori di <see cref="T:System.Windows.Forms.ControlStyles" /> a <see langword="true" /> può causare un comportamento imprevisto o non avere alcun effetto se il controllo non supporta il <see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />gli eventi.  Nella tabella seguente sono elencati i controlli Windows Form e gli eventi (<see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />) viene generato in risposta all'azione del mouse specificato.  <list type="table"><listheader><term> Controllo </term> <description> lasciato clic del Mouse </description> <description> sinistro del Mouse fare doppio clic su </description> <description> con il pulsante destro del Mouse fare clic su </description> <description> fare doppio clic sul pulsante destro del Mouse </description> <description> Clic del Mouse al centro </description> <description> centrale del Mouse fare doppio clic su </description> <description> clic del Mouse XButton1 </description> <description> doppio clic del Mouse XButton1 </description> <description> XButton2 Del clic del mouse </description> <description> XButton2 del Mouse fare doppio clic su </description> </listheader> <item> <term> <see cref="T:System.Windows.Forms.MonthCalendar" />, <see cref="T:System.Windows.Forms.DateTimePicker" />, <see cref="T:System.Windows.Forms.HScrollBar" />, <see cref="T:System.Windows.Forms.VScrollBar" /> </term> <description> none </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> </item> <item> <term> <see cref="T:System.Windows.Forms.Button" />, <see cref="T:System.Windows.Forms.CheckBox" />, <see cref="T:System.Windows.Forms.RichTextBox" />, <see cref="T:System.Windows.Forms.RadioButton" /> </term> <description> Fare clic su </description> <description> fare clic su, fare clic su </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> </item> <item> <term> <see cref="T:System.Windows.Forms.ListBox" />, <see cref="T:System.Windows.Forms.CheckedListBox" />, <see cref="T:System.Windows.Forms.ComboBox" /> </term> <description> Fare clic su </description> <description> fare clic su, DoubleClick </description> <description> Nessuno </description> <description> Nessuno </description> <description> nessuno  </description> <description> none </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> <description> nessuno  </description> </item> <item> <term> <see cref="T:System.Windows.Forms.TextBox" />, <see cref="T:System.Windows.Forms.DomainUpDown" />, <see cref="T:System.Windows.Forms.NumericUpDown" /> </term> <description> Fare clic su </description> <description>  Fare clic su, DoubleClick </description> <description> none </description> <description> nessuno</description>&lt;s&gt;&lt;/s&gt;</para></block>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il rettangolo che rappresenta l'area client del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area client del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area client di un controllo è i limiti del controllo, meno gli elementi non client, ad esempio le barre di scorrimento, i bordi, le barre del titolo e menu.  
  
 Poiché le coordinate del client sono rispetto all'angolo superiore sinistro dell'area client del controllo, le coordinate dell'angolo superiore sinistro del rettangolo restituito da questa proprietà sono (0,0). È possibile utilizzare questa proprietà per ottenere le dimensioni e le coordinate dell'area client del controllo per le attività, ad esempio disegno sulla superficie del controllo.  
  
 Per ulteriori informazioni sul disegno su controlli, vedere [il Rendering di un controllo Windows Form](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
   
  
## Examples  
 Esempio di codice seguente Abilita lo scorrimento automatico per un form, ridimensiona il form e assicura che un pulsante rimanga visibile dopo il form viene ridimensionato. In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Button> denominata `button2` su di esso.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza e la larghezza dell'area client del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> che rappresenta le dimensioni dell'area client del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area client di un controllo è i limiti del controllo, meno gli elementi non client, ad esempio le barre di scorrimento, i bordi, le barre del titolo e menu. Il <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> viene chiamato per impostare il <xref:System.Windows.Forms.Control.ClientSize%2A> proprietà. Il <xref:System.Windows.Forms.Control.ClientSize%2A> proprietà non viene sempre modificata tramite il relativo `set` (metodo), è necessario eseguire l'override il <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodo per garantire che il codice venga eseguito quando il <xref:System.Windows.Forms.Control.ClientSize%2A> è impostata.  
  
 Il <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> e <xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> rappresentano la larghezza e altezza dell'area client del controllo. È possibile utilizzare questa proprietà per ottenere le dimensioni dell'area client del controllo per le attività, ad esempio disegno sulla superficie del controllo.  
  
 Per ulteriori informazioni sul disegno su controlli, vedere [il Rendering di un controllo Windows Form](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
> [!NOTE]
>  Non è possibile associare le impostazioni dell'applicazione per questa proprietà. Per ulteriori informazioni sulle impostazioni dell'applicazione, vedere [Panoramica di impostazioni applicazione](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 Esempio di codice seguente ridimensiona il controllo specificato in modo che il controllo, verrà eseguito il testo formattato. Il testo formattato è il <xref:System.Windows.Forms.Control.Text%2A> assegnata la proprietà con il controllo <xref:System.Windows.Forms.Control.Font%2A> applicato al testo. Il `AutoSizeControl` metodo in questo esempio ha anche un `textPadding` parametro che rappresenta la spaziatura interna da applicare a tutti i bordi del controllo. Per rendere la spaziatura interna uguale, allineare il testo di <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType> valore, se supportato dal controllo.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.ClientSizeChanged : EventHandler " Usage="member this.ClientSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ClientSize" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.ClientSizeChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.ClientSizeChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome della società o dell'autore dell'applicazione che contiene il controllo.</summary>
        <value>Nome della società o dell'autore dell'applicazione che contiene il controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.CompanyName%2A> è una proprietà di sola lettura. Per modificare il valore di questa proprietà, impostare il <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> valore della proprietà di <xref:System.Reflection.AssemblyCompanyAttribute>. La riga di set di codice c# seguente il <xref:System.Windows.Forms.Control.CompanyName%2A> proprietà.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  È consigliabile fornire il nome della società, nome prodotto e versione del prodotto per l'app.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare informazioni sull'applicazione in un <xref:System.Windows.Forms.Label> contenuti in un <xref:System.Windows.Forms.Form>. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> e <xref:System.Windows.Forms.Control.ProductVersion%2A> sono state impostate.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Forms.Control -&gt; bool" Usage="control.Contains ctl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">Oggetto <see cref="T:System.Windows.Forms.Control" /> da valutare.</param>
        <summary>Recupera un valore che indica se il controllo specificato è figlio del controllo.</summary>
        <returns><see langword="true" /> se il controllo specificato è figlio del controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente assicura che una <xref:System.Windows.Forms.Label> è visibile chiamando il relativo <xref:System.Windows.Forms.Control.BringToFront%2A> (metodo). In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Panel> denominata `panel1`e un <xref:System.Windows.Forms.Label> denominato `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsFocus : bool" Usage="System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo o uno dei controlli figlio dispone dello stato attivo per l'input.</summary>
        <value><see langword="true" /> se il controllo o uno dei controlli figlio dispone dello stato attivo per l'input; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questa proprietà per determinare se un controllo o uno qualsiasi dei controlli in esso contenuti ha lo stato attivo di input. Per determinare se il controllo ha lo stato attivo, indipendentemente dal fatto che uno qualsiasi dei relativi controlli figlio lo stato attivo, usare il <xref:System.Windows.Forms.Control.Focused%2A> proprietà. Per consentire a un controllo attivo per l'input, utilizzare il <xref:System.Windows.Forms.Control.Focus%2A> o <xref:System.Windows.Forms.Control.Select%2A> metodi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il menu di scelta rapida associato al controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.ContextMenu" /> che rappresenta il menu di scelta rapida associato al controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare un menu di scelta rapida per fornire opzioni di menu specifiche per il contesto per gli utenti quando essi destro del mouse sul controllo.  
  
   
  
## Examples  
 Consente di visualizzare esempio di codice seguente il <xref:System.Windows.Forms.ContextMenu> assegnato a un <xref:System.Windows.Forms.TreeView> quando il pulsante destro del mouse viene premuto e rilasciato. Questo codice si presuppone di disporre di un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.TreeView> su di esso. È inoltre necessario che il <xref:System.Windows.Forms.TreeView> ha un <xref:System.Windows.Forms.ContextMenu> assegnato al relativo <xref:System.Windows.Forms.Control.ContextMenu%2A> proprietà.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.ContextMenu" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.ContextMenu" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.ContextMenu" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuChanged : EventHandler " Usage="member this.ContextMenuChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ContextMenu" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.ContextMenu%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene visualizzato un messaggio quando viene apportata una modifica al menu di scelta rapida.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Forms.ContextMenuStrip" /> associato al controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.ContextMenuStrip" /> per il controllo o <see langword="null" /> se non sono presenti oggetti <see cref="T:System.Windows.Forms.ContextMenuStrip" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un <xref:System.Windows.Forms.ContextMenu> è stato assegnato anche al controllo, il <xref:System.Windows.Forms.ContextMenu> ha la precedenza sul <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come aggiungere tre <xref:System.Windows.Forms.ToolStripMenuItem> oggetti per un <xref:System.Windows.Forms.ContextMenuStrip>. Viene inoltre illustrato come impostare il <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> proprietà del modulo.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStripChanged : EventHandler " Usage="member this.ContextMenuStripChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.ContextMenuStripChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.ContextMenuStripChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberSignature Language="F#" Value="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si aggiunge un nuovo controllo all'oggetto <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlAdded> per aggiungere un controllo a un form e visualizza il nome del controllo aggiunto in un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberSignature Language="F#" Value="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si rimuove un controllo dall'oggetto <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlRemoved> per rimuovere un controllo da un form e visualizza il nome del controllo rimosso in una <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Windows.Forms.Control.ControlCollection" Usage="System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di controlli contenuti nel controllo.</summary>
        <value>Raccolta <see cref="T:System.Windows.Forms.Control.ControlCollection" /> che rappresenta la raccolta di controlli contenuti nel controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Forms.Control> può fungere da elemento padre di una raccolta di controlli. Ad esempio, quando si aggiungono più controlli a un <xref:System.Windows.Forms.Form>, ognuno dei controlli è un membro del <xref:System.Windows.Forms.Control.ControlCollection> assegnato al <xref:System.Windows.Forms.Control.Controls%2A> proprietà del modulo, che è derivato dal <xref:System.Windows.Forms.Control> (classe).  
  
 È possibile modificare i controlli nel <xref:System.Windows.Forms.Control.ControlCollection> assegnato per il <xref:System.Windows.Forms.Control.Controls%2A> proprietà utilizzando i metodi disponibili nel <xref:System.Windows.Forms.Control.ControlCollection> classe.  
  
 Quando si aggiungono più controlli a un controllo padre, è consigliabile chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo prima di inizializzare i controlli da aggiungere. Dopo aver aggiunto i controlli al controllo padre, chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo. In questo modo migliorano le prestazioni delle applicazioni con molti controlli.  
  
 Utilizzare il <xref:System.Windows.Forms.Control.Controls%2A> proprietà per scorrere tutti i controlli di un form, inclusi i controlli annidati. Utilizzare il <xref:System.Windows.Forms.Control.GetNextControl%2A> metodo per recuperare il controllo figlio precedente o successivo nell'ordine di tabulazione. Utilizzare il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà da ottenere o impostare il controllo attivo di un controllo contenitore.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene rimosso un <xref:System.Windows.Forms.Control> dal <xref:System.Windows.Forms.Control.ControlCollection> della classe derivata <xref:System.Windows.Forms.Panel> se è un membro della raccolta. Nell'esempio si presuppone che sia stato creato un <xref:System.Windows.Forms.Panel>, una <xref:System.Windows.Forms.Button>e almeno un <xref:System.Windows.Forms.RadioButton> control per un <xref:System.Windows.Forms.Form>. Il <xref:System.Windows.Forms.RadioButton> vengono aggiunti al <xref:System.Windows.Forms.Panel> (controllo) e il <xref:System.Windows.Forms.Panel> aggiunto al controllo il <xref:System.Windows.Forms.Form>. Quando si fa clic sul pulsante, il pulsante di opzione denominata `removeButton` rimossa la <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="control.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto di accessibilità per il controllo.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> per il controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si chiama in modo esplicito il metodo <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>, verrà chiamato quando si crea un riferimento alla proprietà <xref:System.Windows.Forms.Control.AccessibilityObject%2A>.  
  
> [!NOTE]
>  Per ottenere o impostare il <xref:System.Windows.Forms.Control.AccessibilityObject%2A> proprietà, è necessario aggiungere un riferimento al `Accessibility` assembly installato con il [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la creazione di un grafico di supporto per l'accessibilità controllare, tramite il <xref:System.Windows.Forms.AccessibleObject> e <xref:System.Windows.Forms.Control.ControlAccessibleObject> alle classi di esporre le informazioni accessibili. Il controllo è rappresentata da due curve insieme a una legenda. Il `ChartControlAccessibleObject` classe che deriva da `ControlAccessibleObject`, viene utilizzata la <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo per fornire informazioni accessibili personalizzate per il controllo chart. Poiché la legenda del grafico non è una vera e propria <xref:System.Windows.Forms.Control> -controllo in base al, ma viene disegnata dal controllo chart, non non contiene informazioni accessibili. Per questo motivo, il `ChartControlAccessibleObject` classe esegue l'override di <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> per restituire il `CurveLegendAccessibleObject` che rappresenta le informazioni accessibili per ogni parte della legenda. Quando un'applicazione accessibile riconoscere utilizza questo controllo, il controllo può fornire le informazioni accessibili necessarie.  
  
 Questo estratto di codice viene illustrato l'override di <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo. Vedere il <xref:System.Windows.Forms.AccessibleObject> Cenni preliminari sulla classe per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> in una classe derivata, non chiamare la classe base <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> metodo.</para></block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberSignature Language="F#" Value="member this.CreateControl : unit -&gt; unit" Usage="control.CreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina la creazione del controllo visibile, inclusa la creazione del punto di controllo e di eventuali controlli figlio visibili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.CreateControl%2A> metodo impone un handle da creare per il controllo e i relativi controlli figlio. Questo metodo viene utilizzato quando è necessario immediatamente un handle per la modifica del controllo o i relativi elementi figlio; è sufficiente chiamare un costruttore del controllo non crea il <xref:System.Windows.Forms.Control.Handle%2A>.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> non crea un punto di controllo se il controllo <xref:System.Windows.Forms.Control.Visible%2A> proprietà `false`. È possibile chiamare il <xref:System.Windows.Forms.Control.CreateHandle%2A> metodo o l'accesso il <xref:System.Windows.Forms.Control.Handle%2A> proprietà per creare il controllo di gestire indipendentemente dalla visibilità del controllo, ma in questo caso, Nessun periodo gli handle vengono creati per gli elementi figlio del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection&#xA;override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="control.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della raccolta di controlli per il controllo.</summary>
        <returns>Nuova istanza dell'oggetto <see cref="T:System.Windows.Forms.Control.ControlCollection" /> assegnato al controllo.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>La versione della classe base di questo metodo non deve essere chiamata da una classe derivata.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Created : bool" Usage="System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo è stato creato.</summary>
        <value><see langword="true" /> se il controllo è stato creato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Created%2A> proprietà restituisce `true` se il <xref:System.Windows.Forms.Control> creato correttamente anche se potrebbe essere l'handle del controllo non sono stato creato o ricreato ancora.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberSignature Language="F#" Value="member this.CreateGraphics : unit -&gt; System.Drawing.Graphics" Usage="control.CreateGraphics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea l'oggetto <see cref="T:System.Drawing.Graphics" /> per il controllo.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Graphics" /> per il controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Drawing.Graphics> oggetto recuperato tramite il <xref:System.Windows.Forms.Control.CreateGraphics%2A> metodo dovrebbe non normalmente venga mantenuto quando il messaggio di Windows corrente è stato elaborato, perché qualsiasi elemento disegnato con quell'oggetto verrà cancellato con il successivo messaggio WM_PAINT. È pertanto non è possibile memorizzare nella cache il <xref:System.Drawing.Graphics> oggetto per il riutilizzo, tranne per utilizzare metodi non visive, ad esempio <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>. In alternativa, è necessario chiamare <xref:System.Windows.Forms.Control.CreateGraphics%2A> ogni volta che si desidera utilizzare il <xref:System.Drawing.Graphics> dell'oggetto e quindi chiamare <xref:System.Drawing.Graphics.Dispose%2A> quando si è terminato. Per ulteriori informazioni sui messaggi di Windows, vedere <xref:System.Windows.Forms.Control.WndProc%2A>.  
  
 Per impostazione predefinita, <xref:System.Windows.Forms.Control.CreateGraphics%2A> imposta la proprietà per il thread chiamante e non riesce se viene chiamato in altri thread.  
  
> [!NOTE]
>  Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
   
  
## Examples  
 Esempio di codice seguente ridimensiona il controllo specificato in modo che il controllo, verrà eseguito il testo formattato. Il testo formattato è il <xref:System.Windows.Forms.Control.Text%2A> assegnata la proprietà con il controllo <xref:System.Windows.Forms.Control.Font%2A> applicato al testo. Il `AutoSizeControl` metodo in questo esempio ha anche un `textPadding` parametro che rappresenta la spaziatura interna da applicare a tutti i bordi del controllo. Per rendere la spaziatura interna uguale, allineare il testo con il `MiddleCenter` valore <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> se supportato dal controllo.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per le sottofinestre chiamare questo metodo. Enumerazione associata: <see langword="SafeSubWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : unit -&gt; unit&#xA;override this.CreateHandle : unit -&gt; unit" Usage="control.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un handle per il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere non è necessario chiamare il <xref:System.Windows.Forms.Control.CreateHandle%2A> metodo direttamente. Il metodo preferito consiste nel chiamare il <xref:System.Windows.Forms.Control.CreateControl%2A> (metodo), che impone un handle da creare per il controllo e i relativi controlli figlio quando viene creato il controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato eliminato.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.CreateHandle" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.CreateHandle" /> metodo per assicurarsi che l'handle è creato.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i parametri necessari per la creazione quando viene creato l'handle del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.CreateParams" /> contenente i parametri di creazione necessari quando viene creato l'handle del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.CreateParams%2A> proprietà non deve essere sottoposto a override e utilizzata per modificare le proprietà del controllo derivato. Le proprietà, ad esempio il <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType> dovrebbe essere impostato per la proprietà corrispondente nel controllo, ad esempio <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>. Il <xref:System.Windows.Forms.CreateParams> deve essere estesa solo quando si esegue il wrapping di una classe di controllo standard di Windows o per impostare gli stili non forniti dallo spazio dei nomi Windows Form. Per ulteriori informazioni sulla creazione di parametri di controllo, vedere la `CreateWindow` e `CreateWindowEx` le funzioni e la [CREATESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)documentazione relativa alla struttura.  
  
   
  
## Examples  
 Esempio di codice seguente estende la <xref:System.Windows.Forms.Control.CreateParams%2A> proprietà di un <xref:System.Windows.Forms.Button> classe derivata. Il <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> proprietà viene modificata, causando il pulsante per visualizzare un <xref:System.Drawing.Icon> anziché un' <xref:System.Drawing.Image>. In questo esempio si suppone una classe che eredita il <xref:System.Windows.Forms.Button> classe.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per il chiamante immediato chiamare codice non gestito durante il recupero il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.CreateParams" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.CreateParams" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para></block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il cursore visualizzato quando il puntatore del mouse viene spostato sul controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Cursor" /> che rappresenta il cursore da visualizzare quando il puntatore del mouse viene spostato sul controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assegnare un <xref:System.Windows.Forms.Cursor> per il <xref:System.Windows.Forms.Control.Cursor%2A> proprietà del controllo per trasformare il cursore visualizzato quando il puntatore del mouse sul controllo. Per modificare temporaneamente il cursore del mouse per tutti i controlli dell'applicazione, impostare il <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> proprietà. In genere si imposterebbe il <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> proprietà di un cursore di attesa durante il popolamento di un <xref:System.Windows.Forms.ComboBox> o il salvataggio o caricamento di un file.  
  
 Il <xref:System.Windows.Forms.Control.Cursor%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere la <xref:System.Windows.Forms.AmbientProperties> classe o il <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Riempimenti di esempio di codice seguente un <xref:System.Windows.Forms.ComboBox> con unità logiche disponibili dell'utente. L'esempio imposta anche la casella combinata <xref:System.Windows.Forms.Cursor> proprietà pertanto la <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> cursore viene visualizzato quando il puntatore del mouse è posizionato il pulsante di menu a discesa. Questo codice si presuppone di disporre di un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.ComboBox> su di esso.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per le sottofinestre impostare il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Cursor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Cursor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> metodi il <see cref="P:System.Windows.Forms.Control.Cursor" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Cursor" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Cursor%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come cambiare il cursore del mouse utilizzando il <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> proprietà, il <xref:System.Windows.Forms.Cursor> (classe) e il <xref:System.Windows.Forms.Cursors> classe. Nell'esempio viene creato un form che contiene un <xref:System.Windows.Forms.ComboBox> (controllo), una <xref:System.Windows.Forms.Panel> (controllo) e un <xref:System.Windows.Forms.ListView> controllo. Il <xref:System.Windows.Forms.ComboBox> contiene tutti i cursori forniti dal <xref:System.Windows.Forms.Cursors> classe. Quando l'utente seleziona un cursore del mouse nel <xref:System.Windows.Forms.ComboBox>, il <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> è impostata sul cursore selezionato, che aggiorna il cursore per il <xref:System.Windows.Forms.Panel>. Il <xref:System.Windows.Forms.ListView> viene aggiornato ogni volta che il <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType> evento si verifica.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataBindings : System.Windows.Forms.ControlBindingsCollection" Usage="System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i data binding per il controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> che contiene gli oggetti <see cref="T:System.Windows.Forms.Binding" /> del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Windows.Forms.Control.DataBindings%2A> proprietà a cui accedere il <xref:System.Windows.Forms.ControlBindingsCollection>. Aggiungendo <xref:System.Windows.Forms.Binding> oggetti alla raccolta, è possibile associare qualsiasi proprietà di un controllo per la proprietà di un oggetto.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge <xref:System.Windows.Forms.Binding> oggetti per il <xref:System.Windows.Forms.ControlBindingsCollection> di cinque controlli: quattro <xref:System.Windows.Forms.TextBox> controlli e <xref:System.Windows.Forms.DateTimePicker> controllo. È possibile accedere a <xref:System.Windows.Forms.ControlBindingsCollection> tramite la proprietà <xref:System.Windows.Forms.Control.DataBindings%2A> della classe <xref:System.Windows.Forms.Control>.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBackColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il colore di sfondo predefinito del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> di sfondo predefinito del controllo. Il valore predefinito è <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa è l'impostazione predefinita <xref:System.Windows.Forms.Control.BackColor%2A> valore della proprietà di un controllo di primo livello generico. Le classi derivate possono avere valori predefiniti diversi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, e <xref:System.Windows.Forms.Control.DefaultForeColor%2A> membri. Per eseguire l'esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.ListBox> denominato ListBox1. Chiamare il `Populate_ListBox` metodo nel costruttore del form o <xref:System.Windows.Forms.Form.Load> metodo di gestione degli eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il cursore predefinito per il controllo.</summary>
        <value>Oggetto di tipo <see cref="T:System.Windows.Forms.Cursor" /> che rappresenta il cursore predefinito corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eseguire l'override <xref:System.Windows.Forms.Control.DefaultCursor%2A> per configurare un cursore predefinito per il controllo del codice. Questo è più efficiente rispetto all'impostazione del cursore nel costruttore del controllo e fornisce il supporto automatico per determinate funzioni della finestra di progettazione correlate ai cursori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultFont : System.Drawing.Font" Usage="System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di carattere predefinito del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Font" /> predefinito del controllo. Il valore restituito varierà in base al sistema operativo usato e alle impostazioni cultura del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente descrive il valore restituito da <xref:System.Windows.Forms.Control.DefaultFont%2A> a seconda del sistema operativo e le impostazioni cultura locali.  
  
|Sistema / e o delle impostazioni cultura|Tipo di carattere|  
|----------------------------|----------|  
|Windows NT 4 x, versione giapponese|MS UI la, 9 punti.|  
|Windows arabo|Tahoma, 8 punti.|  
|Altre impostazioni cultura/sistema operativo|Carattere MS Shell Dlg logico, in genere Microsoft Sans Serif a 8 punti.|  
  
 MS Shell Dlg viene mappato a un tipo di carattere impostato nel Registro di sistema.  
  
 Se i tipi di carattere precedente non sono installati, il tipo di carattere predefinito è Tahoma, 8 punti. Se Tahoma, 8 punti, non è installato, <xref:System.Windows.Forms.Control.DefaultFont%2A> restituisce il valore della <xref:System.Drawing.FontFamily.GenericSansSerif%2A> proprietà  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, e <xref:System.Windows.Forms.Control.DefaultForeColor%2A> membri. Per eseguire l'esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.ListBox> denominato ListBox1. Chiamare il `Populate_ListBox` metodo nel costruttore del form o <xref:System.Windows.Forms.Form.Load> metodo di gestione degli eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo di carattere predefinito o i tipi di carattere alternativi specifici per la lingua in uso non sono installati sul computer client.</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultForeColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il colore di primo piano predefinito del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> di primo piano predefinito del controllo. Il valore predefinito è <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa è l'impostazione predefinita <xref:System.Windows.Forms.Control.ForeColor%2A> valore della proprietà di un controllo privo di controllo. Le classi derivate possono avere valori predefiniti diversi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, e <xref:System.Windows.Forms.Control.DefaultForeColor%2A> membri. Per eseguire l'esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.ListBox> denominato ListBox1. Chiamare il `Populate_ListBox` metodo nel costruttore del form o <xref:System.Windows.Forms.Form.Load> metodo di gestione degli eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la modalità IME (Input Method Editor, editor del metodo di input) predefinita supportata dal controllo.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un Input Method Editor (IME) è un programma che consente agli utenti di immettere caratteri complessi e simboli, ad esempio caratteri Kanji giapponese, mediante una tastiera standard.  
  
 È possibile utilizzare questo evento per eseguire attività quali l'allocazione delle risorse usate dal form. Il <xref:System.Windows.Forms.ImeMode.Inherit> valore specifica che la modalità IME viene ereditata dal controllo padre.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.DefaultImeMode%2A> proprietà per disattivare l'editor del metodo di Input.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para></block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMargin : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo spazio specificato per impostazione predefinita tra i controlli, espresso in pixel.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta lo spazio predefinito tra i controlli.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza e l'altezza specificate come dimensioni massime predefinite di un controllo, espresse in pixel.</summary>
        <value>Oggetto <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" /> che rappresenta le dimensioni del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMinimumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza e l'altezza specificate come dimensioni minime predefinite di un controllo, espresse in pixel.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> che rappresenta le dimensioni del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPadding : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la spaziatura interna del contenuto di un controllo, espressa in pixel.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta la spaziatura interna del contenuto di un controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni predefinite del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> predefinito del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà rappresenta il <xref:System.Drawing.Size> del controllo quando viene creato inizialmente. È possibile regolare le dimensioni del controllo impostando il relativo <xref:System.Windows.Forms.Control.Size%2A> valore della proprietà.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare il <xref:System.Drawing.Size> di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
> [!NOTE]
>  Nei sistemi Windows Server 2003, le dimensioni di un <xref:System.Windows.Forms.Form> è limitato per la larghezza massima in pixel e l'altezza del monitoraggio.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà e le dimensioni predefinite dei pixel modulo 500 quadrato.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.DefaultSize" /> proprietà in una classe derivata, è preferibile restituire una <see cref="T:System.Drawing.Size" /> con le dimensioni desiderate, anziché eseguire l'override di tutta l'implementazione.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member DefWndProc :  -&gt; unit&#xA;override this.DefWndProc :  -&gt; unit" Usage="control.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> di Windows da elaborare.</param>
        <summary>Invia il messaggio specificato alla routine della finestra predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sull'elaborazione dei messaggi di Windows, vedere la [funzione WindowProc](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="control.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina definitivamente il punto di controllo associato al controllo.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> metodo per assicurarsi che l'handle è stato eliminato.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceDpi : int" Usage="System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore DPI per il dispositivo di visualizzazione in cui è attualmente visualizzato il controllo.</summary>
        <value>Valore DPI del dispositivo di visualizzazione.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il rettangolo che rappresenta l'area di visualizzazione del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area di visualizzazione del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DisplayRectangle%2A> proprietà restituisce il rettangolo client dell'area di visualizzazione del controllo. Per la classe base del controllo, questo valore è uguale al rettangolo client. Tuttavia, i controlli che ereditano potrebbe voler modificare questo valore se la relativa area client è diverso dalla relativa area di visualizzazione. Il rettangolo di visualizzazione è il più piccolo <xref:System.Drawing.Rectangle> che racchiude un controllo e viene utilizzato per disporre i controlli.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> proprietà per estendere l'implementazione di base. In alternativa, è necessario fornire tutti l'implementazione.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="control.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Windows.Forms.Control" /> e dai relativi controlli figlio e facoltativamente rilascia le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico `Dispose()` metodo e il <xref:System.Object.Finalize%2A> metodo.`Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Windows.Forms.Control> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para> <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Per ulteriori informazioni <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia backup Resources](~/docs/standard/garbage-collection/unmanaged.md) non gestito e [override del metodo Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Disposing : bool" Usage="System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Windows.Forms.Control" /> base è in corso di eliminazione.</summary>
        <value><see langword="true" /> se la classe <see cref="T:System.Windows.Forms.Control" /> base è in corso di eliminazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questa proprietà restituisce `true`, la base <xref:System.Windows.Forms.Control> classe è in corso di eliminazione. Dopo il controllo viene eliminato, è non possibile non sarà più possibile fare riferimento come un controllo di Windows valido. Anche se l'istanza di un controllo viene eliminata, viene comunque mantenuto in memoria fino a quando non viene rimosso dalla memoria tramite garbage collection. Quando viene eliminato un controllo, è possibile chiamare il relativo <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberSignature Language="F#" Value="member this.Dock : System.Windows.Forms.DockStyle with get, set" Usage="System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i bordi di controllo ancorati al relativo controllo padre e determina la modalità con cui un controllo viene ridimensionato con il proprio padre.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.DockStyle" />. Il valore predefinito è <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.Dock%2A> proprietà per definire come un controllo viene ridimensionato automaticamente quando il relativo controllo padre viene ridimensionato. Ad esempio, impostando <xref:System.Windows.Forms.Control.Dock%2A> a <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> fa sì che il controllo per allineare automaticamente con i bordi sinistro del relativo controllo padre e il controllo padre viene ridimensionato. I controlli vengono ancorati in ordine Z, ovvero l'ordine di disposizione visual dei controlli in un form lungo l'asse z del form (profondità).  
  
 Un controllo può essere ancorato a un bordo del contenitore padre o può essere ancorato a tutti i bordi e riempire il contenitore padre.  
  
 Impostazione di <xref:System.Windows.Forms.Control.Margin%2A> proprietà in un controllo ancorato non ha alcun effetto sulla distanza del controllo dai bordi del contenitore.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Anchor%2A> e <xref:System.Windows.Forms.Control.Dock%2A> proprietà si escludono a vicenda. È possibile impostare solo uno alla volta e l'ultimo ha la precedenza.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creata una <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Successivamente, viene impostato il <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di <see cref="T:System.Windows.Forms.DockStyle" />.</exception>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Dock" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Dock" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> metodi il <see cref="P:System.Windows.Forms.Control.Dock" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberSignature Language="F#" Value="member this.DockChanged : EventHandler " Usage="member this.DockChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Dock" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Dock%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome *PropertyName* `Changed` che vengono generati quando corrispondente *PropertyName* modifiche ai valori (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberSignature Language="F#" Value="member this.DoDragDrop : obj * System.Windows.Forms.DragDropEffects -&gt; System.Windows.Forms.DragDropEffects" Usage="control.DoDragDrop (data, allowedEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Dati da trascinare.</param>
        <param name="allowedEffects">Uno dei valori di <see cref="T:System.Windows.Forms.DragDropEffects" />.</param>
        <summary>Inizia un'operazione di trascinamento e rilascio.</summary>
        <returns>Valore ricavato dall'enumerazione <see cref="T:System.Windows.Forms.DragDropEffects" /> che rappresenta l'effetto finale ottenuto durante l'operazione di trascinamento della selezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `allowedEffects` parametro determina quali operazioni di trascinamento possono verificarsi. Se l'operazione di trascinamento deve interagire con le applicazioni in un altro processo, i dati devono essere una classe base gestita (<xref:System.String>, <xref:System.Drawing.Bitmap>, o <xref:System.Drawing.Imaging.Metafile>), o un oggetto che implementa <xref:System.Runtime.Serialization.ISerializable> o <xref:System.Windows.Forms.IDataObject>.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo nella posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante del mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati o annullare l'operazione in base al valore della <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Continue`, la <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con il nuovo effetto consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sull'obiettivo di rilascio, l'utente è più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio, tagliare i dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Cancel`, il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo intercetta tutte le eccezioni e Rigenera solo le seguente eccezioni di sicurezza o critico:  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando viene avviato l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato oltre <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. L'esempio presenta i requisiti che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per l'operazione di trascinamento personalizzati e non rilascio i cursori, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> sia selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> gestore dell'evento per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostata su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, viene visualizzato lo stato del trascinamento nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata nel `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.DragDropEffects> enumerazione per specificare come devono essere trasferiti i dati tra i controlli coinvolti in un'operazione di trascinamento e rilascio. In questo esempio richiede che il form includa un <xref:System.Windows.Forms.RichTextBox> controllo e una <xref:System.Windows.Forms.ListBox> controllo e che il <xref:System.Windows.Forms.ListBox> controllo venga popolato con un elenco di nomi di file valido. Quando l'utente trascina un nome di file sul <xref:System.Windows.Forms.RichTextBox> (controllo), il controllo <xref:System.Windows.Forms.Control.DragEnter> evento viene generato. All'interno del gestore di evento, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A> proprietà del <xref:System.Windows.Forms.DragEventArgs> viene inizializzata su <xref:System.Windows.Forms.DragDropEffects> per indicare che devono essere copiati i dati a cui fanno riferimento il percorso del file per il <xref:System.Windows.Forms.RichTextBox> controllo.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la superficie del controllo deve essere ridisegnata usando un buffer secondario per ridurre o evitare lo sfarfallio.</summary>
        <value><see langword="true" /> se la superficie del controllo deve essere disegnata usando il doppio buffer; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grafica memorizzata nel buffer può ridurre o eliminare lo sfarfallio causato ridisegnando progressivo delle parti di una superficie visualizzata. Grafica memorizzata nel buffer richiede che i dati di grafici aggiornati prima di tutto sono scritto in un buffer. I dati nel buffer di grafica vengono quindi scritti rapidamente alla memoria della superficie visualizzata. Il commutatore relativamente rapido della memoria grafica visualizzata in genere consente di ridurre lo sfarfallio che può verificarsi in caso contrario.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> non è una proprietà associabile.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa doppio clic sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un doppio clic è determinato dalle impostazioni relative al mouse del sistema operativo dell'utente. L'utente può impostare un intervallo tra i clic effettuati con un pulsante del mouse in modo che debbano essere considerati come un doppio clic anziché come due clic distinti. Il <xref:System.Windows.Forms.Control.Click> evento viene generato ogni volta che un controllo viene fatto doppio clic. Ad esempio, se si dispongono di gestori eventi per il <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> gli eventi di un <xref:System.Windows.Forms.Form>, il <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> eventi vengono generati quando viene fatto doppio clic sul form ed entrambi i metodi vengono chiamati. Se il controllo è fatto doppio clic e che il controllo non supporta il <xref:System.Windows.Forms.Control.DoubleClick> evento, il <xref:System.Windows.Forms.Control.Click> evento potrebbe essere generato due volte.  
  
 È necessario impostare il `StandardDoubleClick` e `StandardClick` valori di <xref:System.Windows.Forms.ControlStyles> a `true` per questo evento da generare. Questi valori potrebbero già essere impostati su `true` se sta ereditando da esistente controlli Windows Form.  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DoubleClick> evento di un <xref:System.Windows.Forms.ListBox> per caricare i file di testo racchiusi il <xref:System.Windows.Forms.ListBox> in un <xref:System.Windows.Forms.TextBox> controllo.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Eredità da un controllo Windows Form standard e la modifica di <see langword="StandardClick" /> o <see langword="StandardDoubleClick" /> valori di <see cref="T:System.Windows.Forms.ControlStyles" /> a <see langword="true" /> può causare un comportamento imprevisto o non avere alcun effetto se il controllo non supporta il <see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />gli eventi.  Nella tabella seguente sono elencati i controlli Windows Form e gli eventi (<see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />) viene generato in risposta all'azione del mouse specificato.  <list type="table"><listheader><term> Controllo </term> <description> lasciato clic del Mouse </description> <description> sinistro del Mouse fare doppio clic su </description> <description> con il pulsante destro del Mouse fare clic su </description> <description> fare doppio clic sul pulsante destro del Mouse </description> <description> Clic del Mouse al centro </description> <description> centrale del Mouse fare doppio clic su </description> <description> clic del Mouse XButton1 </description> <description> doppio clic del Mouse XButton1 </description> <description> XButton2 Del clic del mouse </description> <description> XButton2 del Mouse fare doppio clic su </description> </listheader> <item> <term> <see cref="T:System.Windows.Forms.MonthCalendar" />, <see cref="T:System.Windows.Forms.DateTimePicker" />, <see cref="T:System.Windows.Forms.RichTextBox" />, <see cref="T:System.Windows.Forms.HScrollBar" />, <see cref="T:System.Windows.Forms.VScrollBar" /> </term> <description> Nessuno </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> <description> Nessuno </description> <description>none </description> <description> Nessuno </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> </item> <item> <term> <see cref="T:System.Windows.Forms.Button" />, <see cref="T:System.Windows.Forms.CheckBox" />, <see cref="T:System.Windows.Forms.RadioButton" /> </term> <description> Fare clic su </description> <description> fare clic su, fare clic su </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> </item> <item> <term> <see cref="T:System.Windows.Forms.ListBox" />, <see cref="T:System.Windows.Forms.CheckedListBox" />, <see cref="T:System.Windows.Forms.ComboBox" /> </term> <description> Fare clic su </description> <description> fare clic su, DoubleClick </description> <description> Nessuno </description> <description> Nessuno </description> <description> nessuno  </description> <description> none </description> <description> Nessuno </description> <description> none </description> <description> Nessuno </description> <description> nessuno  </description> </item> <item> <term> <see cref="T:System.Windows.Forms.TextBox" />, <see cref="T:System.Windows.Forms.DomainUpDown" />, <see cref="T:System.Windows.Forms.NumericUpDown" /> </term> <description> Fare clic su </description> <description>  Fare clic su, DoubleClick </description> <description> none </description> <description> nessuno</description>&lt;s&gt;&lt;/s&gt;</para></block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedAfterParent : EventHandler " Usage="member this.DpiChangedAfterParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'impostazione DPI per un controllo viene modificata a livello di codice dopo la modifica del valore DPI del relativo controllo o form padre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedBeforeParent : EventHandler " Usage="member this.DpiChangedBeforeParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'impostazione DPI per un controllo viene modificata a livello di codice prima di un evento di modifica del valore DPI per il relativo controllo o form padre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene completata un'operazione di trascinamento e rilascio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.DragEventArgs.X%2A> e <xref:System.Windows.Forms.DragEventArgs.Y%2A> proprietà del <xref:System.Windows.Forms.DragEventArgs> sono nelle coordinate dello schermo, non delle coordinate client. La riga di codice Visual c# seguente converte le proprietà a un client <xref:System.Drawing.Point>.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  Nelle versioni precedenti a [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], se si inserisce un <xref:System.Windows.Forms.UserControl> con <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> eventi in un Windows Form e trascinare un elemento nel <xref:System.Windows.Forms.UserControl> in fase di progettazione il `DropDrop` e `DropEnter` gli eventi generato. Tuttavia, quando si chiude e riapre la soluzione, il <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> eventi non vengono generati nuovamente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragDrop> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto viene trascinato nei limiti del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DragEnter> evento viene generato quando l'utente trascina il cursore del mouse sul controllo durante un'operazione di trascinamento e rilascio.  
  
> [!NOTE]
>  Nelle versioni precedenti a [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], se si inserisce un <xref:System.Windows.Forms.UserControl> con <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> eventi in un Windows Form e trascinare un elemento nel <xref:System.Windows.Forms.UserControl> in fase di progettazione il `DropDrop` e `DropEnter` gli eventi generato. Tuttavia, quando si chiude e riapre la soluzione, il <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> eventi non vengono generati nuovamente.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo nella posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante del mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati o annullare l'operazione in base al valore della <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Continue`, la <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con il nuovo effetto consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sull'obiettivo di rilascio, l'utente è più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio, tagliare i dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Cancel`, il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.DragEventArgs.X%2A> e <xref:System.Windows.Forms.DragEventArgs.Y%2A> proprietà del <xref:System.Windows.Forms.DragEventArgs> sono nelle coordinate dello schermo, non delle coordinate client. La riga di codice Visual c# seguente converte le proprietà a un client <xref:System.Drawing.Point>.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando viene avviato l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato oltre <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. L'esempio presenta i requisiti che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per l'operazione di trascinamento personalizzati e non rilascio i cursori, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> sia selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> gestore dell'evento per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostata su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, viene visualizzato lo stato del trascinamento nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata nel `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragEnter> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto viene trascinato fuori dai limiti del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato quando l'utente trascina il cursore all'esterno del controllo o l'utente annulla l'operazione di trascinamento e rilascio corrente.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo nella posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante del mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati o annullare l'operazione in base al valore della <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Continue`, la <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con il nuovo effetto consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sull'obiettivo di rilascio, l'utente è più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio, tagliare i dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Cancel`, il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando viene avviato l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato oltre <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. L'esempio presenta i requisiti che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per l'operazione di trascinamento personalizzati e non rilascio i cursori, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> sia selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> gestore dell'evento per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostata su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, viene visualizzato lo stato del trascinamento nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata nel `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragLeave> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto viene trascinato sui limiti del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DragOver> evento viene generato quando il cursore del mouse viene spostato all'interno dei limiti del controllo durante un'operazione di trascinamento e rilascio.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo nella posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante del mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati o annullare l'operazione in base al valore della <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> valore è `Continue`, la <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con il nuovo effetto consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sull'obiettivo di rilascio, l'utente è più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio, tagliare i dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Cancel`, il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.DragEventArgs.X%2A> e <xref:System.Windows.Forms.DragEventArgs.Y%2A> proprietà del <xref:System.Windows.Forms.DragEventArgs> sono nelle coordinate dello schermo, non delle coordinate client. La riga di codice c# seguente converte le proprietà a un client <xref:System.Drawing.Point>:  
    >   
    >  Punto clientPoint = targetControl.PointToClient (nuovo punto (Germania. X, Germania. Y));  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando viene avviato l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato oltre <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. L'esempio presenta i requisiti che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per l'operazione di trascinamento personalizzati e non rilascio i cursori, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> sia selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> gestore dell'evento per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostata su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, viene visualizzato lo stato del trascinamento nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata nel `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragOver> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="member this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="control.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">Bitmap in cui disegnare.</param>
        <param name="targetBounds">Limiti all'interno dei quali viene eseguito il rendering del controllo.</param>
        <summary>Supporta il rendering nella bitmap specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DrawToBitmap%2A> metodo non è supportato per i controlli ActiveX. È possibile eseguire l'override di <xref:System.Windows.Forms.Control.OnPrint%2A> eventi e, se necessario, fornire la logica di stampa personalizzata.  
  
 Il <xref:System.Windows.Forms.Control.DrawToBitmap%2A> metodo presenta le limitazioni seguenti:  
  
-   Un <xref:System.ArgumentException> potrebbe venire generata per bitmap di grandi dimensioni. La dimensione massima consentita dipende dalla macchina.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> non supporta il `Ink` controlli per il sistema operativo Windows XP Tablet PC Edition 2005.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> non consente di disegnare un elemento figlio <xref:System.Windows.Forms.TextBox> se il <xref:System.Windows.Forms.Control.Visible%2A> proprietà del <xref:System.Windows.Forms.TextBox> è impostata su `false`.  
  
-   I controlli all'interno dei contenitori vengono visualizzati in ordine inverso.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> non è completamente funzionale per il <xref:System.Windows.Forms.RichTextBox>; solo il bordo di una bitmap viene disegnato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo può rispondere all'interazione dell'utente.</summary>
        <value><see langword="true" /> se il controllo può rispondere all'interazione dell'utente; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà, è possibile abilitare o disabilitare i controlli in fase di esecuzione. Ad esempio, è possibile disabilitare i controlli che non si applicano allo stato corrente dell'applicazione. È anche possibile disabilitare un controllo per limitarne l'utilizzo. Ad esempio, un pulsante può essere disabilitato per impedire all'utente di clic su di esso. Se un controllo è disabilitato, non può essere selezionato.  
  
> [!IMPORTANT]
>  Impostazione di <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false` non disabilitare la casella di controllo dell'applicazione o la finestra dell'applicazione di ricevere lo stato attivo.  
  
 Quando un controllo contenitore la proprietà attivata è impostato su `false`, tutti i controlli in esso contenuti sono disabilitati, nonché. Ad esempio, se l'utente fa clic su uno dei controlli contenuti in disattivato <xref:System.Windows.Forms.GroupBox> (controllo), non verranno generati eventi.  
  
> [!NOTE]
>  Quando un controllo di scorrimento è disabilitato, vengono disabilitate anche le barre di scorrimento. Ad esempio, una casella di testo multiriga disattivato non può scorrere per visualizzare tutte le righe di testo.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creata una <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Successivamente, viene impostato il <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.EnabledChanged : EventHandler " Usage="member this.EnabledChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene modificato il valore della proprietà <see cref="P:System.Windows.Forms.Control.Enabled" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente vengono utilizzati due <xref:System.Windows.Forms.RadioButton> controlli per illustrare il <xref:System.Windows.Forms.Control.EnabledChanged> evento. Facendo clic su un pulsante Modifica il valore della <xref:System.Windows.Forms.Control.Enabled%2A> proprietà del pulsante a `false` e visualizza un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndInvoke : IAsyncResult -&gt; obj&#xA;override this.EndInvoke : IAsyncResult -&gt; obj" Usage="control.EndInvoke asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta una specifica operazione asincrona di chiamata, restituito durante la chiamata a <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</param>
        <summary>Recupera il valore restituito dell'operazione asincrona rappresentata dall'oggetto <see cref="T:System.IAsyncResult" /> passato.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> generato dall'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione asincrona non è stato completato, questa funzione si blocca fino a quando non è disponibile il risultato.  
  
> [!NOTE]
>  Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <paramref name="asyncResult" /> non è stato creato da una precedente chiamata del metodo <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> dallo stesso controllo.</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberSignature Language="F#" Value="member this.Enter : EventHandler " Usage="member this.Enter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si entra nell'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> eventi eliminati dal <xref:System.Windows.Forms.Form> classe. Gli eventi equivalenti nel <xref:System.Windows.Forms.Form> classe sono il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> sono gerarchici e deve essere propagata in su e giù alla catena padre fino a quando non viene raggiunto il controllo appropriato. Ad esempio, si supponga di disporre di un <xref:System.Windows.Forms.Form> con due <xref:System.Windows.Forms.GroupBox> controlli e ogni <xref:System.Windows.Forms.GroupBox> controllo contiene uno <xref:System.Windows.Forms.TextBox> controllo. Quando il cursore viene spostato da uno <xref:System.Windows.Forms.TextBox> a altro, il <xref:System.Windows.Forms.Control.Leave> evento viene generato per il <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.GroupBox>e il <xref:System.Windows.Forms.Control.Enter> evento viene generato per l'altro <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o il sistema operativo smetterà di rispondere. Per altre informazioni, vedere la `WM_KILLFOCUS` argomento nella sezione "Riferimenti di Input da tastiera" e la sezione "Deadlock messaggio" il[informazioni sui messaggi e le code di messaggi](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Enter> evento per modificare i colori di primo piano e sfondo di un <xref:System.Windows.Forms.TextBox> in condizioni particolari.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberSignature Language="F#" Value="member this.FindForm : unit -&gt; System.Windows.Forms.Form" Usage="control.FindForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera il form in cui si trova il controllo.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Form" /> in cui si trova il controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo <xref:System.Windows.Forms.Control.Parent%2A> valore della proprietà potrebbe non essere lo stesso come il <xref:System.Windows.Forms.Form> restituito da <xref:System.Windows.Forms.Control.FindForm%2A> metodo. Ad esempio, se un <xref:System.Windows.Forms.RadioButton> controllo è contenuto all'interno di un <xref:System.Windows.Forms.GroupBox> (controllo) e il <xref:System.Windows.Forms.GroupBox> si trova in un <xref:System.Windows.Forms.Form>, il <xref:System.Windows.Forms.RadioButton> del controllo <xref:System.Windows.Forms.Control.Parent%2A> è il <xref:System.Windows.Forms.GroupBox> e la <xref:System.Windows.Forms.GroupBox> controllo <xref:System.Windows.Forms.Control.Parent%2A>è il <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di trovare il modulo che contiene il pulsante specificato.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; bool" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta lo stato attivo per l'input del controllo.</summary>
        <returns><see langword="true" /> se la richiesta di stato attivo per l'input è stata completata correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Focus%2A> metodo `true` se il controllo ha ricevuto correttamente lo stato attivo. Il controllo può avere lo stato attivo di input durante la visualizzazione non qualsiasi segnali visivi dello stato attivo. Questo comportamento viene osservato principalmente tramite i controlli non selezionabile elencati di seguito, o tutti i controlli derivano da essi.  
  
 Un controllo può essere selezionato e ricevere lo stato attivo di input se vengono soddisfatte tutte le seguenti opzioni: il `Selectable` pari a <xref:System.Windows.Forms.ControlStyles> è impostata su `true`, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da questi controlli non sono selezionabili.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> un metodo di basso livello è destinato principalmente agli autori di controllo personalizzato. I programmatori di applicazioni devono invece utilizzare la <xref:System.Windows.Forms.Control.Select%2A> metodo o il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà per i controlli figlio, o il <xref:System.Windows.Forms.Form.Activate%2A> metodo per i moduli.  
  
   
  
## Examples  
 Esempio di codice seguente imposta lo stato attivo sull'oggetto specificato <xref:System.Windows.Forms.Control>, se può ricevere lo stato attivo.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo ha lo stato attivo per l'input.</summary>
        <value><see langword="true" /> se il controllo ha lo stato attivo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nel codice seguente esempio viene disabilitata una <xref:System.Windows.Forms.MenuItem> se un <xref:System.Windows.Forms.TextBox> non è attivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.TextBox> denominata `textBox1` e due <xref:System.Windows.Forms.MenuItem> gli oggetti denominati `menuItemEdit` e `menuItemEditInsertCustomerInfo`.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Focused" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Focused" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di carattere del testo visualizzato dal controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Font" /> da applicare al testo visualizzato dal controllo. Il valore predefinito corrisponde al valore della proprietà <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Font%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere la <xref:System.Windows.Forms.AmbientProperties> classe o il <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
 Poiché il <xref:System.Drawing.Font> non è modificabile, ovvero non è possibile modificare le relative proprietà, è possibile assegnare solo il <xref:System.Windows.Forms.Control.Font%2A> proprietà di un nuovo <xref:System.Drawing.Font>. Tuttavia, è possibile basare il nuovo tipo di carattere al tipo di carattere esistente.  
  
 [Visual Basic, c#]  
  
 Di seguito è riportato un esempio di come il carattere esistente per renderlo grassetto:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 Consente di visualizzare esempio di codice seguente una <xref:System.Windows.Forms.FontDialog> dell'utente e le modifiche il <xref:System.Drawing.Font> di un <xref:System.Windows.Forms.DateTimePicker> controllo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> con <xref:System.Windows.Forms.Button> e un <xref:System.Windows.Forms.DateTimePicker> su di esso.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Font" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Font" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.Font" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberSignature Language="F#" Value="member this.FontChanged : EventHandler " Usage="member this.FontChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Font" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.Font%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.FontChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.FontHeight : int with get, set" Usage="System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza del tipo di carattere del controllo.</summary>
        <value>Altezza dell'oggetto <see cref="T:System.Drawing.Font" /> del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.FontHeight%2A> proprietà non deve essere impostata su qualsiasi valore diverso da del controllo <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> valore oppure -1. Impostazione <xref:System.Windows.Forms.Control.FontHeight%2A> su -1 non ha l'effetto di cancellare il valore di altezza memorizzato nella cache e il valore viene ricalcolato la volta successiva che fa riferimento la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il colore primo piano del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> di primo piano del controllo. Il valore predefinito corrisponde al valore della proprietà <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ForeColor%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere la <xref:System.Windows.Forms.AmbientProperties> classe o il <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Il codice seguente viene impostata la <xref:System.Windows.Forms.Control.BackColor%2A> e <xref:System.Windows.Forms.Control.ForeColor%2A> dei controlli per i colori di sistema predefiniti. In modo ricorsivo il codice chiama se stessa se il controllo ha eventuali controlli figlio. Questo esempio di codice è necessario un <xref:System.Windows.Forms.Form> con almeno un controllo figlio; tuttavia, un controllo contenitore figlio, ad esempio un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con il proprio elemento figlio controlli verrebbero illustrare meglio la ricorsione.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.ForeColor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.ForeColor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.ForeColor" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberSignature Language="F#" Value="member this.ForeColorChanged : EventHandler " Usage="member this.ForeColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ForeColor" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.ForeColor%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome *PropertyName* `Changed` che vengono generati quando corrispondente *PropertyName* modifiche ai valori (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromChildHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromChildHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Punto di controllo di finestra (<see langword="HWND" />) da cercare.</param>
        <summary>Recupera il controllo che contiene il punto di controllo specificato.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo associato al punto di controllo specificato; restituisce <see langword="null" /> se non viene trovato alcun controllo con il punto di controllo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue la ricerca fino alla catena padre handle di finestra finché non trova un handle di cui è associato a un controllo. Questo metodo è più affidabile il <xref:System.Windows.Forms.Control.FromHandle%2A> (metodo), in quanto restituisce correttamente i controlli che dispongono di più di un handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Punto di controllo di finestra (<see langword="HWND" />) da cercare.</param>
        <summary>Restituisce il controllo associato al punto di controllo specificato.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo associato al punto di controllo specificato; restituisce <see langword="null" /> se non viene trovato alcun controllo con il punto di controllo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.FromChildHandle%2A> metodo se si desidera restituire i controlli che dispongono di più di un handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject" Usage="control.GetAccessibilityObjectById objectId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectId">Oggetto <see langword="Int32" /> che identifica l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> da recuperare.</param>
        <summary>Recupera l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> specificato.</summary>
        <returns>Classe <see cref="T:System.Windows.Forms.AccessibleObject" /> specificata.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberSignature Language="F#" Value="member this.GetAutoSizeMode : unit -&gt; System.Windows.Forms.AutoSizeMode" Usage="control.GetAutoSizeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un valore che indica il comportamento di un controllo quando la relativa proprietà <see cref="P:System.Windows.Forms.Control.AutoSize" /> è abilitata.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.AutoSizeMode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera il controllo figlio in una posizione specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Oggetto <see cref="T:System.Drawing.Point" /> che contiene le coordinate in cui cercare un controllo. Le coordinate sono espresse in relazione all'angolo superiore sinistro dell'area client del controllo.</param>
        <summary>Recupera il controllo figlio posizionato in corrispondenza delle coordinate specificate.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo posizionato nel punto specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene perso il controllo figlio in un momento specificato, il <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> metodo `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo se il controllo restituito non sono un figlio del controllo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point * System.Windows.Forms.GetChildAtPointSkip -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint (pt, skipValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" />
      </Parameters>
      <Docs>
        <param name="pt">Oggetto <see cref="T:System.Drawing.Point" /> che contiene le coordinate in cui cercare un controllo. Le coordinate sono espresse in relazione all'angolo superiore sinistro dell'area client del controllo.</param>
        <param name="skipValue">Uno dei valori di <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, che determina se ignorare un determinato tipo di controlli figlio.</param>
        <summary>Recupera il controllo figlio posizionato in corrispondenza delle coordinate specificate, indicando se ignorare un determinato tipo di controlli figlio.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> figlio in corrispondenza delle coordinate specificate.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberSignature Language="F#" Value="member this.GetContainerControl : unit -&gt; System.Windows.Forms.IContainerControl" Usage="control.GetContainerControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Windows.Forms.ContainerControl" /> successivo nella catena dei controlli padre.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.IContainerControl" /> che rappresenta l'elemento padre dell'oggetto <see cref="T:System.Windows.Forms.Control" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberSignature Language="F#" Value="member this.GetNextControl : System.Windows.Forms.Control * bool -&gt; System.Windows.Forms.Control" Usage="control.GetNextControl (ctl, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Controllo <see cref="T:System.Windows.Forms.Control" /> con il quale iniziare la ricerca.</param>
        <param name="forward"><see langword="true" /> per ricercare in avanti nell'ordine di tabulazione; <see langword="false" /> per ricercare all'indietro.</param>
        <summary>Recupera il controllo successivo in avanti o all'indietro nell'ordine di tabulazione dei controlli figlio.</summary>
        <returns>Controllo <see cref="T:System.Windows.Forms.Control" /> successivo nell'ordine di tabulazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.GetNextControl%2A> metodo è dipendente dall'ordine di tabulazione. Per scorrere tutti i controlli di un form, inclusi i controlli annidati, utilizzare il <xref:System.Windows.Forms.Control.Controls%2A> proprietà. Per ottenere o impostare il controllo attivo di un controllo contenitore, usare il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Area di dimensioni personalizzate di un controllo.</param>
        <summary>Recupera le dimensioni di un'area rettangolare in cui è possibile adattare un controllo.</summary>
        <returns>Coppia ordinata di tipo <see cref="T:System.Drawing.Size" /> che rappresenta la larghezza e l'altezza di un rettangolo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento di <xref:System.Windows.Forms.Control.GetPreferredSize%2A> è diverso dal controllo. Il <xref:System.Windows.Forms.Control.LayoutEngine%2A> sia in grado di assegnare le dimensioni restituite al controllo. È possibile restituire le dimensioni maggiori rispetto ai vincoli indicati nel `proposedSize` parametro, ma `proposedSize` modo diminuisce il vincolo. Ad esempio `GetPreferredSize(new Size(100, 0))` non deve essere più ampio `GetPreferredSize(new Size(200, 0))`. L'eccezione è un `proposedSize` pari a 0 o `Size.Empty`, che sono definiti come non vincolato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle&#xA;override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="control.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">Oggetto <see cref="T:System.Drawing.Rectangle" /> che specifica l'area per la quale recuperare i limiti di visualizzazione.</param>
        <param name="factor">Altezza e larghezza dei limiti del controllo.</param>
        <param name="specified">Uno dei valori di <see cref="T:System.Windows.Forms.BoundsSpecified" /> che specifica i limiti del controllo da usare per definirne le dimensioni e la posizione.</param>
        <summary>Recupera i limiti all'interno dei quali il controllo viene ridimensionato.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta i limiti all'interno dei quali il controllo viene ridimensionato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo helper che viene chiamato da <xref:System.Windows.Forms.Control.ScaleControl%2A> per recuperare i limiti entro il quale il controllo viene ridimensionato. È possibile eseguire l'override di questo metodo per riutilizzare il <xref:System.Windows.Forms.Control.ScaleControl%2A> scala logica, ma è necessario specificare i limiti personalizzati. L'implementazione predefinita restituisce limiti ridimensionati che prendono in considerazione il `specified` limiti, se il controllo è di livello superiore, se il controllo è stato corretto larghezza o il ridimensionamento automatico e le aree di controllo potrebbe essere necessario il controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberSignature Language="F#" Value="member this.GetStyle : System.Windows.Forms.ControlStyles -&gt; bool" Usage="control.GetStyle flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> da cui restituire il valore.</param>
        <summary>Recupera il valore del bit di stile specificato per il controllo.</summary>
        <returns><see langword="true" /> se il bit di stile del controllo specificato è impostato su <see langword="true" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flag di bit di stile di controllo vengono utilizzati per classificare il comportamento supportato. Un controllo è possibile abilitare un stile chiamando il <xref:System.Windows.Forms.Control.SetStyle%2A> metodo e passando l'oggetto appropriato <xref:System.Windows.Forms.ControlStyles> bit e il valore booleano per impostare il bit. Per determinare il valore assegnato a un determinato <xref:System.Windows.Forms.ControlStyles> bit, utilizzare il <xref:System.Windows.Forms.Control.GetStyle%2A> (metodo) e passare il <xref:System.Windows.Forms.ControlStyles> membro da valutare.  
  
   
  
## Examples  
 Il codice esempio seguente viene restituito il valore di stile correlati al doppio buffer ai bit per un <xref:System.Windows.Forms.Form>. Questo esempio vengono restituite `true` solo se tutti i bit di stile sono impostati su `true`.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberSignature Language="F#" Value="member this.GetTopLevel : unit -&gt; bool" Usage="control.GetTopLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se il controllo è un controllo di primo livello.</summary>
        <returns><see langword="true" /> se il controllo è un controllo di primo livello; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante un'operazione di trascinamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato quando inizia un'operazione di trascinamento e rilascio. Con il <xref:System.Windows.Forms.Control.GiveFeedback> evento, l'origine di un evento di trascinamento può modificare l'aspetto del puntatore del mouse per fornire l'utente indicazioni visive durante un'operazione di trascinamento e rilascio.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo nella posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante del mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati o annullare l'operazione in base al valore della <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Continue`, la <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con il nuovo effetto consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sull'obiettivo di rilascio, l'utente è più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio, tagliare i dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Cancel`, il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando viene avviato l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato oltre <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. L'esempio presenta i requisiti che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per l'operazione di trascinamento personalizzati e non rilascio i cursori, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> sia selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> gestore dell'evento per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostata su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, viene visualizzato lo stato del trascinamento nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata nel `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.GiveFeedback> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : EventHandler " Usage="member this.GotFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo riceve lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 **Nota** il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> gli eventi sono eventi di attivazione di basso livello che sono collegati ai messaggi WM_KILLFOCUS e WM_SETFOCUS di Windows. In genere, il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> vengono utilizzati solo quando si aggiorna <xref:System.Windows.Forms.UICues> o durante la scrittura di controlli personalizzati. Invece il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> eventi devono essere utilizzati per tutti i controlli, ad eccezione di <xref:System.Windows.Forms.Form> classe, che utilizza il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Per ulteriori informazioni sul <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> degli eventi, vedere il [WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)e[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomenti.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o il sistema operativo smetterà di rispondere. Per altre informazioni, vedere la [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.GotFocus> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.GotFocus> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il punto di controllo di finestra a cui è associato il controllo.</summary>
        <value>Oggetto <see cref="T:System.IntPtr" /> che contiene il punto di controllo di finestra (<see langword="HWND" />) del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di <xref:System.Windows.Forms.Control.Handle%2A> proprietà è un Windows `HWND`. Se l'handle non è stato ancora creato, fare riferimento a questa proprietà forzerà l'handle deve essere creato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> e il <xref:System.Windows.Forms.Control.Handle%2A> proprietà. Per eseguire l'esempio, incollare il codice seguente in un form. Aggiungere due pulsanti denominati `Button1` e `Button2` al form e accertarsi che tutti gli eventi siano connessi ai relativi gestori eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberSignature Language="F#" Value="member this.HandleCreated : EventHandler " Usage="member this.HandleCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si crea un punto di controllo del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene creato un handle quando il <xref:System.Windows.Forms.Control> viene visualizzato per la prima volta. Ad esempio, se un <xref:System.Windows.Forms.Control> viene creato ha <xref:System.Windows.Forms.Control.Visible%2A> impostato su `false`, il <xref:System.Windows.Forms.Control.HandleCreated> non vengono generati eventi fino al <xref:System.Windows.Forms.Control.Visible%2A> è impostata su `true`.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.HandleCreated> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.HandleCreated> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberSignature Language="F#" Value="member this.HandleDestroyed : EventHandler " Usage="member this.HandleDestroyed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è in corso l'eliminazione definitiva del punto di controllo del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante la <xref:System.Windows.Forms.Control.HandleDestroyed> evento, il controllo è ancora un controllo di Windows valido e il <xref:System.Windows.Forms.Control.Handle%2A> può essere ricreata chiamando il <xref:System.Windows.Forms.Control.RecreateHandle%2A> (metodo).  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.HandleDestroyed> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.HandleDestroyed> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildren : bool" Usage="System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo contiene uno o più controlli figlio.</summary>
        <value><see langword="true" /> se il controllo contiene uno o più controlli figlio; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.Controls%2A> della raccolta è un <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> maggiore di zero, la <xref:System.Windows.Forms.Control.HasChildren%2A> proprietà restituirà `true`. L'accesso ai <xref:System.Windows.Forms.Control.HasChildren%2A> proprietà non forza la creazione di un <xref:System.Windows.Forms.Control.ControlCollection> se il controllo non ha elementi figlio, in modo che fanno riferimento a questa proprietà può determinare un miglioramento delle prestazioni quando si esamina un albero dei controlli.  
  
   
  
## Examples  
 Il codice seguente viene impostata la <xref:System.Windows.Forms.Control.BackColor%2A> e <xref:System.Windows.Forms.Control.ForeColor%2A> dei controlli per i colori di sistema predefiniti. In modo ricorsivo il codice chiama se stessa se il controllo ha eventuali controlli figlio. Questo esempio di codice è necessario un <xref:System.Windows.Forms.Form> con almeno un controllo figlio; tuttavia, un controllo contenitore figlio, ad esempio un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con il proprio elemento figlio controlli verrebbero illustrare meglio la ricorsione.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Height : int with get, set" Usage="System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza del controllo.</summary>
        <value>Altezza del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Top%2A> i valori delle proprietà causa la <xref:System.Windows.Forms.Control.Bottom%2A> valore della proprietà del controllo da modificare.  
  
> [!NOTE]
>  L'altezza minima per il controllo derivato <xref:System.Windows.Forms.Splitter> è 1 pixel. L'altezza predefinita per il <xref:System.Windows.Forms.Splitter> controllo corrisponde a tre pixel. Impostazione dell'altezza del <xref:System.Windows.Forms.Splitter> il controllo a un valore minore di uno reimposterà il valore della proprietà per l'altezza predefinita.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> controlli in un form e imposta le dimensioni e posizione utilizzando le varie proprietà correlate alla posizione e dimensioni. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberSignature Language="F#" Value="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " Usage="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'utente richiede ulteriori informazioni della Guida relative a un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.HelpRequested> evento viene solitamente generato quando l'utente preme F1 chiave o un pulsante della Guida sensibile al contesto associato fa clic.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene mostrato come gestire il <xref:System.Windows.Forms.Control.HelpRequested> evento per visualizzare il contenuto della Guida personalizzato in un form contenente quattro campi indirizzo. Il <xref:System.Windows.Forms.Control.HelpRequested> evento viene generato premendo il tasto F1 con lo stato attivo in un campo di indirizzo o il pulsante della Guida sensibile al contesto e facendo clic il cursore della Guida su un campo di indirizzo. Il <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> è impostata su true per indicare che il `HelpRequested` viene gestito l'evento. Nell'esempio viene illustrato inoltre la memorizzazione del testo della Guida nel <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType> proprietà.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="control.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nasconde il controllo all'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nascondere il controllo è equivalente all'impostazione di <xref:System.Windows.Forms.Control.Visible%2A> proprietà `false`. Dopo il <xref:System.Windows.Forms.Control.Hide%2A> viene chiamato, il <xref:System.Windows.Forms.Control.Visible%2A> proprietà restituisce un valore di `false` fino a quando non la <xref:System.Windows.Forms.Control.Show%2A> metodo viene chiamato.  
  
   
  
## Examples  
 Esempio di codice seguente viene nascosto un pulsante se viene premuto il tasto CTRL quando si fa clic sul pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.Button> denominato `button1` su un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità IME (Input Method Editor, editor del metodo di input) del controllo.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.ImeMode" />. Il valore predefinito è <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un IME è un programma che consente agli utenti di immettere caratteri complessi e simboli, ad esempio caratteri Kanji giapponese, mediante una tastiera standard. Il <xref:System.Windows.Forms.Control.ImeMode%2A> è in genere impostata su <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> per un <xref:System.Windows.Forms.TextBox> controllo che consente di immettere solo valori numerici. Il <xref:System.Windows.Forms.Control.ImeMode%2A> valore della proprietà è impostato su <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> per il <xref:System.Windows.Forms.Form> classe.  
  
 La maggior parte delle classi che supportano gli Input Method Editor direttamente o consentire a un input diretto da un IME, verranno impostato il valore di questa proprietà su <xref:System.Windows.Forms.ImeMode.NoControl>.  
  
> [!IMPORTANT]
>  L'utente può modificare in modo interattivo il <xref:System.Windows.Forms.Control.ImeMode%2A> a meno che non è stata impostata a livello di codice su <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType>. In questo caso, l'utente non sarà in grado di utilizzare IME.  
>   
>  Il <xref:System.Windows.Forms.Control.ImeMode%2A> proprietà viene ignorata in Windows 8 quando è attiva la modalità input globale. Per ulteriori informazioni, vedi [commutatore testo Input modificato da singoli Thread a ogni utente](http://go.microsoft.com/fwlink/?LinkID=256509).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di enumerazione di <see cref="T:System.Windows.Forms.ImeMode" />.</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità IME di un controllo.</summary>
        <value>Modalità IME del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la proprietà <see cref="P:System.Windows.Forms.Control.ImeMode" /> viene modificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.ImeMode%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 I controlli che non supportano i responsabili di metodo di Input non genererà mai questo evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome *PropertyName* `Changed` che vengono generati quando corrispondente *PropertyName* modifiche ai valori (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberSignature Language="F#" Value="abstract member InitLayout : unit -&gt; unit&#xA;override this.InitLayout : unit -&gt; unit" Usage="control.InitLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiamata eseguita dopo l'aggiunta del controllo a un altro contenitore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.InitLayout%2A> metodo viene chiamato immediatamente dopo l'aggiunta di un controllo a un contenitore. Il <xref:System.Windows.Forms.Control.InitLayout%2A> metodo consente a un controllo inizializzare il proprio stato di layout basato sul relativo contenitore. Ad esempio, è generalmente applicato ancoraggio e aggancio al controllo il <xref:System.Windows.Forms.Control.InitLayout%2A> metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.InitLayout" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.InitLayout" /> metodo in modo che il controllo venga visualizzato correttamente.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invalida un'area specifica del controllo determinando l'invio di un messaggio di disegno al controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberSignature Language="F#" Value="member this.Invalidate : unit -&gt; unit" Usage="control.Invalidate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invalida l'intera superficie del controllo e ne determina il ridisegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno sincrono; per forzare un disegno sincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
   
  
## Examples  
 Il codice esempio seguente viene abilitata all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui viene eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> metodo viene sottoposto a override per ridisegnare l'immagine di ogni volta che viene disegnato il form; in caso contrario, l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati in form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> metodo di gestione eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> può essere creato dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> i valori sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : bool -&gt; unit" Usage="control.Invalidate invalidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren"><see langword="true" /> per invalidare i controlli figlio del controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Invalida un'area specifica del controllo determinando l'invio di un messaggio di disegno al controllo. È possibile che vengano invalidati anche i controlli figlio assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno sincrono; per forzare un disegno sincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.Invalidate rc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area da invalidare.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno sincrono; per forzare un disegno sincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region -&gt; unit" Usage="control.Invalidate region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">Oggetto <see cref="T:System.Drawing.Region" /> da invalidare.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno sincrono; per forzare un disegno sincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle * bool -&gt; unit" Usage="control.Invalidate (rc, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area da invalidare.</param>
        <param name="invalidateChildren"><see langword="true" /> per invalidare i controlli figlio del controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo. È possibile che vengano invalidati anche i controlli figlio assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno sincrono; per forzare un disegno sincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region * bool -&gt; unit" Usage="control.Invalidate (region, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">Oggetto <see cref="T:System.Drawing.Region" /> da invalidare.</param>
        <param name="invalidateChildren"><see langword="true" /> per invalidare i controlli figlio del controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo. È possibile che vengano invalidati anche i controlli figlio assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno sincrono; per forzare un disegno sincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " Usage="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è necessario ridisegnare la visualizzazione di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.Invalidated> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.Invalidated> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un delegato nel thread proprietario del punto di controllo di finestra sottostante del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate -&gt; obj" Usage="control.Invoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegato che contiene un metodo da chiamare nel contesto del thread del controllo.</param>
        <summary>Esegue il delegato specificato nel thread proprietario del punto di controllo di finestra sottostante del controllo.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I delegati sono simili ai puntatori a funzione nel linguaggio C o C++. I delegati incapsulare un riferimento a un metodo all'interno di un oggetto delegato. L'oggetto delegato può quindi essere passato al codice che chiama il metodo di cui viene fatto riferimento e il metodo da richiamare può essere sconosciuto in fase di compilazione. A differenza dei puntatori a funzione in C o C++, i delegati sono orientati agli oggetti, indipendenti dai tipi e più sicuro.  
  
 Il <xref:System.Windows.Forms.Control.Invoke%2A> ricerche metodo catena padre del controllo fino a individuare un controllo o un form che dispone di una finestra di gestiscono se l'handle di finestra sottostante del controllo corrente non esiste ancora. Se non è possibile trovare alcun handle appropriato, il <xref:System.Windows.Forms.Control.Invoke%2A> metodo genererà un'eccezione. Le eccezioni generate durante la chiamata verranno propagate al chiamante.  
  
> [!NOTE]
>  Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
 Il delegato può essere un'istanza di <xref:System.EventHandler>, nel qual caso il parametro mittente conterrà questo controllo e il parametro di evento conterrà <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Il delegato può anche essere un'istanza di <xref:System.Windows.Forms.MethodInvoker>, o qualsiasi altro tipo di delegato che accetta un elenco di parametri void. Una chiamata a un <xref:System.EventHandler> o <xref:System.Windows.Forms.MethodInvoker> delegato sarà più veloce rispetto a una chiamata a un altro tipo di delegato.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra i controlli che contengono un delegato. Il delegato incapsula un metodo che aggiunge elementi alla casella di riepilogo e questo metodo viene eseguito nel thread proprietario dell'handle sottostante del form. Quando l'utente fa clic sul pulsante, `Invoke` esegue il delegato.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : Delegate * obj[] -&gt; obj&#xA;override this.Invoke : Delegate * obj[] -&gt; obj" Usage="control.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegato di un metodo che accetta parametri dello stesso tipo e numero contenuti nel parametro <c>args</c>.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Se il metodo non accetta alcun argomento, questo parametro può essere <see langword="null" />.</param>
        <summary>Esegue il delegato specificato nel thread proprietario del punto di controllo di finestra sottostante del controllo con l'elenco di argomenti specificato.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che contiene il valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I delegati sono simili ai puntatori a funzione nel linguaggio C o C++. I delegati incapsulare un riferimento a un metodo all'interno di un oggetto delegato. L'oggetto delegato può quindi essere passato al codice che chiama il metodo di cui viene fatto riferimento e il metodo da richiamare può essere sconosciuto in fase di compilazione. A differenza dei puntatori a funzione in C o C++, i delegati sono orientati agli oggetti, indipendenti dai tipi e più sicuro.  
  
 Se l'handle del controllo non esiste ancora, questo metodo cerca catena padre del controllo fino a individuare un controllo o un form che dispone di un handle di finestra. Se non è possibile trovare alcun handle appropriato, questo metodo genera un'eccezione. Le eccezioni generate durante la chiamata verranno propagate al chiamante.  
  
> [!NOTE]
>  Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
 Il delegato può essere un'istanza di <xref:System.EventHandler>, nel qual caso il parametro mittente conterrà questo controllo e il parametro di evento conterrà <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Il delegato può anche essere un'istanza di <xref:System.Windows.Forms.MethodInvoker>, o qualsiasi altro tipo di delegato che accetta un elenco di parametri void. Una chiamata a un <xref:System.EventHandler> o <xref:System.Windows.Forms.MethodInvoker> delegato sarà più veloce rispetto a una chiamata a un altro tipo di delegato.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra i controlli che contengono un delegato. Il delegato incapsula un metodo che aggiunge elementi alla casella di riepilogo e questo metodo viene eseguito nel thread proprietario dell'handle sottostante del form, usando gli argomenti specificati. Quando l'utente fa clic sul pulsante, `Invoke` esegue il delegato.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeGotFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeGotFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento.</param>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.GotFocus" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeLostFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeLostFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento.</param>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.LostFocus" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeOnClick : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeOnClick (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento <see cref="E:System.Windows.Forms.Control.Click" />.</param>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Click" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaint : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaint (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Paint" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaintBackground : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaintBackground (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see langword="PaintBackground" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.InvokeRequired : bool" Usage="System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il chiamante deve usare un metodo Invoke per eseguire chiamate di metodo al controllo, in quanto si trova in un thread diverso da quello in cui è stato creato il controllo.</summary>
        <value><see langword="true" /> se l'oggetto <see cref="P:System.Windows.Forms.Control.Handle" /> del controllo è stato creato in un thread diverso da quello del chiamante, ovvero è necessario effettuare chiamate al controllo tramite un metodo Invoke; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlli Windows Form sono associati a un thread specifico e non sono thread-safe. Pertanto, se si chiama un metodo di controllo da un thread differente, è necessario utilizzare uno dei metodi per il marshalling della chiamata al thread appropriato invoke del controllo. Questa proprietà può essere utilizzata per determinare se è necessario chiamare un metodo invoke, che può essere utile se non si conosce il thread proprietario di un controllo.  
  
> [!NOTE]
>  Oltre ai <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe chiamare: <xref:System.Windows.Forms.Control.Invoke%2A>,<xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate al metodo, è necessario utilizzare uno di questi metodi invoke quando la chiamata da un thread diverso.  
  
 Se l'handle del controllo non esiste ancora, <xref:System.Windows.Forms.Control.InvokeRequired%2A> Cerca catena padre del controllo fino a individuare un controllo o un form che dispone di un handle di finestra. Se non è possibile trovare alcun handle appropriato, il <xref:System.Windows.Forms.Control.InvokeRequired%2A> metodo `false`.  
  
 Ciò significa che <xref:System.Windows.Forms.Control.InvokeRequired%2A> può restituire `false` se <xref:System.Windows.Forms.Control.Invoke%2A> non è obbligatorio (la chiamata viene eseguita sullo stesso thread), o se il controllo è stato creato in un thread differente, ma non è ancora stato creato l'handle del controllo.  
  
 Nel caso in cui l'handle del controllo non è ancora stato creato, è necessario non è sufficiente chiamare proprietà, metodi o eventi sul controllo. Ciò potrebbe causare l'handle del controllo da creare sul thread in background, isolando il controllo su un thread senza un message pump e rendendo instabile l'applicazione.  
  
 È possibile evitare questa eventualità controllando inoltre il valore di <xref:System.Windows.Forms.Control.IsHandleCreated%2A> quando <xref:System.Windows.Forms.Control.InvokeRequired%2A> restituisce `false` in un thread in background. Se non è ancora stato creato l'handle del controllo, è necessario attendere fino a quando non è stato creato prima di chiamare <xref:System.Windows.Forms.Control.Invoke%2A> o <xref:System.Windows.Forms.Control.BeginInvoke%2A>. In genere, ciò si verifica solo se viene creato un thread in background nel costruttore del form principale per l'applicazione (come in `Application.Run(new MainForm())`prima che il form sia stato visualizzato o `Application.Run` è stato chiamato.  
  
 Una soluzione consiste ad aspettare fino a handle del modulo è stato creato prima di avviare il thread in background. È possibile imporre la creazione dell'handle chiamando il <xref:System.Windows.Forms.Control.Handle%2A> proprietà o attenderne il <xref:System.Windows.Forms.Form.Load> evento per avviare il processo in background.  
  
 Una soluzione migliore consiste nell'utilizzare il `SynchronizationContext` restituito da <xref:System.Threading.SynchronizationContext> anziché un controllo per il marshalling cross-thread.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
 Per altre informazioni sui controlli Windows Form con multithreading, vedere [procedura: utilizzare un Thread in Background per la ricerca di file](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) e [procedura: effettuare chiamate Thread-Safe a controlli Windows Form](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : bool with get, set" Usage="System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo è visibile per le applicazioni di accessibilità.</summary>
        <value><see langword="true" /> se il controllo è visibile per le applicazioni di accessibilità; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo è stato eliminato.</summary>
        <value><see langword="true" /> se il controllo è stato eliminato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questa proprietà restituisce `true`, il controllo è stato eliminato e non può essere specificato come un controllo di Windows valido. Anche se l'istanza di un controllo viene eliminata, viene comunque mantenuto in memoria fino a quando non viene rimosso dalla memoria tramite garbage collection. Quando viene eliminato un controllo, è possibile chiamare il relativo <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleCreated : bool" Usage="System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un punto di controllo è associato al controllo.</summary>
        <value><see langword="true" /> se è stato assegnato un punto di controllo al controllo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Windows.Forms.Control.IsHandleCreated%2A> proprietà per determinare se <xref:System.Windows.Forms.Control.CreateHandle%2A> è stato chiamato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member IsInputChar : char -&gt; bool&#xA;override this.IsInputChar : char -&gt; bool" Usage="control.IsInputChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da testare.</param>
        <summary>Determina se un carattere è un carattere di input riconosciuto dal controllo.</summary>
        <returns><see langword="true" /> se il carattere deve essere inviato direttamente al controllo e non pre-elaborato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Forms.Control.IsInputChar%2A> metodo per determinare se il carattere specificato dal `charCode` parametro è un carattere di input che il controllo richiede. Questo metodo viene chiamato durante la pre-elaborazione messaggio finestra per determinare se il carattere di input specificato deve essere pre-elaborato o inviato direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputChar%2A> restituisce `true`, il carattere specificato viene inviato direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputChar%2A> restituisce `false`, il carattere specificato è la pre-elaborazione e inviato al controllo solo se non utilizzato nella fase di pre-elaborazione. La pre-elaborazione di un carattere include il controllo se il carattere è un tasto di scelta di un altro controllo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member IsInputKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno dei valori di <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Determina se il tasto specificato è un normale tasto di input o un tasto speciale che richiede una pre-elaborazione.</summary>
        <returns><see langword="true" /> se il tasto specificato è un normale tasto di input; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo per determinare se la chiave specificata per il `keyData` parametro è un tasto di input che il controllo richiede. Questo metodo viene chiamato durante la pre-elaborazione messaggio finestra per determinare se la chiave di input specificata deve essere pre-elaborata o inviata direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputKey%2A> restituisce `true`, la chiave specificata viene inviata direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputKey%2A> restituisce `false`, la chiave specificata è la pre-elaborazione e inviata al controllo solo se non utilizzato nella fase di pre-elaborazione. Chiavi di pre-elaborati sono includono la scheda, RETURN, ESC e i tasti freccia su, freccia giù, freccia sinistra e freccia destra.  
  
   
  
## Examples  
 Esempio di codice seguente mostra come eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo per un <xref:System.Windows.Forms.TextBox> controllo. In questo esempio, il `TabTextBox` classe gestisce il tasto TAB. Quando il `TabTextBox` ha lo stato attivo e l'utente preme il tasto TAB quattro spazi vengono aggiunti al punto di inserimento di testo, sostituendo il testo selezionato. Per impostazione predefinita, il <xref:System.Windows.Forms.TextBox> controllo gestisce il tasto TAB per spostare lo stato attivo al controllo successivo. In questo caso, la pressione del tasto non raggiunge mai il <xref:System.Windows.Forms.Control.OnKeyDown%2A> override del metodo. Per evitare questo comportamento predefinito, il <xref:System.Windows.Forms.Control.IsInputKey%2A> restituisce l'override del metodo `true` quando l'utente preme il tasto TAB. Per tutti gli altri tasti, il <xref:System.Windows.Forms.Control.IsInputKey%2A> override del metodo restituisce il risultato della chiamata alla versione della classe di base del metodo.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberSignature Language="F#" Value="static member IsKeyLocked : System.Windows.Forms.Keys -&gt; bool" Usage="System.Windows.Forms.Control.IsKeyLocked keyVal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyVal">Membro BLOC MAIUSC, BLOC NUM o BLOC SCORR dell'enumerazione <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Determina se il tasto BLOC MAIUSC, BLOC NUM o BLOC SCORR è attivo.</summary>
        <returns><see langword="true" /> se il tasto o i tasti specificati sono attivi; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.IsKeyLocked%2A> proprietà per determinare se le chiavi BLOC MAIUSC, BLOC NUM o BLOC SCORR sono, singolarmente o in combinazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare una finestra di messaggio che indica se la chiave specificata (in questo caso il tasto BLOC MAIUSC) è attivo.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="keyVal" /> fa riferimento a un tasto diverso dai tasti BLOC MAIUSC, BLOC NUM o BLOC SCORR.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMirrored : bool" Usage="System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo è sottoposto a mirroring.</summary>
        <value><see langword="true" /> se il controllo è sottoposto a mirroring; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consente di visualizzare un controllo con mirroring sia layout di testo da destra a sinistra. Per altre informazioni, vedere [procedura: creare Windows Form con mirroring e controlli](http://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsMnemonic : char * string -&gt; bool" Usage="System.Windows.Forms.Control.IsMnemonic (charCode, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da testare.</param>
        <param name="text">Stringa in cui effettuare la ricerca.</param>
        <summary>Determina se il carattere specificato è il carattere per i tasti di scelta rapida assegnato al controllo nella stringa specificata.</summary>
        <returns><see langword="true" /> se il carattere <paramref name="charCode" /> è il carattere per i tasti di scelta rapida assegnato al controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il carattere mnemonico è il carattere che segue immediatamente la prima istanza di "&" in un <xref:System.String>.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra un'estensione della classe pulsante che esegue l'override di <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodo per mostrare un comportamento personalizzato. Nell'esempio viene inoltre illustrato l'utilizzo del <xref:System.Windows.Forms.Control.CanSelect%2A> e <xref:System.Windows.Forms.Control.IsMnemonic%2A> proprietà. Per eseguire questo esempio, incollare il codice seguente dopo una classe del modulo, nello stesso file. Aggiungere un pulsante di tipo `MnemonicButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si preme un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi principali si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Per gestire gli eventi di tastiera solo a livello di modulo e non abilitare altri controlli per la ricezione di eventi della tastiera, impostare il <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> proprietà del modulo <xref:System.Windows.Forms.Control.KeyPress> metodo di gestione degli eventi da `true`. Alcuni tasti, ad esempio, RETURN, ESC, freccia e TAB vengono gestiti automaticamente dai controlli. Per generare queste chiavi il <xref:System.Windows.Forms.Control.KeyDown> evento, è necessario eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo in ogni controllo nel form. Il codice esegue l'override del <xref:System.Windows.Forms.Control.IsInputKey%2A> sarà necessario determinare se si preme uno dei tasti speciali e restituiscono un valore di `true`. Anziché eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo, è possibile gestire il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento e set il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà da `true`. Per un esempio di codice, vedere il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyDown> evento per determinare il tipo di carattere immesso nel controllo.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " Usage="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si preme un tasto carattere, la barra spaziatrice o il tasto backspace mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi principali si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Il <xref:System.Windows.Forms.Control.KeyPress> evento non viene generato da chiavi non carattere diverso da spazio e backspace; tuttavia, le chiavi non carattere generano il <xref:System.Windows.Forms.Control.KeyDown> e <xref:System.Windows.Forms.Control.KeyUp> eventi.  
  
 Utilizzare il <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> proprietà per campionare le sequenze di tasti in fase di esecuzione e per utilizzare o modificare un sottoinsieme di sequenze di tasti comuni.  
  
 Per gestire gli eventi di tastiera solo a livello di modulo e non abilitare altri controlli per la ricezione di eventi della tastiera, impostare il <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> proprietà del modulo <xref:System.Windows.Forms.Control.KeyPress> metodo di gestione degli eventi da `true`.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyPress> evento per impedire che i caratteri accedendo al controllo.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si rilascia un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi principali si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Per gestire gli eventi di tastiera solo a livello di modulo e non abilitare altri controlli per la ricezione di eventi della tastiera, impostare il <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> proprietà del modulo <xref:System.Windows.Forms.Control.KeyPress> metodo di gestione degli eventi da `true`. Alcuni tasti, ad esempio, RETURN, ESC, freccia e TAB vengono gestiti automaticamente dai controlli. Per generare queste chiavi il <xref:System.Windows.Forms.Control.KeyUp> evento, è necessario eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo in ogni controllo nel form. Il codice esegue l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> sarà necessario determinare se si preme uno dei tasti speciali e restituiscono un valore di `true`.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyUp> evento con la <xref:System.Windows.Forms.Help> classe per visualizzare la Guida di stile popup all'utente.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberSignature Language="F#" Value="member this.Layout : System.Windows.Forms.LayoutEventHandler " Usage="member this.Layout : System.Windows.Forms.LayoutEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è necessario riposizionare i controlli figlio di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Layout> evento si verifica quando i controlli figlio vengono aggiunti o rimossi, quando i limiti del controllo cambia, e quando vengono apportate altre modifiche che possono influenzare il layout del controllo. L'evento layout può essere soppresso mediante il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi. La sospensione del layout consente di eseguire più azioni su un controllo senza dover eseguire un layout per ogni modifica. Ad esempio, se si ridimensionare e spostare un controllo, ogni operazione genererebbe un <xref:System.Windows.Forms.Control.Layout> evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Centri di esempio di codice seguente una <xref:System.Windows.Forms.Form> nella schermata di <xref:System.Windows.Forms.Control.Layout> evento. Questo consente di mantenere il form al centro come l'utente lo ridimensiona. In questo esempio richiede che sia stato creato un <xref:System.Windows.Forms.Form> controllo.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LayoutEngine : System.Windows.Forms.Layout.LayoutEngine" Usage="System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un'istanza memorizzata nella cache del modulo di layout del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> per il contenuto del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.LayoutEngine%2A> proprietà ottiene il motore di layout per gli elementi figlio del controllo piuttosto che per il controllo stesso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberSignature Language="F#" Value="member this.Leave : EventHandler " Usage="member this.Leave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando lo stato attivo per l'input esce dall'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> eventi eliminati dal <xref:System.Windows.Forms.Form> classe. Gli eventi equivalenti nel <xref:System.Windows.Forms.Form> classe sono il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> sono gerarchici e deve essere propagata in su e giù alla catena padre fino a quando non viene raggiunto il controllo appropriato. Ad esempio, si supponga di disporre di un <xref:System.Windows.Forms.Form> con due <xref:System.Windows.Forms.GroupBox> controlli e ogni <xref:System.Windows.Forms.GroupBox> controllo contiene uno <xref:System.Windows.Forms.TextBox> controllo. Quando il cursore viene spostato da uno <xref:System.Windows.Forms.TextBox> a altro, il <xref:System.Windows.Forms.Control.Leave> evento viene generato per il <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.GroupBox>e il <xref:System.Windows.Forms.Control.Enter> evento viene generato per l'altro <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o il sistema operativo smetterà di rispondere. Per altre informazioni, vedere la [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Leave> evento per reimpostare un controllo allo stato precedente.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Left : int with get, set" Usage="System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la distanza in pixel tra il bordo sinistro del controllo e il bordo sinistro dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo sinistro del controllo e il bordo sinistro dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Left%2A> è equivalente al valore della proprietà di <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> proprietà del <xref:System.Windows.Forms.Control.Location%2A> valore della proprietà del controllo.  
  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Width%2A> e <xref:System.Windows.Forms.Control.Left%2A> i valori delle proprietà causa la <xref:System.Windows.Forms.Control.Right%2A> valore della proprietà del controllo da modificare.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> controlli in un form e imposta le dimensioni e posizione utilizzando le varie proprietà correlate alla posizione e dimensioni. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le coordinate dell'angolo superiore sinistro del controllo in relazione all'angolo superiore sinistro del relativo contenitore.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Point" /> che rappresenta l'angolo superiore sinistro del controllo in relazione all'angolo superiore sinistro del relativo contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché il <xref:System.Drawing.Point> classe è un tipo valore (`Structure` in Visual Basic `struct` in Visual c#), viene restituito per valore, ovvero l'accesso alla proprietà restituisce una copia del punto superiore sinistro del controllo. In tal caso, la regolazione il <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> proprietà del <xref:System.Drawing.Point> restituito da questa proprietà non avrà effetto sul <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, o <xref:System.Windows.Forms.Control.Bottom%2A> i valori delle proprietà del controllo. Per modificare queste proprietà, impostare singolarmente ogni valore della proprietà o impostare il <xref:System.Windows.Forms.Control.Location%2A> proprietà con un nuovo <xref:System.Drawing.Point>.  
  
 Se il <xref:System.Windows.Forms.Control> è un <xref:System.Windows.Forms.Form>, la <xref:System.Windows.Forms.Control.Location%2A> valore della proprietà rappresenta l'angolo superiore sinistro del <xref:System.Windows.Forms.Form> nelle coordinate dello schermo.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creata una <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Successivamente, viene impostato il <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene modificato il valore della proprietà <see cref="P:System.Windows.Forms.Control.Location" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.Location%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene genera il <xref:System.Windows.Forms.Control.LocationChanged> evento su un <xref:System.Windows.Forms.StatusStrip> quando il form viene ridimensionato.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : int -&gt; int" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore logico da convertire.</param>
        <summary>Converte un valore DPI logico nel valore DPI DeviceUnit equivalente.</summary>
        <returns>Valore DeviceUnit risultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : EventHandler " Usage="member this.LostFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo perde lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Se il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> è impostata su `true` nel <xref:System.Windows.Forms.Control.Validating> delegato dell'evento, tutti gli eventi che in genere si verificano dopo il <xref:System.Windows.Forms.Control.Validating> evento vengono soppressi.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> gli eventi sono eventi di attivazione di basso livello che sono collegati ai messaggi WM_KILLFOCUS e WM_SETFOCUS di Windows. In genere, il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> vengono utilizzati solo quando si aggiorna <xref:System.Windows.Forms.UICues> o durante la scrittura di controlli personalizzati. Invece il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> eventi devono essere utilizzati per tutti i controlli, ad eccezione di <xref:System.Windows.Forms.Form> classe, che utilizza il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Per ulteriori informazioni sul <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> degli eventi, vedere il [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) e [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomenti.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o il sistema operativo smetterà di rispondere. Per altre informazioni, vedere la [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come convalidare il testo per TextBox1. Viene inoltre illustrato come la gestione di <xref:System.Windows.Forms.Control.LostFocus> evento impostando il <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> proprietà per il testo in TextBox1. L'esempio di codice usato il <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> metodo per verificare la presenza di errori prima di aprire la finestra di dialogo file. Per eseguire questo esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.TextBox> denominato `TextBox1`, un <xref:System.Windows.Forms.OpenFileDialog> denominato `OpenFileDialog1`, un <xref:System.Windows.Forms.Button> denominata `Button1`e un oggetto <xref:System.Windows.Forms.ErrorProvider> denominato `ErrorProvider1`. Verificare che tutti gli eventi sono associati i relativi gestori eventi.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo spazio tra i controlli.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta lo spazio tra i controlli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori predefiniti per i controlli ricevono <xref:System.Windows.Forms.Control.Margin%2A> che ragionevolmente sta per raggiungere linee guida sull'interfaccia utente di Windows. Alcune modifiche potrebbero essere ancora necessari per determinate applicazioni.  
  
> [!NOTE]
>  Impostazione di <xref:System.Windows.Forms.Control.Margin%2A> proprietà in un controllo ancorato non ha alcun effetto sulla distanza del controllo dai bordi del contenitore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando cambia il margine del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.MarginChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.MarginChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione che rappresenta il limite superiore specificabile dal metodo <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />.</summary>
        <value>Coppia ordinata di tipo <see cref="T:System.Drawing.Size" /> che rappresenta la larghezza e l'altezza di un rettangolo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione che rappresenta il limite inferiore specificabile dal metodo <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />.</summary>
        <value>Coppia ordinata di tipo <see cref="T:System.Drawing.Size" /> che rappresenta la larghezza e l'altezza di un rettangolo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberSignature Language="F#" Value="member this.ModifierKeys : System.Windows.Forms.Keys" Usage="System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica quale tasto di modifica (MAIUSC, CTRL e ALT) è premuto.</summary>
        <value>Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.Keys" />. Il valore predefinito è <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente consente di nascondere un pulsante quando viene premuto il tasto CTRL mentre si fa clic sul pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.Button> denominato `button1` su un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberSignature Language="F#" Value="member this.MouseButtons : System.Windows.Forms.MouseButtons" Usage="System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica quale pulsante del mouse è premuto.</summary>
        <value>Combinazione bit per bit dei valori di enumerazione di <see cref="T:System.Windows.Forms.MouseButtons" />. Il valore predefinito è <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, e <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> membri. Per eseguire l'esempio, incollare il codice seguente in un form denominato Form1 contenente diversi controlli. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, e <xref:System.Windows.Forms.Control.MouseUp> eventi connessi ai gestori di eventi definiti nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberSignature Language="F#" Value="member this.MouseCaptureChanged : EventHandler " Usage="member this.MouseCaptureChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo perde il mouse capture.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In rari casi potrebbe essere necessario rilevare input imprevisto. Ad esempio, considerare gli scenari seguenti.  
  
-   Durante un'operazione del mouse, l'utente apre il menu Start premendo il tasto Windows o CTRL + ESC.  
  
-   Durante un'operazione del mouse, l'utente passa a un altro programma premendo ALT + TAB.  
  
-   Durante un'operazione del mouse, un altro programma consente di visualizzare una finestra o una finestra di messaggio che riceve lo stato attivo dall'applicazione corrente.  
  
 Possono includere le operazioni del mouse facendo clic e tenere il mouse su un form o un controllo o esecuzione di un'operazione di trascinamento. Se è necessario rilevare quando un form o un controllo perde lo stato mouse capture per queste e scenari imprevisti correlati, è possibile utilizzare il <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento per un <xref:System.Windows.Forms.Button> controllo.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Per testare questo esempio, eseguirlo nel debugger premendo F5. Aprire la **Output** finestra in Visual Studio in modo da visualizzare quando vengono generati eventi. Fare clic sul <xref:System.Windows.Forms.Button> e notare l'output seguente.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 A questo punto, fare clic e tenere premuto il pulsante sinistro del mouse <xref:System.Windows.Forms.Button> controllo. Mentre si fa clic del mouse, premere ALT + TAB per passare a un altro programma. Si noti che il <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento viene generato in quanto consente di gestire potenzialmente questo scenario. A seconda delle azioni dell'utente, il <xref:System.Windows.Forms.Control.MouseUp> evento potrebbe non essere generato. È anche possibile provare il test con il tasto Windows o CTRL + ESC.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa clic con il mouse sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pressione di un pulsante del mouse quando il cursore si trova su un controllo in genere genera la seguente serie di eventi dal controllo:  
  
1.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
2.  Evento <xref:System.Windows.Forms.Control.Click>.  
  
3.  Evento <xref:System.Windows.Forms.Control.MouseClick>.  
  
4.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
 Per questa operazione venga eseguita, i vari eventi non possono essere disabilitati nella classe del controllo.  
  
 Due singoli clic che si verificano nel tempo, come determinato dalle impostazioni del mouse del sistema operativo dell'utente, genereranno una <xref:System.Windows.Forms.Control.MouseDoubleClick> evento anziché il secondo <xref:System.Windows.Forms.Control.MouseClick> evento.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click> gli eventi sono eventi logicamente livello superiore di un controllo. Vengono spesso generati da altre azioni, ad esempio premendo il tasto INVIO quando il controllo ha lo stato attivo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.MouseClick> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.MouseClick> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa doppio clic con il mouse sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.MouseDoubleClick> evento si verifica quando l'utente preme un pulsante del mouse due volte in rapida successione, mentre il cursore viene spostato sul controllo. L'intervallo di tempo che separa i due clic distinti solo da un doppio clic è determinato dalle impostazioni del mouse del sistema operativo dell'utente.  
  
 La seguente serie di eventi viene generata dal controllo quando si verifica tale azione utente:  
  
1.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
2.  Evento <xref:System.Windows.Forms.Control.Click>.  
  
3.  Evento <xref:System.Windows.Forms.Control.MouseClick>.  
  
4.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
5.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
6.  Evento <xref:System.Windows.Forms.Control.DoubleClick>.  
  
7.  Evento <xref:System.Windows.Forms.Control.MouseDoubleClick>.  
  
8.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
 Per questa operazione venga eseguita, i vari eventi non possono essere disabilitati nella classe del controllo.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick> gli eventi sono eventi logicamente livello superiore di un controllo. Essi possono essere generati da altre azioni dell'utente, ad esempio le combinazioni di tasti di scelta rapida.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.MouseDoubleClick> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.MouseDoubleClick> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDown : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse si trova sul controllo mentre viene premuto un pulsante del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse entra nell'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse si sofferma sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tipico utilizzo di <xref:System.Windows.Forms.Control.MouseHover> consiste nel visualizzare una descrizione comandi quando si posiziona il puntatore del mouse su un controllo all'interno di una determinata area intorno al controllo (il "area rettangolare"). Richiesto per la generazione di questo evento viene specificato in millisecondi per il <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> proprietà.  
  
 Il <xref:System.Windows.Forms.Control.MouseHover> evento viene definito e rilevato in combinazione con il <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> e <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> proprietà.  
  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse esce dall'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse viene spostato sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzi tipici di <xref:System.Windows.Forms.Control.MouseMove> sono per modificare il colore del controllo o per disegnare un rettangolo generato intorno al controllo.  
  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.MousePosition : System.Drawing.Point" Usage="System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la posizione del cursore del mouse in base alle coordinate dello schermo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Point" /> che contiene le coordinate del cursore del mouse in relazione all'angolo superiore sinistro dello schermo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.MousePosition%2A> proprietà restituisce un <xref:System.Drawing.Point> che rappresenta la posizione del cursore del mouse al momento la proprietà è stato fatto riferimento. Le coordinate indicano la posizione sullo schermo, non rispetto al controllo e vengono restituite indipendentemente dal fatto il cursore viene posizionato sul controllo. Le coordinate dell'angolo superiore sinistro dello schermo sono 0,0.  
  
 Il <xref:System.Windows.Forms.Control.MousePosition%2A> è identica alla proprietà di <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 Nel codice seguente viene inserita una <xref:System.Windows.Forms.TreeNode> etichetta in uno stato modificabile quando l'utente preme ALT + E mentre il cursore si trova sopra il nodo dell'albero. Dopo che l'utente viene eseguita modificando l'etichetta, le etichette non possono essere modificate nuovamente finché non viene premuta nuovamente la combinazione di tasti ALT + E. In questo esempio si suppone una <xref:System.Windows.Forms.TreeView> su un <xref:System.Windows.Forms.Form>. Visualizzazione albero deve essere almeno <xref:System.Windows.Forms.TreeNode> nel relativo <xref:System.Windows.Forms.TreeView.Nodes%2A> insieme.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseUp : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse si trova sul controllo mentre viene rilasciato un pulsante del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non è presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> insieme: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo scheda (in cui la <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della pagina della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si sposta la rotellina del mouse mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si gestisce il <xref:System.Windows.Forms.Control.MouseWheel> eventi è importante seguire gli standard di interfaccia utente associati con la rotellina del mouse. Il <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> valore della proprietà indica la quantità la rotellina del mouse è stata spostata. Quando il delta accumulato è più o meno 120 è necessario scorrere l'interfaccia utente. L'interfaccia utente è necessario scorrere il numero di righe logiche restituite dal <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> proprietà per ciascun valore delta raggiunto. È possibile anche scorrimento più agevolmente tale 120 unità incrementi inferiori, ma il rapporto deve rimanere costante, vale a dire <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> righe scorse per 120 unità delta di spostamento della rotellina.  
  
 Per ulteriori informazioni sulla gestione dei messaggi rotellina del mouse, vedere la[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)argomento.  
  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare gli eventi del mouse diversi per tracciare il percorso del puntatore del mouse su un <xref:System.Windows.Forms.Panel>. Un segmento di linea viene aggiunto per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando i <xref:System.Windows.Forms.Control.MouseWheel> evento si verifica. Eventi mouse aggiuntive, quali ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Ulteriori informazioni sul mouse da vengono inoltre visualizzate sullo schermo il <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberSignature Language="F#" Value="member this.Move : EventHandler " Usage="member this.Move : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo viene spostato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Move> evento per visualizzare la posizione del form in coordinate dello schermo nella barra del titolo del form.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del controllo.</summary>
        <value>Nome del controllo. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Name%2A> proprietà può essere utilizzata in fase di esecuzione per valutare l'oggetto per nome anziché a tipo e nome a livello di codice. Poiché il <xref:System.Windows.Forms.Control.Name%2A> proprietà restituisce un <xref:System.String> tipo, possono essere valutata in istruzioni case stile logiche (`Select` istruzione in Visual Basic `switch` istruzione in Visual c# e [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]).  
  
   
  
## Examples  
 Consente di visualizzare esempio di codice seguente il <xref:System.Windows.Forms.Control.Name%2A> di un controllo in un <xref:System.Windows.Forms.MessageBox> quando il controllo viene aggiunto o rimosso da un form.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberSignature Language="F#" Value="abstract member NotifyInvalidate : System.Drawing.Rectangle -&gt; unit&#xA;override this.NotifyInvalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.NotifyInvalidate invalidatedArea" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area da invalidare.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Invalidated" /> con un'area specificata del controllo da invalidare.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="control.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="control.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCausesValidationChanged : EventArgs -&gt; unit&#xA;override this.OnCausesValidationChanged : EventArgs -&gt; unit" Usage="control.OnCausesValidationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit&#xA;override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="control.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.UICuesEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ChangeUICues" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnChangeUICues%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="control.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'override di <xref:System.Windows.Forms.Control.OnClick%2A> metodo in una classe derivata. Per eseguire l'esempio, incollare il codice seguente dopo una classe del modulo, nello stesso file. Aggiungere una casella di testo di tipo `SingleClickTextBox` al form.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 Esempio di codice seguente illustra uno dei numerosi impieghi del <xref:System.Windows.Forms.Control.Click> evento e gestore eventi.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClientSizeChanged : EventArgs -&gt; unit&#xA;override this.OnClientSizeChanged : EventArgs -&gt; unit" Usage="control.OnClientSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuStripChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuStripChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuStripChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.ControlEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ControlAdded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamato quando un controllo figlio viene aggiunto al controllo.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnControlAdded%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlAdded> per aggiungere un controllo a un form e visualizza il nome del controllo aggiunto in un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlRemoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.ControlEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ControlRemoved" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamato quando un controllo figlio viene rimossa dal controllo.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnControlRemoved%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlRemoved> per rimuovere un controllo da un form e visualizza il nome del controllo rimosso in una <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateControl : unit -&gt; unit&#xA;override this.OnCreateControl : unit -&gt; unit" Usage="control.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera il metodo <see cref="M:System.Windows.Forms.Control.CreateControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.OnCreateControl%2A> metodo viene chiamato quando il controllo viene innanzitutto creato.  
  
 Il metodo <xref:System.Windows.Forms.Control.OnCreateControl%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCursorChanged : EventArgs -&gt; unit&#xA;override this.OnCursorChanged : EventArgs -&gt; unit" Usage="control.OnCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnCursorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDockChanged : EventArgs -&gt; unit&#xA;override this.OnDockChanged : EventArgs -&gt; unit" Usage="control.OnDockChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DockChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDockChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoubleClick : EventArgs -&gt; unit&#xA;override this.OnDoubleClick : EventArgs -&gt; unit" Usage="control.OnDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDoubleClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DoubleClick> evento di un <xref:System.Windows.Forms.ListBox> per caricare i file di testo racchiusi il <xref:System.Windows.Forms.ListBox> in un <xref:System.Windows.Forms.TextBox> controllo.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedAfterParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedAfterParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedAfterParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedBeforeParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedBeforeParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedBeforeParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragDrop drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragDrop%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragEnter drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragEnter%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="control.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragLeave%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragOver drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragOver%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="control.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnter : EventArgs -&gt; unit&#xA;override this.OnEnter : EventArgs -&gt; unit" Usage="control.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Enter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnEnter%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Enter> evento per modificare i colori di primo piano e sfondo di un <xref:System.Windows.Forms.TextBox> in condizioni particolari.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFontChanged : EventArgs -&gt; unit&#xA;override this.OnFontChanged : EventArgs -&gt; unit" Usage="control.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnFontChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="control.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="control.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">Oggetto <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.GiveFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : EventArgs -&gt; unit&#xA;override this.OnGotFocus : EventArgs -&gt; unit" Usage="control.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnGotFocus%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleCreated : EventArgs -&gt; unit&#xA;override this.OnHandleCreated : EventArgs -&gt; unit" Usage="control.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnHandleCreated%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleDestroyed : EventArgs -&gt; unit&#xA;override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="control.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit&#xA;override this.OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit" Usage="control.OnHelpRequested hevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">Oggetto <see cref="T:System.Windows.Forms.HelpEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.HelpRequested" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnHelpRequested%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeModeChanged : EventArgs -&gt; unit&#xA;override this.OnImeModeChanged : EventArgs -&gt; unit" Usage="control.OnImeModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ImeModeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit&#xA;override this.OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit" Usage="control.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.InvalidateEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Invalidated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnInvalidated%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.KeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnKeyDown%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyDown> evento per determinare il tipo di carattere immesso nel controllo.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="control.OnKeyPress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.KeyPress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnKeyPress%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyPress> evento per impedire che i caratteri accedendo al controllo.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.KeyUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnKeyUp%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyUp> evento con la <xref:System.Windows.Forms.Help> classe per visualizzare la Guida di stile popup all'utente.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="abstract member OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit&#xA;override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="control.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Oggetto <see cref="T:System.Windows.Forms.LayoutEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLayout%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento e per l'ancoraggio tipici e funzioni di ancoraggio. Le classi derivate devono eseguire l'override di questo metodo per eseguire qualsiasi logica di layout personalizzato.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLeave : EventArgs -&gt; unit&#xA;override this.OnLeave : EventArgs -&gt; unit" Usage="control.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Leave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLeave%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Leave> evento per reimpostare un controllo allo stato precedente.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="control.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLocationChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : EventArgs -&gt; unit&#xA;override this.OnLostFocus : EventArgs -&gt; unit" Usage="control.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.LostFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLostFocus%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMarginChanged : EventArgs -&gt; unit&#xA;override this.OnMarginChanged : EventArgs -&gt; unit" Usage="control.OnMarginChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MarginChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMarginChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseCaptureChanged : EventArgs -&gt; unit&#xA;override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="control.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseDown%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : EventArgs -&gt; unit&#xA;override this.OnMouseEnter : EventArgs -&gt; unit" Usage="control.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseEnter%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : EventArgs -&gt; unit&#xA;override this.OnMouseHover : EventArgs -&gt; unit" Usage="control.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseHover" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseHover%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come eseguire l'override di <xref:System.Windows.Forms.Control.OnMouseHover%2A> e <xref:System.Windows.Forms.Control.OnMouseMove%2A> metodi in una classe derivata. Per eseguire l'esempio, incollare il codice seguente in un nuovo form e incollare questa classe, che costituiscono lo stesso file, dopo il modulo. Aggiungere un pulsante di tipo `FunButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : EventArgs -&gt; unit&#xA;override this.OnMouseLeave : EventArgs -&gt; unit" Usage="control.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseLeave%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseMove" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseMove%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come eseguire l'override di <xref:System.Windows.Forms.Control.OnMouseHover%2A> e <xref:System.Windows.Forms.Control.OnMouseMove%2A> metodi in una classe derivata. Per eseguire l'esempio, incollare il codice seguente in un nuovo form e incollare questa classe, che costituiscono lo stesso file, dopo il modulo. Aggiungere un pulsante di tipo `FunButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseUp%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseWheel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseWheel%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMove : EventArgs -&gt; unit&#xA;override this.OnMove : EventArgs -&gt; unit" Usage="control.OnMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Move" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMove%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Move> evento per visualizzare la posizione del form in coordinate dello schermo nella barra del titolo del form.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyMessage : System.Windows.Forms.Message -&gt; unit&#xA;override this.OnNotifyMessage : System.Windows.Forms.Message -&gt; unit" Usage="control.OnNotifyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> che rappresenta il messaggio di Windows.</param>
        <summary>Notifica al controllo i messaggi di Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> metodo viene chiamato se il controllo `EnableNotifyMessage` bit di stile è impostato <xref:System.Windows.Forms.ControlStyles>. Il `EnableNotifyMessage` stile <xref:System.Windows.Forms.ControlStyles> consente di ricevere una notifica quando il controllo di <xref:System.Windows.Forms.Control.WndProc%2A> metodo riceve un messaggio di Windows. Con questo metodo, i controlli semi-trusted possono restare in attesa dei messaggi di Windows senza dover modificare il messaggio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> in una classe derivata, chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> (metodo) non è necessario perché non vi è Nessuna implementazione iniziale.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaddingChanged : EventArgs -&gt; unit&#xA;override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="control.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.PaddingChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnPaint%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente consente all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui viene eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> metodo viene sottoposto a override per ridisegnare l'immagine di ogni volta che viene disegnato il form; in caso contrario, l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati in form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> metodo di gestione eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> può essere creato dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> i valori sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaintBackground pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene informazioni sul controllo da disegnare.</param>
        <summary>Disegna lo sfondo del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.OnPaintBackground%2A> le richieste di cancellazione metodo consente alle classi derivate di gestire in background di Windows.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Le classi che ereditano devono eseguire l'override di questo metodo per gestire la richiesta di cancellazione in background da windows. Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> in una classe derivata non è necessario chiamare la classe basa <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackColorChanged : EventArgs -&gt; unit" Usage="control.OnParentBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackColor" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnParentBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnParentBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnParentBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BindingContext" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentChanged : EventArgs -&gt; unit&#xA;override this.OnParentChanged : EventArgs -&gt; unit" Usage="control.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ParentChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentCursorChanged : EventArgs -&gt; unit&#xA;override this.OnParentCursorChanged : EventArgs -&gt; unit" Usage="control.OnParentCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnParentEnabledChanged : EventArgs -&gt; unit" Usage="control.OnParentEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Enabled" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentFontChanged : EventArgs -&gt; unit&#xA;override this.OnParentFontChanged : EventArgs -&gt; unit" Usage="control.OnParentFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.FontChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Font" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentForeColorChanged : EventArgs -&gt; unit" Usage="control.OnParentForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ForeColor" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnParentRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnParentRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.RightToLeft" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentVisibleChanged : EventArgs -&gt; unit" Usage="control.OnParentVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Visible" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit" Usage="control.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPrint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `UserPaint` bit del <xref:System.Windows.Forms.ControlStyles> è impostata, è possibile eseguire l'override <xref:System.Windows.Forms.Control.OnPrint%2A> per eseguire un disegno su più livelli. Per altre informazioni, vedere <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="e" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="control.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">Oggetto <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver iniziato il trascinamento, questo metodo viene chiamato più volte dal [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] finché l'operazione di trascinamento viene annullata o completata.  
  
> [!NOTE]
>  Eseguire l'override di questo metodo se si desidera modificare il punto in cui il trascinamento viene annullato o in cui viene eseguito un rilascio.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRegionChanged : EventArgs -&gt; unit&#xA;override this.OnRegionChanged : EventArgs -&gt; unit" Usage="control.OnRegionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.RegionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnRegionChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResize : EventArgs -&gt; unit&#xA;override this.OnResize : EventArgs -&gt; unit" Usage="control.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Resize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnResize%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento. Il <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> metodo può essere chiamato durante la costruzione, pertanto se si esegue l'override <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> può essere chiamato prima della chiamata al costruttore del controllo.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSizeChanged : EventArgs -&gt; unit&#xA;override this.OnSizeChanged : EventArgs -&gt; unit" Usage="control.OnSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnSizeChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : EventArgs -&gt; unit&#xA;override this.OnStyleChanged : EventArgs -&gt; unit" Usage="control.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.StyleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnStyleChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSystemColorsChanged : EventArgs -&gt; unit&#xA;override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="control.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabIndexChanged : EventArgs -&gt; unit&#xA;override this.OnTabIndexChanged : EventArgs -&gt; unit" Usage="control.OnTabIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.TabIndexChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabStopChanged : EventArgs -&gt; unit&#xA;override this.OnTabStopChanged : EventArgs -&gt; unit" Usage="control.OnTabStopChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.TabStopChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextChanged : EventArgs -&gt; unit&#xA;override this.OnTextChanged : EventArgs -&gt; unit" Usage="control.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnTextChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidated : EventArgs -&gt; unit&#xA;override this.OnValidated : EventArgs -&gt; unit" Usage="control.OnValidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Validated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnValidated%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="control.OnValidating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.ComponentModel.CancelEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Validating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnValidating%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="control.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modifiche ai valori (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dal <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la spaziatura interna del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta le caratteristiche di spaziatura interna del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i contenitori, ad esempio <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.TabControl>, la <xref:System.Windows.Forms.Control.Padding%2A> proprietà recupera o imposta le rispettive <xref:System.Windows.Forms.Control.DisplayRectangle%2A> proprietà. Il <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType> proprietà è uguale al relativo <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType> proprietà.  
  
 I valori predefiniti per i controlli ricevono <xref:System.Windows.Forms.Control.Padding%2A> che ragionevolmente sta per raggiungere linee guida sull'interfaccia utente di Windows. Alcune modifiche potrebbero essere ancora necessari per determinate applicazioni.  
  
 Tutti i controlli che implementano <xref:System.Windows.Forms.Control.GetPreferredSize%2A> sono aumentati quantità in <xref:System.Windows.Forms.Control.Padding%2A> quando <xref:System.Windows.Forms.Control.AutoSize%2A> è `true`.  
  
 I controlli seguenti non utilizzano <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   I controlli che non implementano <xref:System.Windows.Forms.Control.AutoSize%2A> tramite <xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   Controlli personalizzati che ereditano direttamente dalla <xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la spaziatura interna del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.PaddingChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.PaddingChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo viene ridisegnato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Paint> evento viene generato quando il controllo viene ridisegnato. Passa un'istanza di <xref:System.Windows.Forms.PaintEventArgs> per i metodi che gestisce il <xref:System.Windows.Forms.Control.Paint> evento.  
  
 Quando si crea un nuovo controllo personalizzato o un controllo ereditato con un aspetto visivo diverso, è necessario fornire il codice per il rendering del controllo eseguendo l'override di <xref:System.Windows.Forms.Control.OnPaint%2A> metodo. Per altre informazioni, vedere [override del metodo OnPaint](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) e [disegno e controlli personalizzati per il Rendering](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md).  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.PictureBox> controllo sulla forma e viene utilizzato il <xref:System.Windows.Forms.Control.Paint> evento per tracciare a esso.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contenitore padre del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo padre o contenitore del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione di <xref:System.Windows.Forms.Control.Parent%2A> valore della proprietà da `null` rimuove il controllo dal <xref:System.Windows.Forms.Control.ControlCollection> del relativo controllo padre corrente.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Parent%2A> proprietà e il <xref:System.Windows.Forms.Control.FindForm%2A> metodo per impostare le proprietà del controllo padre di un pulsante e il relativo modulo.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre ottenere il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentChanged : EventHandler " Usage="member this.ParentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Parent" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Parent%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina l'applicazione della logica di layout del controllo ai controlli figlio.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : unit -&gt; unit" Usage="control.PerformLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina l'applicazione della logica di layout del controllo a tutti i rispettivi controlli figlio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo è stato chiamato prima di chiamare il <xref:System.Windows.Forms.Control.PerformLayout%2A> metodo, il <xref:System.Windows.Forms.Control.Layout> evento viene eliminato.  
  
 Il <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> e <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> proprietà del <xref:System.Windows.Forms.LayoutEventArgs> creato vengono impostate su `null` se viene fornito alcun valore quando il <xref:System.Windows.Forms.Control.PerformLayout%2A> metodo è stato chiamato.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come utilizzare il metodo <xref:System.Windows.Forms.Control.PerformLayout%2A>. Vengono inoltre illustrati i modi in cui il <xref:System.Windows.Forms.Control.Layout> evento viene generato. In questo esempio, il `Click` gestore eventi per `Button1` chiama in modo esplicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. Il `Click` gestore eventi per `Button2` chiama in modo implicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> viene inoltre chiamato quando viene caricato il modulo. `Button3` Restituisce il controllo lo stato al caricamento. In ogni caso, il <xref:System.Windows.Forms.Control.Layout> evento viene generato.  
  
 Questo è un esempio completo. Per eseguire l'esempio, incollare il codice seguente in un form vuoto.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : System.Windows.Forms.Control * string -&gt; unit" Usage="control.PerformLayout (affectedControl, affectedProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo modificato più di recente.</param>
        <param name="affectedProperty">Nome della proprietà del controllo modificata più di recente.</param>
        <summary>Determina l'applicazione della logica di layout del controllo a tutti i rispettivi controlli figlio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo è stato chiamato prima di chiamare il <xref:System.Windows.Forms.Control.PerformLayout%2A> metodo, il <xref:System.Windows.Forms.Control.Layout> evento viene eliminato.  
  
 Il `affectedControl` e `affectedProperty` parametri possono essere entrambe impostati su `null`. Determina il <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> e <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> proprietà del <xref:System.Windows.Forms.LayoutEventArgs> creata per essere impostato su `null`.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come utilizzare il metodo <xref:System.Windows.Forms.Control.PerformLayout%2A>. Vengono inoltre illustrati i modi in cui il <xref:System.Windows.Forms.Control.Layout> evento viene generato. In questo esempio, il `Click` gestore eventi per `Button1` chiama in modo esplicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. Il `Click` gestore eventi per `Button2` chiama in modo implicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> viene inoltre chiamato quando viene caricato il modulo. `Button3` Restituisce il controllo lo stato al caricamento. In ogni caso, il <xref:System.Windows.Forms.Control.Layout> evento viene generato.  
  
 Questo è un esempio completo. Per eseguire l'esempio, incollare il codice seguente in un form vuoto.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToClient p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Oggetto <see cref="T:System.Drawing.Point" /> delle coordinate dello schermo da convertire.</param>
        <summary>Calcola la posizione del punto dello schermo specificato nelle coordinate client.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Point" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Point" /> convertito, <paramref name="p" />, nelle coordinate client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice esempio seguente viene abilitata all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui viene eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> metodo viene sottoposto a override per ridisegnare l'immagine di ogni volta che viene disegnato il form; in caso contrario, l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati in form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> metodo di gestione eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> può essere creato dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> i valori sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToScreen p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Oggetto <see cref="T:System.Drawing.Point" /> delle coordinate client da convertire.</param>
        <summary>Calcola la posizione del punto client specificato nelle coordinate dello schermo.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Point" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Point" /> convertito, <paramref name="p" />, nelle coordinate dello schermo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, e <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> membri. Per eseguire l'esempio, incollare il codice seguente in un form denominato Form1 contenente diversi controlli. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, e <xref:System.Windows.Forms.Control.MouseUp> eventi connessi ai gestori di eventi definiti nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni di un'area rettangolare in cui è possibile inserire un controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> contenente l'altezza e la larghezza, espresse in pixel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="member this.PreProcessControlMessage :  -&gt; System.Windows.Forms.PreProcessControlState" Usage="control.PreProcessControlMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Windows.Forms.Message" /> che rappresenta il messaggio da elaborare.</param>
        <summary>Consente la pre-elaborazione dei messaggi di tastiera o di input all'interno del ciclo di messaggi prima che vengano inviati.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.PreProcessControlState" />, a seconda se il metodo <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> è <see langword="true" /> o <see langword="false" /> e se i metodi <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> o <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> sono <see langword="true" /> o <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="abstract member PreProcessMessage :  -&gt; bool&#xA;override this.PreProcessMessage :  -&gt; bool" Usage="control.PreProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio da elaborare. I valori possibili sono WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR e WM_SYSCHAR.</param>
        <summary>Consente la pre-elaborazione dei messaggi di tastiera o di input all'interno del ciclo di messaggi prima che vengano inviati.</summary>
        <returns><see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> viene chiamato dal ciclo di messaggi dell'applicazione da pre-elaborare i messaggi di input prima che vengano inviati. I valori possibili per il `msg` parametro sono WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR e WM_SYSCHAR.  
  
 Quando si esegue l'override <xref:System.Windows.Forms.Control.PreProcessMessage%2A>, deve restituire un controllo `true` per indicare che è stato elaborato il messaggio. Per i messaggi non elaborati dal controllo, il risultato di `base.PreProcessMessage` devono essere restituiti. I controlli in genere sostituiranno uno dei metodi più specializzati, ad esempio <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>, o <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> anziché eseguire l'override <xref:System.Windows.Forms.Control.PreProcessMessage%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per il chiamante immediato chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica prima dell'evento <see cref="E:System.Windows.Forms.Control.KeyDown" /> quando viene premuto un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni pressioni dei tasti, ad esempio la scheda, RETURN, ESC e tasti di direzione, in genere vengono ignorati da alcuni controlli perché non sono considerati inpue pressioni dei tasti. Ad esempio, per impostazione predefinita, un <xref:System.Windows.Controls.Button> controllo Ignora i tasti di direzione. Premere i tasti di direzione in genere fa sì che lo stato attivo spostare il controllo precedente o successivo. I tasti di direzione sono considerati tasti di navigazione e premendo queste chiavi non è in genere aumentare la <xref:System.Windows.Forms.Control.KeyDown> evento per un <xref:System.Windows.Controls.Button>. Tuttavia, premere la freccia di chiavi per un <xref:System.Windows.Controls.Button> generare il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento. Gestendo il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento per un <xref:System.Windows.Controls.Button> e impostando il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà `true`, è possibile generare il <xref:System.Windows.Forms.Control.KeyDown> evento quando vengono premuti i tasti di direzione. Tuttavia, se si gestiscono i tasti di direzione, lo stato attivo non è più passerà al controllo precedente o successivo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra una <xref:System.Windows.Forms.Button> che include un <xref:System.Windows.Forms.ContextMenuStrip>. Quando il <xref:System.Windows.Forms.Button> ha lo stato attivo e si premono i tasti freccia su o freccia giù, il <xref:System.Windows.Forms.ContextMenuStrip> viene visualizzata. Il <xref:System.Windows.Forms.Control.PreviewKeyDown> gestore eventi rilevare quando vengono premuti i tasti freccia su o freccia giù e imposta il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà `true`. Questo genera la <xref:System.Windows.Forms.Control.KeyDown> eventi in modo che sia possibile visualizzare il <xref:System.Windows.Forms.ContextMenuStrip>. Non è opportuno inserire qualsiasi logica <xref:System.Windows.Forms.Control.PreviewKeyDown> gestore dell'evento, se non per impostare il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà. Al contrario, è necessario inserire la logica nel <xref:System.Windows.Forms.Control.KeyDown> gestore dell'evento.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <param name="keyData">Uno dei valori di <see cref="T:System.Windows.Forms.Keys" /> che rappresenta il tasto da elaborare.</param>
        <summary>Elabora un tasto di comando.</summary>
        <returns><see langword="true" /> se il carattere è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato durante la pre-elaborazione di messaggi per gestire le chiavi di comando. Comando chiavi sono chiavi che hanno sempre la precedenza sulle normali tasti di input. Menu di scelta rapida e tasti di scelta rapida sono esempi di chiavi di comando. Il metodo deve restituire `true` per indicare che è stato elaborato il tasto di comando, o `false` per indicare che la chiave non è un tasto di comando. Questo metodo viene chiamato solo quando il controllo è ospitato in un'applicazione Windows Forms o come un controllo ActiveX.  
  
 Il <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> metodo determina innanzitutto se il controllo ha un <xref:System.Windows.Forms.ContextMenu>e in tal caso, abilita il <xref:System.Windows.Forms.ContextMenu> per elaborare il tasto di comando. Se il tasto di comando non è un collegamento al menu e il controllo ha un padre, la chiave viene passata al padre <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> metodo. L'effetto finale è tale comando chiavi sono "propagate" la gerarchia dei controlli. Oltre alla chiave utente ha premuto, i dati della chiave indicano inoltre che, se presenti, sono stati premuti modifica in contemporanea con la chiave. Tasti di modifica includono i tasti MAIUSC, CTRL e ALT.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato e le classi che ereditano da chiamare questo metodo. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe di base <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogChar : char -&gt; bool&#xA;override this.ProcessDialogChar : char -&gt; bool" Usage="control.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da elaborare.</param>
        <summary>Elabora un carattere della finestra di dialogo.</summary>
        <returns><see langword="true" /> se il carattere è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato durante la pre-elaborazione per gestire i caratteri di finestra di dialogo, ad esempio i tasti di scelta di controllo dei messaggi. Questo metodo viene chiamato solo se il <xref:System.Windows.Forms.Control.IsInputChar%2A> metodo indica che il controllo non elabora il carattere. Il <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> metodo invia semplicemente il carattere dell'elemento padre <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> metodo oppure restituisce `false` se il controllo non ha elementi padre. Il <xref:System.Windows.Forms.Form> classe esegue l'override di questo metodo per eseguire operazioni di elaborazione effettivo di caratteri di finestra di dialogo. Questo metodo viene chiamato solo quando il controllo è ospitato in un'applicazione Windows Forms o come un controllo ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il carattere è stato elaborato. Per i caratteri che non vengono elaborati dal controllo, il risultato della chiamata della classe di base <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno dei valori di <see cref="T:System.Windows.Forms.Keys" /> che rappresenta il tasto da elaborare.</param>
        <summary>Elabora un tasto della finestra di dialogo.</summary>
        <returns><see langword="true" /> se il tasto è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato durante la pre-elaborazione di messaggi per gestire i caratteri di finestra di dialogo, ad esempio, RETURN, ESC, tasti freccia e TAB. Questo metodo viene chiamato solo se il <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo indica che il controllo non elabora il tasto. Il <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> invia semplicemente il carattere dell'elemento padre <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> metodo oppure restituisce `false` se il controllo non ha elementi padre. Il <xref:System.Windows.Forms.Form> classe esegue l'override di questo metodo per eseguire l'elaborazione effettiva di finestre di dialogo. Questo metodo viene chiamato solo quando il controllo è ospitato in un'applicazione Windows Forms o come un controllo ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe di base <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyEventArgs :  -&gt; bool&#xA;override this.ProcessKeyEventArgs :  -&gt; bool" Usage="control.ProcessKeyEventArgs m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <summary>Elabora un messaggio relativo ai tasti e generare gli eventi appropriati del controllo.</summary>
        <returns><see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato quando un controllo riceve un messaggio della tastiera. Il metodo è responsabile della generazione di eventi chiavi appropriati per il messaggio chiamando il <xref:System.Windows.Forms.Control.OnKeyPress%2A>, <xref:System.Windows.Forms.Control.OnKeyDown%2A>, o <xref:System.Windows.Forms.Control.OnKeyUp%2A> metodi. Il `m` parametro contiene la finestra di messaggio che deve essere elaborato. I valori possibili per il <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> proprietà sono WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP e WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe di base <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyMessage :  -&gt; bool&#xA;override this.ProcessKeyMessage :  -&gt; bool" Usage="control.ProcessKeyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <summary>Elabora un messaggio della tastiera.</summary>
        <returns><see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato quando un controllo riceve un messaggio della tastiera. Il metodo determina innanzitutto se il controllo ha un padre. In tal caso, chiama il genitore <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo. Se l'elemento padre <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo non viene elaborato il messaggio il <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> metodo viene chiamato per generare gli eventi della tastiera appropriata. Il `m` parametro contiene la finestra di messaggio che deve essere elaborato. I valori possibili per il <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> proprietà sono WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP e WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> metodo, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della classe base <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> devono essere restituiti. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyPreview :  -&gt; bool&#xA;override this.ProcessKeyPreview :  -&gt; bool" Usage="control.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <summary>Visualizza in anteprima un messaggio della tastiera.</summary>
        <returns><see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da un controllo figlio quando il controllo figlio riceve un messaggio della tastiera. Il controllo figlio chiama questo metodo prima di generare tutti gli eventi della tastiera per il messaggio. Se questo metodo restituisce `true`, il controllo figlio considera elaborato il messaggio e non genera alcun evento della tastiera. Il `m` parametro contiene il messaggio della finestra per visualizzare in anteprima. I valori possibili per il <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> proprietà sono WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP e WM_SYSKEYUP. Il <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo invia semplicemente il carattere dell'elemento padre <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo oppure restituisce `false` se il controllo non ha elementi padre. Il <xref:System.Windows.Forms.Form> classe esegue l'override di questo metodo per eseguire l'elaborazione effettiva di finestre di dialogo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe di base <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> (metodo) deve essere restituito.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessMnemonic : char -&gt; bool&#xA;override this.ProcessMnemonic : char -&gt; bool" Usage="control.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da elaborare.</param>
        <summary>Elabora un carattere per il tasto di scelta.</summary>
        <returns><see langword="true" /> se il carattere è stato elaborato come tasto di scelta dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato per consentire a un controllo per l'elaborazione di un tasto mnemonico. Il metodo deve determinare se il controllo è in uno stato a tasti di scelta di processo e se il carattere specificato rappresenta un tasto di scelta. Se in tal caso, il metodo deve eseguire l'azione associata con il tasto di scelta e ritorno `true`. Se non, il metodo dovrebbe restituire `false`. Le implementazioni di questo metodo utilizzano spesso la <xref:System.Windows.Forms.Control.IsMnemonic%2A> metodo per determinare se il carattere specificato corrisponde a un tasto di scelta nel testo del controllo.  
  
 Ad esempio:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Questa implementazione predefinita del <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodo restituisce semplicemente `false` per indicare che il controllo non dispone di alcun tasto di scelta.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra un'estensione della classe pulsante che esegue l'override di <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodo per mostrare un comportamento personalizzato. Nell'esempio viene inoltre illustrato l'utilizzo del <xref:System.Windows.Forms.Control.CanSelect%2A> e <xref:System.Windows.Forms.Control.IsMnemonic%2A> proprietà. Per eseguire questo esempio, incollare il codice seguente dopo una classe del modulo, nello stesso file. Aggiungere un pulsante di tipo `MnemonicButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del prodotto dell'assembly che contiene il controllo.</summary>
        <value>Nome del prodotto dell'assembly che contiene il controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ProductName%2A> è una proprietà di sola lettura. Per modificare il valore di questa proprietà, impostare il <xref:System.Reflection.AssemblyProductAttribute.Product%2A> valore della proprietà di <xref:System.Reflection.AssemblyProductAttribute>. La riga di set di codice c# seguente il <xref:System.Windows.Forms.Control.ProductName%2A> proprietà.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  Si consiglia fornire il nome della società, nome prodotto e versione del prodotto. Queste informazioni consentono l'uso delle funzionalità di Windows Form, ad esempio <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> che semplificano la creazione di applicazioni compatibili con il programma "Certified for Windows". Per ulteriori informazioni sul programma Certified for Windows, vedere http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare informazioni sull'applicazione in un <xref:System.Windows.Forms.Label> contenuti in un <xref:System.Windows.Forms.Form>. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> e <xref:System.Windows.Forms.Control.ProductVersion%2A> sono state impostate.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la versione dell'assembly che contiene il controllo.</summary>
        <value>Versione del file dell'assembly che contiene il controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ProductVersion%2A> è una proprietà di sola lettura. Per modificare il valore di questa proprietà, impostare il <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> valore della proprietà di <xref:System.Reflection.AssemblyVersionAttribute>. La riga di set di codice c# seguente il <xref:System.Windows.Forms.Control.ProductVersion%2A> proprietà.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  Si consiglia fornire il nome della società, nome prodotto e versione del prodotto. Queste informazioni consentono l'uso delle funzionalità di Windows Form, ad esempio <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> che semplificano la creazione di applicazioni compatibili con il programma "Certified for Windows". Per ulteriori informazioni sul programma Certified for Windows, vedere http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare informazioni sull'applicazione in un <xref:System.Windows.Forms.Label> contenuti in un <xref:System.Windows.Forms.Form>. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> e <xref:System.Windows.Forms.Control.ProductVersion%2A> sono state impostate.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.PropagatingImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che rappresenta una modalità IME di propagazione.</summary>
        <value>Oggetto che rappresenta una modalità IME di propagazione.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberSignature Language="F#" Value="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " Usage="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> fornisce la Guida per le applicazioni di accessibilità.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile utilizzare il <xref:System.Windows.Forms.HelpProvider> classe per consentire agli utenti di richiamare la Guida relativa all'oggetto accessibile premendo il tasto F1. Utilizzando il <xref:System.Windows.Forms.HelpProvider> vengono fornite informazioni complete nel <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>. Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la creazione di un grafico di supporto per l'accessibilità controllare, tramite il <xref:System.Windows.Forms.AccessibleObject> e <xref:System.Windows.Forms.Control.ControlAccessibleObject> alle classi di esporre le informazioni accessibili. Il controllo è rappresentata da due curve insieme a una legenda. Il `ChartControlAccessibleObject` classe che deriva da `ControlAccessibleObject`, viene utilizzata la <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo per fornire informazioni accessibili personalizzate per il controllo chart. Poiché la legenda del grafico non è una vera e propria <xref:System.Windows.Forms.Control> -controllo in base al, ma viene disegnata dal controllo chart, non non contiene informazioni accessibili. Per questo motivo, il `ChartControlAccessibleObject` classe esegue l'override di <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> per restituire il `CurveLegendAccessibleObject` che rappresenta le informazioni accessibili per ogni parte della legenda. Quando un'applicazione accessibile riconoscere utilizza questo controllo, il controllo può fornire le informazioni accessibili necessarie.  
  
 Questo estratto di codice viene mostrato come gestire il <xref:System.Windows.Forms.Control.QueryAccessibilityHelp> evento. Vedere il <xref:System.Windows.Forms.AccessibleObject> Cenni preliminari sulla classe per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante un'operazione di trascinamento della selezione e consente all'origine del trascinamento di determinare se l'operazione deve essere annullata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato quando si verifica un cambiamento nello stato pulsante layout di tastiera o mouse durante un'operazione di trascinamento e rilascio. Il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento consente all'origine del trascinamento di determinare se l'operazione di trascinamento e rilascio deve essere annullata.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo nella posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante del mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati o annullare l'operazione in base al valore della <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Continue`, la <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con il nuovo effetto consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sull'obiettivo di rilascio, l'utente è più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio, tagliare i dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> viene `Cancel`, il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato.  
  
 Per impostazione predefinita, il <xref:System.Windows.Forms.Control.QueryContinueDrag> set di eventi <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> alla `Cancel` in <xref:System.Windows.Forms.DragAction> se è stato premuto ESC e imposta <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> a `Drop` in <xref:System.Windows.Forms.DragAction> se viene premuto il pulsante sinistro, centrale o destro del mouse.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando viene avviato l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato oltre <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. L'esempio presenta i requisiti che due file cursore,`3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per l'operazione di trascinamento personalizzati e non rilascio i cursori, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> sia selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> gestore dell'evento per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostata su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, viene visualizzato lo stato del trascinamento nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata nel `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.QueryContinueDrag> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseDragEvent : obj * System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.RaiseDragEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento di trascinamento appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseKeyEvent : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.RaiseKeyEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento del tasto appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseMouseEvent : obj * System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.RaiseMouseEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento del mouse appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaisePaintEvent : obj * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.RaisePaintEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento di disegno appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberSignature Language="F#" Value="member this.RecreateHandle : unit -&gt; unit" Usage="control.RecreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina la creazione di un nuovo handle per il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo viene chiamato ogni volta che i parametri sono necessari per un nuovo controllo, ma tramite una chiamata dal <xref:System.Windows.Forms.Control.UpdateStyles%2A> a <xref:System.Windows.Forms.Control.CreateParams%2A> è insufficiente. Questo metodo chiama anche <xref:System.Windows.Forms.Control.DestroyHandle%2A> e <xref:System.Windows.Forms.Control.CreateHandle%2A> e imposta <xref:System.Windows.Forms.Control.RecreatingHandle%2A> a `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RecreatingHandle : bool" Usage="System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo sta creando nuovamente il relativo punto di controllo.</summary>
        <value><see langword="true" /> se il controllo sta creando nuovamente il relativo punto di controllo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.RecreatingHandle%2A> proprietà restituisce `true` se il <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo è ancora in esecuzione sul controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToClient r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Oggetto <see cref="T:System.Drawing.Rectangle" /> delle coordinate dello schermo da convertire.</param>
        <summary>Calcola le dimensioni e la posizione del rettangolo dello schermo specificato nelle coordinate client.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Rectangle" /> convertito, <paramref name="r" />, nelle coordinate client.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToScreen : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToScreen r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Oggetto <see cref="T:System.Drawing.Rectangle" /> delle coordinate client da convertire.</param>
        <summary>Calcola le dimensioni e la posizione del rettangolo client specificato nelle coordinate dello schermo.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Rectangle" /> convertito, <paramref name="p" />, nelle coordinate dello schermo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, e <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> membri. Per eseguire l'esempio, incollare il codice seguente in un form denominato **Form1** contenente diversi controlli. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, e <xref:System.Windows.Forms.Control.MouseUp> eventi connessi ai gestori di eventi definiti nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="static member ReflectMessage : nativeint *  -&gt; bool" Usage="System.Windows.Forms.Control.ReflectMessage (hWnd, m)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">Oggetto <see cref="T:System.IntPtr" /> che rappresenta il punto di controllo del controllo in cui riprodurre il messaggio.</param>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> che rappresenta il messaggio di Windows da riprodurre.</param>
        <summary>Riproduce il messaggio specificato nel controllo associato al punto di controllo specificato.</summary>
        <returns><see langword="true" /> se il messaggio è stato riprodotto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ReflectMessage%2A> metodo è un metodo di infrastruttura e che non deve essere chiamato dal codice.  
  
 Se il `hWnd` parametro non rappresenta un controllo valido, il <xref:System.Windows.Forms.Control.ReflectMessage%2A> restituisce `false`.  
  
 Poiché la finestra di primo livello, vengono restituiti messaggi di Windows il <xref:System.Windows.Forms.Control.ReflectMessage%2A> metodo viene utilizzato per trasmettere il messaggio restituito al controllo che ha inviato il messaggio.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="control.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina l'invalidazione dell'area client del controllo e il nuovo disegno di quest'ultimo e degli eventuali controlli figlio.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.Refresh" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.Refresh" /> metodo in modo che il controllo e i relativi controlli figlio vengono invalidate e ridisegnati.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Region : System.Drawing.Region with get, set" Usage="System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'area della finestra associata al controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Region" /> della finestra associato al controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area della finestra è una raccolta di pixel all'interno della finestra in cui il sistema operativo consente il disegno. Il sistema operativo non in grado di visualizzare le parti di una finestra che si trova all'esterno dell'area della finestra. Le coordinate dell'area del controllo sono rispetto all'angolo superiore sinistro del controllo, non l'area client del controllo.  
  
> [!NOTE]
>  La raccolta di pixel contenuti con l'area può essere non contigua.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Region%2A> proprietà mediante la creazione di un pulsante circolare. Per eseguire l'esempio, incollare il codice seguente in un form contenente un pulsante chiamato `roundButton`. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.Paint> evento sia connesso al gestore dell'evento definito nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre impostare il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberSignature Language="F#" Value="member this.RegionChanged : EventHandler " Usage="member this.RegionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Region" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.RegionChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.RegionChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderRightToLeft : bool" Usage="System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questa proprietà è ora obsoleta.</summary>
        <value><see langword="true" /> se viene eseguito il rendering del controllo da destra a sinistra; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="abstract member RescaleConstantsForDpi : int * int -&gt; unit&#xA;override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="control.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Valore DPI prima della modifica.</param>
        <param name="deviceDpiNew">Valore DPI dopo la modifica.</param>
        <summary>Fornisce le costanti per il ridimensionamento del controllo quando si verifica una modifica del valore DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetBackColor : unit -&gt; unit&#xA;override this.ResetBackColor : unit -&gt; unit" Usage="control.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.BackColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : unit -&gt; unit" Usage="control.ResetBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fa sì che un controllo associato all'oggetto <see cref="T:System.Windows.Forms.BindingSource" /> esegua la rilettura di tutti gli elementi dell'elenco e aggiorni i relativi valori visualizzati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberSignature Language="F#" Value="abstract member ResetCursor : unit -&gt; unit&#xA;override this.ResetCursor : unit -&gt; unit" Usage="control.ResetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberSignature Language="F#" Value="abstract member ResetFont : unit -&gt; unit&#xA;override this.ResetFont : unit -&gt; unit" Usage="control.ResetFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.Font" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetForeColor : unit -&gt; unit&#xA;override this.ResetForeColor : unit -&gt; unit" Usage="control.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.ForeColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberSignature Language="F#" Value="member this.ResetImeMode : unit -&gt; unit" Usage="control.ResetImeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.ImeMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberSignature Language="F#" Value="member this.ResetMouseEventArgs : unit -&gt; unit" Usage="control.ResetMouseEventArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il controllo per gestire l'evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberSignature Language="F#" Value="abstract member ResetRightToLeft : unit -&gt; unit&#xA;override this.ResetRightToLeft : unit -&gt; unit" Usage="control.ResetRightToLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.RightToLeft" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberSignature Language="F#" Value="abstract member ResetText : unit -&gt; unit&#xA;override this.ResetText : unit -&gt; unit" Usage="control.ResetText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta la proprietà <see cref="P:System.Windows.Forms.Control.Text" /> sul valore predefinito <see cref="F:System.String.Empty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere utilizzare questo metodo se si crea una finestra di progettazione per il <xref:System.Windows.Forms.Control> o la creazione di controllo personalizzato che includa il <xref:System.Windows.Forms.Control>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : EventHandler " Usage="member this.Resize : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo viene ridimensionato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare il <xref:System.Windows.Forms.Control.Size%2A> del controllo ridimensionato, è possibile eseguire il cast di `sender` parametro delle proprietà registrate <xref:System.Windows.Forms.ControlEventHandler> metodo da un <xref:System.Windows.Forms.Control> e ottenere relativo <xref:System.Windows.Forms.Control.Size%2A> proprietà (o <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Width%2A> proprietà singolarmente).  
  
 Per gestire layout personalizzati, utilizzare il <xref:System.Windows.Forms.Control.Layout> evento anziché l'evento di ridimensionamento. Il <xref:System.Windows.Forms.Control.Layout> evento viene generato in risposta a un <xref:System.Windows.Forms.Control.Resize> evento, ma anche in risposta ad altre modifiche che influisce sul layout del controllo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Gli handle di esempio di codice seguente il <xref:System.Windows.Forms.Control.Resize> evento di un <xref:System.Windows.Forms.Form>. Quando il form viene ridimensionato, il gestore dell'evento assicura che il modulo resta al quadrato (relativi <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Width%2A> rimangono uguali). Per eseguire questo esempio, verificare e associare questo metodo di gestione degli eventi del modulo <xref:System.Windows.Forms.Control.Resize> evento.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeRedraw : bool with get, set" Usage="System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo viene ridisegnato quando è ridimensionato.</summary>
        <value><see langword="true" /> se il controllo viene ridisegnato quando è ridimensionato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ResizeRedraw%2A> valore della proprietà è equivalente al valore restituito del <xref:System.Windows.Forms.Control.GetStyle%2A> metodo quando si passa il <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType> come parametro un valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riprende la consueta logica di layout.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : unit -&gt; unit" Usage="control.ResumeLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riprende la consueta logica di layout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo impone un layout immediato se sono presenti eventuali richieste di layout in sospeso.  
  
 Il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi vengono usati insieme per eliminare più <xref:System.Windows.Forms.Control.Layout> eventi durante la regolazione di più attributi del controllo. Ad esempio, in genere chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> (metodo), quindi impostare il <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> le proprietà del controllo e quindi chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo per consentire le modifiche diventino effettive.  
  
 Non deve esserci Nessuna chiamata a in sospeso <xref:System.Windows.Forms.Control.SuspendLayout%2A> per <xref:System.Windows.Forms.Control.ResumeLayout%2A> sia chiamato correttamente.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge due pulsanti a un form. Nell'esempio viene eseguita l'aggiunta dei pulsanti utilizzando la <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : bool -&gt; unit" Usage="control.ResumeLayout performLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout"><see langword="true" /> per eseguire le richieste di layout in attesa; in caso contrario, <see langword="false" />.</param>
        <summary>Riprende la consueta logica di layout, imponendo, eventualmente, l'esecuzione di un layout immediato delle richieste di layout in sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo impone un layout immediato se sono presenti eventuali richieste di layout in sospeso. Quando il `performLayout` parametro è impostato su `true`, un layout immediato si verifica se sono presenti eventuali richieste di layout in sospeso.  
  
 Il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi vengono usati insieme per eliminare più <xref:System.Windows.Forms.Control.Layout> eventi durante la regolazione di più attributi del controllo. Ad esempio, in genere chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> (metodo), quindi impostare il <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> le proprietà del controllo e quindi chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo per consentire le modifiche diventino effettive.  
  
 Non deve esserci Nessuna chiamata a in sospeso <xref:System.Windows.Forms.Control.SuspendLayout%2A> per <xref:System.Windows.Forms.Control.ResumeLayout%2A> sia chiamato correttamente.  
  
> [!NOTE]
>  Quando si aggiungono più controlli a un controllo padre, è consigliabile chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo prima di inizializzare i controlli da aggiungere. Dopo aver aggiunto i controlli al controllo padre, chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo. Ciò aumenta le prestazioni delle applicazioni con molti controlli.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Right : int" Usage="System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la distanza in pixel tra il bordo destro del controllo e il bordo sinistro dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo destro del controllo e il bordo sinistro dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Windows.Forms.Control.Right%2A> proprietà è uguale alla somma del <xref:System.Windows.Forms.Control.Left%2A> valore della proprietà e il <xref:System.Windows.Forms.Control.Width%2A> valore della proprietà.  
  
 La proprietà <xref:System.Windows.Forms.Control.Right%2A> è di sola lettura. È possibile modificare il valore della proprietà indirettamente modificando il valore della <xref:System.Windows.Forms.Control.Left%2A> o <xref:System.Windows.Forms.Control.Width%2A> proprietà o chiama la <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, o <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> controlli in un form e imposta le dimensioni e posizione utilizzando le varie proprietà correlate alla posizione e dimensioni. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se gli elementi del controllo sono allineati per supportare le impostazioni locali che prevedono la scrittura da destra a sinistra.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.RightToLeft" />. Il valore predefinito è <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere la <xref:System.Windows.Forms.AmbientProperties> classe o il <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
 Il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà viene utilizzata per le applicazioni interne in cui la lingua viene scritto da destra a sinistra, quale l'ebraico o l'arabo. Quando questa proprietà è impostata su <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>, gli elementi di controllo che includono testo vengono visualizzati da destra a sinistra.  
  
> [!NOTE]
>  Se il valore di <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà viene modificata in fase di esecuzione, viene mantenuto solo il testo non elaborato senza formattazione.  
  
 Ecco alcuni esempi del modo in cui gli elementi del controllo da parte di <xref:System.Windows.Forms.Control.RightToLeft%2A> valore della proprietà <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> :  
  
-   Vengono visualizzate barre di scorrimento verticale sul lato sinistro anziché sul lato destro dei controlli scorrevoli (ad esempio <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>su più righe <xref:System.Windows.Forms.TextBox>, e <xref:System.Windows.Forms.RichTextBox>).  
  
-   Barre di scorrimento orizzontale iniziano con la casella di scorrimento (scorrimento) allineata a destra.  
  
-   L'allineamento dell'elemento casella di controllo, applicando il `CheckAlign` proprietà, è invertita per <xref:System.Windows.Forms.CheckBox> e <xref:System.Windows.Forms.RadioButton> controlli.  
  
-   Gli elementi nella casella di riepilogo, casella combinata e controlli di scorrimento sono allineati a destra.  
  
-   Pulsanti su e giù sono allineati a sinistra sui <xref:System.Windows.Forms.NumericUpDown> e <xref:System.Windows.Forms.DomainUpDown> controlli.  
  
-   Menu (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, e <xref:System.Windows.Forms.ContextMenu>) sono allineati a destra.  
  
-   L'allineamento dei pulsanti della barra degli strumenti in un <xref:System.Windows.Forms.ToolBar> controllo o l'allineamento del testo in un <xref:System.Windows.Forms.ToolBarButton> non è influenzato il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà.  
  
-   <xref:System.Windows.Forms.AxHost> supporta l'allineamento a destra a sinistra; Tuttavia, l'effetto su un controllo ActiveX dipende l'extent a cui l'autore di controllo implementato il supporto per la visualizzazione da destra a sinistra.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di <see cref="T:System.Windows.Forms.RightToLeft" />.</exception>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.RightToLeft" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.RightToLeft" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.RightToLeft" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftChanged : EventHandler " Usage="member this.RightToLeftChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.RightToLeft" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguito quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe ha diversi metodi con il modello di nome *PropertyName* `Changed` che vengono generati quando corrispondente *PropertyName* modifiche ai valori (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte l'allineamento corrente nell'allineamento appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Drawing.ContentAlignment" /> specificato nell'oggetto <see cref="T:System.Drawing.ContentAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostata su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostata su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostata su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateContent : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateContent align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Drawing.ContentAlignment" /> specificato nell'oggetto <see cref="T:System.Drawing.ContentAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostata su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateHorizontal : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateHorizontal align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostata su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateLeftRight : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateLeftRight align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostata su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scala il controllo e degli eventuali controlli figlio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberSignature Language="F#" Value="member this.Scale : System.Drawing.SizeF -&gt; unit" Usage="control.Scale factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="factor">Oggetto <see cref="T:System.Drawing.SizeF" /> contenente i fattori di scala orizzontale e verticale.</param>
        <summary>Ridimensiona il controllo e tutti i relativi controlli figlio in base al fattore di scala specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Scale%2A> metodo ridimensiona il controllo per la scala specificato `factor`. È inoltre in modo ricorsivo Ridimensiona tutti i controlli figlio se il <xref:System.Windows.Forms.Control.ScaleChildren%2A> proprietà `true`. Internamente, questo metodo chiama <xref:System.Windows.Forms.Control.ScaleControl%2A> scala ogni controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberSignature Language="F#" Value="member this.Scale : single -&gt; unit" Usage="control.Scale ratio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">Il rapporto da usare per l'adattamento in scala.</param>
        <summary>Scala il controllo e degli eventuali controlli figlio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Scale : single * single -&gt; unit" Usage="control.Scale (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Fattore di scala orizzontale.</param>
        <param name="dy">Fattore di scala verticale.</param>
        <summary>Scala l'intero controllo ed eventuali controlli figlio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberSignature Language="F#" Value="member this.ScaleBitmapLogicalToDevice :  -&gt; unit" Usage="control.ScaleBitmapLogicalToDevice logicalBitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">Bitmap da ridimensionare.</param>
        <summary>Ridimensiona un valore di bitmap logica in base al valore unitario del dispositivo equivalente quando si verifica una modifica del valore DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ScaleChildren : bool" Usage="System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che determina il ridimensionamento dei controlli figlio.</summary>
        <value><see langword="true" /> se i controlli figlio verranno ridimensionati alla chiamata del metodo <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" /> su questo controllo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.ScaleChildren%2A> proprietà è `true`, quindi il <xref:System.Windows.Forms.Control.Scale%2A> metodo verrà chiamata in modo ricorsivo il <xref:System.Windows.Forms.Control.ScaleControl%2A> metodo di ciascuno dei relativi controlli figlio.  
  
 L'implementazione predefinita di <xref:System.Windows.Forms.Control.ScaleChildren%2A> restituisce sempre `true`. Le classi derivate possono eseguire l'override <xref:System.Windows.Forms.Control.ScaleChildren%2A> per restituire `false` per indicare che la scalabilità non deve essere eseguita sugli elementi figlio.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Fattore di scala per l'altezza e la larghezza del controllo.</param>
        <param name="specified">Valore di <see cref="T:System.Windows.Forms.BoundsSpecified" /> che specifica i limiti del controllo da usare per definirne le dimensioni e la posizione.</param>
        <summary>Scala la posizione, le dimensioni, la spaziatura interna e il margine di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il controllo è di livello superiore, il percorso del controllo non verrà ridimensionata. Non consente una scalabilità elementi figlio o delle dimensioni dei controlli automaticamente ridimensionati. È possibile omettere il ridimensionamento in qualsiasi direzione modificando il valore di `specified` parametro.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberSignature Language="F#" Value="abstract member ScaleCore : single * single -&gt; unit&#xA;override this.ScaleCore : single * single -&gt; unit" Usage="control.ScaleCore (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Fattore di scala orizzontale.</param>
        <param name="dy">Fattore di scala verticale.</param>
        <summary>Questo metodo non è pertinente per questa classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attiva un controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="control.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attiva il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Select%2A> metodo attiva il controllo se il controllo `Selectable` bit di stile è impostata su `true` in <xref:System.Windows.Forms.ControlStyles>, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da controlli nell'elenco anche non saranno selezionabili.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
   
  
## Examples  
 L'esempio di codice seguente seleziona specificato <xref:System.Windows.Forms.Control>, se è selezionabile.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="abstract member Select : bool * bool -&gt; unit&#xA;override this.Select : bool * bool -&gt; unit" Usage="control.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed"><see langword="true" /> per specificare la direzione del controllo da selezionare; in caso contrario, <see langword="false" />.</param>
        <param name="forward"><see langword="true" /> per spostarsi in avanti nell'ordine di tabulazione, <see langword="false" /> per spostarsi all'indietro.</param>
        <summary>Attiva un controllo figlio. Può anche specificare la direzione nell'ordine di tabulazione da cui selezionare il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `directed` e `forward` i parametri vengono utilizzati dai controlli contenitore. Quando il `directed` parametro è impostato su `true`, il `forward` parametro viene valutato per determinare il controllo da selezionare. Quando si `forward` è impostata su `true`, viene selezionato il controllo successivo nell'ordine di tabulazione; quando `false`, viene selezionato il controllo precedente nell'ordine di tabulazione.  
  
 Il <xref:System.Windows.Forms.Control.Select%2A> metodo attiva il controllo se il controllo `Selectable` bit di stile è impostata su `true` in <xref:System.Windows.Forms.ControlStyles>, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da controlli nell'elenco anche non saranno selezionabili.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="F#" Value="member this.SelectNextControl : System.Windows.Forms.Control * bool * bool * bool * bool -&gt; bool" Usage="control.SelectNextControl (ctl, forward, tabStopOnly, nested, wrap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Oggetto <see cref="T:System.Windows.Forms.Control" /> da cui iniziare la ricerca.</param>
        <param name="forward"><see langword="true" /> per spostarsi in avanti nell'ordine di tabulazione, <see langword="false" /> per spostarsi all'indietro.</param>
        <param name="tabStopOnly"><see langword="true" /> per ignorare i controlli con la proprietà <see cref="P:System.Windows.Forms.Control.TabStop" /> impostata su <see langword="false" />; in caso contrario, <see langword="false" />.</param>
        <param name="nested"><see langword="true" /> per includere controlli figlio annidati, ovvero controlli figlio di controlli figlio; in caso contrario, <see langword="false" />.</param>
        <param name="wrap"><see langword="true" /> per continuare la ricerca dal primo controllo nell'ordine di tabulazione dopo avere raggiunto l'ultimo controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Attiva il controllo successivo.</summary>
        <returns><see langword="true" /> se il controllo è stato attivato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodo attiva il controllo successivo nell'ordine di tabulazione se il controllo `Selectable` bit di stile è impostata su `true` in <xref:System.Windows.Forms.ControlStyles>, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da controlli nell'elenco anche non saranno selezionabili.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
   
  
## Examples  
 Nell'esempio di codice exampleshows il <xref:System.Windows.Forms.Control.SelectNextControl%2A> il metodo utilizzato in un form che dispone di alcuni controlli. Ogni volta che si fa clic su form, viene attivato il controllo successivo. Il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà ottiene il controllo attualmente attivo nel controllo contenitore.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 Illustrato nell'esempio di codice seguente il <xref:System.Windows.Forms.Control.SelectNextControl%2A> il metodo utilizzato in un form contenente un <xref:System.Windows.Forms.Button> e alcuni altri controlli. Quando si fa clic il <xref:System.Windows.Forms.Button>, il controllo successivo dopo il <xref:System.Windows.Forms.Button> è attivato. Si noti che è necessario ottenere l'elemento padre del <xref:System.Windows.Forms.Button> controllo. Poiché <xref:System.Windows.Forms.Button> non è un contenitore, chiamare <xref:System.Windows.Forms.Control.SelectNextControl%2A> direttamente sul <xref:System.Windows.Forms.Button> non modifica l'attivazione.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberSignature Language="F#" Value="member this.SendToBack : unit -&gt; unit" Usage="control.SendToBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Porta il controllo in background nell'ordine z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo viene spostato nella parte posteriore dello z-order. Se il controllo è un elemento figlio di un altro controllo, il controllo figlio viene spostato nella parte posteriore dello z-order. Se il controllo è un controllo di primo livello, questo metodo non funzionerà correttamente a meno che il controllo è attivo. Un controllo di primo livello è un controllo, ad esempio un <xref:System.Windows.Forms.Form>, ovvero non un elemento figlio di un altro controllo. Un controllo attivo è un controllo visibile che ha lo stato attivo di input. Usare la <xref:System.Windows.Forms.Control.SendToBack%2A> metodo con un controllo di primo livello inattivo, chiamare innanzitutto il <xref:System.Windows.Forms.Control.BringToFront%2A> metodo sul controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberSignature Language="F#" Value="member this.SetAutoSizeMode : System.Windows.Forms.AutoSizeMode -&gt; unit" Usage="control.SetAutoSizeMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno dei valori di <see cref="T:System.Windows.Forms.AutoSizeMode" />.</param>
        <summary>Imposta un valore che indica il comportamento di un controllo quando la relativa proprietà <see cref="P:System.Windows.Forms.Control.AutoSize" /> è abilitata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta i limiti del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int -&gt; unit" Usage="control.SetBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Left" /> del controllo.</param>
        <param name="y">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Top" /> del controllo.</param>
        <param name="width">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Width" /> del controllo.</param>
        <param name="height">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Height" /> del controllo.</param>
        <summary>Imposta i limiti del controllo sulla posizione e le dimensioni specificate.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBounds (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Left" /> del controllo.</param>
        <param name="y">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Top" /> del controllo.</param>
        <param name="width">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Width" /> del controllo.</param>
        <param name="height">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Height" /> del controllo.</param>
        <param name="specified">Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.BoundsSpecified" />. Nel caso di parametri non specificati, verrà usato il valore corrente.</param>
        <summary>Imposta i limiti specificati del controllo sulla posizione e le dimensioni specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Centri di esempio di codice seguente una <xref:System.Windows.Forms.Form> nella schermata di <xref:System.Windows.Forms.Control.Layout> evento. Questo consente di mantenere il form al centro come l'utente lo ridimensiona. In questo esempio richiede che sia stato creato un <xref:System.Windows.Forms.Form> controllo.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Left" /> del controllo.</param>
        <param name="y">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Top" /> del controllo.</param>
        <param name="width">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Width" /> del controllo.</param>
        <param name="height">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Height" /> del controllo.</param>
        <param name="specified">Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Imposta i limiti specificati di questo controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, i parametri che corrispondono ai limiti non inclusi nel `specified` parametro vengono passati con i relativi valori correnti. Ad esempio, il <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, o il <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> delle proprietà del <xref:System.Windows.Forms.Control.Location%2A> proprietà può essere passata con un riferimento all'istanza corrente del controllo. I valori passati sono tuttavia rispettati e applicati al controllo.  
  
 Il `boundsSpecified` parametro rappresenta gli elementi dei controlli <xref:System.Windows.Forms.Control.Bounds%2A> modificato dall'applicazione. Ad esempio, se si modifica il <xref:System.Windows.Forms.Control.Size%2A> del controllo, il `boundsSpecified` valore del parametro è il `Size` valore <xref:System.Windows.Forms.BoundsSpecified>. Tuttavia, se il <xref:System.Windows.Forms.Control.Size%2A> viene modificata in risposta al <xref:System.Windows.Forms.Control.Dock%2A> proprietà viene impostata, la `boundsSpecified` valore del parametro è il `None` pari a <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  Nei sistemi Windows Server 2003, le dimensioni di un <xref:System.Windows.Forms.Form> è limitato per la larghezza massima in pixel e l'altezza del monitoraggio.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.SetBoundsCore%2A> metodo per assicurarsi che il controllo resta a dimensione fissa. In questo esempio si suppone una classe derivata direttamente o indirettamente dal <xref:System.Windows.Forms.Control> classe.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metodo per imporre i limiti del controllo da modificare. Le classi derivate possono aggiungere alle restrizioni di dimensioni per il <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metodo.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member SetClientSizeCore : int * int -&gt; unit&#xA;override this.SetClientSizeCore : int * int -&gt; unit" Usage="control.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Larghezza dell'area client in pixel.</param>
        <param name="y">Altezza dell'area client in pixel.</param>
        <summary>Imposta le dimensioni dell'area client del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area client inizia in corrispondenza di (0, 0) percorso ed estende alla (`x`, `y`) percorso.  
  
 In genere, non è necessario impostare il <xref:System.Windows.Forms.Control.ClientSize%2A> del controllo.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodo per garantire che il controllo rimanga quadrato. In questo esempio si suppone una classe derivata direttamente o indirettamente dal <xref:System.Windows.Forms.Control> classe.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> metodo in modo che il <see cref="P:System.Windows.Forms.Control.ClientSize" /> proprietà viene regolata.  Per ulteriori informazioni sul disegno su controlli, vedere [Rendering Control](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md) un form Windows.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetStyle : System.Windows.Forms.ControlStyles * bool -&gt; unit" Usage="control.SetStyle (flag, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> da impostare.</param>
        <param name="value"><see langword="true" /> per applicare lo stile specificato al controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta il flag specificato dell'oggetto <see cref="T:System.Windows.Forms.ControlStyles" /> o su <see langword="true" /> o su <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flag di bit di stile di controllo vengono utilizzati per classificare il comportamento supportato. Un controllo è possibile abilitare un stile chiamando il <xref:System.Windows.Forms.Control.SetStyle%2A> metodo e passando l'oggetto appropriato <xref:System.Windows.Forms.ControlStyles> bit (o bits) e il valore booleano per impostare i bit. Per determinare il valore assegnato a un determinato <xref:System.Windows.Forms.ControlStyles> bit, utilizzare il <xref:System.Windows.Forms.Control.GetStyle%2A> (metodo) e passare il <xref:System.Windows.Forms.ControlStyles> membro da valutare.  
  
> [!CAUTION]
>  Impostazione dei bit di stile del controllo sostanzialmente cambiare il comportamento del controllo. Rivedere le <xref:System.Windows.Forms.ControlStyles> documentazione relativa all'enumerazione comprendere gli effetti della modifica i bit di stile del controllo prima di chiamare il <xref:System.Windows.Forms.Control.SetStyle%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente Abilita il buffering doppio su un <xref:System.Windows.Forms.Form> e aggiorna gli stili per riflettere le modifiche.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetTopLevel : bool -&gt; unit" Usage="control.SetTopLevel value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" /> per impostare il controllo come controllo di primo livello; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta il controllo come controllo di primo livello.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si chiama il <xref:System.Windows.Forms.Control.SetTopLevel%2A> metodo di un <xref:System.Windows.Forms.Form> e passare un valore di `false`, la forma non sarà visibile finché non si chiama <xref:System.Windows.Forms.Control.SetTopLevel%2A> nuovamente, passando un valore di `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="value" /> è impostato su <see langword="true" /> e il controllo è un controllo ActiveX.</exception>
        <exception cref="T:System.Exception">Il valore <see cref="M:System.Windows.Forms.Control.GetTopLevel" /> restituito non è uguale al parametro <paramref name="value" /> e la proprietà <see cref="P:System.Windows.Forms.Control.Parent" /> non è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Per impostare il controllo come controllo di primo livello in caso di qualsiasi tipo diverso da <see cref="T:System.Windows.Forms.Form" />. Questa autorizzazione è richiesta solo se il <paramref name="value" /> parametro <see langword="true" /> e il controllo non è un controllo ActiveX. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="abstract member SetVisibleCore : bool -&gt; unit&#xA;override this.SetVisibleCore : bool -&gt; unit" Usage="control.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" /> per rendere visibile il controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta il controllo sullo stato di visibilità specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generalmente è sottoposto a override questo metodo per modificare il comportamento di visibilità del controllo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> metodo per forzare la visibilità del controllo da modificare.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="control.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende visibile il controllo all'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visualizzare il controllo è equivalente all'impostazione di <xref:System.Windows.Forms.Control.Visible%2A> proprietà `true`. Dopo il <xref:System.Windows.Forms.Control.Show%2A> viene chiamato, il <xref:System.Windows.Forms.Control.Visible%2A> proprietà restituisce un valore di `true` fino a quando non la <xref:System.Windows.Forms.Control.Hide%2A> metodo viene chiamato.  
  
   
  
## Examples  
 Consente di visualizzare esempio di codice seguente sulla finestra di dialogo e disegna temporaneamente un quadrato blu relativa area. In questo esempio richiede che è stata definita una classe che deriva da <xref:System.Windows.Forms.Form> denominato `AboutDialog`.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowFocusCues : bool" Usage="System.Windows.Forms.Control.ShowFocusCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se nel controllo devono essere visualizzati i rettangoli di attivazione.</summary>
        <value><see langword="true" /> se nel controllo devono essere visualizzati i rettangoli di attivazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni su questa funzionalità, vedere la[argomenti WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)e il [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)argomenti.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para></block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowKeyboardCues : bool" Usage="System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se lo stato dell'interfaccia utente consente di visualizzare o nascondere i tasti di scelta rapida.</summary>
        <value><see langword="true" /> se i tasti di scelta rapida sono visibili; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nei controlli creati in Progettazione Windows Form, tasti di scelta rapida sono visibili per impostazione predefinita.  
  
 Per ulteriori informazioni su questa funzionalità, vedere la[argomenti WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)e il [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)argomenti.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il sito del controllo.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISite" /> associato all'oggetto <see cref="T:System.Windows.Forms.Control" />, se presente.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza e la larghezza del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> che rappresenta l'altezza e la larghezza del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché il <xref:System.Drawing.Size> classe è un tipo valore (`Structure` in Visual Basic `struct` in Visual c#), viene restituito per valore, ovvero l'accesso alla proprietà restituisce una copia delle dimensioni del controllo. In tal caso, la regolazione il <xref:System.Drawing.Size.Width%2A> o <xref:System.Drawing.Size.Height%2A> proprietà del <xref:System.Drawing.Size> restituito da questa proprietà non avrà effetto sul <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> del controllo. Per modificare il <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> del controllo, è necessario impostare il controllo <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> , proprietà o un set di <xref:System.Windows.Forms.Control.Size%2A> proprietà con un nuovo <xref:System.Drawing.Size>.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare il <xref:System.Drawing.Size> di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
> [!NOTE]
>  Nei sistemi Windows Server 2003, le dimensioni di un <xref:System.Windows.Forms.Form> è limitato per la larghezza massima in pixel e l'altezza del monitoraggio.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. Nell'esempio il pulsante nell'angolo in basso a destra del form è ancorato in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> al `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio è necessario un <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : EventHandler " Usage="member this.SizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Size" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È preferibile usare il <xref:System.Windows.Forms.Control.Layout> evento da gestire layout personalizzati. Il <xref:System.Windows.Forms.Control.Layout> evento viene generato in risposta a <xref:System.Windows.Forms.Control.Resize> eventi, ma anche in altre condizioni quando layout potrebbe essere necessario da applicare.  
  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Size%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.SizeChanged> evento. Un'istanza di un <xref:System.Windows.Forms.Button> controllo non è stata specificata che può essere scalato orizzontalmente e verticalmente. Oggetto <xref:System.Windows.Forms.NumericUpDown> istanza fornisce il valore di scala orizzontale e verticale. Il <xref:System.Windows.Forms.Button> istanza denominata **OK** utilizzato per impostare i valori di scala per il <xref:System.Windows.Forms.Button> istanza del controllo. Ogni volta che cambiano le dimensioni del controllo, il gestore dell'evento associato con la <xref:System.Windows.Forms.Control.SizeChanged> evento del controllo viene chiamato. Questo gestore eventi viene visualizzato un messaggio indicante che le dimensioni del controllo sono stato modificato.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="abstract member SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.SizeFromClientSize clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize">Valore <see cref="T:System.Drawing.Size" /> che rappresenta l'altezza e la larghezza dell'area client del controllo.</param>
        <summary>Determina le dimensioni dell'intero controllo a partire dall'altezza e dalla larghezza della relativa area client.</summary>
        <returns>Valore <see cref="T:System.Drawing.Size" /> che rappresenta l'altezza e la larghezza dell'intero controllo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberSignature Language="F#" Value="member this.StyleChanged : EventHandler " Usage="member this.StyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando lo stile del controllo viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.StyleChanged> evento si verifica quando <xref:System.Windows.Forms.ControlStyles> flag sono stati aggiunti o modificati.  
  
 Questo evento viene generato se lo stile del controllo viene modificato da una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.StyleChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.StyleChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberSignature Language="F#" Value="member this.SuspendLayout : unit -&gt; unit" Usage="control.SuspendLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sospende temporaneamente la logica di layout per il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La logica di layout del controllo viene sospeso finché il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo viene chiamato.  
  
 Il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi vengono usati insieme per eliminare più <xref:System.Windows.Forms.Control.Layout> eventi durante la regolazione di più attributi del controllo. Ad esempio, in genere chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> (metodo), quindi impostare il <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> le proprietà del controllo e quindi chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo per consentire le modifiche diventino effettive.  
  
 Non deve esserci Nessuna chiamata a in sospeso <xref:System.Windows.Forms.Control.SuspendLayout%2A> per <xref:System.Windows.Forms.Control.ResumeLayout%2A> sia chiamato correttamente.  
  
> [!NOTE]
>  Quando si aggiungono più controlli a un controllo padre, è consigliabile chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo prima di inizializzare i controlli da aggiungere. Dopo aver aggiunto i controlli al controllo padre, chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo. Ciò aumenta le prestazioni delle applicazioni con molti controlli.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge due pulsanti a un form. Nell'esempio viene eseguita l'aggiunta dei pulsanti utilizzando la <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberSignature Language="F#" Value="member this.SystemColorsChanged : EventHandler " Usage="member this.SystemColorsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando i colori di sistema vengono modificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Drawing.SystemColors> viene modificato da una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.SystemColorsChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.SystemColorsChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'ordine di tabulazione del controllo all'interno del relativo contenitore.</summary>
        <value>Valore dell'indice del controllo nel set di controlli all'interno del relativo contenitore. Il controlli del contenitore sono inclusi nell'ordine di tabulazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un indice di tabulazione può essere costituito da qualsiasi numero intero valido maggiore o uguale a zero, i numeri più bassi in corso più indietro in ordine di tabulazione. Se più di un controllo nello stesso controllo padre include l'indice della scheda stessa, l'ordine z dei controlli determina l'ordine per scorrere i controlli.  
  
 Per un controllo da includere nell'ordine di tabulazione, il relativo <xref:System.Windows.Forms.Control.TabStop%2A> proprietà deve essere impostata su `true`.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. Nell'esempio il pulsante nell'angolo in basso a destra del form è ancorato in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> al `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio è necessario un <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.TabIndex" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.TabIndexChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.TabIndexChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'utente può assegnare lo stato attivo al controllo con TAB.</summary>
        <value><see langword="true" /> se l'utente può assegnare lo stato attivo al controllo con TAB; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.  
  
 <block subset="none" type="note"><para> Questa proprietà restituirà sempre <see langword="true" /> per un'istanza del <see cref="T:System.Windows.Forms.Form" /> classe.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'utente preme il tasto TAB, è impostato lo stato attivo al controllo successivo nell'ordine di tabulazione. Controlli con il <xref:System.Windows.Forms.Control.TabStop%2A> valore della proprietà `false` non sono inclusi nella raccolta di controlli nell'ordine di tabulazione. L'ordine di tabulazione può essere modificato mediante l'impostazione del controllo <xref:System.Windows.Forms.Control.TabIndex%2A> valore della proprietà.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. Nell'esempio il pulsante nell'angolo in basso a destra del form è ancorato in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> al `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio è necessario un <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.TabStop" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.TabStop%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio report sull'occorrenza di un gestore eventi di <xref:System.Windows.Forms.Control.TabStopChanged> evento. Questo report consente di capire quando l'evento si verifica e può semplificare il debug. Per generare report su più eventi o per gli eventi che si verificano di frequente, prendere in considerazione la sostituzione <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a una proprietà multiline <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome dell'istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.TabStopChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto che contiene i dati sul controllo.</summary>
        <value>Oggetto <see cref="T:System.Object" /> che contiene i dati sul controllo. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualsiasi tipo derivato dal <xref:System.Object> classe può essere assegnata a questa proprietà. Se il <xref:System.Windows.Forms.Control.Tag%2A> viene impostata tramite la finestra di progettazione Windows Form, è possibile assegnare solo testo.  
  
 Un utilizzo comune per il <xref:System.Windows.Forms.Control.Tag%2A> proprietà consiste nell'archiviare i dati che sono strettamente associati al controllo. Ad esempio, se si dispone di un controllo che visualizza le informazioni relative a un cliente, è possibile archiviare un <xref:System.Data.DataSet> che contiene la cronologia degli ordini del cliente in tale controllo <xref:System.Windows.Forms.Control.Tag%2A> proprietà in modo da accedere rapidamente ai dati.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare un form e archivia una `Customer` nel relativo <xref:System.Windows.Forms.Control.Tag%2A> proprietà. In questo esempio richiede che è stata definita una classe che deriva da <xref:System.Windows.Forms.Form> denominato `CustomerForm` e che è stato definito un `Customer`.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il testo associato a questo controllo.</summary>
        <value>Testo associato a questo controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Text%2A> proprietà del controllo viene usata in modo diverso da ogni classe derivata. Ad esempio il <xref:System.Windows.Forms.Control.Text%2A> proprietà di un <xref:System.Windows.Forms.Form> viene visualizzato nella barra del titolo nella parte superiore del form, è di dimensioni limitate nel numero di caratteri e in genere viene visualizzato il nome dell'applicazione o del documento. Tuttavia, il <xref:System.Windows.Forms.Control.Text%2A> proprietà di un <xref:System.Windows.Forms.RichTextBox> può essere elevato e può includere diversi caratteri non visivi utilizzate per formattare il testo. Ad esempio, il testo visualizzato un <xref:System.Windows.Forms.RichTextBox> possono essere formattati regolando il <xref:System.Drawing.Font> proprietà, o mediante l'aggiunta di spazi o caratteri di tabulazione per allineare il testo.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creata una <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Successivamente, viene impostato il <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Text" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Text" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> le funzioni di accesso del <see cref="P:System.Windows.Forms.Control.Text" /> proprietà; è possibile sostituire uno solo se necessario.</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Text" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Text%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Le modifiche di esempio di codice seguente il <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e delle modifiche la <xref:System.Windows.Forms.Control.ForeColor%2A> al <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Top : int with get, set" Usage="System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la distanza in pixel tra il bordo superiore del controllo e il bordo superiore dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo inferiore del controllo e il bordo superiore dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Top%2A> è equivalente al valore della proprietà di <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> proprietà del <xref:System.Windows.Forms.Control.Location%2A> valore della proprietà del controllo.  
  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Top%2A> i valori delle proprietà causa la <xref:System.Windows.Forms.Control.Bottom%2A> valore della proprietà del controllo da modificare.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> controlli in un form e imposta le dimensioni e posizione utilizzando le varie proprietà correlate alla posizione e dimensioni. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TopLevelControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il controllo padre non associato a un altro controllo Windows Form. In genere, si tratta del <see cref="T:System.Windows.Forms.Form" /> più esterno in cui il controllo è contenuto.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo di primo livello che contiene il controllo corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controllo di primo livello è definito come il controllo padre non associato a un altro controllo Windows Form. In genere, si tratta del <xref:System.Windows.Forms.Form> più esterno in cui il controllo è contenuto. Ad esempio, se il controllo è contenuto in un figlio MDI <xref:System.Windows.Forms.Form>, quindi il controllo di primo livello è l'elemento padre dell'interfaccia a documenti multipli (MDI) <xref:System.Windows.Forms.Form>. Se il controllo non è associato in un <xref:System.Windows.Forms.Form>, questa proprietà restituirà `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre ottenere il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; unit" Usage="control.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina il nuovo disegno delle aree invalidate del controllo all'interno della relativa area client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esegue tutte le richieste in sospeso per il disegno.  
  
 Esistono due modi per aggiornare un modulo e il relativo contenuto:  
  
-   È possibile usare uno degli overload del <xref:System.Windows.Forms.Control.Invalidate%2A> metodo con il <xref:System.Windows.Forms.Control.Update%2A> metodo.  
  
-   È possibile chiamare il <xref:System.Windows.Forms.Control.Refresh%2A> metodo, che impone il ridisegno stessa e tutti i relativi elementi figlio del controllo. Ciò equivale a impostare il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo `true` e l'uso con <xref:System.Windows.Forms.Control.Update%2A>.  
  
 Il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo determina le aree di disegno o ridisegnata. Il <xref:System.Windows.Forms.Control.Update%2A> metodo determina quando vengono eseguite queste operazioni. Se si utilizza il <xref:System.Windows.Forms.Control.Invalidate%2A> e <xref:System.Windows.Forms.Control.Update%2A> insieme anziché chiamare i metodi <xref:System.Windows.Forms.Control.Refresh%2A>, cosa ridisegnare sul quale eseguire l'overload di <xref:System.Windows.Forms.Control.Invalidate%2A> è utilizzare. Il <xref:System.Windows.Forms.Control.Update%2A> metodo impone soltanto il controllo da disegnare immediatamente, ma la <xref:System.Windows.Forms.Control.Invalidate%2A> metodo determina cosa disegnare quando si chiama il <xref:System.Windows.Forms.Control.Update%2A> metodo.  
  
 Per altre informazioni, vedere la[WM_PAINT](http://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)argomento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna i limiti del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : unit -&gt; unit" Usage="control.UpdateBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna i limiti del controllo in base alla posizione e alle dimensioni correnti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il nuovo <xref:System.Windows.Forms.Control.Size%2A> del controllo è diverso dal precedente <xref:System.Drawing.Size>, il <xref:System.Windows.Forms.Control.SizeChanged> evento viene generato. Analogamente, se il <xref:System.Windows.Forms.Control.Location%2A> del controllo cambia, il <xref:System.Windows.Forms.Control.LocationChanged> evento viene generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordinata <see cref="P:System.Drawing.Point.X" /> del controllo.</param>
        <param name="y">Coordinata <see cref="P:System.Drawing.Point.Y" /> del controllo.</param>
        <param name="width">Valore <see cref="P:System.Drawing.Size.Width" /> del controllo.</param>
        <param name="height">Valore <see cref="P:System.Drawing.Size.Height" /> del controllo.</param>
        <summary>Aggiorna i limiti del controllo in base alla posizione e alle dimensioni specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il nuovo <xref:System.Windows.Forms.Control.Size%2A> del controllo se diverso dal precedente <xref:System.Drawing.Size>, il <xref:System.Windows.Forms.Control.SizeChanged> evento viene generato. Analogamente, il <xref:System.Windows.Forms.Control.Location%2A> del controllo cambia, il <xref:System.Windows.Forms.Control.LocationChanged> evento viene generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height, clientWidth, clientHeight)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordinata <see cref="P:System.Drawing.Point.X" /> del controllo.</param>
        <param name="y">Coordinata <see cref="P:System.Drawing.Point.Y" /> del controllo.</param>
        <param name="width">Valore <see cref="P:System.Drawing.Size.Width" /> del controllo.</param>
        <param name="height">Valore <see cref="P:System.Drawing.Size.Height" /> del controllo.</param>
        <param name="clientWidth">Valore <see cref="P:System.Drawing.Size.Width" /> client del controllo.</param>
        <param name="clientHeight">Valore <see cref="P:System.Drawing.Size.Height" /> client del controllo.</param>
        <summary>Aggiorna i limiti del controllo in base alle dimensioni, alla posizione e alle dimensioni client specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il nuovo <xref:System.Windows.Forms.Control.Size%2A> del controllo è diverso dal precedente <xref:System.Drawing.Size>, il <xref:System.Windows.Forms.Control.SizeChanged> evento viene generato. Analogamente, se il <xref:System.Windows.Forms.Control.Location%2A> del controllo cambia, il <xref:System.Windows.Forms.Control.LocationChanged> evento viene generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberSignature Language="F#" Value="member this.UpdateStyles : unit -&gt; unit" Usage="control.UpdateStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina la nuova applicazione degli stili assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il <xref:System.Windows.Forms.Control.CreateParams%2A> metodo per ottenere lo stile da applicare. Gli stili assegnati per il <xref:System.Windows.Forms.CreateParams.Style%2A> e <xref:System.Windows.Forms.CreateParams.ExStyle%2A> proprietà del <xref:System.Windows.Forms.CreateParams> assegnato al controllo <xref:System.Windows.Forms.Control.CreateParams%2A> vengono riapplicate proprietà. Il controllo viene ridisegnato per riflettere le modifiche dello stile se necessario.  
  
 Il <xref:System.Windows.Forms.Control.UpdateStyles%2A> metodo non ha alcun effetto se la <xref:System.Windows.Forms.Control.IsHandleCreated%2A> valore della proprietà è `false`.  
  
   
  
## Examples  
 Esempio di codice seguente Abilita il buffering doppio su un <xref:System.Windows.Forms.Form> e aggiorna gli stili per riflettere le modifiche.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberSignature Language="F#" Value="member this.UpdateZOrder : unit -&gt; unit" Usage="control.UpdateZOrder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna il controllo nell'ordine z del controllo padre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.UpdateZOrder%2A> metodo aggiorna la posizione del controllo nell'ordine z del controllo padre. Ad esempio, se questo controllo è controllare un oggetto appena creato che è stato aggiunto a un <xref:System.Windows.Forms.Control.ControlCollection>, l'ordine z viene aggiornato con il nuovo controllo aggiunto nella parte posteriore.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se usare il cursore di attesa per il controllo corrente e per tutti i controlli figlio.</summary>
        <value><see langword="true" /> per usare il cursore di attesa per il controllo corrente e per tutti i controlli figlio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare un cursore di attesa ogni volta che si esegue un'operazione che richiede una notevole quantità di tempo. Si noti tuttavia che le operazioni che bloccano il thread dell'interfaccia utente verranno bloccata anche acursor modifica. Pertanto, questa proprietà deve essere utilizzata solo quando si eseguono operazioni molto tempo in un altro thread. Per modificare il cursore globale e immediatamente, vedere <xref:System.Windows.Forms.Cursor.Current%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberSignature Language="F#" Value="member this.Validated : EventHandler " Usage="member this.Validated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al termine della convalida del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Se il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> è impostata su `true` nel <xref:System.Windows.Forms.Control.Validating> delegato dell'evento, tutti gli eventi che in genere si verificano dopo il <xref:System.Windows.Forms.Control.Validating> evento vengono soppressi.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o il sistema operativo smetterà di rispondere. Per altre informazioni, vedere la[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)argomento e la sezione "Deadlock messaggio" il [informazioni sui messaggi e le code di messaggi](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente usa la classe derivata <xref:System.Windows.Forms.TextBox> e convalida un indirizzo di posta elettronica immessi dall'utente. Se l'indirizzo di posta elettronica non è nel formato standard (che contiene "@" and "."), la convalida non riesce, un <xref:System.Windows.Forms.ErrorProvider> viene visualizzata l'icona e l'evento viene annullato. Questo esempio si presuppone che un <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.ErrorProvider> controllo sono stati creati in un form.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberSignature Language="F#" Value="member this.Validating : System.ComponentModel.CancelEventHandler " Usage="member this.Validating : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante la convalida del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando il <xref:System.Windows.Forms.Control.Select%2A> oppure <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodi, oppure impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi dello stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, la <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Se il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> è impostata su `true` nel <xref:System.Windows.Forms.Control.Validating> delegato dell'evento, tutti gli eventi che in genere si verificano dopo il <xref:System.Windows.Forms.Control.Validating> evento vengono soppressi.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o il sistema operativo smetterà di rispondere. Per altre informazioni, vedere la `WM_KILLFOCUS` argomento nella sezione "Riferimenti di Input da tastiera" e la sezione "Messaggio deadlock" dell'argomento "Sui messaggi e code di messaggi" in MSDN all'indirizzo http://msdn.microsoft.com/library.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente usa la classe derivata <xref:System.Windows.Forms.TextBox> e convalida un indirizzo di posta elettronica immessi dall'utente. Se l'indirizzo di posta elettronica non è nel formato standard (che contiene "@" and "."), la convalida non riesce, un <xref:System.Windows.Forms.ErrorProvider> viene visualizzata l'icona e l'evento viene annullato. Questo esempio si presuppone che un <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.ErrorProvider> controllo sono stati creati in un form.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se vengono visualizzati il controllo e tutti i relativi controlli figlio.</summary>
        <value><see langword="true" /> se vengono visualizzati il controllo e tutti i relativi controlli figlio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che, anche se `Visible` è impostata su `true`, il controllo potrebbe non essere visibile all'utente se è nascosto dietro altri controlli.  
  
   
  
## Examples  
 L'esempio di codice seguente usa le classi derivate <xref:System.Windows.Forms.VScrollBar> e <xref:System.Windows.Forms.HScrollBar> e imposta i relativi <xref:System.Windows.Forms.Control.Visible%2A> i valori delle proprietà in base alla dimensione di una <xref:System.Drawing.Image> visualizzate nell'elenco un <xref:System.Windows.Forms.PictureBox> controllo. Questo esempio si presuppone che un <xref:System.Windows.Forms.PictureBox> è stato creato in un form e che <xref:System.Windows.Forms.HScrollBar> e <xref:System.Windows.Forms.VScrollBar> controlli sono stati creati nel <xref:System.Windows.Forms.PictureBox>. Questo codice deve essere chiamato quando l'immagine viene caricata, nella casella di immagine e dal <xref:System.Windows.Forms.Control.Resize> eventi del modulo.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.VisibleChanged : EventHandler " Usage="member this.VisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Visible" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Visible%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Genera di esempio di codice seguente il <xref:System.Windows.Forms.Control.VisibleChanged> evento quando le <xref:System.Windows.Forms.Control.Visible%2A> valore della proprietà il <xref:System.Windows.Forms.Label> controllo è stato modificato.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Width : int with get, set" Usage="System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la larghezza del controllo.</summary>
        <value>Larghezza del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Width%2A> e <xref:System.Windows.Forms.Control.Left%2A> i valori delle proprietà causa la <xref:System.Windows.Forms.Control.Right%2A> valore della proprietà del controllo da modificare.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> controlli in un form e imposta le dimensioni e posizione utilizzando le varie proprietà correlate alla posizione e dimensioni. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTarget : System.Windows.Forms.IWindowTarget with get, set" Usage="System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questa proprietà non è pertinente per questa classe.</summary>
        <value>NativeWindow contenuto nel controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="control.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> di Windows da elaborare.</param>
        <summary>Elabora i messaggi di Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti i messaggi vengono inviati per la <xref:System.Windows.Forms.Control.WndProc%2A> metodo dopo essere stati filtrati tramite il <xref:System.Windows.Forms.Control.PreProcessMessage%2A> metodo.  
  
 Il metodo <xref:System.Windows.Forms.Control.WndProc%2A> corrisponde esattamente alla funzione `WindowProc` di Windows. Per ulteriori informazioni sull'elaborazione dei messaggi di Windows, vedere la [funzione WindowProc](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'override di <xref:System.Windows.Forms.Control.WndProc%2A> metodo per gestire i messaggi di sistema operativo identificati nel <xref:System.Windows.Forms.Message> struttura. Il[WM_ACTIVATEAPP](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)messaggio del sistema operativo è gestito in questo esempio per sapere quando un'altra applicazione sta diventando sempre attiva. Vedere gli argomenti seguenti per comprendere il disponibili <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> valori. Valori costanti effettivi è reperibile nel file di intestazione di Windows. h.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>I controlli che ereditano devono chiamare la classe base <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> metodo per elaborare i messaggi che non gestiti.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>