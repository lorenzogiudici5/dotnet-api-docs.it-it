<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f165afa77e5133f21dc1457c8775b30a3be3018" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061833" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Viene definita la classe base per i controlli, ovvero i componenti con una rappresentazione visiva.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare la propria classe di controllo, ereditare il <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> classi, o da altri formati di Windows purché i controlli. Per ulteriori informazioni sulla creazione di controlli personalizzati, vedere [sviluppo personalizzato controlli Windows Form in .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 La <xref:System.Windows.Forms.Control> classe implementa le funzionalità di base richieste dalle classi che consentono di visualizzare informazioni all'utente. Gestisce l'input dell'utente tramite la tastiera e i dispositivi di puntamento. Gestisce il routing dei messaggi e la sicurezza. Definisce i limiti di un controllo (la posizione e dimensioni), anche se non implementa il disegno. Fornisce un handle di finestra (`hWnd`).  
  
 Controlli Windows Form usare le proprietà di ambiente in modo i controlli figlio viene visualizzato come ambiente circostante. Un *proprietà di ambiente* è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Se il controllo non dispone di un <xref:System.Windows.Forms.Control.Parent%2A>e la proprietà non è impostata, il controllo tenta di determinare il valore della proprietà di ambiente tramite la <xref:System.Windows.Forms.Control.Site%2A> proprietà. Se il controllo non viene individuato, se il sito non supporta le proprietà di ambiente o se la proprietà non è impostata sul <xref:System.Windows.Forms.AmbientProperties>, il controllo utilizza i valori predefiniti. In genere, una proprietà di ambiente rappresenta una caratteristica di un controllo, ad esempio <xref:System.Windows.Forms.Control.BackColor%2A>, che viene comunicato a un controllo figlio. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Proprietà di ambiente fornita dal <xref:System.Windows.Forms.Control> classe includono: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A>, e <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Per rendere l'applicazione Windows Form supportano gli stili di visualizzazione, assicurarsi di impostare il <xref:System.Windows.Forms.FlatStyle> proprietà `System` e includere un manifesto con il file eseguibile. Un manifesto è un file XML che viene incluso come una risorsa all'interno del file eseguibile dell'applicazione o come file separato che si trova nella stessa directory del file eseguibile. Per un esempio di un manifesto, vedere la sezione esempio del <xref:System.Windows.Forms.FlatStyle> enumerazione. Per ulteriori informazioni sull'utilizzo di stili di visualizzazione, vedere [stili visivi](http://msdn.microsoft.com/library/windows/desktop/bb773187.aspx).  
  
 Windows Form dispone di supporto di accessibilità incorporato e vengono fornite informazioni sull'applicazione che consente di lavorare con applicazioni client di accessibilità, ad esempio l'utilità di utilità di ingrandimento e di schermate, voice utilità di input, sullo schermo tastiere, dispositivi di input alternativi e le utilità di miglioramento. Talvolta potrebbe essere fornire informazioni aggiuntive per le applicazioni client di accessibilità. Esistono due modi per fornire queste informazioni aggiuntive. È possibile impostare il <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>, e <xref:System.Windows.Forms.Control.AccessibleRole%2A> i valori delle proprietà che verranno segnalati alle applicazioni client di accessibilità. Questo metodo viene in genere utilizzato per fornire informazioni limitate sull'accessibilità per i controlli esistenti. In alternativa, è possibile scrivere la propria classe che deriva dal <xref:System.Windows.Forms.AccessibleObject> o <xref:System.Windows.Forms.Control.ControlAccessibleObject> classi, fornendo più informazioni sull'accessibilità in base alle esigenze.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare le dimensioni di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
> [!NOTE]
>  Non aggiungere associazioni dati per un <xref:System.Windows.Forms.Control> nel relativo costruttore. Questa operazione causerà errori nella generazione del codice e può causare comportamenti indesiderati.  
  
 La maggior parte dei controlli di <xref:System.Windows.Forms> dello spazio dei nomi utilizzare il controllo comune di Windows sottostante come base per compilare in. Per ulteriori informazioni sui controlli comuni di Windows, vedere [riferimento controllo generale](http://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Per identificare i controlli Windows Form da un processo separato, utilizzare uno standard `SendMessage` chiamata per passare il messaggio WM_GETCONTROLNAME. Che è indipendente del linguaggio e della gerarchia di Windows. Per ulteriori informazioni, vedere l'argomento "Soluzione consigliata per Windows Form" in[automazione di Windows Form](http://msdn.microsoft.com/library/ms996405.aspx).  
  
 Utilizzare il <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà per sincronizzare l'accesso al controllo da più thread. Per ulteriori informazioni sui controlli Windows Form con multithreading, vedere [procedura: effettuare chiamate Thread-Safe a controlli Windows Form](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>Solo i membri seguenti sono thread-safe: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" />, e <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> se è già stato creato l'handle per il controllo. La chiamata <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> con le impostazioni predefinite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Testo visualizzato dal controllo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> con testo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione di <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà di `text` valore del parametro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta l'elemento padre del controllo.</param>
        <param name="text">Testo visualizzato dal controllo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> come controllo figlio con testo specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione di <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà di `text` valore del parametro. Il costruttore aggiunge anche il controllo del controllo padre <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Testo visualizzato dal controllo.</param>
        <param name="left">Posizione <see cref="P:System.Drawing.Point.X" /> del controllo, in pixel, a partire dal bordo sinistro del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Posizione <see cref="P:System.Drawing.Point.Y" /> del controllo, in pixel, a partire dal bordo superiore del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Larghezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Altezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> con testo, dimensioni e posizione specifici.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione di <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà di `text` valore del parametro. Iniziale <xref:System.Windows.Forms.Control.Size%2A> e <xref:System.Windows.Forms.Control.Location%2A> del controllo sono determinati dalle `left`, `top`, `width` e `height` i valori dei parametri.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare le dimensioni di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta l'elemento padre del controllo.</param>
        <param name="text">Testo visualizzato dal controllo.</param>
        <param name="left">Posizione <see cref="P:System.Drawing.Point.X" /> del controllo, in pixel, a partire dal bordo sinistro del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Posizione <see cref="P:System.Drawing.Point.Y" /> del controllo, in pixel, a partire dal bordo superiore del contenitore del controllo. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Larghezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Altezza del controllo in pixel. Il valore è assegnato alla proprietà <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Forms.Control" /> come controllo figlio con testo, dimensioni e posizione specifici.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Forms.Control> classe è la classe base per tutti i controlli utilizzati in un'applicazione Windows Form. Poiché questa classe non è in genere utilizzata per creare un'istanza della classe, questo costruttore in genere non viene chiamato direttamente, ma viene invece chiamato da una classe derivata.  
  
 Questa versione di <xref:System.Windows.Forms.Control.%23ctor%2A> costruttore imposta iniziale <xref:System.Windows.Forms.Control.Text%2A> valore della proprietà di `text` valore del parametro. Il costruttore aggiunge anche il controllo del controllo padre <xref:System.Windows.Forms.Control.ControlCollection>. Iniziale <xref:System.Windows.Forms.Control.Size%2A> e <xref:System.Windows.Forms.Control.Location%2A> del controllo sono determinati dalle `left`, `top`, `width` e `height` i valori dei parametri.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare le dimensioni di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Notifica alle applicazioni client di accessibilità l'oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> da notificare alle applicazioni client di accessibilità.</param>
        <param name="childID">Controllo <see cref="T:System.Windows.Forms.Control" /> figlio cui notificare l'evento accessibile.</param>
        <summary>Notifica alle applicazioni client di accessibilità l'oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> specificato per il controllo figlio specifico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> metodo per ogni <xref:System.Windows.Forms.AccessibleEvents> le applicazioni client di accessibilità sono da notificare. Il <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> viene in genere chiamato quando una proprietà è impostata o in un gestore eventi. Ad esempio, è possibile chiamare il <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> (metodo) e passare un <xref:System.Windows.Forms.AccessibleEvents> valore `Hide` all'interno del gestore eventi per il <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType> evento.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la creazione di un grafico di supporto per l'accessibilità controllare, tramite il <xref:System.Windows.Forms.AccessibleObject> e <xref:System.Windows.Forms.Control.ControlAccessibleObject> alle classi di esporre le informazioni accessibili. Il controllo traccia due curve e una legenda. Il `ChartControlAccessibleObject` classe che deriva da `ControlAccessibleObject`, viene utilizzata la <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo per fornire informazioni accessibili personalizzate per il controllo chart. Poiché la legenda del grafico non è una vera e propria <xref:System.Windows.Forms.Control> -controllo di base, ma viene disegnata dal controllo chart, non non contiene informazioni accessibili. Per questo motivo, il `ChartControlAccessibleObject` classe esegue l'override di <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> per restituire il `CurveLegendAccessibleObject` che rappresenta le informazioni accessibili per ogni parte della legenda. Quando viene utilizzato da un'applicazione accessibile abilitata, il controllo può fornire le informazioni accessibili necessarie.  
  
 Questo estratto di codice viene illustrata la chiamata di <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A> metodo. Vedere il <xref:System.Windows.Forms.AccessibleObject> Cenni preliminari sulla classe per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="objectID" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> da notificare alle applicazioni client di accessibilità.</param>
        <param name="objectID">Identificatore di <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">Controllo <see cref="T:System.Windows.Forms.Control" /> figlio cui notificare l'evento accessibile.</param>
        <summary>Notifica alle applicazioni client di accessibilità l'oggetto <see cref="T:System.Windows.Forms.AccessibleEvents" /> specificato per il controllo figlio specifico.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> assegnato al controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> assegnato al controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare l'istanza restituita da questo metodo, eseguire l'override di <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo.  
  
 Se al controllo non viene assegnato alcun oggetto <xref:System.Windows.Forms.AccessibleObject>, ne viene creata una nuova istanza.  
  
> [!NOTE]
>  Per ottenere o impostare il <xref:System.Windows.Forms.Control.AccessibilityObject%2A> proprietà, è necessario aggiungere un riferimento al `Accessibility` assembly installato con il[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Per ulteriori informazioni sugli oggetti accessibili, vedere [Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la descrizione dell'azione predefinita del controllo usata dalle applicazioni client di accessibilità.</summary>
        <value>Descrizione dell'azione predefinita del controllo usata dalle applicazioni client di accessibilità.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un oggetto <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> proprietà descrive il metodo principale per la modifica da parte dell'utente. Questa proprietà deve essere un verbo o una frase breve del verbo.  
  
> [!NOTE]
>  Non tutti gli oggetti dispongono di azioni predefinite e alcuni oggetti potrebbero contenere un'azione predefinita che corrisponde alla relativa <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType> proprietà, come illustrato negli esempi seguenti:  
  
-   Una casella di controllo selezionata è l'azione predefinita di "Deselezionare" e il valore "Checked".  
  
-   Dispone di una casella di controllo deselezionata, l'azione predefinita di "Controllo" e il valore è "Deselezionato".  
  
-   Un pulsante con etichetta "Print" è un'azione predefinita di "Press", non prevede alcun valore.  
  
-   Un'etichetta o un controllo casella di testo contenente "Printer" non presenta azioni predefinite, ma avrebbe un valore di "Printer".  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere [contenuto delle proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la descrizione del controllo usato dalle applicazioni client di accessibilità.</summary>
        <value>Descrizione del controllo usata dalle applicazioni client di accessibilità. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un oggetto <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà fornisce una descrizione testuale sull'aspetto visivo dell'oggetto. La descrizione viene utilizzata principalmente per fornire un contesto per gli utenti di problemi di vista o nascosta, ma può anche essere utilizzata per la ricerca nel contesto o altre applicazioni.  
  
 Il <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà è necessaria se la descrizione non è chiara o se è ridondante in base all'oggetto <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleRole%2A>, <xref:System.Windows.Forms.AccessibleObject.State%2A>, e <xref:System.Windows.Forms.AccessibleObject.Value%2A> proprietà. Ad esempio, un pulsante "OK" non richiede ulteriori informazioni, ma un pulsante che mostra l'immagine di una funzione. Il <xref:System.Windows.Forms.Control.AccessibleName%2A>, e <xref:System.Windows.Forms.Control.AccessibleRole%2A> (ed eventualmente <xref:System.Windows.Forms.AccessibleObject.Help%2A>) per il pulsante di funzione si descrivono le finalità, ma la <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà può contenere informazioni che sono meno tangibile, ad esempio "Un pulsante che mostra l'immagine di una funzione".  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere [contenuto delle proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Esempio di codice seguente crea un'istanza di un <xref:System.Windows.Forms.CheckBox> classe derivata `MyCheckBox`, assegna un <xref:System.Drawing.Image> per relativo <xref:System.Windows.Forms.ButtonBase.Image%2A> proprietà e i set di <xref:System.Windows.Forms.Control.AccessibleName%2A> e <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà, perché il <xref:System.Windows.Forms.Control.Text%2A> proprietà `null`. In questo esempio si suppone una <xref:System.Windows.Forms.Form> denominato `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del controllo usato dalle applicazioni client di accessibilità.</summary>
        <value>Nome del controllo usato dalle applicazioni client di accessibilità. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.AccessibleName%2A> proprietà è un'etichetta che descrive brevemente e identifica l'oggetto all'interno del contenitore, ad esempio il testo in un <xref:System.Windows.Forms.Button>, il nome di un <xref:System.Windows.Forms.MenuItem>, o un'etichetta visualizzata accanto a un <xref:System.Windows.Forms.TextBox> controllo.  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere la "[contenuto della proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Esempio di codice seguente crea un'istanza di un <xref:System.Windows.Forms.CheckBox> classe derivata `MyCheckBox`, assegna un <xref:System.Drawing.Image> per relativo <xref:System.Windows.Forms.ButtonBase.Image%2A> proprietà e i set di <xref:System.Windows.Forms.Control.AccessibleName%2A> e <xref:System.Windows.Forms.Control.AccessibleDescription%2A> proprietà dal <xref:System.Windows.Forms.Control.Text%2A> proprietà è `null`. In questo esempio si suppone una <xref:System.Windows.Forms.Form> denominato `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il ruolo accessibile del controllo.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.AccessibleRole" />. Il valore predefinito è <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.Windows.Forms.Control.AccessibleRole%2A> descrive il tipo di elemento dell'interfaccia utente rappresentato da un oggetto. Se non è possibile determinare il ruolo del controllo, la proprietà <xref:System.Windows.Forms.Control.AccessibleRole%2A> è impostata su `Default`.  
  
 Per ulteriori informazioni sulle proprietà degli oggetti accessibili, vedere [contenuto delle proprietà descrittive](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di <see cref="T:System.Windows.Forms.AccessibleRole" />.</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se nel controllo sono consentiti dati trascinati dall'utente.</summary>
        <value>
          <see langword="true" /> se le operazioni di trascinamento sono consentite nel controllo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice esempio seguente viene abilitata all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui è stato eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> viene eseguito l'override di metodo per aggiornare l'immagine ogni volta che viene disegnato il form; in caso contrario l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati nel form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> il metodo di gestione degli eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> possono essere creati dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Per impostare questa proprietà l'accesso illimitato Appunti <see langword="true" />. Enumerazione associata: il <see langword="AllClipboard" /> valore <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.AllowDrop" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.AllowDrop" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.AllowDrop" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i bordi del contenitore a cui è associato un controllo e determina la modalità con cui un controllo viene ridimensionato con il relativo padre.</summary>
        <value>Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.AnchorStyles" />. Il valore predefinito è <see langword="Top" /> e <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.Anchor%2A> proprietà per definire come un controllo viene ridimensionato automaticamente quando il relativo controllo padre viene ridimensionato. Ancoraggio di un controllo al relativo controllo padre assicura che i bordi ancorati rimangano nella stessa posizione relativi ai bordi del controllo padre quando il controllo padre viene ridimensionato.  
  
 È possibile ancorare un controllo a uno o più i bordi del contenitore. Ad esempio, se dispone di un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Button> cui <xref:System.Windows.Forms.Control.Anchor%2A> il valore di proprietà è impostato su `Top` e `Bottom`, il <xref:System.Windows.Forms.Button> viene estesa per mantenere la distanza ancorata al bordo superiore e inferiore della finestra il <xref:System.Windows.Forms.Form>come il <xref:System.Windows.Forms.Control.Height%2A> del <xref:System.Windows.Forms.Form> è aumentato.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Anchor%2A> e <xref:System.Windows.Forms.Control.Dock%2A> si escludono a vicenda. È possibile impostare solo uno alla volta e l'ultima occorrenza ha la precedenza.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. L'esempio consente di limitare il pulsante nell'angolo in basso a destra del form in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> a `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Anchor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Anchor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.Anchor" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione di scorrimento del controllo nel metodo <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" />.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Point" /> che specifica la posizione di scorrimento. Il valore predefinito è l'angolo superiore sinistro del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questa proprietà non è pertinente per questa classe.</summary>
        <value>
          <see langword="true" /> se abilitato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questo evento non è pertinente per questa classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il colore di sfondo del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> che rappresenta il colore di sfondo del controllo. Il valore predefinito corrisponde al valore della proprietà <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.BackColor%2A> proprietà non supporta colori trasparenti, a meno che il `SupportsTransparentBackColor` valore <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> è impostato su `true`.  
  
 Il <xref:System.Windows.Forms.Control.BackColor%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere il <xref:System.Windows.Forms.AmbientProperties> classe o <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Windows.Forms.Control.BackColor%2A> e <xref:System.Windows.Forms.Control.ForeColor%2A> dei controlli per i colori di sistema predefiniti. Se il controllo dispone di tutti i controlli figlio, in modo ricorsivo il codice chiama se stessa. Questo esempio di codice è necessario disporre una <xref:System.Windows.Forms.Form> con almeno un controllo figlio; tuttavia, un controllo contenitore figlio, ad esempio un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con il proprio elemento figlio controlli sarebbero illustrare meglio la ricorsione.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.BackColor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.BackColor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.BackColor" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackColor" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.BackColor%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome *PropertyName* `Changed` che sono generati quando corrispondente *PropertyName* modificato il valore (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'immagine di sfondo visualizzata nel controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Image" /> che rappresenta l'immagine da visualizzare sullo sfondo del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Utilizzare il <xref:System.Windows.Forms.Control.BackgroundImage%2A> proprietà per inserire un'immagine grafica in un controllo.  
  
> [!NOTE]
>  Le immagini con colori trasparente o semitrasparente non sono supportate dai controlli Windows Form come immagini di sfondo.  
>   
>  Questa proprietà non è supportata nei controlli figlio la cui <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. L'esempio consente di limitare il pulsante nell'angolo in basso a destra del form in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> a `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.BackgroundImage%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome *PropertyName* `Changed` che sono generati quando corrispondente *PropertyName* modificato il valore (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il layout dell'immagine di sfondo definito nell'enumerazione <see cref="T:System.Windows.Forms.ImageLayout" />.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.ImageLayout" /> (<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> o <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />). <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> è il valore predefinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> proprietà per specificare la posizione e il comportamento di un'immagine inserita in un controllo. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> ha effetto solo se il <xref:System.Windows.Forms.Control.BackgroundImage%2A> proprietà è impostata.  
  
 È possibile migliorare le prestazioni per le immagini di grandi dimensioni se si imposta <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> su un valore diverso da <xref:System.Windows.Forms.ImageLayout.Tile>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore di enumerazione specificato non esiste.</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la proprietà <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> proprietà modificata a livello di codice o dall'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue in modo asincrono un delegato nel thread in cui è stato creato il punto di controllo sottostante del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegato di un metodo che non accetta parametri.</param>
        <summary>Esegue in modo asincrono il delegato specificato nel thread in cui è stato creato il punto di controllo sottostante del controllo.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta il risultato dell'operazione <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato viene chiamato in modo asincrono e questo metodo restituisce immediatamente. Questo metodo è possibile chiamare da qualsiasi thread, anche il thread proprietario dell'handle del controllo. Se l'handle del controllo non esiste ancora, questo metodo cerca catena padre del controllo finché trova un controllo o un form che dispone di un handle di finestra. Se non viene trovato alcun handle appropriato, <xref:System.Windows.Forms.Control.BeginInvoke%2A> genererà un'eccezione. Le eccezioni all'interno del metodo delegato sono considerate non intercettate e verrà inviato al gestore dell'eccezione non intercettata dell'applicazione.  
  
 È possibile chiamare <xref:System.Windows.Forms.Control.EndInvoke%2A> per recuperare il valore restituito dal delegato, se necessario, ma questo non è necessaria. <xref:System.Windows.Forms.Control.EndInvoke%2A> verrà bloccata fino a quando il valore restituito può essere recuperato.  
  
> [!NOTE]
>  La maggior parte dei metodi su un controllo possono essere chiamati solo dal thread in cui è stato creato il controllo. Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo. I metodi invoke richiamano sempre relativi callback sul thread del controllo.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del <xref:System.Windows.Forms.Control.BeginInvoke%2A> metodo.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare un handle di finestra appropriato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegato di un metodo che accetta parametri dello stesso tipo e numero contenuti nel parametro <c>args</c>.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Se non sono richiesti argomenti, può corrispondere a <see langword="null" />.</param>
        <summary>Esegue in modo asincrono il delegato specificato con gli argomenti specificati nel thread in cui è stato creato il punto di controllo sottostante del controllo.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta il risultato dell'operazione <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato viene chiamato in modo asincrono e questo metodo restituisce immediatamente. Questo metodo è possibile chiamare da qualsiasi thread, anche il thread proprietario dell'handle del controllo. Se l'handle del controllo non esiste ancora, questo metodo cerca catena padre del controllo finché trova un controllo o un form che dispone di un handle di finestra. Se non viene trovato alcun handle appropriato, <xref:System.Windows.Forms.Control.BeginInvoke%2A> genererà un'eccezione. Le eccezioni all'interno del metodo delegato sono considerate non intercettate e verrà inviato al gestore dell'eccezione non intercettata dell'applicazione.  
  
 È possibile chiamare <xref:System.Windows.Forms.Control.EndInvoke%2A> per recuperare il valore restituito dal delegato, se necessario, ma questo non è necessaria. <xref:System.Windows.Forms.Control.EndInvoke%2A> verrà bloccata fino a quando il valore restituito può essere recuperato.  
  
> [!NOTE]
>  La maggior parte dei metodi su un controllo possono essere chiamati solo dal thread in cui è stato creato il controllo. Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo. I metodi invoke richiamano sempre relativi callback sul thread del controllo.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del <xref:System.Windows.Forms.Control.BeginInvoke%2A> metodo.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare un handle di finestra appropriato.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Forms.BindingContext" /> del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.BindingContext" /> del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.BindingContext> di un <xref:System.Windows.Forms.Control> viene utilizzata per restituire un singolo <xref:System.Windows.Forms.BindingManagerBase> per tutti i controlli con associazione a dati contenuti nel <xref:System.Windows.Forms.Control>. Il <xref:System.Windows.Forms.BindingManagerBase> mantiene tutti i controlli associati alla stessa origine dati sincronizzata. Ad esempio, impostando il <xref:System.Windows.Forms.BindingManagerBase.Position%2A> proprietà del <xref:System.Windows.Forms.BindingManagerBase> specifica l'elemento nell'elenco sottostante a cui puntare tutti i controlli con associazione a dati.  
  
 Per ulteriori informazioni sulla creazione di un nuovo <xref:System.Windows.Forms.BindingContext> e assegnarlo al <xref:System.Windows.Forms.Control.BindingContext%2A> proprietà, vedere il <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
   
  
## Examples  
 L'esempio di codice seguente crea quattro <xref:System.Windows.Forms.Binding> oggetti per associare i controlli di cinque, un <xref:System.Windows.Forms.DateTimePicker> e quattro <xref:System.Windows.Forms.TextBox> controlli, a diverse origini dati. Il <xref:System.Windows.Forms.BindingContext> viene quindi utilizzato per ottenere il <xref:System.Windows.Forms.BindingManagerBase> per ogni origine dati.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.BindingContext" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.BindingContext" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.BindingContext" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="T:System.Windows.Forms.BindingContext" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per aggiungere un nuovo <xref:System.Windows.Forms.BindingContext> per il <xref:System.Windows.Forms.Control> tramite il <xref:System.Windows.Forms.Control.BindingContext%2A> proprietà, vedere il <xref:System.Windows.Forms.BindingContext.%23ctor%2A> costruttore.  
  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.BindingContext%2A> modifica della proprietà viene modificato da una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.EventHandler> delegare il <xref:System.Windows.Forms.Control.BindingContextChanged> evento di un <xref:System.Windows.Forms.TextBox> controllo.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la distanza in pixel tra il bordo inferiore del controllo e il bordo superiore dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo inferiore del controllo e il bordo superiore dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è uguale alla somma dei valori di <xref:System.Windows.Forms.Control.Top%2A> valore della proprietà e <xref:System.Windows.Forms.Control.Height%2A> valore della proprietà.  
  
 Il <xref:System.Windows.Forms.Control.Bottom%2A> è una proprietà di sola lettura. È possibile modificare il valore della proprietà modificando il valore del <xref:System.Windows.Forms.Control.Top%2A> o <xref:System.Windows.Forms.Control.Height%2A> proprietà o chiamare il <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, o <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodi.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Bottom%2A> proprietà per definire il limite inferiore di un <xref:System.Windows.Forms.TextBox> controllo relativo all'area client del contenitore.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione e la posizione del controllo, compresi i relativi elementi non client relativi al controllo padre, espressi in pixel.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Rectangle" /> in pixel relativo al controllo padre che rappresenta la dimensione e la posizione del controllo, compresi i relativi elementi non client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I limiti del controllo includono gli elementi non client, ad esempio le barre di scorrimento, bordi, le barre del titolo e menu. Il <xref:System.Windows.Forms.Control.SetBoundsCore%2A> metodo viene chiamato per impostare il <xref:System.Windows.Forms.Control.Bounds%2A> proprietà. Il <xref:System.Windows.Forms.Control.Bounds%2A> proprietà non viene sempre modificata tramite relativo `set` (metodo), è necessario eseguire l'override di <xref:System.Windows.Forms.Control.SetBoundsCore%2A> metodo per assicurarsi che il codice venga eseguito quando il <xref:System.Windows.Forms.Control.Bounds%2A> proprietà è impostata.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> i controlli in un form e imposta le dimensioni e posizione utilizzando le varie dimensioni correlate e relative proprietà. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e l'altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sposta il controllo in primo piano nell'ordine z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo viene spostato in primo piano nell'ordine z. Se il controllo è un elemento figlio di un altro controllo, il controllo figlio viene spostato in primo piano nell'ordine z. <xref:System.Windows.Forms.Control.BringToFront%2A> non consente di rendere un controllo dispositivo di primo livello e non genera il <xref:System.Windows.Forms.Control.Paint> evento.  
  
   
  
## Examples  
 Esempio di codice seguente garantisce che un <xref:System.Windows.Forms.Label> è visibile chiamando il relativo <xref:System.Windows.Forms.Control.BringToFront%2A> (metodo). In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Panel> denominato `panel1`e un <xref:System.Windows.Forms.Label> denominato `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la proprietà <see cref="P:System.Windows.Forms.Control.ImeMode" /> può essere impostata su un valore attivo, per abilitare il supporto IME.</summary>
        <value>
          <see langword="true" /> in tutti i casi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate possono eseguire l'override di questa proprietà per restituire `false` se IME non è supportata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo può ricevere lo stato attivo.</summary>
        <value>
          <see langword="true" /> se il controllo può ricevere lo stato attivo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affinché un controllo riceve lo stato attivo di input, il controllo deve avere un handle assegnato e <xref:System.Windows.Forms.Control.Visible%2A> e <xref:System.Windows.Forms.Control.Enabled%2A> proprietà devono essere impostate entrambi su `true` per il controllo e tutti i controlli padre e il controllo deve essere un form o elemento padre più esterno del controllo deve essere un form.  
  
   
  
## Examples  
 Esempio di codice seguente imposta lo stato attivo sull'oggetto specificato <xref:System.Windows.Forms.Control>, se può ricevere lo stato attivo.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se è possibile generare eventi sul controllo.</summary>
        <value>
          <see langword="true" /> se il controllo viene incluso come controllo ActiveX in cui gli eventi sono bloccati; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo controllo è ospitato come controllo ActiveX, questa proprietà restituirà `false` se il controllo ActiveX gli eventi è bloccati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo può essere selezionato.</summary>
        <value>
          <see langword="true" /> se il controllo può essere selezionato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `true` se il `Selectable` valore <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> è impostato su `true`è contenuto in un altro controllo, il controllo è visibile e abilitato e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili e verrà restituito un valore di `false` per il <xref:System.Windows.Forms.Control.CanSelect%2A> proprietà. I controlli derivati da questi controlli non sono selezionabili.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
   
  
## Examples  
 L'esempio di codice seguente seleziona specificato <xref:System.Windows.Forms.Control>, se è selezionabile.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo ha ricevuto l'input del mouse.</summary>
        <value>
          <see langword="true" /> se il controllo ha ricevuto l'input del mouse; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un controllo ha acquisito il mouse, riceve l'input del mouse o meno il cursore si trova all'interno dei bordi. Il puntatore del mouse in genere viene acquisito solo durante le operazioni di trascinamento.  
  
 Solo la finestra di primo piano è possibile acquisire il mouse. Quando una finestra di sfondo tenta di eseguire questa operazione, la finestra riceve i messaggi solo per gli eventi del mouse che si verificano quando il cursore del mouse è all'interno della parte visibile della finestra. Inoltre, anche se la finestra di primo piano ha acquisito il mouse, l'utente può comunque fare clic su un'altra finestra portarla in primo piano.  
  
 Quando viene acquisito il mouse, non devono usare i tasti di scelta rapida.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.Capture%2A> proprietà. Per eseguire questo esempio, incollare il seguente codice in un form contenente un <xref:System.Windows.Forms.Label> denominato label1 e due <xref:System.Windows.Forms.ListBox> controlli denominati listbox1 e listbox2. Verificare che il form e dei controlli <xref:System.Windows.Forms.Control.MouseDown> evento è associato al metodo in questo esempio.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre impostare il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se viene eseguita la convalida di tutti i controlli per cui è richiesta quando il controllo riceve lo stato attivo.</summary>
        <value>
          <see langword="true" /> se viene eseguita la convalida di tutti i controlli per cui è richiesta quando il controllo riceve lo stato attivo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Il <xref:System.Windows.Forms.Control.CausesValidation%2A> valore della proprietà viene in genere impostato su `false` per i controlli, ad esempio un pulsante della Guida.  
  
   
  
## Examples  
 L'esempio di codice seguente viene utilizzata la classe derivata <xref:System.Windows.Forms.TextBox> e convalida un indirizzo di posta elettronica immesso dall'utente. Se l'indirizzo di posta elettronica non è nel formato standard (contenente "@" and "."), la convalida non riesce, un <xref:System.Windows.Forms.ErrorProvider> viene visualizzata l'icona e l'evento viene annullato. Uno dei pulsanti nel form è relativo <xref:System.Windows.Forms.Control.CausesValidation%2A> proprietà impostata su `false`. Facendo clic o impostando lo stato attivo su questo pulsante non attiva la convalida. Questo esempio si presuppone che un <xref:System.Windows.Forms.TextBox>, un <xref:System.Windows.Forms.ErrorProvider> (controllo) e un <xref:System.Windows.Forms.Button> sono stati creati in un form.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.CausesValidation" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.CausesValidation%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando lo stato attivo o i tasti di scelta rapida dell'interfaccia utente vengono modificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.ChangeUICues> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.ChangeUICues> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se intercettare le chiamate sul thread errato che accedono a una proprietà <see cref="P:System.Windows.Forms.Control.Handle" /> del controllo se è in corso il debug dell'applicazione.</summary>
        <value>
          <see langword="true" /> se le chiamate sul thread sbagliato vengono intercettate; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un thread diverso da quello di creazione di un controllo tenta di accedere a uno dei metodi o proprietà che controllano, spesso comporta risultati imprevisti. Un'attività comune di thread non valida è una chiamata sul thread errato che accede al controllo <xref:System.Windows.Forms.Control.Handle%2A> proprietà. Impostare <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> a `true` per individuare e diagnosticare più facilmente l'attività dei thread durante il debug.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa clic sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Click> evento passa un <xref:System.EventArgs> per il gestore eventi, pertanto solo indica che si è verificato un clic. Se sono necessarie informazioni più specifiche di mouse (pulsante, numero di clic, alla rotazione della rotellina o alla posizione), utilizzare il <xref:System.Windows.Forms.Control.MouseClick> evento. Tuttavia, il <xref:System.Windows.Forms.Control.MouseClick> evento non essere generato se il clic è determinato da un'azione del mouse, ad esempio premendo il tasto INVIO.  
  
 Un doppio clic è determinato dalle impostazioni relative al mouse del sistema operativo dell'utente. L'utente può impostare un intervallo tra i clic effettuati con un pulsante del mouse in modo che debbano essere considerati come un doppio clic anziché come due clic distinti. Il <xref:System.Windows.Forms.Control.Click> evento viene generato ogni volta che un controllo si fa doppio clic. Ad esempio, se si dispongono di gestori eventi per il <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> gli eventi di un <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> eventi vengono generati quando viene fatto doppio clic sul form ed entrambi i metodi vengono chiamati. Se si fa doppio clic un controllo e che non supporta il <xref:System.Windows.Forms.Control.DoubleClick> evento, il <xref:System.Windows.Forms.Control.Click> evento potrebbe essere generato due volte.  
  
 È necessario impostare il `StandardClick` valore <xref:System.Windows.Forms.ControlStyles> a `true` per questo evento da generare.  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato il <xref:System.Windows.Forms.Control.Click> evento in un gestore eventi.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Eredità da un controllo Windows Form standard e la modifica di <see langword="StandardClick" /> o <see langword="StandardDoubleClick" /> valori di <see cref="T:System.Windows.Forms.ControlStyles" /> a <see langword="true" /> può causare un comportamento imprevisto o non avere alcun effetto se il controllo non supporta il <see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />eventi.  
  
 Nella tabella seguente sono elencati i controlli Windows Form e gli eventi (<see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />) viene generato in risposta all'azione del mouse specificato.  
  
 <list type="table"><listheader><term> Controllo  
  
 </term><description> Clic del Mouse  
  
 </description><description> Fare doppio clic sinistro del Mouse  
  
 </description><description> Fare clic destro del Mouse  
  
 </description><description> Fare doppio clic destro del Mouse  
  
 </description><description> Fare clic su centrale del Mouse  
  
 </description><description> Fare doppio clic centrale del Mouse  
  
 </description><description> Clic del Mouse XButton1  
  
 </description><description> Fare doppio clic del Mouse XButton1  
  
 </description><description> Fare clic su di XButton2 del Mouse  
  
 </description><description> Fare doppio clic del Mouse XButton2  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />,  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />,  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />,  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />,  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />,  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />,  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \* <see cref="T:System.Windows.Forms.ListView" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />,  
  
 <see cref="T:System.Windows.Forms.Label" />,  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />,  
  
 <see cref="T:System.Windows.Forms.Panel" />,  
  
 <see cref="T:System.Windows.Forms.GroupBox" />,  
  
 <see cref="T:System.Windows.Forms.PictureBox" />,  
  
 <see cref="T:System.Windows.Forms.Splitter" />,  
  
 <see cref="T:System.Windows.Forms.StatusBar" />,  
  
 <see cref="T:System.Windows.Forms.ToolBar" />,  
  
 <see cref="T:System.Windows.Forms.TabPage" />,  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description></item></list>  
  
 \* Il puntatore del mouse deve essere posizionato su un oggetto figlio (<see cref="T:System.Windows.Forms.TreeNode" /> o <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
 * Il <see cref="T:System.Windows.Forms.TabControl" /> deve avere almeno un <see cref="T:System.Windows.Forms.TabPage" /> nel relativo <see cref="P:System.Windows.Forms.TabControl.TabPages" /> insieme.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il rettangolo che rappresenta l'area client del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area client del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area client di un controllo è i limiti del controllo, meno gli elementi non client, ad esempio le barre di scorrimento, bordi, le barre del titolo e menu.  
  
 Poiché le coordinate del client sono rispetto all'angolo superiore sinistro dell'area client del controllo, le coordinate dell'angolo superiore sinistro del rettangolo restituito da questa proprietà sono (0,0). È possibile utilizzare questa proprietà per ottenere le dimensioni e le coordinate dell'area client del controllo per attività quali disegno sulla superficie del controllo.  
  
 Per ulteriori informazioni sul disegno nei controlli, vedere [il Rendering di un controllo Windows Form](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
   
  
## Examples  
 Nell'esempio seguente Abilita lo scorrimento automatico per un form, ridimensiona il form e assicura che un pulsante rimanga visibile dopo il form viene ridimensionato. In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Button> denominato `button2` su di esso.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza e la larghezza dell'area client del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> che rappresenta le dimensioni dell'area client del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area client di un controllo è i limiti del controllo, meno gli elementi non client, ad esempio le barre di scorrimento, bordi, le barre del titolo e menu. Il <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodo viene chiamato per impostare il <xref:System.Windows.Forms.Control.ClientSize%2A> proprietà. Il <xref:System.Windows.Forms.Control.ClientSize%2A> proprietà non viene sempre modificata tramite relativo `set` (metodo), è necessario eseguire l'override di <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodo per assicurarsi che il codice venga eseguito quando il <xref:System.Windows.Forms.Control.ClientSize%2A> proprietà è impostata.  
  
 Il <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> e <xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> rappresentano la larghezza e altezza dell'area client del controllo. È possibile utilizzare questa proprietà per ottenere le dimensioni dell'area client del controllo per attività quali disegno sulla superficie del controllo.  
  
 Per ulteriori informazioni sul disegno nei controlli, vedere [il Rendering di un controllo Windows Form](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
> [!NOTE]
>  Per questa proprietà non è possibile associare le impostazioni dell'applicazione. Per ulteriori informazioni sulle impostazioni dell'applicazione, vedere [Application Settings Overview](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 Esempio di codice seguente ridimensiona il controllo specificato in modo il testo formattato, verrà eseguito il controllo. Il testo formattato è il <xref:System.Windows.Forms.Control.Text%2A> assegnata la proprietà con il controllo <xref:System.Windows.Forms.Control.Font%2A> applicato al testo. Il `AutoSizeControl` metodo in questo esempio ha anche un `textPadding` parametro che rappresenta la spaziatura interna da applicare a tutti i bordi del controllo. Per rendere la spaziatura interna uguale, allineare il testo di <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType> valore, se supportato dal controllo.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ClientSize" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.ClientSizeChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.ClientSizeChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome della società o dell'autore dell'applicazione che contiene il controllo.</summary>
        <value>Nome della società o dell'autore dell'applicazione che contiene il controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.CompanyName%2A> è una proprietà di sola lettura. Per modificare il valore di questa proprietà, impostare il <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> valore della proprietà di <xref:System.Reflection.AssemblyCompanyAttribute>. La seguente riga del set di codice c# di <xref:System.Windows.Forms.Control.CompanyName%2A> proprietà.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  È consigliabile fornire il nome della società, il nome del prodotto e versione del prodotto per l'app.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare informazioni sull'applicazione in un <xref:System.Windows.Forms.Label> contenuti in un <xref:System.Windows.Forms.Form>. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> e <xref:System.Windows.Forms.Control.ProductVersion%2A> sono state impostate.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">Oggetto <see cref="T:System.Windows.Forms.Control" /> da valutare.</param>
        <summary>Recupera un valore che indica se il controllo specificato è figlio del controllo.</summary>
        <returns>
          <see langword="true" /> se il controllo specificato è figlio del controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente garantisce che un <xref:System.Windows.Forms.Label> è visibile chiamando il relativo <xref:System.Windows.Forms.Control.BringToFront%2A> (metodo). In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.Panel> denominato `panel1`e un <xref:System.Windows.Forms.Label> denominato `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo o uno dei controlli figlio dispone dello stato attivo per l'input.</summary>
        <value>
          <see langword="true" /> se il controllo o uno dei controlli figlio dispone dello stato attivo per l'input; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questa proprietà per determinare se un controllo o uno dei controlli in esso contenuti è nello stato attivo. Per determinare se il controllo ha lo stato attivo, indipendentemente dal fatto se uno dei relativi controlli figlio dispone dello stato attivo, utilizzare il <xref:System.Windows.Forms.Control.Focused%2A> proprietà. Per assegnare un controllo attivo per l'input, utilizzare il <xref:System.Windows.Forms.Control.Focus%2A> o <xref:System.Windows.Forms.Control.Select%2A> metodi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il menu di scelta rapida associato al controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.ContextMenu" /> che rappresenta il menu di scelta rapida associato al controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare un menu di scelta rapida per le opzioni di menu specifiche per il contesto per gli utenti quando essi destro del mouse sul controllo.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Windows.Forms.ContextMenu> assegnato a un <xref:System.Windows.Forms.TreeView> quando il pulsante destro del mouse viene premuto e rilasciato. Questo codice è necessario che sia disponibile un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.TreeView> su di esso. È inoltre necessario che il <xref:System.Windows.Forms.TreeView> ha un <xref:System.Windows.Forms.ContextMenu> assegnato al relativo <xref:System.Windows.Forms.Control.ContextMenu%2A> proprietà.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.ContextMenu" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.ContextMenu" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.ContextMenu" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ContextMenu" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.ContextMenu%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente visualizza un messaggio quando viene apportata una modifica al menu di scelta rapida.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Forms.ContextMenuStrip" /> associato al controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.ContextMenuStrip" /> per il controllo o <see langword="null" /> se non sono presenti oggetti <see cref="T:System.Windows.Forms.ContextMenuStrip" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un <xref:System.Windows.Forms.ContextMenu> è anch'essi assegnati al controllo, il <xref:System.Windows.Forms.ContextMenu> ha la precedenza sul <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come aggiungere tre <xref:System.Windows.Forms.ToolStripMenuItem> oggetti in un <xref:System.Windows.Forms.ContextMenuStrip>. Viene inoltre illustrato come impostare il <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> proprietà del form.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.ContextMenuStripChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.ContextMenuStripChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si aggiunge un nuovo controllo all'oggetto <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlAdded> per aggiungere un controllo a un form e visualizza il nome del controllo aggiunto in un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si rimuove un controllo dall'oggetto <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlRemoved> per rimuovere un controllo da un form e visualizza il nome del controllo rimosso in una <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di controlli contenuti nel controllo.</summary>
        <value>Raccolta <see cref="T:System.Windows.Forms.Control.ControlCollection" /> che rappresenta la raccolta di controlli contenuti nel controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Forms.Control> può fungere da elemento padre di una raccolta di controlli. Ad esempio, quando si aggiungono più controlli per un <xref:System.Windows.Forms.Form>, ognuno dei controlli è un membro del <xref:System.Windows.Forms.Control.ControlCollection> assegnato al <xref:System.Windows.Forms.Control.Controls%2A> proprietà del modulo, che è derivato dalla <xref:System.Windows.Forms.Control> classe.  
  
 È possibile modificare i controlli di <xref:System.Windows.Forms.Control.ControlCollection> assegnato al <xref:System.Windows.Forms.Control.Controls%2A> proprietà utilizzando i metodi disponibili nel <xref:System.Windows.Forms.Control.ControlCollection> classe.  
  
 Quando si aggiungono più controlli a un controllo padre, è consigliabile chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo prima di inizializzare i controlli da aggiungere. Dopo l'aggiunta di controlli al controllo padre, chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo. In questo modo aumenta le prestazioni delle applicazioni con molti controlli.  
  
 Utilizzare il <xref:System.Windows.Forms.Control.Controls%2A> proprietà per scorrere tutti i controlli di un form, inclusi i controlli annidati. Utilizzare il <xref:System.Windows.Forms.Control.GetNextControl%2A> metodo per recuperare il controllo figlio precedente o successivo nell'ordine di tabulazione. Utilizzare il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà da ottenere o impostare il controllo attivo di un controllo contenitore.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene rimuove un <xref:System.Windows.Forms.Control> dal <xref:System.Windows.Forms.Control.ControlCollection> della classe derivata <xref:System.Windows.Forms.Panel> se è un membro della raccolta. Nell'esempio si presuppone che sia stato creato un <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.Button>e almeno un <xref:System.Windows.Forms.RadioButton> control per un <xref:System.Windows.Forms.Form>. Il <xref:System.Windows.Forms.RadioButton> vengono aggiunti al <xref:System.Windows.Forms.Panel> (controllo) e <xref:System.Windows.Forms.Panel> aggiunto al controllo il <xref:System.Windows.Forms.Form>. Quando si fa clic sul pulsante, il pulsante di opzione denominato `removeButton` rimossa la <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto di accessibilità per il controllo.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> per il controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si chiama in modo esplicito il metodo <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>, verrà chiamato quando si crea un riferimento alla proprietà <xref:System.Windows.Forms.Control.AccessibilityObject%2A>.  
  
> [!NOTE]
>  Per ottenere o impostare il <xref:System.Windows.Forms.Control.AccessibilityObject%2A> proprietà, è necessario aggiungere un riferimento al `Accessibility` assembly installato con il [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la creazione di un grafico di supporto per l'accessibilità controllare, tramite il <xref:System.Windows.Forms.AccessibleObject> e <xref:System.Windows.Forms.Control.ControlAccessibleObject> alle classi di esporre le informazioni accessibili. Il controllo traccia due curve e una legenda. Il `ChartControlAccessibleObject` classe che deriva da `ControlAccessibleObject`, viene utilizzata la <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo per fornire informazioni accessibili personalizzate per il controllo chart. Poiché la legenda del grafico non è una vera e propria <xref:System.Windows.Forms.Control> -controllo di base, ma viene disegnata dal controllo chart, non non contiene informazioni accessibili. Per questo motivo, il `ChartControlAccessibleObject` classe esegue l'override di <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> per restituire il `CurveLegendAccessibleObject` che rappresenta le informazioni accessibili per ogni parte della legenda. Quando viene utilizzato da un'applicazione accessibile abilitata, il controllo può fornire le informazioni accessibili necessarie.  
  
 Questo estratto di codice viene illustrato l'override di <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo. Vedere il <xref:System.Windows.Forms.AccessibleObject> Cenni preliminari sulla classe per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> in una classe derivata, non chiamare la classe base <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> metodo.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina la creazione del controllo visibile, inclusa la creazione del punto di controllo e di eventuali controlli figlio visibili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.CreateControl%2A> metodo impone un handle da creare per il controllo e i relativi controlli figlio. Questo metodo viene utilizzato quando è necessario immediatamente un handle per la modifica del controllo o i relativi elementi figlio; è sufficiente chiamare un costruttore del controllo non crea il <xref:System.Windows.Forms.Control.Handle%2A>.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> non crea un punto di controllo se il controllo <xref:System.Windows.Forms.Control.Visible%2A> proprietà `false`. È possibile chiamare il <xref:System.Windows.Forms.Control.CreateHandle%2A> metodo o accesso di <xref:System.Windows.Forms.Control.Handle%2A> proprietà per creare il controllo di gestire indipendentemente dalla visibilità del controllo, ma in questo caso, nessuna finestra handle vengono creati per gli elementi figlio del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della raccolta di controlli per il controllo.</summary>
        <returns>Nuova istanza dell'oggetto <see cref="T:System.Windows.Forms.Control.ControlCollection" /> assegnato al controllo.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>La versione della classe di base di questo metodo non deve essere chiamata da una classe derivata.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo è stato creato.</summary>
        <value>
          <see langword="true" /> se il controllo è stato creato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Created%2A> restituisce proprietà `true` se il <xref:System.Windows.Forms.Control> è stato creato correttamente, anche se potrebbe essere l'handle del controllo non sono stato creato o ricreato ancora.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea l'oggetto <see cref="T:System.Drawing.Graphics" /> per il controllo.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Graphics" /> per il controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Drawing.Graphics> oggetto recuperato tramite il <xref:System.Windows.Forms.Control.CreateGraphics%2A> metodo non normalmente conservare dopo aver elaborato il messaggio di Windows corrente, perché qualsiasi elemento disegnato con tale oggetto verrà cancellato con il successivo messaggio WM_PAINT. È pertanto possibile memorizzare nella cache il <xref:System.Drawing.Graphics> oggetto per il riutilizzo, tranne per utilizzare i metodi non visivi come <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>. In alternativa, è necessario chiamare <xref:System.Windows.Forms.Control.CreateGraphics%2A> ogni volta che si desidera utilizzare il <xref:System.Drawing.Graphics> e quindi chiamare <xref:System.Drawing.Graphics.Dispose%2A> quando si è terminato. Per ulteriori informazioni sui messaggi di Windows, vedere <xref:System.Windows.Forms.Control.WndProc%2A>.  
  
 Per impostazione predefinita, <xref:System.Windows.Forms.Control.CreateGraphics%2A> imposta la proprietà per il thread chiamante e non riesce se viene chiamato da altri thread.  
  
> [!NOTE]
>  Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
   
  
## Examples  
 Esempio di codice seguente ridimensiona il controllo specificato in modo il testo formattato, verrà eseguito il controllo. Il testo formattato è il <xref:System.Windows.Forms.Control.Text%2A> assegnata la proprietà con il controllo <xref:System.Windows.Forms.Control.Font%2A> applicato al testo. Il `AutoSizeControl` metodo in questo esempio ha anche un `textPadding` parametro che rappresenta la spaziatura interna da applicare a tutti i bordi del controllo. Per rendere la spaziatura interna uguale, allineare il testo di `MiddleCenter` valore <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> se supportato dal controllo.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per le sottofinestre chiamare questo metodo. Enumerazione associata: <see langword="SafeSubWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un handle per il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere non è necessario chiamare il <xref:System.Windows.Forms.Control.CreateHandle%2A> metodo direttamente. Il metodo preferito consiste nel chiamare il <xref:System.Windows.Forms.Control.CreateControl%2A> (metodo), che impone un handle da creare per il controllo e i relativi controlli figlio quando viene creato il controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato eliminato.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.CreateHandle" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.CreateHandle" /> metodo per assicurarsi che l'handle è creato.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i parametri necessari per la creazione quando viene creato l'handle del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.CreateParams" /> contenente i parametri di creazione necessari quando viene creato l'handle del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.CreateParams%2A> proprietà non deve essere sottoposto a override e utilizzata per modificare le proprietà del controllo derivato. Proprietà, ad esempio il <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType> dovrebbe essere impostato per la proprietà corrispondente nel controllo, ad esempio <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>. Il <xref:System.Windows.Forms.CreateParams> deve essere estesa solo quando si esegue il wrapping di una classe di controllo standard di Windows o per impostare gli stili non forniti dallo spazio dei nomi Windows Form. Per ulteriori informazioni sulla creazione di parametri di controllo, vedere il `CreateWindow` e `CreateWindowEx` funzioni e [CREATESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)documentazione relativa alla struttura.  
  
   
  
## Examples  
 L'esempio di codice seguente estende la <xref:System.Windows.Forms.Control.CreateParams%2A> proprietà di un <xref:System.Windows.Forms.Button> classe derivata. Il <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> proprietà viene modificata, causando il pulsante per visualizzare un <xref:System.Drawing.Icon> anziché un oggetto <xref:System.Drawing.Image>. In questo esempio si suppone una classe che eredita la <xref:System.Windows.Forms.Button> classe.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per il chiamante immediato chiamare codice non gestito quando si recupera il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.CreateParams" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.CreateParams" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il cursore visualizzato quando il puntatore del mouse viene spostato sul controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Cursor" /> che rappresenta il cursore da visualizzare quando il puntatore del mouse viene spostato sul controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assegnare un <xref:System.Windows.Forms.Cursor> per il <xref:System.Windows.Forms.Control.Cursor%2A> proprietà del controllo per modificare il cursore visualizzato quando il puntatore del mouse si trova sul controllo. Per modificare temporaneamente il cursore del mouse per tutti i controlli dell'applicazione, impostare il <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> proprietà. In genere è necessario impostare il <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> proprietà per un cursore di attesa durante il popolamento di un <xref:System.Windows.Forms.ComboBox> o il salvataggio o caricamento di un file.  
  
 Il <xref:System.Windows.Forms.Control.Cursor%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere il <xref:System.Windows.Forms.AmbientProperties> classe o <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene riempimenti un <xref:System.Windows.Forms.ComboBox> con unità logiche disponibili dell'utente. L'esempio imposta anche la casella combinata <xref:System.Windows.Forms.Cursor> proprietà pertanto <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> cursore viene visualizzato quando il puntatore del mouse viene spostato sul pulsante di menu a discesa. Questo codice è necessario che sia disponibile un <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.ComboBox> su di esso.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per le sottofinestre impostare il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Cursor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Cursor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> metodi del <see cref="P:System.Windows.Forms.Control.Cursor" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Cursor" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Cursor%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come cambiare il cursore del mouse utilizzando il <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> proprietà, il <xref:System.Windows.Forms.Cursor> (classe) e <xref:System.Windows.Forms.Cursors> classe. Nell'esempio viene creato un form contenente un <xref:System.Windows.Forms.ComboBox> (controllo), un <xref:System.Windows.Forms.Panel> (controllo) e un <xref:System.Windows.Forms.ListView> controllo. Il <xref:System.Windows.Forms.ComboBox> contiene tutti i cursori forniti dalla <xref:System.Windows.Forms.Cursors> classe. Quando l'utente seleziona un cursore del mouse nel <xref:System.Windows.Forms.ComboBox>, <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> proprietà è impostata sul cursore selezionato, che aggiorna il cursore per il <xref:System.Windows.Forms.Panel>. Il <xref:System.Windows.Forms.ListView> viene aggiornato ogni volta che il <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType> si verifica l'evento.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i data binding per il controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> che contiene gli oggetti <see cref="T:System.Windows.Forms.Binding" /> del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.DataBindings%2A> proprietà a cui accedere il <xref:System.Windows.Forms.ControlBindingsCollection>. Aggiungendo <xref:System.Windows.Forms.Binding> oggetti alla raccolta, è possibile associare qualsiasi proprietà di un controllo per la proprietà di un oggetto.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge <xref:System.Windows.Forms.Binding> oggetti per il <xref:System.Windows.Forms.ControlBindingsCollection> di cinque controlli: quattro <xref:System.Windows.Forms.TextBox> controlli e un <xref:System.Windows.Forms.DateTimePicker> controllo. È possibile accedere a <xref:System.Windows.Forms.ControlBindingsCollection> tramite la proprietà <xref:System.Windows.Forms.Control.DataBindings%2A> della classe <xref:System.Windows.Forms.Control>.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il colore di sfondo predefinito del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> di sfondo predefinito del controllo. Il valore predefinito è <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa è l'impostazione predefinita <xref:System.Windows.Forms.Control.BackColor%2A> valore della proprietà di un controllo di primo livello generico. Le classi derivate possono avere valori predefiniti diversi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, e <xref:System.Windows.Forms.Control.DefaultForeColor%2A> membri. Per eseguire l'esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.ListBox> denominato ListBox1. Chiamare il `Populate_ListBox` metodo nel costruttore del form o <xref:System.Windows.Forms.Form.Load> il metodo di gestione degli eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il cursore predefinito per il controllo.</summary>
        <value>Oggetto di tipo <see cref="T:System.Windows.Forms.Cursor" /> che rappresenta il cursore predefinito corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eseguire l'override <xref:System.Windows.Forms.Control.DefaultCursor%2A> per configurare un cursore predefinito per il controllo. Questo è più efficiente rispetto all'impostazione del cursore nel costruttore del controllo e fornisce il supporto automatico per determinate funzioni della finestra di progettazione relative al cursore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di carattere predefinito del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Font" /> predefinito del controllo. Il valore restituito varierà in base al sistema operativo usato e alle impostazioni cultura del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente descrive il valore restituito da <xref:System.Windows.Forms.Control.DefaultFont%2A> a seconda del sistema operativo e le impostazioni cultura locali.  
  
|Sistema / e o delle impostazioni cultura|Tipo di carattere|  
|----------------------------|----------|  
|Windows NT 4 x, versione giapponese|MS UI gotica, 9 punti.|  
|Windows arabo|Tahoma, 8 punti.|  
|Altre impostazioni cultura/sistema operativo|Carattere MS Shell Dlg logico, in genere Microsoft Sans Serif a 8 punti.|  
  
 MS Shell Dlg viene mappato a un tipo di carattere impostato nel Registro di sistema.  
  
 Se non sono installati i tipi di carattere precedente, il tipo di carattere predefinito è Tahoma, 8 punti. Se Tahoma, 8 punti, non è installato, <xref:System.Windows.Forms.Control.DefaultFont%2A> restituisce il valore della <xref:System.Drawing.FontFamily.GenericSansSerif%2A> proprietà  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, e <xref:System.Windows.Forms.Control.DefaultForeColor%2A> membri. Per eseguire l'esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.ListBox> denominato ListBox1. Chiamare il `Populate_ListBox` metodo nel costruttore del form o <xref:System.Windows.Forms.Form.Load> il metodo di gestione degli eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo di carattere predefinito o i tipi di carattere alternativi specifici per la lingua in uso non sono installati sul computer client.</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il colore di primo piano predefinito del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> di primo piano predefinito del controllo. Il valore predefinito è <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa è l'impostazione predefinita <xref:System.Windows.Forms.Control.ForeColor%2A> valore della proprietà di un controllo privo di controllo. Le classi derivate possono avere valori predefiniti diversi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, e <xref:System.Windows.Forms.Control.DefaultForeColor%2A> membri. Per eseguire l'esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.ListBox> denominato ListBox1. Chiamare il `Populate_ListBox` metodo nel costruttore del form o <xref:System.Windows.Forms.Form.Load> il metodo di gestione degli eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la modalità IME (Input Method Editor, editor del metodo di input) predefinita supportata dal controllo.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Input Method Editor (IME) è un programma che consente agli utenti di immettere simboli, ad esempio caratteri Kanji giapponese e caratteri complessi mediante una tastiera standard.  
  
 Quando implementato nel <xref:System.Windows.Forms.Control> classe, questa proprietà restituisce sempre il <xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType> valore. Il <xref:System.Windows.Forms.ImeMode.Inherit> valore specifica che la modalità IME viene ereditata dal controllo padre.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.DefaultImeMode%2A> proprietà per attivare l'editor del metodo di Input.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo spazio specificato per impostazione predefinita tra i controlli, espresso in pixel.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta lo spazio predefinito tra i controlli.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza e l'altezza specificate come dimensioni massime predefinite di un controllo, espresse in pixel.</summary>
        <value>Oggetto <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" /> che rappresenta le dimensioni del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza e l'altezza specificate come dimensioni minime predefinite di un controllo, espresse in pixel.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> che rappresenta le dimensioni del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la spaziatura interna del contenuto di un controllo, espressa in pixel.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta la spaziatura interna del contenuto di un controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni predefinite del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> predefinito del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà rappresenta il <xref:System.Drawing.Size> del controllo quando viene inizialmente creato. È possibile regolare le dimensioni del controllo impostando il relativo <xref:System.Windows.Forms.Control.Size%2A> valore della proprietà.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare il <xref:System.Drawing.Size> di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
> [!NOTE]
>  Nei sistemi Windows Server 2003, le dimensioni di un <xref:System.Windows.Forms.Form> è limitato per la larghezza massima in pixel e l'altezza del monitoraggio.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> , proprietà e le dimensioni predefinite dei pixel modulo 500 quadrato.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.DefaultSize" /> proprietà in una classe derivata, è preferibile restituire un <see cref="T:System.Drawing.Size" /> con le dimensioni desiderate anziché eseguire l'override di tutta l'implementazione.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> di Windows da elaborare.</param>
        <summary>Invia il messaggio specificato alla routine della finestra predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sull'elaborazione dei messaggi di Windows, vedere il [funzione WindowProc](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina definitivamente il punto di controllo associato al controllo.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> metodo per assicurarsi che l'handle è stato eliminato.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore DPI per il dispositivo di visualizzazione in cui è attualmente visualizzato il controllo.</summary>
        <value>Valore DPI del dispositivo di visualizzazione.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il rettangolo che rappresenta l'area di visualizzazione del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area di visualizzazione del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DisplayRectangle%2A> proprietà restituisce il rettangolo client dell'area di visualizzazione del controllo. Per la classe di base di controllo, questo valore è uguale al rettangolo client. Tuttavia, i controlli che ereditano potrebbe voler modificare questo valore se la relativa area client è diverso dalla relativa area di visualizzazione. Il rettangolo di visualizzazione è il più piccolo <xref:System.Drawing.Rectangle> che racchiude un controllo e viene utilizzato per disporre i controlli.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> proprietà per estendere l'implementazione di base. In alternativa, è necessario fornire tutti l'implementazione.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Windows.Forms.Control" /> e dai relativi controlli figlio e facoltativamente rilascia le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico `Dispose()` (metodo) e <xref:System.Object.Finalize%2A> metodo.`Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Windows.Forms.Control> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento a oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [si esegue l'override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Windows.Forms.Control" /> base è in corso di eliminazione.</summary>
        <value>
          <see langword="true" /> se la classe <see cref="T:System.Windows.Forms.Control" /> base è in corso di eliminazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questa proprietà restituisce `true`, la base <xref:System.Windows.Forms.Control> classe è in corso di eliminazione. Una volta eliminato il controllo, non può più fare riferimento a un controllo di Windows valido. Anche se l'istanza di un controllo viene eliminata, viene comunque mantenuto in memoria fino a quando non viene rimosso dalla memoria tramite garbage collection. Quando viene eliminato un controllo, è possibile chiamare il relativo <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i bordi di controllo ancorati al relativo controllo padre e determina la modalità con cui un controllo viene ridimensionato con il proprio padre.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.DockStyle" />. Il valore predefinito è <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.Dock%2A> proprietà per definire come un controllo viene ridimensionato automaticamente quando il relativo controllo padre viene ridimensionato. Ad esempio, l'impostazione <xref:System.Windows.Forms.Control.Dock%2A> a <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> , il controllo con il bordo sinistro del controllo padre e il controllo padre viene ridimensionato. I controlli vengono ancorati nell'ordine Z, ovvero la disposizione visiva di controlli in un form lungo l'asse z del form (profondità).  
  
 Un controllo può essere ancorato a un bordo del contenitore padre o può essere ancorato a tutti i bordi e riempire il contenitore padre.  
  
 L'impostazione di <xref:System.Windows.Forms.Control.Margin%2A> proprietà in un controllo ancorato non ha effetto sulla distanza del controllo dai bordi del contenitore.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Anchor%2A> e <xref:System.Windows.Forms.Control.Dock%2A> si escludono a vicenda. È possibile impostare solo uno alla volta e l'ultima occorrenza ha la precedenza.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creato un <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Viene quindi impostata la <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di <see cref="T:System.Windows.Forms.DockStyle" />.</exception>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Dock" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Dock" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> metodi del <see cref="P:System.Windows.Forms.Control.Dock" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Dock" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Dock%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome *PropertyName* `Changed` che sono generati quando corrispondente *PropertyName* modificato il valore (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Dati da trascinare.</param>
        <param name="allowedEffects">Uno dei valori di <see cref="T:System.Windows.Forms.DragDropEffects" />.</param>
        <summary>Inizia un'operazione di trascinamento e rilascio.</summary>
        <returns>Valore ricavato dall'enumerazione <see cref="T:System.Windows.Forms.DragDropEffects" /> che rappresenta l'effetto finale ottenuto durante l'operazione di trascinamento della selezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `allowedEffects` parametro determina quali operazioni di trascinamento possono verificarsi. Se l'operazione di trascinamento deve interagire con le applicazioni in un altro processo, dati devono essere una classe base gestita (<xref:System.String>, <xref:System.Drawing.Bitmap>, o <xref:System.Drawing.Imaging.Metafile>), o un oggetto che implementa <xref:System.Runtime.Serialization.ISerializable> o <xref:System.Windows.Forms.IDataObject>.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo sotto la posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati, o per annullare l'operazione in base al valore del <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e <xref:System.Windows.Forms.Control.GiveFeedback> viene generato l'evento con il nuovo effetto, consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sulla destinazione di trascinamento, l'utente riceva le informazioni più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio il taglio dei dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> viene generato l'evento.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo intercetta tutte le eccezioni e Rigenera solo le seguente eccezioni di sicurezza o critico:  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando si avvia l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato più <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. Nell'esempio si presuppone che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per il trascinamento personalizzato e non trascinamento, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> è selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> il gestore eventi per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, quindi il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostato su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, lo stato del trascinamento viene visualizzato nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata all'interno di `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.DragDropEffects> enumerazione per specificare la modalità devono trasferimento dati tra i controlli coinvolti in un'operazione di trascinamento e rilascio. Nell'esempio si presuppone che il form includa un <xref:System.Windows.Forms.RichTextBox> controllo e un <xref:System.Windows.Forms.ListBox> controllo e che il <xref:System.Windows.Forms.ListBox> controllo venga popolato con un elenco di nomi di file valido. Quando l'utente trascina un nome di file sul <xref:System.Windows.Forms.RichTextBox> (controllo), il controllo <xref:System.Windows.Forms.Control.DragEnter> viene generato l'evento. All'interno del gestore di evento, il <xref:System.Windows.Forms.DragEventArgs.Effect%2A> proprietà del <xref:System.Windows.Forms.DragEventArgs> viene inizializzata su <xref:System.Windows.Forms.DragDropEffects> per indicare che devono essere copiati i dati a cui fa riferimento il percorso del file di <xref:System.Windows.Forms.RichTextBox> controllo.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la superficie del controllo deve essere ridisegnata usando un buffer secondario per ridurre o evitare lo sfarfallio.</summary>
        <value>
          <see langword="true" /> se la superficie del controllo deve essere disegnata usando il doppio buffer; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grafica memorizzata nel buffer può ridurre o eliminare lo sfarfallio causato dal ridisegno progressivo delle parti di una superficie visualizzata. Grafica memorizzata nel buffer richiede che i dati di grafici aggiornati prima vengono scritti in un buffer. I dati nel buffer di grafica vengano quindi scritti rapidamente memoria della superficie visualizzata. Il passaggio relativamente rapido della memoria grafica visualizzata in genere consente di ridurre lo sfarfallio che può verificarsi in caso contrario.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> non è una proprietà associabile.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa doppio clic sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un doppio clic è determinato dalle impostazioni relative al mouse del sistema operativo dell'utente. L'utente può impostare un intervallo tra i clic effettuati con un pulsante del mouse in modo che debbano essere considerati come un doppio clic anziché come due clic distinti. Il <xref:System.Windows.Forms.Control.Click> evento viene generato ogni volta che un controllo si fa doppio clic. Ad esempio, se si dispongono di gestori eventi per il <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> gli eventi di un <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Click> e <xref:System.Windows.Forms.Control.DoubleClick> eventi vengono generati quando viene fatto doppio clic sul form ed entrambi i metodi vengono chiamati. Se si fa doppio clic un controllo e che non supporta il <xref:System.Windows.Forms.Control.DoubleClick> evento, il <xref:System.Windows.Forms.Control.Click> evento potrebbe essere generato due volte.  
  
 È necessario impostare il `StandardDoubleClick` e `StandardClick` valori di <xref:System.Windows.Forms.ControlStyles> a `true` per questo evento da generare. Questi valori potrebbero già essere impostati su `true` se sta ereditando da esistente controlli Windows Form.  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DoubleClick> evento di un <xref:System.Windows.Forms.ListBox> per caricare i file di testo elencati nel <xref:System.Windows.Forms.ListBox> in un <xref:System.Windows.Forms.TextBox> controllo.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Eredità da un controllo Windows Form standard e la modifica di <see langword="StandardClick" /> o <see langword="StandardDoubleClick" /> valori di <see cref="T:System.Windows.Forms.ControlStyles" /> a <see langword="true" /> può causare un comportamento imprevisto o non avere alcun effetto se il controllo non supporta il <see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />eventi.  
  
 Nella tabella seguente sono elencati i controlli Windows Form e gli eventi (<see cref="E:System.Windows.Forms.Control.Click" /> o <see cref="E:System.Windows.Forms.Control.DoubleClick" />) viene generato in risposta all'azione del mouse specificato.  
  
 <list type="table"><listheader><term> Controllo  
  
 </term><description> Clic del Mouse  
  
 </description><description> Fare doppio clic sinistro del Mouse  
  
 </description><description> Fare clic destro del Mouse  
  
 </description><description> Fare doppio clic destro del Mouse  
  
 </description><description> Fare clic su centrale del Mouse  
  
 </description><description> Fare doppio clic centrale del Mouse  
  
 </description><description> Clic del Mouse XButton1  
  
 </description><description> Fare doppio clic del Mouse XButton1  
  
 </description><description> Fare clic su di XButton2 del Mouse  
  
 </description><description> Fare doppio clic del Mouse XButton2  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />,  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />,  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />,  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />,  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />,  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />,  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \* <see cref="T:System.Windows.Forms.ListView" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description><description> Nessuno  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic su  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />,  
  
 <see cref="T:System.Windows.Forms.Label" />,  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />,  
  
 <see cref="T:System.Windows.Forms.Panel" />,  
  
 <see cref="T:System.Windows.Forms.GroupBox" />,  
  
 <see cref="T:System.Windows.Forms.PictureBox" />,  
  
 <see cref="T:System.Windows.Forms.Splitter" />,  
  
 <see cref="T:System.Windows.Forms.StatusBar" />,  
  
 <see cref="T:System.Windows.Forms.ToolBar" />,  
  
 <see cref="T:System.Windows.Forms.TabPage" />,  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description><description> Fare clic su  
  
 </description><description> Fare clic, doppio clic  
  
 </description></item></list>  
  
 \* Il puntatore del mouse deve essere posizionato su un oggetto figlio (<see cref="T:System.Windows.Forms.TreeNode" /> o <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
 * Il <see cref="T:System.Windows.Forms.TabControl" /> deve avere almeno un <see cref="T:System.Windows.Forms.TabPage" /> nel relativo <see cref="P:System.Windows.Forms.TabControl.TabPages" /> insieme.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'impostazione DPI per un controllo viene modificata a livello di codice dopo la modifica del valore DPI del relativo controllo o form padre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'impostazione DPI per un controllo viene modificata a livello di codice prima di un evento di modifica del valore DPI per il relativo controllo o form padre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene completata un'operazione di trascinamento e rilascio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.DragEventArgs.X%2A> e <xref:System.Windows.Forms.DragEventArgs.Y%2A> le proprietà del <xref:System.Windows.Forms.DragEventArgs> sono nelle coordinate dello schermo, non delle coordinate client. La riga di codice Visual c# seguente converte le proprietà a un client <xref:System.Drawing.Point>.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  Nelle versioni precedenti a [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], se si inserisce un <xref:System.Windows.Forms.UserControl> con <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> gli eventi in un Windows Form e trascinare un elemento nel <xref:System.Windows.Forms.UserControl> in fase di progettazione di `DropDrop` e `DropEnter` gli eventi sono generato. Tuttavia, quando si chiude e riapre la soluzione, il <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> non vengono più generati eventi.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragDrop> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto viene trascinato nei limiti del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DragEnter> evento viene generato quando l'utente trascina il puntatore del mouse sul controllo durante un'operazione di trascinamento e rilascio.  
  
> [!NOTE]
>  Nelle versioni precedenti a [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], se si inserisce un <xref:System.Windows.Forms.UserControl> con <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> gli eventi in un Windows Form e trascinare un elemento nel <xref:System.Windows.Forms.UserControl> in fase di progettazione di `DropDrop` e `DropEnter` gli eventi sono generato. Tuttavia, quando si chiude e riapre la soluzione, il <xref:System.Windows.Forms.Control.DragEnter> e <xref:System.Windows.Forms.Control.DragDrop> non vengono più generati eventi.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo sotto la posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati, o per annullare l'operazione in base al valore del <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e <xref:System.Windows.Forms.Control.GiveFeedback> viene generato l'evento con il nuovo effetto, consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sulla destinazione di trascinamento, l'utente riceva le informazioni più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio il taglio dei dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> viene generato l'evento.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.DragEventArgs.X%2A> e <xref:System.Windows.Forms.DragEventArgs.Y%2A> le proprietà del <xref:System.Windows.Forms.DragEventArgs> sono nelle coordinate dello schermo, non delle coordinate client. La riga di codice Visual c# seguente converte le proprietà a un client <xref:System.Drawing.Point>.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando si avvia l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato più <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. Nell'esempio si presuppone che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per il trascinamento personalizzato e non trascinamento, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> è selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> il gestore eventi per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, quindi il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostato su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, lo stato del trascinamento viene visualizzato nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata all'interno di `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragEnter> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto viene trascinato fuori dai limiti del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DragLeave> evento viene generato quando l'utente trascina il cursore all'esterno del controllo o l'utente annulla l'operazione di trascinamento e rilascio corrente.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo sotto la posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati, o per annullare l'operazione in base al valore del <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e <xref:System.Windows.Forms.Control.GiveFeedback> viene generato l'evento con il nuovo effetto, consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sulla destinazione di trascinamento, l'utente riceva le informazioni più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio il taglio dei dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> viene generato l'evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando si avvia l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato più <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. Nell'esempio si presuppone che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per il trascinamento personalizzato e non trascinamento, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> è selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> il gestore eventi per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, quindi il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostato su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, lo stato del trascinamento viene visualizzato nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata all'interno di `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragLeave> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto viene trascinato sui limiti del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DragOver> evento viene generato quando il cursore del mouse viene spostato all'interno dei limiti del controllo durante un'operazione di trascinamento e rilascio.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo sotto la posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati, o per annullare l'operazione in base al valore del <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> valore è `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e <xref:System.Windows.Forms.Control.GiveFeedback> viene generato l'evento con il nuovo effetto, consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sulla destinazione di trascinamento, l'utente riceva le informazioni più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio il taglio dei dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> viene generato l'evento.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.DragEventArgs.X%2A> e <xref:System.Windows.Forms.DragEventArgs.Y%2A> le proprietà del <xref:System.Windows.Forms.DragEventArgs> sono nelle coordinate dello schermo, non delle coordinate client. La riga di codice c# seguente converte le proprietà a un client <xref:System.Drawing.Point>:  
    >   
    >  Punto clientPoint = targetControl.PointToClient (nuovo punto (Germania. X, Germania. Y));  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando si avvia l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato più <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. Nell'esempio si presuppone che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per il trascinamento personalizzato e non trascinamento, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> è selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> il gestore eventi per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, quindi il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostato su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, lo stato del trascinamento viene visualizzato nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata all'interno di `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.DragOver> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">Bitmap in cui disegnare.</param>
        <param name="targetBounds">Limiti all'interno dei quali viene eseguito il rendering del controllo.</param>
        <summary>Supporta il rendering nella bitmap specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.DrawToBitmap%2A> metodo non è supportato per i controlli ActiveX. È possibile eseguire l'override di <xref:System.Windows.Forms.Control.OnPrint%2A> eventi e, se necessario, fornire la logica di stampa personalizzata.  
  
 Il <xref:System.Windows.Forms.Control.DrawToBitmap%2A> metodo presenta le limitazioni seguenti:  
  
-   Un <xref:System.ArgumentException> potrebbe essere generata per bitmap di grandi dimensioni. La dimensione massima consentita varia in base al computer.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> non supporta il `Ink` controlli per il sistema operativo Windows XP Tablet PC Edition 2005.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> non consente di disegnare un elemento figlio <xref:System.Windows.Forms.TextBox> se il <xref:System.Windows.Forms.Control.Visible%2A> proprietà del <xref:System.Windows.Forms.TextBox> è impostato su `false`.  
  
-   I controlli all'interno dei contenitori vengono visualizzati in ordine inverso.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> non è completamente funzionale per il <xref:System.Windows.Forms.RichTextBox>; solo il bordo di una bitmap viene disegnato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo può rispondere all'interazione dell'utente.</summary>
        <value>
          <see langword="true" /> se il controllo può rispondere all'interazione dell'utente; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà, è possibile abilitare o disabilitare i controlli in fase di esecuzione. Ad esempio, è possibile disabilitare i controlli che non si applicano allo stato corrente dell'applicazione. È anche possibile disabilitare un controllo per l'utilizzo. Ad esempio, un pulsante può essere disabilitato per impedire che l'utente facendo clic. Se un controllo è disabilitato, non può essere selezionato.  
  
> [!IMPORTANT]
>  L'impostazione di <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false` non disabilitare la casella di controllo dell'applicazione o la finestra dell'applicazione di ricevere lo stato attivo.  
  
 Quando un controllo contenitore la proprietà attivata è impostato su `false`, tutti i controlli in esso contenuti sono disabilitati, nonché. Ad esempio, se l'utente fa clic su uno dei controlli contenuti in un disabilitato <xref:System.Windows.Forms.GroupBox> controllo, viene generato alcun evento.  
  
> [!NOTE]
>  Quando un controllo di scorrimento è disabilitato, le barre di scorrimento sono disabilitate. Ad esempio, una casella di testo multiriga disabilitato è in grado di scorrere per visualizzare tutte le righe di testo.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creato un <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Viene quindi impostata la <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene modificato il valore della proprietà <see cref="P:System.Windows.Forms.Control.Enabled" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente vengono utilizzati due <xref:System.Windows.Forms.RadioButton> controlli per illustrare il <xref:System.Windows.Forms.Control.EnabledChanged> evento. Fare clic su un pulsante Modifica il valore della <xref:System.Windows.Forms.Control.Enabled%2A> proprietà del pulsante per `false` e visualizza un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta una specifica operazione asincrona di chiamata, restituito durante la chiamata a <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</param>
        <summary>Recupera il valore restituito dell'operazione asincrona rappresentata dall'oggetto <see cref="T:System.IAsyncResult" /> passato.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> generato dall'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione asincrona non è stato completato, questa funzione si blocca fino a quando non è disponibile il risultato.  
  
> [!NOTE]
>  Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <paramref name="asyncResult" /> non è stato creato da una precedente chiamata del metodo <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> dallo stesso controllo.</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si entra nell'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> vengono eliminati gli eventi per il <xref:System.Windows.Forms.Form> classe. Gli eventi equivalenti nella <xref:System.Windows.Forms.Form> classe sono il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> sono gerarchici e deve essere propagata in su e giù la catena padre finché non viene raggiunto il controllo appropriato. Ad esempio, si supponga un <xref:System.Windows.Forms.Form> con due <xref:System.Windows.Forms.GroupBox> controlli e ogni <xref:System.Windows.Forms.GroupBox> controllo dispone di uno <xref:System.Windows.Forms.TextBox> controllo. Quando il cursore viene spostato da uno <xref:System.Windows.Forms.TextBox> a altro, il <xref:System.Windows.Forms.Control.Leave> evento viene generato per il <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.GroupBox>e <xref:System.Windows.Forms.Control.Enter> evento viene generato per gli altri <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o del sistema operativo di rispondere. Per ulteriori informazioni, vedere il `WM_KILLFOCUS` argomento nella sezione "Riferimenti di Input da tastiera" e la sezione "Messaggio deadlock" del[informazioni sui messaggi e le code di messaggi](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Enter> evento per modificare i colori di primo piano e sfondo di un <xref:System.Windows.Forms.TextBox> in condizioni particolari.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera il form in cui si trova il controllo.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Form" /> in cui si trova il controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo <xref:System.Windows.Forms.Control.Parent%2A> potrebbe non essere lo stesso come valore della proprietà di <xref:System.Windows.Forms.Form> restituito da <xref:System.Windows.Forms.Control.FindForm%2A> metodo. Ad esempio, se un <xref:System.Windows.Forms.RadioButton> controllo è contenuto all'interno di un <xref:System.Windows.Forms.GroupBox> (controllo) e il <xref:System.Windows.Forms.GroupBox> si trova in un <xref:System.Windows.Forms.Form>, il <xref:System.Windows.Forms.RadioButton> del controllo <xref:System.Windows.Forms.Control.Parent%2A> è il <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.GroupBox> controllo <xref:System.Windows.Forms.Control.Parent%2A>è il <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di trovare il modulo che contiene il pulsante specificato.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta lo stato attivo per l'input del controllo.</summary>
        <returns>
          <see langword="true" /> se la richiesta di stato attivo per l'input è stata completata correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Focus%2A> restituisce `true` se il controllo ricevuti correttamente lo stato attivo di input. Il controllo può avere lo stato attivo di input durante la visualizzazione non qualsiasi segnali visivi dello stato attivo. Tramite i controlli non selezionabile elencati di seguito è possibile osservare questo comportamento o nei controlli derivati da essi.  
  
 Un controllo può essere selezionato e ricevere lo stato attivo di input se vengono soddisfatte le condizioni seguenti: il `Selectable` valore <xref:System.Windows.Forms.ControlStyles> è impostato su `true`, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da questi controlli non sono selezionabili.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> è un metodo di basso livello è destinato principalmente agli autori di controlli personalizzati. I programmatori di applicazioni devono invece utilizzare il <xref:System.Windows.Forms.Control.Select%2A> metodo o <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà per i controlli figlio o <xref:System.Windows.Forms.Form.Activate%2A> metodo per i moduli.  
  
   
  
## Examples  
 Esempio di codice seguente imposta lo stato attivo sull'oggetto specificato <xref:System.Windows.Forms.Control>, se può ricevere lo stato attivo.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo ha lo stato attivo per l'input.</summary>
        <value>
          <see langword="true" /> se il controllo ha lo stato attivo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice riportato di seguito viene disabilita un <xref:System.Windows.Forms.MenuItem> se un <xref:System.Windows.Forms.TextBox> non è attivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> con un <xref:System.Windows.Forms.TextBox> denominato `textBox1` e due <xref:System.Windows.Forms.MenuItem> gli oggetti denominati `menuItemEdit` e `menuItemEditInsertCustomerInfo`.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Focused" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Focused" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di carattere del testo visualizzato dal controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Font" /> da applicare al testo visualizzato dal controllo. Il valore predefinito corrisponde al valore della proprietà <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Font%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere il <xref:System.Windows.Forms.AmbientProperties> classe o <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
 Poiché il <xref:System.Drawing.Font> non è modificabile, ovvero non è possibile modificare le relative proprietà, è possibile assegnare solo il <xref:System.Windows.Forms.Control.Font%2A> proprietà di un nuovo <xref:System.Drawing.Font>. Tuttavia, è possibile basare il nuovo tipo di carattere al tipo di carattere esistente.  
  
 [Visual Basic, c#]  
  
 Di seguito è riportato un esempio di come il carattere esistente per renderlo grassetto:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 Consente di visualizzare esempio di codice seguente un <xref:System.Windows.Forms.FontDialog> dell'utente e le modifiche di <xref:System.Drawing.Font> di un <xref:System.Windows.Forms.DateTimePicker> controllo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> con <xref:System.Windows.Forms.Button> e <xref:System.Windows.Forms.DateTimePicker> su di esso.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Font" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Font" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.Font" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Font" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.Font%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.FontChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza del tipo di carattere del controllo.</summary>
        <value>Altezza dell'oggetto <see cref="T:System.Drawing.Font" /> del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.FontHeight%2A> proprietà non deve essere impostata su qualsiasi valore diverso da del controllo <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> valore oppure -1. Impostazione <xref:System.Windows.Forms.Control.FontHeight%2A> su -1 ha l'effetto di cancellare il valore di altezza memorizzato nella cache e il valore viene ricalcolato la volta successiva che fa riferimento la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il colore primo piano del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Color" /> di primo piano del controllo. Il valore predefinito corrisponde al valore della proprietà <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ForeColor%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere il <xref:System.Windows.Forms.AmbientProperties> classe o <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Windows.Forms.Control.BackColor%2A> e <xref:System.Windows.Forms.Control.ForeColor%2A> dei controlli per i colori di sistema predefiniti. Se il controllo dispone di tutti i controlli figlio, in modo ricorsivo il codice chiama se stessa. Questo esempio di codice è necessario disporre una <xref:System.Windows.Forms.Form> con almeno un controllo figlio; tuttavia, un controllo contenitore figlio, ad esempio un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con il proprio elemento figlio controlli sarebbero illustrare meglio la ricorsione.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.ForeColor" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.ForeColor" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.ForeColor" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ForeColor" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.ForeColor%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome *PropertyName* `Changed` che sono generati quando corrispondente *PropertyName* modificato il valore (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Punto di controllo di finestra (<see langword="HWND" />) da cercare.</param>
        <summary>Recupera il controllo che contiene il punto di controllo specificato.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo associato al punto di controllo specificato; restituisce <see langword="null" /> se non viene trovato alcun controllo con il punto di controllo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue la ricerca fino alla catena padre handle di finestra finché trova un handle di cui è associato a un controllo. Questo metodo è più affidabile il <xref:System.Windows.Forms.Control.FromHandle%2A> (metodo), in quanto restituisce correttamente i controlli che dispongono di più di un handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Punto di controllo di finestra (<see langword="HWND" />) da cercare.</param>
        <summary>Restituisce il controllo associato al punto di controllo specificato.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo associato al punto di controllo specificato; restituisce <see langword="null" /> se non viene trovato alcun controllo con il punto di controllo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.FromChildHandle%2A> metodo se si desidera restituire i controlli che dispongono di più di un handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectId">Oggetto <see langword="Int32" /> che identifica l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> da recuperare.</param>
        <summary>Recupera l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> specificato.</summary>
        <returns>Classe <see cref="T:System.Windows.Forms.AccessibleObject" /> specificata.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un valore che indica il comportamento di un controllo quando la relativa proprietà <see cref="P:System.Windows.Forms.Control.AutoSize" /> è abilitata.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.AutoSizeMode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera il controllo figlio in una posizione specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Oggetto <see cref="T:System.Drawing.Point" /> che contiene le coordinate in cui cercare un controllo. Le coordinate sono espresse in relazione all'angolo superiore sinistro dell'area client del controllo.</param>
        <summary>Recupera il controllo figlio posizionato in corrispondenza delle coordinate specificate.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo posizionato nel punto specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non è presente alcun controllo figlio al punto specificato, il <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> restituisce `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo se il controllo restituito non sono un figlio del controllo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" />
      </Parameters>
      <Docs>
        <param name="pt">Oggetto <see cref="T:System.Drawing.Point" /> che contiene le coordinate in cui cercare un controllo. Le coordinate sono espresse in relazione all'angolo superiore sinistro dell'area client del controllo.</param>
        <param name="skipValue">Uno dei valori di <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, che determina se ignorare un determinato tipo di controlli figlio.</param>
        <summary>Recupera il controllo figlio posizionato in corrispondenza delle coordinate specificate, indicando se ignorare un determinato tipo di controlli figlio.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.Control" /> figlio in corrispondenza delle coordinate specificate.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Windows.Forms.ContainerControl" /> successivo nella catena dei controlli padre.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Forms.IContainerControl" /> che rappresenta l'elemento padre dell'oggetto <see cref="T:System.Windows.Forms.Control" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Controllo <see cref="T:System.Windows.Forms.Control" /> con il quale iniziare la ricerca.</param>
        <param name="forward">
          <see langword="true" /> per ricercare in avanti nell'ordine di tabulazione; <see langword="false" /> per ricercare all'indietro.</param>
        <summary>Recupera il controllo successivo in avanti o all'indietro nell'ordine di tabulazione dei controlli figlio.</summary>
        <returns>Controllo <see cref="T:System.Windows.Forms.Control" /> successivo nell'ordine di tabulazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.GetNextControl%2A> metodo è dipendente dall'ordine di tabulazione. Per scorrere tutti i controlli di un form, inclusi i controlli annidati, utilizzare il <xref:System.Windows.Forms.Control.Controls%2A> proprietà. Per ottenere o impostare il controllo attivo di un controllo contenitore, usare il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Area di dimensioni personalizzate di un controllo.</param>
        <summary>Recupera le dimensioni di un'area rettangolare in cui è possibile adattare un controllo.</summary>
        <returns>Coppia ordinata di tipo <see cref="T:System.Drawing.Size" /> che rappresenta la larghezza e l'altezza di un rettangolo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento di <xref:System.Windows.Forms.Control.GetPreferredSize%2A> è diverso dal controllo. Il <xref:System.Windows.Forms.Control.LayoutEngine%2A> potrebbe non essere possibile assegnare le dimensioni restituite al controllo. È possibile restituire una dimensione maggiore rispetto ai vincoli indicati nel `proposedSize` parametro, ma `proposedSize` modo diminuisce il vincolo. Ad esempio, `GetPreferredSize(new Size(100, 0))` non deve essere maggiore di `GetPreferredSize(new Size(200, 0))`. L'eccezione è un `proposedSize` pari a 0 o `Size.Empty`, che sono definiti come non vincolato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">Oggetto <see cref="T:System.Drawing.Rectangle" /> che specifica l'area per la quale recuperare i limiti di visualizzazione.</param>
        <param name="factor">Altezza e larghezza dei limiti del controllo.</param>
        <param name="specified">Uno dei valori di <see cref="T:System.Windows.Forms.BoundsSpecified" /> che specifica i limiti del controllo da usare per definirne le dimensioni e la posizione.</param>
        <summary>Recupera i limiti all'interno dei quali il controllo viene ridimensionato.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta i limiti all'interno dei quali il controllo viene ridimensionato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo helper che viene chiamato da <xref:System.Windows.Forms.Control.ScaleControl%2A> per recuperare i limiti all'interno del quale il controllo viene ridimensionato. È possibile eseguire l'override di questo metodo per riutilizzare il <xref:System.Windows.Forms.Control.ScaleControl%2A> scala logica, ma è necessario specificare i limiti personalizzati. L'implementazione predefinita restituisce i limiti ridimensionati che prendono in considerazione il `specified` limiti, se il controllo è di livello superiore, se il controllo è fissa larghezza o il ridimensionamento automatico e le aree di controllo potrebbe essere il controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> da cui restituire il valore.</param>
        <summary>Recupera il valore del bit di stile specificato per il controllo.</summary>
        <returns>
          <see langword="true" /> se il bit di stile del controllo specificato è impostato su <see langword="true" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flag di bit di stile di controllo vengono utilizzati per classificare il comportamento supportato. Un controllo è possibile attivare uno stile chiamando il <xref:System.Windows.Forms.Control.SetStyle%2A> metodo e passando l'oggetto appropriato <xref:System.Windows.Forms.ControlStyles> bit e il valore booleano su cui impostare il bit. Per determinare il valore assegnato a un oggetto specificato <xref:System.Windows.Forms.ControlStyles> bit, utilizzare il <xref:System.Windows.Forms.Control.GetStyle%2A> (metodo) e passare il <xref:System.Windows.Forms.ControlStyles> membro da valutare.  
  
   
  
## Examples  
 Il codice esempio seguente viene restituito il valore di stile correlati al doppio buffer bit per un <xref:System.Windows.Forms.Form>. Questo esempio viene restituito `true` solo se tutti i bit di stile sono impostati su `true`.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se il controllo è un controllo di primo livello.</summary>
        <returns>
          <see langword="true" /> se il controllo è un controllo di primo livello; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante un'operazione di trascinamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato quando viene avviata un'operazione di trascinamento e rilascio. Con il <xref:System.Windows.Forms.Control.GiveFeedback> evento, l'origine di un evento di trascinamento può modificare l'aspetto del puntatore del mouse per fornire l'utente indicazioni visive durante un'operazione di trascinamento e rilascio.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo sotto la posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati, o per annullare l'operazione in base al valore del <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e <xref:System.Windows.Forms.Control.GiveFeedback> viene generato l'evento con il nuovo effetto, consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sulla destinazione di trascinamento, l'utente riceva le informazioni più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio il taglio dei dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> viene generato l'evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando si avvia l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato più <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. Nell'esempio si presuppone che due file cursore, `3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per il trascinamento personalizzato e non trascinamento, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> è selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> il gestore eventi per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, quindi il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostato su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, lo stato del trascinamento viene visualizzato nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata all'interno di `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.GiveFeedback> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo riceve lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 **Nota** il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> gli eventi sono eventi di attivazione di basso livello che sono associati ai messaggi WM_KILLFOCUS e WM_SETFOCUS di Windows. In genere, il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> vengono utilizzati solo quando si aggiorna <xref:System.Windows.Forms.UICues> o la scrittura di controlli personalizzati. Invece di <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> eventi devono essere utilizzati per tutti i controlli, ad eccezione di <xref:System.Windows.Forms.Form> classe, che utilizza il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Per ulteriori informazioni sul <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> eventi, vedere il [WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)e[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomenti.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o del sistema operativo di rispondere. Per ulteriori informazioni, vedere il [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.GotFocus> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.GotFocus> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il punto di controllo di finestra a cui è associato il controllo.</summary>
        <value>Oggetto <see cref="T:System.IntPtr" /> che contiene il punto di controllo di finestra (<see langword="HWND" />) del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di <xref:System.Windows.Forms.Control.Handle%2A> proprietà è un Windows `HWND`. Non è ancora stato creato l'handle, fare riferimento a questa proprietà si forzerà l'handle deve essere creato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.Control.Handle%2A> proprietà. Per eseguire l'esempio, incollare il codice seguente in un form. Aggiungere due pulsanti denominati `Button1` e `Button2` al form e accertarsi che tutti gli eventi siano connessi ai relativi gestori eventi.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si crea un punto di controllo del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene creato un handle quando il <xref:System.Windows.Forms.Control> viene visualizzato per la prima volta. Ad esempio, se un <xref:System.Windows.Forms.Control> viene creato è <xref:System.Windows.Forms.Control.Visible%2A> impostato su `false`, il <xref:System.Windows.Forms.Control.HandleCreated> non verrà generato l'evento fino al <xref:System.Windows.Forms.Control.Visible%2A> è impostato su `true`.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.HandleCreated> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.HandleCreated> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è in corso l'eliminazione definitiva del punto di controllo del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante il <xref:System.Windows.Forms.Control.HandleDestroyed> evento, il controllo è ancora un controllo di Windows valido e <xref:System.Windows.Forms.Control.Handle%2A> potrà essere ricreato mediante la chiamata di <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.HandleDestroyed> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.HandleDestroyed> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo contiene uno o più controlli figlio.</summary>
        <value>
          <see langword="true" /> se il controllo contiene uno o più controlli figlio; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.Controls%2A> raccolta ha un <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> maggiore di zero, il <xref:System.Windows.Forms.Control.HasChildren%2A> restituirà `true`. L'accesso di <xref:System.Windows.Forms.Control.HasChildren%2A> proprietà non forza la creazione di un <xref:System.Windows.Forms.Control.ControlCollection> se il controllo non ha elementi figlio, quindi facendo riferimento a questa proprietà può determinare un miglioramento delle prestazioni quando si esamina una struttura ad albero dei controlli.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Windows.Forms.Control.BackColor%2A> e <xref:System.Windows.Forms.Control.ForeColor%2A> dei controlli per i colori di sistema predefiniti. Se il controllo dispone di tutti i controlli figlio, in modo ricorsivo il codice chiama se stessa. Questo esempio di codice è necessario disporre una <xref:System.Windows.Forms.Form> con almeno un controllo figlio; tuttavia, un controllo contenitore figlio, ad esempio un <xref:System.Windows.Forms.Panel> o <xref:System.Windows.Forms.GroupBox>, con il proprio elemento figlio controlli sarebbero illustrare meglio la ricorsione.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza del controllo.</summary>
        <value>Altezza del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Top%2A> causa i valori delle proprietà di <xref:System.Windows.Forms.Control.Bottom%2A> valore della proprietà del controllo da modificare.  
  
> [!NOTE]
>  L'altezza minima per il controllo derivato <xref:System.Windows.Forms.Splitter> un pixel. L'altezza predefinita per il <xref:System.Windows.Forms.Splitter> controllo corrisponde a tre pixel. Impostazione dell'altezza del <xref:System.Windows.Forms.Splitter> il controllo a un valore minore di uno verrà reimpostato il valore della proprietà per l'altezza predefinita.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> i controlli in un form e imposta le dimensioni e posizione utilizzando le varie dimensioni correlate e relative proprietà. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e l'altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'utente richiede ulteriori informazioni della Guida relative a un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.HelpRequested> evento viene solitamente generato quando l'utente preme F1 chiave o un pulsante della Guida sensibile al contesto associato viene fatto clic su.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene mostrato come gestire il <xref:System.Windows.Forms.Control.HelpRequested> evento per visualizzare il contenuto della Guida personalizzato in un form contenente quattro campi indirizzo. Il <xref:System.Windows.Forms.Control.HelpRequested> evento viene generato premendo il tasto F1 con lo stato attivo in un campo di indirizzo o il pulsante della Guida sensibile al contesto e facendo clic il cursore della Guida su un campo di indirizzo. Il <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> proprietà è impostata su true per indicare che il `HelpRequested` viene gestito l'evento. Nell'esempio viene inoltre illustrata la memorizzazione di testo della Guida nel <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType> proprietà.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nasconde il controllo all'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nascondere il controllo è equivalente all'impostazione di <xref:System.Windows.Forms.Control.Visible%2A> proprietà `false`. Dopo il <xref:System.Windows.Forms.Control.Hide%2A> metodo viene chiamato, il <xref:System.Windows.Forms.Control.Visible%2A> proprietà restituisce un valore di `false` fino a quando il <xref:System.Windows.Forms.Control.Show%2A> metodo viene chiamato.  
  
   
  
## Examples  
 Esempio di codice seguente nasconde il pulsante se viene premuto il tasto CTRL quando si fa clic sul pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.Button> denominato `button1` su un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità IME (Input Method Editor, editor del metodo di input) del controllo.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.ImeMode" />. Il valore predefinito è <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un IME è un programma che consente agli utenti di immettere simboli, ad esempio caratteri Kanji giapponese e caratteri complessi mediante una tastiera standard. Il <xref:System.Windows.Forms.Control.ImeMode%2A> è in genere impostata su <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> per un <xref:System.Windows.Forms.TextBox> controllo destinato a immettere solo valori numerici. Il <xref:System.Windows.Forms.Control.ImeMode%2A> il valore di proprietà è impostato su <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> per la <xref:System.Windows.Forms.Form> classe.  
  
 La maggior parte delle classi che non supportano gli Input Method Editor direttamente o consentire a un input diretto da un IME, verranno impostato il valore di questa proprietà su <xref:System.Windows.Forms.ImeMode.NoControl>.  
  
> [!IMPORTANT]
>  L'utente può modificare in modo interattivo il <xref:System.Windows.Forms.Control.ImeMode%2A> a meno che non è stato impostato a livello di codice su <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType>. In questo caso, l'utente non sarà in grado di utilizzare IME.  
>   
>  Il <xref:System.Windows.Forms.Control.ImeMode%2A> proprietà viene ignorata in Windows 8 quando è attiva la modalità input globale. Per altre informazioni, vedere [commutatore testo Input modificato da ogni Thread per ciascun utente](http://go.microsoft.com/fwlink/?LinkID=256509).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di enumerazione di <see cref="T:System.Windows.Forms.ImeMode" />.</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità IME di un controllo.</summary>
        <value>Modalità IME del controllo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la proprietà <see cref="P:System.Windows.Forms.Control.ImeMode" /> viene modificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.ImeMode%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 I controlli che non supporta i gestori di metodo di Input non genererà mai questo evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome *PropertyName* `Changed` che sono generati quando corrispondente *PropertyName* modificato il valore (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiamata eseguita dopo l'aggiunta del controllo a un altro contenitore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.InitLayout%2A> metodo viene chiamato immediatamente dopo l'aggiunta di un controllo a un contenitore. Il <xref:System.Windows.Forms.Control.InitLayout%2A> metodo consente a un controllo inizializzare il proprio stato di layout basato sul relativo contenitore. Ad esempio, è generalmente applicato ancoraggio e aggancio al controllo il <xref:System.Windows.Forms.Control.InitLayout%2A> metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.InitLayout" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.InitLayout" /> metodo in modo che il controllo viene visualizzato correttamente.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invalida un'area specifica del controllo determinando l'invio di un messaggio di disegno al controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invalida l'intera superficie del controllo e ne determina il ridisegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno asincrono; per forzare un disegno asincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
   
  
## Examples  
 Il codice esempio seguente viene abilitata all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui è stato eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> viene eseguito l'override di metodo per aggiornare l'immagine ogni volta che viene disegnato il form; in caso contrario l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati nel form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> il metodo di gestione degli eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> possono essere creati dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">
          <see langword="true" /> per invalidare i controlli figlio del controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Invalida un'area specifica del controllo determinando l'invio di un messaggio di disegno al controllo. È possibile che vengano invalidati anche i controlli figlio assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno asincrono; per forzare un disegno asincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area da invalidare.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno asincrono; per forzare un disegno asincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">Oggetto <see cref="T:System.Drawing.Region" /> da invalidare.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno asincrono; per forzare un disegno asincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area da invalidare.</param>
        <param name="invalidateChildren">
          <see langword="true" /> per invalidare i controlli figlio del controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo. È possibile che vengano invalidati anche i controlli figlio assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno asincrono; per forzare un disegno asincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">Oggetto <see cref="T:System.Drawing.Region" /> da invalidare.</param>
        <param name="invalidateChildren">
          <see langword="true" /> per invalidare i controlli figlio del controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Invalida l'area specificata del controllo aggiungendola all'area di aggiornamento del controllo, ovvero l'area che verrà ridisegnata alla successiva operazione di disegno, determinando l'invio di un messaggio di disegno al controllo. È possibile che vengano invalidati anche i controlli figlio assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo non impone un disegno asincrono; per forzare un disegno asincrono, chiamare il <xref:System.Windows.Forms.Control.Update%2A> metodo dopo la chiamata di <xref:System.Windows.Forms.Control.Invalidate%2A> (metodo). Quando questo metodo viene chiamato senza parametri, l'intera area client viene aggiunto all'area di aggiornamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è necessario ridisegnare la visualizzazione di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.Invalidated> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.Invalidated> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un delegato nel thread proprietario del punto di controllo di finestra sottostante del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegato che contiene un metodo da chiamare nel contesto del thread del controllo.</param>
        <summary>Esegue il delegato specificato nel thread proprietario del punto di controllo di finestra sottostante del controllo.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I delegati sono simili ai puntatori a funzione nel linguaggio C o C++. I delegati incapsulare un riferimento a un metodo all'interno di un oggetto delegato. L'oggetto delegato può quindi essere passato al codice che chiama il metodo di cui viene fatto riferimento e il metodo da richiamare in fase di compilazione può essere sconosciuto. A differenza dei puntatori a funzione in C o C++, i delegati sono orientata agli oggetti, indipendenti dai tipi e più sicuro.  
  
 Il <xref:System.Windows.Forms.Control.Invoke%2A> ricerche metodo catena del controllo padre finché trova un controllo o un form che dispone di una finestra gestiscono se l'handle di finestra sottostante del controllo corrente non esiste ancora. Se non viene trovato alcun handle appropriato, il <xref:System.Windows.Forms.Control.Invoke%2A> metodo genererà un'eccezione. Le eccezioni generate durante la chiamata verranno propagate al chiamante.  
  
> [!NOTE]
>  Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
 Il delegato può essere un'istanza di <xref:System.EventHandler>, nel qual caso il parametro mittente conterrà questo controllo e il parametro dell'evento conterrà <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Il delegato può anche essere un'istanza di <xref:System.Windows.Forms.MethodInvoker>, o qualsiasi altro tipo di delegato che accetta un elenco di parametri void. Una chiamata a un <xref:System.EventHandler> o <xref:System.Windows.Forms.MethodInvoker> delegato sarà più veloce rispetto a una chiamata a un altro tipo di delegato.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra i controlli che contengono un delegato. Il delegato incapsula un metodo che aggiunge elementi alla casella di riepilogo e questo metodo viene eseguito nel thread proprietario dell'handle sottostante del form. Quando l'utente fa clic sul pulsante, `Invoke` esegue il delegato.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegato di un metodo che accetta parametri dello stesso tipo e numero contenuti nel parametro <c>args</c>.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Se il metodo non accetta alcun argomento, questo parametro può essere <see langword="null" />.</param>
        <summary>Esegue il delegato specificato nel thread proprietario del punto di controllo di finestra sottostante del controllo con l'elenco di argomenti specificato.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che contiene il valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I delegati sono simili ai puntatori a funzione nel linguaggio C o C++. I delegati incapsulare un riferimento a un metodo all'interno di un oggetto delegato. L'oggetto delegato può quindi essere passato al codice che chiama il metodo di cui viene fatto riferimento e il metodo da richiamare in fase di compilazione può essere sconosciuto. A differenza dei puntatori a funzione in C o C++, i delegati sono orientata agli oggetti, indipendenti dai tipi e più sicuro.  
  
 Se l'handle del controllo non esiste ancora, questo metodo cerca catena padre del controllo finché trova un controllo o un form che dispone di un handle di finestra. Se non viene trovato alcun handle appropriato, questo metodo genera un'eccezione. Le eccezioni generate durante la chiamata verranno propagate al chiamante.  
  
> [!NOTE]
>  Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno dei metodi invoke per effettuare il marshalling della chiamata al thread del controllo.  
  
 Il delegato può essere un'istanza di <xref:System.EventHandler>, nel qual caso il parametro mittente conterrà questo controllo e il parametro dell'evento conterrà <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Il delegato può anche essere un'istanza di <xref:System.Windows.Forms.MethodInvoker>, o qualsiasi altro tipo di delegato che accetta un elenco di parametri void. Una chiamata a un <xref:System.EventHandler> o <xref:System.Windows.Forms.MethodInvoker> delegato sarà più veloce rispetto a una chiamata a un altro tipo di delegato.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra i controlli che contengono un delegato. Il delegato incapsula un metodo che aggiunge elementi alla casella di riepilogo e questo metodo viene eseguito nel thread proprietario dell'handle sottostante del form, usando gli argomenti specificati. Quando l'utente fa clic sul pulsante, `Invoke` esegue il delegato.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento.</param>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.GotFocus" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento.</param>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.LostFocus" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento <see cref="E:System.Windows.Forms.Control.Click" />.</param>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Click" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Paint" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Oggetto <see cref="T:System.Windows.Forms.Control" /> a cui assegnare l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see langword="PaintBackground" /> per il controllo specificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il chiamante deve usare un metodo Invoke per eseguire chiamate di metodo al controllo, in quanto si trova in un thread diverso da quello in cui è stato creato il controllo.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="P:System.Windows.Forms.Control.Handle" /> del controllo è stato creato in un thread diverso da quello del chiamante, ovvero è necessario effettuare chiamate al controllo tramite un metodo Invoke; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlli Windows Form sono associati a un thread specifico e non sono thread-safe. Pertanto, se si chiama un metodo di controllo da un thread differente, è necessario utilizzare uno dei metodi per il marshalling della chiamata al thread appropriato di richiamare il controllo. Questa proprietà può essere utilizzata per determinare se è necessario chiamare un metodo invoke, che può essere utile se non si conosce il thread proprietario di un controllo.  
  
> [!NOTE]
>  Oltre al <xref:System.Windows.Forms.Control.InvokeRequired%2A> proprietà, sono disponibili quattro metodi su un controllo che sono thread-safe chiamare: <xref:System.Windows.Forms.Control.Invoke%2A>,<xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> e <xref:System.Windows.Forms.Control.CreateGraphics%2A> se è già stato creato l'handle per il controllo. La chiamata <xref:System.Windows.Forms.Control.CreateGraphics%2A> prima di aver creato l'handle del controllo in un thread in background può causare valido chiamate tra thread. Per tutte le altre chiamate di metodo, è necessario utilizzare uno di questi metodi invoke quando la chiamata da un thread diverso.  
  
 Se l'handle del controllo non esiste ancora, <xref:System.Windows.Forms.Control.InvokeRequired%2A> Cerca catena padre del controllo finché trova un controllo o un form che dispone di un handle di finestra. Se non viene trovato alcun handle appropriato, il <xref:System.Windows.Forms.Control.InvokeRequired%2A> restituisce `false`.  
  
 Ciò significa che <xref:System.Windows.Forms.Control.InvokeRequired%2A> può restituire `false` se <xref:System.Windows.Forms.Control.Invoke%2A> non è obbligatorio (la chiamata viene eseguita sullo stesso thread), o se è stato creato il controllo in un thread differente, ma non è ancora stato creato l'handle del controllo.  
  
 Nel caso in cui l'handle del controllo non è ancora stato creato, è necessario non è sufficiente chiamare proprietà, metodi o eventi sul controllo. Ciò potrebbe causare l'handle del controllo da creare sul thread in background, il controllo su un thread senza un message pump di isolare e rendendo instabile l'applicazione.  
  
 È possibile evitare questa eventualità anche controllando il valore di <xref:System.Windows.Forms.Control.IsHandleCreated%2A> quando <xref:System.Windows.Forms.Control.InvokeRequired%2A> restituisce `false` in un thread in background. Se non è ancora stato creato l'handle del controllo, è necessario attendere che è stato creato prima di chiamare <xref:System.Windows.Forms.Control.Invoke%2A> o <xref:System.Windows.Forms.Control.BeginInvoke%2A>. In genere, ciò si verifica solo se viene creato un thread in background nel costruttore del form principale per l'applicazione (come in `Application.Run(new MainForm())`, prima che sia stato visualizzato il form o `Application.Run` è stato chiamato.  
  
 Una soluzione è in attesa fino a quando l'handle del modulo è stato creato prima di avviare il thread in background. È possibile imporre la creazione dell'handle chiamando la <xref:System.Windows.Forms.Control.Handle%2A> proprietà o attenderne il <xref:System.Windows.Forms.Form.Load> evento per avviare il processo in background.  
  
 Una soluzione migliore consiste nell'utilizzare il `SynchronizationContext` restituito da <xref:System.Threading.SynchronizationContext> anziché un controllo per il marshalling cross-thread.  
  
> [!NOTE]
>  Potrebbe essere generata un'eccezione se il thread che deve elaborare il messaggio non è più attivo.  
  
 Per ulteriori informazioni sui controlli Windows Form con multithreading, vedere [procedura: utilizzare un Thread in Background per la ricerca di file](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) e [procedura: effettuare chiamate Thread-Safe a controlli Windows Form](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo è visibile per le applicazioni di accessibilità.</summary>
        <value>
          <see langword="true" /> se il controllo è visibile per le applicazioni di accessibilità; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo è stato eliminato.</summary>
        <value>
          <see langword="true" /> se il controllo è stato eliminato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questa proprietà restituisce `true`, il controllo viene eliminato e non può più essere riferimento come un controllo di Windows valido. Anche se l'istanza di un controllo viene eliminata, viene comunque mantenuto in memoria fino a quando non viene rimosso dalla memoria tramite garbage collection. Quando viene eliminato un controllo, è possibile chiamare il relativo <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un punto di controllo è associato al controllo.</summary>
        <value>
          <see langword="true" /> se è stato assegnato un punto di controllo al controllo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.IsHandleCreated%2A> proprietà per determinare se <xref:System.Windows.Forms.Control.CreateHandle%2A> è stato chiamato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da testare.</param>
        <summary>Determina se un carattere è un carattere di input riconosciuto dal controllo.</summary>
        <returns>
          <see langword="true" /> se il carattere deve essere inviato direttamente al controllo e non pre-elaborato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Forms.Control.IsInputChar%2A> metodo per determinare se il carattere specificato da di `charCode` parametro è un carattere di input accettato dal controllo. Questo metodo viene chiamato durante la pre-elaborazione messaggio finestra per determinare se il carattere di input specificato deve essere pre-elaborato o inviato direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputChar%2A> restituisce `true`, il carattere specificato viene inviato direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputChar%2A> restituisce `false`, il carattere specificato viene pre-elaborato e inviato al controllo solo se non è stato utilizzato nella fase di pre-elaborazione. La pre-elaborazione di un carattere include il controllo se il carattere è un tasto di scelta di un altro controllo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno dei valori di <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Determina se il tasto specificato è un normale tasto di input o un tasto speciale che richiede una pre-elaborazione.</summary>
        <returns>
          <see langword="true" /> se il tasto specificato è un normale tasto di input; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo per determinare se la chiave specificata dal `keyData` parametro è un tasto di input accettato dal controllo. Questo metodo viene chiamato durante la pre-elaborazione messaggio finestra per determinare se la chiave di input specificata deve essere pre-elaborata o inviata direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputKey%2A> restituisce `true`, la chiave specificata viene inviata direttamente al controllo. Se <xref:System.Windows.Forms.Control.IsInputKey%2A> restituisce `false`, la chiave specificata è pre-elaborata e inviata al controllo solo se non è stato utilizzato nella fase di pre-elaborazione. Chiavi di pre-elaborati sono includono la scheda, RETURN, ESC e i tasti freccia su, freccia giù, freccia sinistra e freccia destra.  
  
   
  
## Examples  
 Esempio di codice seguente mostra come eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo per un <xref:System.Windows.Forms.TextBox> controllo. In questo esempio, la `TabTextBox` classe gestisce il tasto TAB. Quando il `TabTextBox` ha lo stato attivo e l'utente preme il tasto TAB quattro spazi vengono aggiunti al punto di inserimento di testo, sostituendo il testo selezionato. Per impostazione predefinita, il <xref:System.Windows.Forms.TextBox> controllo gestisce il tasto TAB per spostare lo stato attivo al controllo successivo. In questo caso, la pressione del tasto non raggiunge mai il <xref:System.Windows.Forms.Control.OnKeyDown%2A> override del metodo. Per evitare questo comportamento predefinito, il <xref:System.Windows.Forms.Control.IsInputKey%2A> restituisce l'override del metodo `true` quando l'utente preme il tasto TAB. Per tutti gli altri tasti, il <xref:System.Windows.Forms.Control.IsInputKey%2A> override del metodo restituisce il risultato della chiamata alla versione della classe di base del metodo.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyVal">Membro BLOC MAIUSC, BLOC NUM o BLOC SCORR dell'enumerazione <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Determina se il tasto BLOC MAIUSC, BLOC NUM o BLOC SCORR è attivo.</summary>
        <returns>
          <see langword="true" /> se il tasto o i tasti specificati sono attivi; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Forms.Control.IsKeyLocked%2A> proprietà per determinare se le chiavi BLOC MAIUSC, BLOC NUM o BLOC SCORR, singolarmente o in combinazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare una finestra di messaggio che indica se la chiave specificata (in questo caso il tasto BLOC MAIUSC) è attivo.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="keyVal" /> fa riferimento a un tasto diverso dai tasti BLOC MAIUSC, BLOC NUM o BLOC SCORR.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo è sottoposto a mirroring.</summary>
        <value>
          <see langword="true" /> se il controllo è sottoposto a mirroring; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consente di visualizzare un controllo con mirroring sia layout e il testo da destra a sinistra. Per ulteriori informazioni, vedere [procedura: creare Windows Form con mirroring e controlli](http://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da testare.</param>
        <param name="text">Stringa in cui effettuare la ricerca.</param>
        <summary>Determina se il carattere specificato è il carattere per i tasti di scelta rapida assegnato al controllo nella stringa specificata.</summary>
        <returns>
          <see langword="true" /> se il carattere <paramref name="charCode" /> è il carattere per i tasti di scelta rapida assegnato al controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il carattere mnemonico è il carattere che segue immediatamente la prima istanza di "&" in un <xref:System.String>.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come un'estensione della classe di pulsanti che esegue l'override di <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodo possono presentare un comportamento personalizzato. Nell'esempio viene inoltre illustrato l'utilizzo del <xref:System.Windows.Forms.Control.CanSelect%2A> e <xref:System.Windows.Forms.Control.IsMnemonic%2A> proprietà. Per eseguire questo esempio, incollare il codice seguente dopo una classe del modulo, nello stesso file. Aggiungere un pulsante di tipo `MnemonicButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si preme un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiavi eventi si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Per gestire gli eventi di tastiera solo a livello di modulo e non abilitare altri controlli per la ricezione di eventi della tastiera, impostare il <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> proprietà del modulo <xref:System.Windows.Forms.Control.KeyPress> il metodo di gestione degli eventi per `true`. Alcuni tasti, ad esempio, RETURN, ESC, freccia e TAB vengono gestiti automaticamente dai controlli. Per generare queste chiavi il <xref:System.Windows.Forms.Control.KeyDown> evento, è necessario eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo in ogni controllo nel form. Il codice esegue l'override del <xref:System.Windows.Forms.Control.IsInputKey%2A> sarà necessario determinare se si preme uno dei tasti speciali e restituiscono un valore di `true`. Anziché eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> (metodo), è possibile gestire il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento e set il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà `true`. Per un esempio di codice, vedere il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyDown> evento per determinare il tipo di carattere immesso nel controllo.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si preme un tasto carattere, la barra spaziatrice o il tasto backspace mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiavi eventi si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Il <xref:System.Windows.Forms.Control.KeyPress> evento non viene generato da chiavi di carattere diversi da spazi e backspace; tuttavia, le chiavi non carattere generano il <xref:System.Windows.Forms.Control.KeyDown> e <xref:System.Windows.Forms.Control.KeyUp> eventi.  
  
 Utilizzare il <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> proprietà per campionare le sequenze di tasti in fase di esecuzione e per utilizzare o modificare un sottoinsieme di sequenze di tasti comuni.  
  
 Per gestire gli eventi di tastiera solo a livello di modulo e non abilitare altri controlli per la ricezione di eventi della tastiera, impostare il <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> proprietà del modulo <xref:System.Windows.Forms.Control.KeyPress> il metodo di gestione degli eventi per `true`.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyPress> evento per impedire l'accesso al controllo di caratteri.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si rilascia un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiavi eventi si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Per gestire gli eventi di tastiera solo a livello di modulo e non abilitare altri controlli per la ricezione di eventi della tastiera, impostare il <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> proprietà del modulo <xref:System.Windows.Forms.Control.KeyPress> il metodo di gestione degli eventi per `true`. Alcuni tasti, ad esempio, RETURN, ESC, freccia e TAB vengono gestiti automaticamente dai controlli. Per generare queste chiavi il <xref:System.Windows.Forms.Control.KeyUp> evento, è necessario eseguire l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo in ogni controllo nel form. Il codice esegue l'override di <xref:System.Windows.Forms.Control.IsInputKey%2A> sarà necessario determinare se si preme uno dei tasti speciali e restituiscono un valore di `true`.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyUp> evento con la <xref:System.Windows.Forms.Help> classe per visualizzare una finestra popup della Guida l'utente.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è necessario riposizionare i controlli figlio di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Layout> evento si verifica quando i controlli figlio vengono aggiunti o rimossi, quando i limiti del controllo cambia e quando vengono apportate altre modifiche che possono influenzare il layout del controllo. L'evento layout può essere soppresso mediante il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi. La sospensione del layout consente di eseguire più azioni su un controllo senza dover eseguire un layout per ogni modifica. Ad esempio, se si ridimensionare e spostare un controllo, ogni operazione genererebbe un <xref:System.Windows.Forms.Control.Layout> evento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 I centri di esempio di codice seguente un <xref:System.Windows.Forms.Form> nella schermata di <xref:System.Windows.Forms.Control.Layout> evento. Il modulo centrato durante il ridimensionamento verrà mantenuta. In questo esempio presuppone che sia stato creato un <xref:System.Windows.Forms.Form> controllo.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un'istanza memorizzata nella cache del modulo di layout del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> per il contenuto del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.LayoutEngine%2A> proprietà ottiene il motore di layout per gli elementi figlio del controllo anziché per il controllo stesso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando lo stato attivo per l'input esce dall'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> vengono eliminati gli eventi per il <xref:System.Windows.Forms.Form> classe. Gli eventi equivalenti nella <xref:System.Windows.Forms.Form> classe sono il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Il <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> sono gerarchici e deve essere propagata in su e giù la catena padre finché non viene raggiunto il controllo appropriato. Ad esempio, si supponga un <xref:System.Windows.Forms.Form> con due <xref:System.Windows.Forms.GroupBox> controlli e ogni <xref:System.Windows.Forms.GroupBox> controllo dispone di uno <xref:System.Windows.Forms.TextBox> controllo. Quando il cursore viene spostato da uno <xref:System.Windows.Forms.TextBox> a altro, il <xref:System.Windows.Forms.Control.Leave> evento viene generato per il <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.GroupBox>e <xref:System.Windows.Forms.Control.Enter> evento viene generato per gli altri <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o del sistema operativo di rispondere. Per ulteriori informazioni, vedere il [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Leave> evento per reimpostare un controllo allo stato precedente.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la distanza in pixel tra il bordo sinistro del controllo e il bordo sinistro dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo sinistro del controllo e il bordo sinistro dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Left%2A> è equivalente al valore della proprietà di <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> proprietà del <xref:System.Windows.Forms.Control.Location%2A> valore della proprietà del controllo.  
  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Width%2A> e <xref:System.Windows.Forms.Control.Left%2A> causa i valori delle proprietà di <xref:System.Windows.Forms.Control.Right%2A> valore della proprietà del controllo da modificare.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> i controlli in un form e imposta le dimensioni e posizione utilizzando le varie dimensioni correlate e relative proprietà. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e l'altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le coordinate dell'angolo superiore sinistro del controllo in relazione all'angolo superiore sinistro del relativo contenitore.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Point" /> che rappresenta l'angolo superiore sinistro del controllo in relazione all'angolo superiore sinistro del relativo contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché il <xref:System.Drawing.Point> classe è un tipo valore (`Structure` in Visual Basic `struct` in Visual c#), viene restituito per valore, ovvero l'accesso alla proprietà restituisce una copia del punto superiore sinistro del controllo. In tal caso, regolare il <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> le proprietà del <xref:System.Drawing.Point> restituito da questa non avrà effetto sulle proprietà di <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, o <xref:System.Windows.Forms.Control.Bottom%2A> i valori delle proprietà del controllo. Per modificare queste proprietà, impostare singolarmente ogni valore della proprietà o impostare il <xref:System.Windows.Forms.Control.Location%2A> proprietà con un nuovo <xref:System.Drawing.Point>.  
  
 Se il <xref:System.Windows.Forms.Control> è un <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Location%2A> valore della proprietà rappresenta l'angolo superiore sinistro del <xref:System.Windows.Forms.Form> nelle coordinate dello schermo.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creato un <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Viene quindi impostata la <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene modificato il valore della proprietà <see cref="P:System.Windows.Forms.Control.Location" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Windows.Forms.Control.Location%2A> viene modificata una proprietà di una modifica a livello di codice o tramite interazione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene genera il <xref:System.Windows.Forms.Control.LocationChanged> evento su un <xref:System.Windows.Forms.StatusStrip> quando il form viene ridimensionato.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore logico da convertire.</param>
        <summary>Converte un valore DPI logico nel valore DPI DeviceUnit equivalente.</summary>
        <returns>Valore DeviceUnit risultante.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo perde lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Se il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> è impostato su `true` nel <xref:System.Windows.Forms.Control.Validating> delegato dell'evento, tutti gli eventi che in genere si verificano dopo il <xref:System.Windows.Forms.Control.Validating> evento verranno soppressi.  
  
> [!NOTE]
>  Il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> gli eventi sono eventi di attivazione di basso livello che sono associati ai messaggi WM_KILLFOCUS e WM_SETFOCUS di Windows. In genere, il <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> vengono utilizzati solo quando si aggiorna <xref:System.Windows.Forms.UICues> o la scrittura di controlli personalizzati. Invece di <xref:System.Windows.Forms.Control.Enter> e <xref:System.Windows.Forms.Control.Leave> eventi devono essere utilizzati per tutti i controlli, ad eccezione di <xref:System.Windows.Forms.Form> classe, che utilizza il <xref:System.Windows.Forms.Form.Activated> e <xref:System.Windows.Forms.Form.Deactivate> eventi. Per ulteriori informazioni sul <xref:System.Windows.Forms.Control.GotFocus> e <xref:System.Windows.Forms.Control.LostFocus> eventi, vedere il [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) e [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomenti.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o del sistema operativo di rispondere. Per ulteriori informazioni, vedere il [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come convalidare il testo di TextBox1. Viene inoltre illustrato come la gestione di <xref:System.Windows.Forms.Control.LostFocus> evento impostando il <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> proprietà per il testo in TextBox1. L'esempio di codice viene utilizzato il <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> metodo per verificare la presenza di errori prima di aprire la finestra di dialogo file. Per eseguire questo esempio, incollare il codice seguente in un form contenente un <xref:System.Windows.Forms.TextBox> denominato `TextBox1`, un <xref:System.Windows.Forms.OpenFileDialog> denominato `OpenFileDialog1`, <xref:System.Windows.Forms.Button> denominato `Button1`e un <xref:System.Windows.Forms.ErrorProvider> denominato `ErrorProvider1`. Verificare che tutti gli eventi sono associati i gestori di eventi.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo spazio tra i controlli.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta lo spazio tra i controlli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori predefiniti per i controlli ricevono <xref:System.Windows.Forms.Control.Margin%2A> che ragionevolmente sta per raggiungere linee guida sull'interfaccia utente di Windows. Alcune modifiche potrebbero essere ancora necessari per determinate applicazioni.  
  
> [!NOTE]
>  L'impostazione di <xref:System.Windows.Forms.Control.Margin%2A> proprietà in un controllo ancorato non ha effetto sulla distanza del controllo dai bordi del contenitore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando cambia il margine del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.MarginChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.MarginChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione che rappresenta il limite superiore specificabile dal metodo <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />.</summary>
        <value>Coppia ordinata di tipo <see cref="T:System.Drawing.Size" /> che rappresenta la larghezza e l'altezza di un rettangolo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione che rappresenta il limite inferiore specificabile dal metodo <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />.</summary>
        <value>Coppia ordinata di tipo <see cref="T:System.Drawing.Size" /> che rappresenta la larghezza e l'altezza di un rettangolo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica quale tasto di modifica (MAIUSC, CTRL e ALT) è premuto.</summary>
        <value>Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.Keys" />. Il valore predefinito è <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio di codice seguente consente di nascondere un pulsante quando viene premuto il tasto CTRL mentre si fa clic sul pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.Button> denominato `button1` su un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica quale pulsante del mouse è premuto.</summary>
        <value>Combinazione bit per bit dei valori di enumerazione di <see cref="T:System.Windows.Forms.MouseButtons" />. Il valore predefinito è <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, e <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> membri. Per eseguire l'esempio, incollare il codice seguente in un form denominato Form1 contenente diversi controlli. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, e <xref:System.Windows.Forms.Control.MouseUp> gli eventi siano connessi ai gestori di eventi definiti nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo perde il mouse capture.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In rari casi potrebbe essere necessario rilevare input imprevisto. Ad esempio, considerare gli scenari seguenti.  
  
-   Durante un'operazione del mouse, l'utente apre il menu Start premendo il tasto Windows o CTRL + ESC.  
  
-   Durante un'operazione del mouse, l'utente passa a un altro programma premendo ALT + TAB.  
  
-   Durante un'operazione del mouse, un altro programma visualizza una finestra o una finestra di messaggio che riceve lo stato attivo dall'applicazione corrente.  
  
 Possono includere le operazioni del mouse facendo clic e tenere il mouse su un form o un controllo o esecuzione di un'operazione di trascinamento. Se è necessario rilevare quando un form o un controllo perde lo stato mouse capture per questi e scenari imprevisti correlati, è possibile utilizzare il <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento per un <xref:System.Windows.Forms.Button> controllo.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Per testare questo esempio, eseguirlo nel debugger premendo F5. Aprire il **Output** finestra in Visual Studio in modo da visualizzare quando vengono generati eventi. Fare clic su di <xref:System.Windows.Forms.Button> e notare l'output seguente.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 A questo punto, fare clic e tenere premuto il pulsante sinistro del mouse di <xref:System.Windows.Forms.Button> controllo. Mentre si fa clic del mouse, premere ALT + TAB per passare a un altro programma. Si noti che il <xref:System.Windows.Forms.Control.MouseCaptureChanged> evento consente di gestire potenzialmente questo scenario. A seconda delle azioni, il <xref:System.Windows.Forms.Control.MouseUp> evento potrebbe non essere generato. È anche possibile provare il test con il tasto Windows o CTRL + ESC.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa clic con il mouse sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pressione di un pulsante del mouse quando il cursore si trova su un controllo in genere genera una serie di eventi dal controllo seguenti:  
  
1.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
2.  Evento <xref:System.Windows.Forms.Control.Click>.  
  
3.  Evento <xref:System.Windows.Forms.Control.MouseClick>.  
  
4.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
 A questo scopo, i vari eventi non possono essere disabilitati nella classe del controllo.  
  
 Due singoli clic che si verificano nel tempo, come determinato dalle impostazioni del mouse del sistema operativo dell'utente, generano un <xref:System.Windows.Forms.Control.MouseDoubleClick> evento anziché il secondo <xref:System.Windows.Forms.Control.MouseClick> evento.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click> gli eventi sono eventi in modo logico di livello superiore di un controllo. Vengono spesso generati da altre azioni, ad esempio premendo il tasto INVIO quando il controllo ha lo stato attivo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.MouseClick> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.MouseClick> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si fa doppio clic con il mouse sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.MouseDoubleClick> evento si verifica quando l'utente preme un pulsante del mouse due volte in rapida successione, mentre il cursore si trova sul controllo. L'intervallo di tempo che separa i due clic singolo da un doppio clic è determinato dalle impostazioni del mouse del sistema operativo dell'utente.  
  
 La seguente serie di eventi viene generata dal controllo quando si verifica tale azione utente:  
  
1.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
2.  Evento <xref:System.Windows.Forms.Control.Click>.  
  
3.  Evento <xref:System.Windows.Forms.Control.MouseClick>.  
  
4.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
5.  Evento <xref:System.Windows.Forms.Control.MouseDown>.  
  
6.  Evento <xref:System.Windows.Forms.Control.DoubleClick>.  
  
7.  Evento <xref:System.Windows.Forms.Control.MouseDoubleClick>.  
  
8.  Evento <xref:System.Windows.Forms.Control.MouseUp>.  
  
 A questo scopo, i vari eventi non possono essere disabilitati nella classe del controllo.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick> gli eventi sono eventi in modo logico di livello superiore di un controllo. Essi possono essere generati da altre azioni utente, ad esempio le combinazioni di tasti di scelta rapida.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.MouseDoubleClick> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.MouseDoubleClick> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse si trova sul controllo mentre viene premuto un pulsante del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse entra nell'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse si sofferma sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tipico utilizzo di <xref:System.Windows.Forms.Control.MouseHover> consiste nel visualizzare una descrizione comandi quando il puntatore del mouse si sofferma su un controllo all'interno di una determinata area intorno al controllo (il "area rettangolare"). Necessario generare questo evento viene specificato in millisecondi per il <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> proprietà.  
  
 Il <xref:System.Windows.Forms.Control.MouseHover> evento viene definito e rilevato in relazione la <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> e <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> proprietà.  
  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse esce dall'area del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse viene spostato sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzi tipici di <xref:System.Windows.Forms.Control.MouseMove> sono per modificare il colore del controllo o per disegnare un rettangolo generato intorno al controllo.  
  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la posizione del cursore del mouse in base alle coordinate dello schermo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Point" /> che contiene le coordinate del cursore del mouse in relazione all'angolo superiore sinistro dello schermo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.MousePosition%2A> proprietà restituisce un <xref:System.Drawing.Point> che rappresenta la posizione del cursore del mouse quando la proprietà è stato fatto riferimento. Le coordinate indicano la posizione sullo schermo, non rispetto al controllo e vengono restituite indipendentemente dal fatto che il cursore viene posizionato sul controllo. Le coordinate dell'angolo superiore sinistro dello schermo sono 0,0.  
  
 Il <xref:System.Windows.Forms.Control.MousePosition%2A> è identica al <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 Il codice seguente viene inserita una <xref:System.Windows.Forms.TreeNode> etichetta in uno stato modificabile quando l'utente preme ALT + E, quando il cursore del mouse è posizionato il nodo dell'albero. Dopo l'utente modifica l'etichetta, le etichette non sarà più possibile modificarla fino a quando la combinazione di tasti ALT + E viene premuta nuovamente. In questo esempio si suppone una <xref:System.Windows.Forms.TreeView> su un <xref:System.Windows.Forms.Form>. Visualizzazione albero deve inoltre essere presente almeno un <xref:System.Windows.Forms.TreeNode> nel relativo <xref:System.Windows.Forms.TreeView.Nodes%2A> insieme.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il puntatore del mouse si trova sul controllo mentre viene rilasciato un pulsante del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  I seguenti eventi non vengono generati per il <xref:System.Windows.Forms.TabControl> classe a meno che non sia presente almeno un <xref:System.Windows.Forms.TabPage> nel <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> raccolta: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> e <xref:System.Windows.Forms.Control.MouseMove>. Se è presente almeno un <xref:System.Windows.Forms.TabPage> nella raccolta, e l'utente interagisce con l'intestazione del controllo struttura a schede (in cui il <xref:System.Windows.Forms.TabPage> i nomi visualizzati), il <xref:System.Windows.Forms.TabControl> genera l'evento appropriato. Tuttavia, se l'interazione dell'utente è all'interno dell'area client della scheda, il <xref:System.Windows.Forms.TabPage> genera l'evento appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando si sposta la rotellina del mouse mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si gestisce il <xref:System.Windows.Forms.Control.MouseWheel> eventi è importante seguire gli standard di interfaccia utente associati con la rotellina del mouse. Il <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> valore della proprietà indica la quantità la rotellina del mouse è stata spostata. È necessario scorrere l'interfaccia utente quando il delta accumulato è più o meno 120. L'interfaccia utente è necessario scorrere il numero di righe logiche restituite dal <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> proprietà per ciascun valore delta raggiunto. È possibile anche scorrimento inferiori che incrementi di 120 unità, ma il rapporto deve rimanere costante, ovvero <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> righe scorse per 120 unità delta di spostamento della rotellina.  
  
 Per ulteriori informazioni sulla gestione di messaggi rotellina del mouse, vedere il[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)argomento.  
  
 Gli eventi del mouse si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di eventi del mouse differenti per disegnare il tracciato del mouse su un <xref:System.Windows.Forms.Panel>. Viene aggiunto un segmento di linea per il <xref:System.Drawing.Drawing2D.GraphicsPath> per ogni <xref:System.Windows.Forms.Control.MouseMove> e <xref:System.Windows.Forms.Control.MouseDown> eventi che si verificano. Per aggiornare la grafica, il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo viene chiamato per il <xref:System.Windows.Forms.Panel> in ogni `MouseDown` e `MouseUp` evento. Inoltre, il percorso grafico è necessario scorrere verso l'alto o verso il basso quando il <xref:System.Windows.Forms.Control.MouseWheel> si verifica l'evento. Ulteriori eventi del mouse, ad esempio <xref:System.Windows.Forms.Control.MouseHover>, vengono identificati anche sullo schermo. Viene visualizzato anche sullo schermo è ulteriori informazioni sul mouse dalla <xref:System.Windows.Forms.SystemInformation> classe.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo viene spostato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Move> evento per visualizzare la posizione del form in coordinate dello schermo nella barra del titolo del form.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del controllo.</summary>
        <value>Nome del controllo. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Name%2A> proprietà può essere utilizzata in fase di esecuzione per valutare l'oggetto per nome anziché tipo e il nome a livello di codice. Poiché il <xref:System.Windows.Forms.Control.Name%2A> proprietà restituisce un <xref:System.String> tipo, possono essere valutata in istruzioni case stile logiche (`Select` istruzione in Visual Basic `switch` istruzione in Visual c# e [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Windows.Forms.Control.Name%2A> di un controllo in un <xref:System.Windows.Forms.MessageBox> quando il controllo viene aggiunto o rimosso da un modulo.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'area da invalidare.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Invalidated" /> con un'area specificata del controllo da invalidare.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.UICuesEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ChangeUICues" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnChangeUICues%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'override di <xref:System.Windows.Forms.Control.OnClick%2A> metodo in una classe derivata. Per eseguire l'esempio, incollare il codice seguente dopo una classe del modulo, nello stesso file. Aggiungere una casella di testo di tipo `SingleClickTextBox` al form.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 Esempio di codice seguente viene illustrato uno dei numerosi impieghi del <xref:System.Windows.Forms.Control.Click> evento e gestore eventi.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.ControlEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ControlAdded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamato quando un controllo figlio viene aggiunto al controllo.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnControlAdded%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlAdded> per aggiungere un controllo a un form e visualizza il nome del controllo aggiunto in un <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.ControlEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ControlRemoved" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamato quando un controllo figlio viene rimosso dal controllo.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnControlRemoved%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare <xref:System.Windows.Forms.Control.ControlRemoved> per rimuovere un controllo da un form e visualizza il nome del controllo rimosso in una <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera il metodo <see cref="M:System.Windows.Forms.Control.CreateControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.OnCreateControl%2A> metodo viene chiamato quando il controllo viene creato.  
  
 Il metodo <xref:System.Windows.Forms.Control.OnCreateControl%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnCursorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DockChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDockChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDoubleClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.DoubleClick> evento di un <xref:System.Windows.Forms.ListBox> per caricare i file di testo elencati nel <xref:System.Windows.Forms.ListBox> in un <xref:System.Windows.Forms.TextBox> controllo.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragDrop%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragEnter%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragLeave%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnDragOver%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Enter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnEnter%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Enter> evento per modificare i colori di primo piano e sfondo di un <xref:System.Windows.Forms.TextBox> in condizioni particolari.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnFontChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">Oggetto <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.GiveFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnGotFocus%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnHandleCreated%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">Oggetto <see cref="T:System.Windows.Forms.HelpEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.HelpRequested" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnHelpRequested%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ImeModeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.InvalidateEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Invalidated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnInvalidated%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.KeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnKeyDown%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyDown> evento per determinare il tipo di carattere immesso nel controllo.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.KeyPress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnKeyPress%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyPress> evento per impedire l'accesso al controllo di caratteri.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.KeyUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnKeyUp%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.KeyUp> evento con la <xref:System.Windows.Forms.Help> classe per visualizzare una finestra popup della Guida l'utente.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Oggetto <see cref="T:System.Windows.Forms.LayoutEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLayout%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento e per l'ancoraggio tipico e funzioni di ancoraggio. Le classi derivate devono eseguire l'override di questo metodo per eseguire qualsiasi logica di layout personalizzato.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Leave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLeave%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Leave> evento per reimpostare un controllo allo stato precedente.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLocationChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.LostFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnLostFocus%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MarginChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMarginChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseDown%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseEnter%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseHover" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseHover%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come eseguire l'override di <xref:System.Windows.Forms.Control.OnMouseHover%2A> e <xref:System.Windows.Forms.Control.OnMouseMove%2A> metodi in una classe derivata. Per eseguire l'esempio, incollare il codice seguente in un nuovo form e incollare questa classe, che costituiscono lo stesso file, dopo il modulo. Aggiungere un pulsante di tipo `FunButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseLeave%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseMove" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseMove%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come eseguire l'override di <xref:System.Windows.Forms.Control.OnMouseHover%2A> e <xref:System.Windows.Forms.Control.OnMouseMove%2A> metodi in una classe derivata. Per eseguire l'esempio, incollare il codice seguente in un nuovo form e incollare questa classe, che costituiscono lo stesso file, dopo il modulo. Aggiungere un pulsante di tipo `FunButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseUp%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.MouseWheel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMouseWheel%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Move" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnMove%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Move> evento per visualizzare la posizione del form in coordinate dello schermo nella barra del titolo del form.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> che rappresenta il messaggio di Windows.</param>
        <summary>Notifica al controllo i messaggi di Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> metodo viene chiamato se il controllo `EnableNotifyMessage` bit di stile è impostato in <xref:System.Windows.Forms.ControlStyles>. Il `EnableNotifyMessage` stile <xref:System.Windows.Forms.ControlStyles> consente di ricevere una notifica quando il controllo di <xref:System.Windows.Forms.Control.WndProc%2A> metodo riceve un messaggio di Windows. Con questo metodo, controlli semi-trusted possono rimanere in ascolto dei messaggi di Windows senza dover modificare il messaggio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> in una classe derivata, chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> (metodo) non è necessaria perché non vi è Nessuna implementazione iniziale.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.PaddingChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnPaint%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente consente all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui viene eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> viene eseguito l'override di metodo per aggiornare l'immagine ogni volta che viene disegnato il form; in caso contrario l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati nel form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> il metodo di gestione degli eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> possono essere creati dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene informazioni sul controllo da disegnare.</param>
        <summary>Disegna lo sfondo del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.OnPaintBackground%2A> le richieste di cancellazione metodo consente alle classi derivate di gestire in background di Windows.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le classi che ereditano devono eseguire l'override di questo metodo per gestire la richiesta di cancellazione in background da windows. Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> in una classe derivata non è necessario chiamare la classe base <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackColor" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.BindingContext" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ParentChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Enabled" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.FontChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Font" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.ForeColor" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.RightToLeft" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Visible" /> del contenitore del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `UserPaint` bit del <xref:System.Windows.Forms.ControlStyles> è impostato, è possibile eseguire l'override <xref:System.Windows.Forms.Control.OnPrint%2A> per eseguire un disegno a più livelli. Per altre informazioni, vedere <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="e" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">Oggetto <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver iniziato il trascinamento, questo metodo viene chiamato più volte dal [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] fino a quando l'operazione di trascinamento viene annullata o completata.  
  
> [!NOTE]
>  Eseguire l'override di questo metodo se si desidera modificare il punto in cui il trascinamento viene annullato o in cui viene eseguito un rilascio.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.RegionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Windows.Forms.Control.OnRegionChanged%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Resize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnResize%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento. Il <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> metodo può essere chiamato durante la costruzione, pertanto se si esegue l'override <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> può essere chiamato prima della chiamata al costruttore del controllo.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnSizeChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.StyleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnStyleChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.TabIndexChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.TabStopChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnTextChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Validated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnValidated%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.ComponentModel.CancelEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.Validating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnValidating%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> metodo consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
   
  
## Examples  
 Esempio di codice seguente è un metodo di generazione di eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome `On` *PropertyName* `Changed` che generano corrispondente *PropertyName* `Changed` eventi quando il *PropertyName* modificato il valore (*PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> derivata la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una classe che deriva dalla <xref:System.Windows.Forms.TextBox> classe.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> in una classe derivata, verificare di chiamare il metodo <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> della classe di base in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la spaziatura interna del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Padding" /> che rappresenta le caratteristiche di spaziatura interna del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i contenitori, ad esempio <xref:System.Windows.Forms.GroupBox> e <xref:System.Windows.Forms.TabControl>, <xref:System.Windows.Forms.Control.Padding%2A> proprietà ottiene o imposta le rispettive <xref:System.Windows.Forms.Control.DisplayRectangle%2A> proprietà. Il <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType> proprietà è uguale al relativo <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType> proprietà.  
  
 I valori predefiniti per i controlli ricevono <xref:System.Windows.Forms.Control.Padding%2A> che ragionevolmente sta per raggiungere linee guida sull'interfaccia utente di Windows. Alcune modifiche potrebbero essere ancora necessari per determinate applicazioni.  
  
 Tutti i controlli che implementano <xref:System.Windows.Forms.Control.GetPreferredSize%2A> sono aumentati quantità in <xref:System.Windows.Forms.Control.Padding%2A> quando <xref:System.Windows.Forms.Control.AutoSize%2A> è `true`.  
  
 Non utilizzano i seguenti controlli <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   I controlli che non implementano <xref:System.Windows.Forms.Control.AutoSize%2A> tramite <xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   Controlli personalizzati che ereditano direttamente dalla <xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la spaziatura interna del controllo cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.PaddingChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.PaddingChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo viene ridisegnato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Paint> evento viene generato quando il controllo viene ridisegnato. Passa a un'istanza di <xref:System.Windows.Forms.PaintEventArgs> per il metodo che gestisce il <xref:System.Windows.Forms.Control.Paint> evento.  
  
 Quando si crea un nuovo controllo personalizzato o un controllo ereditato con un aspetto visivo diverso, è necessario fornire il codice per il rendering del controllo eseguendo l'override di <xref:System.Windows.Forms.Control.OnPaint%2A> metodo. Per ulteriori informazioni, vedere [l'override del metodo OnPaint](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) e [il disegno del controllo personalizzato e il Rendering](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md).  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.PictureBox> controllo sulla forma e viene utilizzato il <xref:System.Windows.Forms.Control.Paint> evento per tracciare il.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contenitore padre del controllo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo padre o contenitore del controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione di <xref:System.Windows.Forms.Control.Parent%2A> valore della proprietà da `null` rimuove il controllo dal <xref:System.Windows.Forms.Control.ControlCollection> del relativo controllo padre corrente.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Parent%2A> proprietà e <xref:System.Windows.Forms.Control.FindForm%2A> metodo per impostare le proprietà del controllo padre di un pulsante e il relativo modulo.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre ottenere il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Parent" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Parent%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina l'applicazione della logica di layout del controllo ai controlli figlio.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina l'applicazione della logica di layout del controllo a tutti i rispettivi controlli figlio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo è stato chiamato prima di chiamare il <xref:System.Windows.Forms.Control.PerformLayout%2A> (metodo), il <xref:System.Windows.Forms.Control.Layout> evento viene eliminato.  
  
 Il <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> e <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> le proprietà del <xref:System.Windows.Forms.LayoutEventArgs> creato vengono impostate su `null` se viene fornito alcun valore quando il <xref:System.Windows.Forms.Control.PerformLayout%2A> metodo è stato chiamato.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come utilizzare il metodo <xref:System.Windows.Forms.Control.PerformLayout%2A>. Vengono inoltre illustrati i modi in cui il <xref:System.Windows.Forms.Control.Layout> viene generato l'evento. In questo esempio, il `Click` gestore eventi per `Button1` chiama in modo esplicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. Il `Click` gestore eventi per `Button2` chiama in modo implicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> viene inoltre chiamato quando viene caricato il modulo. `Button3` Restituisce il controllo lo stato quando caricato. In ogni caso, il <xref:System.Windows.Forms.Control.Layout> viene generato l'evento.  
  
 Questo è un esempio completo. Per eseguire l'esempio, incollare il codice seguente in un form vuoto.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo modificato più di recente.</param>
        <param name="affectedProperty">Nome della proprietà del controllo modificata più di recente.</param>
        <summary>Determina l'applicazione della logica di layout del controllo a tutti i rispettivi controlli figlio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo è stato chiamato prima di chiamare il <xref:System.Windows.Forms.Control.PerformLayout%2A> (metodo), il <xref:System.Windows.Forms.Control.Layout> evento viene eliminato.  
  
 Il `affectedControl` e `affectedProperty` parametri possono essere entrambe impostati su `null`. Determina il <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> e <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> le proprietà del <xref:System.Windows.Forms.LayoutEventArgs> creato per essere impostato su `null`.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come utilizzare il metodo <xref:System.Windows.Forms.Control.PerformLayout%2A>. Vengono inoltre illustrati i modi in cui il <xref:System.Windows.Forms.Control.Layout> viene generato l'evento. In questo esempio, il `Click` gestore eventi per `Button1` chiama in modo esplicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. Il `Click` gestore eventi per `Button2` chiama in modo implicito <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> viene inoltre chiamato quando viene caricato il modulo. `Button3` Restituisce il controllo lo stato quando caricato. In ogni caso, il <xref:System.Windows.Forms.Control.Layout> viene generato l'evento.  
  
 Questo è un esempio completo. Per eseguire l'esempio, incollare il codice seguente in un form vuoto.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Oggetto <see cref="T:System.Drawing.Point" /> delle coordinate dello schermo da convertire.</param>
        <summary>Calcola la posizione del punto dello schermo specificato nelle coordinate client.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Point" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Point" /> convertito, <paramref name="p" />, nelle coordinate client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice esempio seguente viene abilitata all'utente di trascinare un'immagine o un file di immagine nel form e fare in modo da visualizzare nel punto in cui è stato eliminato. Il <xref:System.Windows.Forms.Control.OnPaint%2A> viene eseguito l'override di metodo per aggiornare l'immagine ogni volta che viene disegnato il form; in caso contrario l'immagine verrà mantenuta solo fino al successivo ridisegno. Il <xref:System.Windows.Forms.Control.DragEnter> metodo di gestione di eventi determina il tipo di dati trascinati nel form e fornisce le informazioni appropriate. Il <xref:System.Windows.Forms.Control.DragDrop> il metodo di gestione degli eventi visualizza l'immagine del form, se un <xref:System.Drawing.Image> possono essere creati dai dati. Poiché il <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> sono coordinate dello schermo, nell'esempio viene utilizzato il <xref:System.Windows.Forms.Control.PointToClient%2A> metodo per convertirli in coordinate client.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Oggetto <see cref="T:System.Drawing.Point" /> delle coordinate client da convertire.</param>
        <summary>Calcola la posizione del punto client specificato nelle coordinate dello schermo.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Point" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Point" /> convertito, <paramref name="p" />, nelle coordinate dello schermo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, e <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> membri. Per eseguire l'esempio, incollare il codice seguente in un form denominato Form1 contenente diversi controlli. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, e <xref:System.Windows.Forms.Control.MouseUp> gli eventi siano connessi ai gestori di eventi definiti nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni di un'area rettangolare in cui è possibile inserire un controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> contenente l'altezza e la larghezza, espresse in pixel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Windows.Forms.Message" /> che rappresenta il messaggio da elaborare.</param>
        <summary>Consente la pre-elaborazione dei messaggi di tastiera o di input all'interno del ciclo di messaggi prima che vengano inviati.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.PreProcessControlState" />, a seconda se il metodo <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> è <see langword="true" /> o <see langword="false" /> e se i metodi <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> o <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> sono <see langword="true" /> o <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio da elaborare. I valori possibili sono WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR e WM_SYSCHAR.</param>
        <summary>Consente la pre-elaborazione dei messaggi di tastiera o di input all'interno del ciclo di messaggi prima che vengano inviati.</summary>
        <returns>
          <see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> viene chiamato dal ciclo di messaggi dell'applicazione da pre-elaborare i messaggi di input prima che vengano inviati. I valori possibili per il `msg` parametro sono WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR e WM_SYSCHAR.  
  
 Quando si esegue l'override <xref:System.Windows.Forms.Control.PreProcessMessage%2A>, deve restituire un controllo `true` per indicare che è stato elaborato il messaggio. Per i messaggi non elaborati dal controllo, il risultato di `base.PreProcessMessage` deve essere restituito. I controlli in genere sostituiranno uno dei metodi più specializzati, ad esempio <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>, o <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> anziché eseguire l'override <xref:System.Windows.Forms.Control.PreProcessMessage%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per il chiamante immediato chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica prima dell'evento <see cref="E:System.Windows.Forms.Control.KeyDown" /> quando viene premuto un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni tasti, ad esempio la scheda, RETURN, ESC e tasti di direzione, in genere vengono ignorati da alcuni controlli perché non sono considerati inpue pressioni dei tasti. Ad esempio, per impostazione predefinita, un <xref:System.Windows.Controls.Button> controllo Ignora i tasti di direzione. Premere i tasti di direzione in genere determina lo stato attivo spostare il controllo precedente o successivo. I tasti di direzione sono considerati tasti di navigazione e premendo queste chiavi non è in genere aumentare di <xref:System.Windows.Forms.Control.KeyDown> evento per un <xref:System.Windows.Controls.Button>. Tuttavia, premere la freccia di chiavi per un <xref:System.Windows.Controls.Button> generare la <xref:System.Windows.Forms.Control.PreviewKeyDown> evento. Gestendo il <xref:System.Windows.Forms.Control.PreviewKeyDown> evento per un <xref:System.Windows.Controls.Button> e impostando il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà `true`, è possibile generare il <xref:System.Windows.Forms.Control.KeyDown> evento quando vengono premuti i tasti di direzione. Tuttavia, se si gestiscono i tasti di direzione, lo stato attivo non è più passerà al controllo precedente o successivo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra un <xref:System.Windows.Forms.Button> che include un <xref:System.Windows.Forms.ContextMenuStrip>. Quando il <xref:System.Windows.Forms.Button> ha lo stato attivo e si premono i tasti freccia su o freccia giù, il <xref:System.Windows.Forms.ContextMenuStrip> viene visualizzato. Il <xref:System.Windows.Forms.Control.PreviewKeyDown> gestore rileva quando vengono premuti i tasti freccia su o freccia giù e imposta il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà `true`. Questo genera il <xref:System.Windows.Forms.Control.KeyDown> evento in modo che sia possibile visualizzare il <xref:System.Windows.Forms.ContextMenuStrip>. Non è opportuno inserire qualsiasi logica <xref:System.Windows.Forms.Control.PreviewKeyDown> gestore dell'evento, se non per impostare il <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> proprietà. In alternativa, è necessario inserire la logica nel <xref:System.Windows.Forms.Control.KeyDown> gestore dell'evento.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <param name="keyData">Uno dei valori di <see cref="T:System.Windows.Forms.Keys" /> che rappresenta il tasto da elaborare.</param>
        <summary>Elabora un tasto di comando.</summary>
        <returns>
          <see langword="true" /> se il carattere è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato durante la pre-elaborazione di messaggi per gestire le chiavi di comando. Tasti di comando sono chiavi che hanno la precedenza sui tasti di input regolare. Tasti di scelta rapida e menu di scelta rapida sono esempi di tasti di comando. Il metodo deve restituire `true` per indicare che è stato elaborato il tasto di comando o `false` per indicare che la chiave non è un tasto di comando. Questo metodo viene chiamato solo quando il controllo è ospitato in un'applicazione Windows Forms o come un controllo ActiveX.  
  
 Il <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> metodo determina innanzitutto se il controllo ha un <xref:System.Windows.Forms.ContextMenu>, garantendo in tal caso, il <xref:System.Windows.Forms.ContextMenu> per elaborare il tasto di comando. Se il tasto di comando non è un collegamento di menu e il controllo ha un padre, la chiave viene passata al padre <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> metodo. L'effetto finale è comando chiavi vengono "trasmessi" la gerarchia dei controlli. Oltre alla chiave, l'utente ha premuto, i dati della chiave indicano inoltre che, se presente, in sono stati premuti i tasti di modifica alla stessa ora la chiave. Tasti di modifica sono i tasti MAIUSC, CTRL e ALT.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato e le classi che ereditano da chiamare questo metodo. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe base <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da elaborare.</param>
        <summary>Elabora un carattere della finestra di dialogo.</summary>
        <returns>
          <see langword="true" /> se il carattere è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato durante la pre-elaborazione per gestire i caratteri di finestra di dialogo, ad esempio i tasti di scelta di controllo dei messaggi. Questo metodo viene chiamato solo se il <xref:System.Windows.Forms.Control.IsInputChar%2A> metodo indica che il controllo non elabora il carattere. Il <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> metodo invia semplicemente il carattere dell'elemento padre <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> metodo oppure restituisce `false` se il controllo non ha elementi padre. La <xref:System.Windows.Forms.Form> classe esegue l'override di questo metodo per eseguire operazioni di elaborazione effettivo di caratteri di finestra di dialogo. Questo metodo viene chiamato solo quando il controllo è ospitato in un'applicazione Windows Forms o come un controllo ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che è stato elaborato il carattere. Per i caratteri che non vengono elaborati dal controllo, il risultato della chiamata della classe base <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Uno dei valori di <see cref="T:System.Windows.Forms.Keys" /> che rappresenta il tasto da elaborare.</param>
        <summary>Elabora un tasto della finestra di dialogo.</summary>
        <returns>
          <see langword="true" /> se il tasto è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato durante la pre-elaborazione di messaggi per gestire i caratteri di finestra di dialogo, ad esempio, RETURN, ESC, tasti freccia e TAB. Questo metodo viene chiamato solo se il <xref:System.Windows.Forms.Control.IsInputKey%2A> metodo indica che il controllo non elabora il tasto. Il <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> invia semplicemente il carattere dell'elemento padre <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> metodo oppure restituisce `false` se il controllo non ha elementi padre. La <xref:System.Windows.Forms.Form> classe esegue l'override di questo metodo per eseguire l'elaborazione effettiva di finestre di dialogo. Questo metodo viene chiamato solo quando il controllo è ospitato in un'applicazione Windows Forms o come un controllo ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe base <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <summary>Elabora un messaggio relativo ai tasti e generare gli eventi appropriati del controllo.</summary>
        <returns>
          <see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato quando un controllo riceve un messaggio della tastiera. Il metodo è responsabile della generazione di eventi chiavi appropriati per il messaggio chiamando il <xref:System.Windows.Forms.Control.OnKeyPress%2A>, <xref:System.Windows.Forms.Control.OnKeyDown%2A>, o <xref:System.Windows.Forms.Control.OnKeyUp%2A> metodi. Il `m` parametro contiene la finestra di messaggio che deve essere elaborato. I valori possibili per il <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> proprietà sono WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP e WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe base <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> (metodo) deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <summary>Elabora un messaggio della tastiera.</summary>
        <returns>
          <see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato quando un controllo riceve un messaggio della tastiera. Il metodo determina innanzitutto se il controllo ha un padre. Se in tal caso, l'elemento padre chiama <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo. Se l'elemento padre <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo non elabora il messaggio il <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> metodo viene chiamato per generare gli eventi della tastiera appropriata. Il `m` parametro contiene la finestra di messaggio che deve essere elaborato. I valori possibili per il <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> proprietà sono WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP e WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> metodo deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della classe base <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> deve essere restituito. Controlli raramente, se applicabile, dovrà eseguire l'override di questo metodo.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" />, passato per riferimento, che rappresenta il messaggio della finestra da elaborare.</param>
        <summary>Visualizza in anteprima un messaggio della tastiera.</summary>
        <returns>
          <see langword="true" /> se il messaggio è stato elaborato dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da un controllo figlio quando il controllo figlio riceve un messaggio della tastiera. Il controllo figlio chiama questo metodo prima di generare tutti gli eventi della tastiera per il messaggio. Se questo metodo restituisce `true`, il controllo figlio considera elaborato il messaggio e non genera alcun evento della tastiera. Il `m` parametro contiene il messaggio della finestra per visualizzare in anteprima. I valori possibili per il <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> proprietà sono WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP e WM_SYSKEYUP. Il <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo invia semplicemente il carattere dell'elemento padre <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodo oppure restituisce `false` se il controllo non ha elementi padre. La <xref:System.Windows.Forms.Form> classe esegue l'override di questo metodo per eseguire l'elaborazione effettiva di finestre di dialogo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> metodo in una classe derivata, deve restituire un controllo <see langword="true" /> per indicare che il tasto è stato elaborato. Per le chiavi che non vengono elaborate dal controllo, il risultato della chiamata della classe base <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> (metodo) deve essere restituito.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Carattere da elaborare.</param>
        <summary>Elabora un carattere per il tasto di scelta.</summary>
        <returns>
          <see langword="true" /> se il carattere è stato elaborato come tasto di scelta dal controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato per consentire a un controllo per l'elaborazione di un tasto mnemonico. Il metodo deve determinare se il controllo è in uno stato per i tasti di scelta di processo e se il carattere specificato rappresenta un tasto di scelta rapida. Se in tal caso, il metodo deve eseguire l'azione associata con il tasto di scelta e restituire `true`. Se non, il metodo deve restituire `false`. Le implementazioni di questo metodo utilizzano spesso la <xref:System.Windows.Forms.Control.IsMnemonic%2A> metodo per determinare se il carattere specificato corrisponde a un tasto di scelta nel testo del controllo.  
  
 Ad esempio:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Questa implementazione predefinita del <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodo restituisce semplicemente `false` per indicare che il controllo non dispone di alcun tasto di scelta.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come un'estensione della classe di pulsanti che esegue l'override di <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodo possono presentare un comportamento personalizzato. Nell'esempio viene inoltre illustrato l'utilizzo del <xref:System.Windows.Forms.Control.CanSelect%2A> e <xref:System.Windows.Forms.Control.IsMnemonic%2A> proprietà. Per eseguire questo esempio, incollare il codice seguente dopo una classe del modulo, nello stesso file. Aggiungere un pulsante di tipo `MnemonicButton` al form.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre per classi che ereditano per chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del prodotto dell'assembly che contiene il controllo.</summary>
        <value>Nome del prodotto dell'assembly che contiene il controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ProductName%2A> è una proprietà di sola lettura. Per modificare il valore di questa proprietà, impostare il <xref:System.Reflection.AssemblyProductAttribute.Product%2A> valore della proprietà di <xref:System.Reflection.AssemblyProductAttribute>. La seguente riga del set di codice c# di <xref:System.Windows.Forms.Control.ProductName%2A> proprietà.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  È consigliabile fornire il nome della società, il nome del prodotto e versione del prodotto. Queste informazioni consentono l'uso delle funzionalità di Windows Form, ad esempio <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> che semplificano la creazione di applicazioni compatibili con il programma "Certified for Windows". Per ulteriori informazioni sul programma Certified for Windows, vedere http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare informazioni sull'applicazione in un <xref:System.Windows.Forms.Label> contenuti in un <xref:System.Windows.Forms.Form>. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> e <xref:System.Windows.Forms.Control.ProductVersion%2A> sono state impostate.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la versione dell'assembly che contiene il controllo.</summary>
        <value>Versione del file dell'assembly che contiene il controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ProductVersion%2A> è una proprietà di sola lettura. Per modificare il valore di questa proprietà, impostare il <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> valore della proprietà di <xref:System.Reflection.AssemblyVersionAttribute>. La seguente riga del set di codice c# di <xref:System.Windows.Forms.Control.ProductVersion%2A> proprietà.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  È consigliabile fornire il nome della società, il nome del prodotto e versione del prodotto. Queste informazioni consentono l'uso delle funzionalità di Windows Form, ad esempio <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> che semplificano la creazione di applicazioni compatibili con il programma "Certified for Windows". Per ulteriori informazioni sul programma Certified for Windows, vedere http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare informazioni sull'applicazione in un <xref:System.Windows.Forms.Label> contenuti in un <xref:System.Windows.Forms.Form>. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> e <xref:System.Windows.Forms.Control.ProductVersion%2A> sono state impostate.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che rappresenta una modalità IME di propagazione.</summary>
        <value>Oggetto che rappresenta una modalità IME di propagazione.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'oggetto <see cref="T:System.Windows.Forms.AccessibleObject" /> fornisce la Guida per le applicazioni di accessibilità.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile utilizzare la <xref:System.Windows.Forms.HelpProvider> classe per consentire agli utenti di richiamare la Guida relativa all'oggetto accessibile premendo il tasto F1. Utilizzo di <xref:System.Windows.Forms.HelpProvider> vengono fornite informazioni complete nel <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>. Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la creazione di un grafico di supporto per l'accessibilità controllare, tramite il <xref:System.Windows.Forms.AccessibleObject> e <xref:System.Windows.Forms.Control.ControlAccessibleObject> alle classi di esporre le informazioni accessibili. Il controllo traccia due curve e una legenda. Il `ChartControlAccessibleObject` classe che deriva da `ControlAccessibleObject`, viene utilizzata la <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodo per fornire informazioni accessibili personalizzate per il controllo chart. Poiché la legenda del grafico non è una vera e propria <xref:System.Windows.Forms.Control> -controllo di base, ma viene disegnata dal controllo chart, non non contiene informazioni accessibili. Per questo motivo, il `ChartControlAccessibleObject` classe esegue l'override di <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> per restituire il `CurveLegendAccessibleObject` che rappresenta le informazioni accessibili per ogni parte della legenda. Quando viene utilizzato da un'applicazione accessibile abilitata, il controllo può fornire le informazioni accessibili necessarie.  
  
 Questo estratto di codice viene illustrata la gestione di <xref:System.Windows.Forms.Control.QueryAccessibilityHelp> evento. Vedere il <xref:System.Windows.Forms.AccessibleObject> Cenni preliminari sulla classe per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante un'operazione di trascinamento della selezione e consente all'origine del trascinamento di determinare se l'operazione deve essere annullata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato quando viene apportata una modifica nello stato pulsante layout di tastiera o mouse durante un'operazione di trascinamento e rilascio. Il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento consente all'origine del trascinamento di determinare se l'operazione di trascinamento e rilascio deve essere annullata.  
  
 Di seguito vengono illustrate le modalità e le circostanze in cui vengono generati eventi relativi a operazioni di trascinamento e rilascio.  
  
 Il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo determina il controllo sotto la posizione corrente del cursore. Viene quindi verificato se il controllo è un obiettivo di rilascio valido.  
  
 Se il controllo è un obiettivo di rilascio valido, il <xref:System.Windows.Forms.Control.GiveFeedback> evento viene generato con l'effetto di trascinamento e rilascio specificato. Per un elenco degli effetti di trascinamento, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
 Viene tenuta traccia delle modifiche apportate alla posizione del cursore del mouse, allo stato della tastiera e allo stato dei pulsanti del mouse.  
  
-   Se l'utente si sposta al di fuori di una finestra, verrà generato un evento <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Se il mouse viene spostato su un altro controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragEnter> per tale controllo.  
  
-   Se il mouse viene spostato ma sempre all'interno dello stesso controllo, verrà generato l'evento <xref:System.Windows.Forms.Control.DragOver>.  
  
 Se si verifica un cambiamento nello stato pulsante mouse o tastiera, il <xref:System.Windows.Forms.Control.QueryContinueDrag> evento viene generato e verrà determinato se continuare l'operazione di trascinamento, rilasciare i dati, o per annullare l'operazione in base al valore del <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> proprietà dell'evento <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Continue`, <xref:System.Windows.Forms.Control.DragOver> evento viene generato per continuare l'operazione e <xref:System.Windows.Forms.Control.GiveFeedback> viene generato l'evento con il nuovo effetto, consentire l'impostazione della risposta visiva appropriata. Per un elenco degli effetti di trascinamento validi, vedere l'enumerazione <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  Il <xref:System.Windows.Forms.Control.DragOver> e <xref:System.Windows.Forms.Control.GiveFeedback> gli eventi vengono abbinati in modo che, mentre il mouse viene spostato sulla destinazione di trascinamento, l'utente riceva le informazioni più aggiornate sulla posizione del mouse.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Drop`, il valore dell'effetto di rilascio viene restituito all'origine, in modo che l'applicazione di origine può eseguire l'operazione appropriata sui dati di origine, ad esempio il taglio dei dati se l'operazione è un'operazione di spostamento.  
  
-   Se il valore di <xref:System.Windows.Forms.DragAction> è `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> viene generato l'evento.  
  
 Per impostazione predefinita, il <xref:System.Windows.Forms.Control.QueryContinueDrag> set di eventi <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> a `Cancel` in <xref:System.Windows.Forms.DragAction> se viene premuto il tasto ESC e imposta <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> a `Drop` in <xref:System.Windows.Forms.DragAction> se viene premuto il pulsante sinistro, centrale o destro del mouse.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata un'operazione di trascinamento e rilascio tra due <xref:System.Windows.Forms.ListBox> controlli. Nell'esempio viene chiamato il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo quando si avvia l'azione di trascinamento. L'azione di trascinamento viene avviata se il mouse viene spostato più <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> dalla posizione del mouse durante la <xref:System.Windows.Forms.Control.MouseDown> evento. Il <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metodo viene utilizzato per determinare l'indice dell'elemento da trascinare durante il `MouseDown` evento.  
  
 Nell'esempio viene inoltre illustrato l'utilizzo di cursori personalizzati per l'operazione di trascinamento e rilascio. Nell'esempio si presuppone che due file cursore,`3dwarro.cur` e `3dwno.cur`, esiste nella directory dell'applicazione, per il trascinamento personalizzato e non trascinamento, rispettivamente. I cursori personalizzati da utilizzare se il `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> è selezionata. I cursori personalizzati vengono impostati <xref:System.Windows.Forms.Control.GiveFeedback> gestore dell'evento.  
  
 Lo stato della tastiera viene valutato nel <xref:System.Windows.Forms.Control.DragOver> il gestore eventi per il diritto `ListBox`, per determinare l'operazione di trascinamento in base allo stato dei tasti MAIUSC, CTRL, ALT o CTRL + ALT. Il percorso nel `ListBox` in cui si verificherà il rilascio è determinato anche durante la `DragOver` evento. Se i dati da eliminare non sono un `String`, quindi il <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> è impostato su `None` in <xref:System.Windows.Forms.DragDropEffects>. Infine, lo stato del trascinamento viene visualizzato nel `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 I dati da eliminare per il diritto `ListBox` viene determinato nel <xref:System.Windows.Forms.Control.DragDrop> gestore dell'evento e il `String` valore viene aggiunto nella posizione appropriata all'interno di `ListBox`. Se l'operazione di trascinamento viene spostato all'esterno dei limiti del form, quindi viene annullata l'operazione di trascinamento e rilascio nel <xref:System.Windows.Forms.Control.QueryContinueDrag> gestore dell'evento.  
  
 Questo estratto di codice viene illustrato l'utilizzo di <xref:System.Windows.Forms.Control.QueryContinueDrag> evento. Vedere il <xref:System.Windows.Forms.Control.DoDragDrop%2A> metodo per l'esempio di codice completo.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento di trascinamento appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.KeyEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento del tasto appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.MouseEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento del mouse appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Evento da generare.</param>
        <param name="e">Oggetto <see cref="T:System.Windows.Forms.PaintEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento di disegno appropriato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina la creazione di un nuovo handle per il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo viene chiamato ogni volta che i parametri sono necessari per un nuovo controllo, ma tramite una chiamata da <xref:System.Windows.Forms.Control.UpdateStyles%2A> a <xref:System.Windows.Forms.Control.CreateParams%2A> è insufficiente. Questo metodo chiama anche <xref:System.Windows.Forms.Control.DestroyHandle%2A> e <xref:System.Windows.Forms.Control.CreateHandle%2A> e imposta <xref:System.Windows.Forms.Control.RecreatingHandle%2A> a `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo sta creando nuovamente il relativo punto di controllo.</summary>
        <value>
          <see langword="true" /> se il controllo sta creando nuovamente il relativo punto di controllo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.RecreatingHandle%2A> restituisce proprietà `true` se il <xref:System.Windows.Forms.Control.RecreateHandle%2A> metodo è ancora in esecuzione sul controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Oggetto <see cref="T:System.Drawing.Rectangle" /> delle coordinate dello schermo da convertire.</param>
        <summary>Calcola le dimensioni e la posizione del rettangolo dello schermo specificato nelle coordinate client.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Rectangle" /> convertito, <paramref name="r" />, nelle coordinate client.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Oggetto <see cref="T:System.Drawing.Rectangle" /> delle coordinate client da convertire.</param>
        <summary>Calcola le dimensioni e la posizione del rettangolo client specificato nelle coordinate dello schermo.</summary>
        <returns>Oggetto <see cref="T:System.Drawing.Rectangle" /> che rappresenta l'oggetto <see cref="T:System.Drawing.Rectangle" /> convertito, <paramref name="p" />, nelle coordinate dello schermo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, e <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> membri. Per eseguire l'esempio, incollare il codice seguente in un form denominato **Form1** contenente diversi controlli. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, e <xref:System.Windows.Forms.Control.MouseUp> gli eventi siano connessi ai gestori di eventi definiti nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">Oggetto <see cref="T:System.IntPtr" /> che rappresenta il punto di controllo del controllo in cui riprodurre il messaggio.</param>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> che rappresenta il messaggio di Windows da riprodurre.</param>
        <summary>Riproduce il messaggio specificato nel controllo associato al punto di controllo specificato.</summary>
        <returns>
          <see langword="true" /> se il messaggio è stato riprodotto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ReflectMessage%2A> metodo è un metodo di infrastruttura e che non deve essere chiamato dal codice.  
  
 Se il `hWnd` parametro non rappresenta un controllo valido, il <xref:System.Windows.Forms.Control.ReflectMessage%2A> restituisce `false`.  
  
 Poiché i messaggi di Windows vengono restituiti alla finestra di primo livello, il <xref:System.Windows.Forms.Control.ReflectMessage%2A> metodo viene utilizzato per trasmettere il messaggio restituito al controllo che ha inviato il messaggio.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre di chiamare questo metodo. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina l'invalidazione dell'area client del controllo e il nuovo disegno di quest'ultimo e degli eventuali controlli figlio.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.Refresh" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.Refresh" /> metodo in modo che il controllo e i relativi controlli figlio vengono invalidate e ridisegnati.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'area della finestra associata al controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Region" /> della finestra associato al controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area della finestra è una raccolta di pixel all'interno della finestra in cui il sistema operativo consente il disegno. Il sistema operativo non viene visualizzata una parte di una finestra che si trova di fuori dell'area della finestra. Le coordinate dell'area del controllo sono rispetto all'angolo superiore sinistro del controllo, non l'area client del controllo.  
  
> [!NOTE]
>  La raccolta di contenuto nell'area di pixel può essere non contigua.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Forms.Control.Region%2A> proprietà mediante la creazione di un pulsante circolare. Per eseguire l'esempio, incollare il codice seguente in un form contenente un pulsante chiamato `roundButton`. Questo esempio si presuppone che il <xref:System.Windows.Forms.Control.Paint> evento sia connesso al gestore dell'evento definito nell'esempio.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre impostare il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Region" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.RegionChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.RegionChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questa proprietà è ora obsoleta.</summary>
        <value>
          <see langword="true" /> se viene eseguito il rendering del controllo da destra a sinistra; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Valore DPI prima della modifica.</param>
        <param name="deviceDpiNew">Valore DPI dopo la modifica.</param>
        <summary>Fornisce le costanti per il ridimensionamento del controllo quando si verifica una modifica del valore DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.BackColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fa sì che un controllo associato all'oggetto <see cref="T:System.Windows.Forms.BindingSource" /> esegua la rilettura di tutti gli elementi dell'elenco e aggiorni i relativi valori visualizzati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.Font" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.ForeColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.ImeMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il controllo per gestire l'evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il valore predefinito della proprietà <see cref="P:System.Windows.Forms.Control.RightToLeft" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta la proprietà <see cref="P:System.Windows.Forms.Control.Text" /> sul valore predefinito <see cref="F:System.String.Empty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo in genere se si crea una finestra di progettazione per il <xref:System.Windows.Forms.Control> o la creazione di controllo personalizzato che includa il <xref:System.Windows.Forms.Control>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il controllo viene ridimensionato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare il <xref:System.Windows.Forms.Control.Size%2A> del controllo ridimensionato, è possibile eseguire il cast di `sender` parametro di tipo registrato <xref:System.Windows.Forms.ControlEventHandler> metodo da un <xref:System.Windows.Forms.Control> e ottenere relativo <xref:System.Windows.Forms.Control.Size%2A> proprietà (o <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Width%2A> proprietà singolarmente).  
  
 Per gestire layout personalizzati, utilizzare il <xref:System.Windows.Forms.Control.Layout> evento anziché l'evento di ridimensionamento. Il <xref:System.Windows.Forms.Control.Layout> evento viene generato in risposta a un <xref:System.Windows.Forms.Control.Resize> evento, ma anche in risposta ad altre modifiche che hanno effetto sul layout del controllo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Gli handle di esempio di codice seguente il <xref:System.Windows.Forms.Control.Resize> evento di un <xref:System.Windows.Forms.Form>. Quando il form viene ridimensionato, il gestore eventi assicura che il modulo resta quadrato (il <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Width%2A> rimangono uguali). Per eseguire questo esempio, verificare e associare questo metodo di gestione degli eventi con il modulo <xref:System.Windows.Forms.Control.Resize> evento.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il controllo viene ridisegnato quando è ridimensionato.</summary>
        <value>
          <see langword="true" /> se il controllo viene ridisegnato quando è ridimensionato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.ResizeRedraw%2A> valore della proprietà è equivalente al valore restituito del <xref:System.Windows.Forms.Control.GetStyle%2A> metodo quando si passa il <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType> come parametro un valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riprende la consueta logica di layout.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riprende la consueta logica di layout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo impone un layout immediato se vi sono in attesa di richieste di layout.  
  
 Il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> vengono utilizzati insieme per eliminare più <xref:System.Windows.Forms.Control.Layout> eventi durante la regolazione di più attributi del controllo. Ad esempio, in genere chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> (metodo), quindi impostare il <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> le proprietà del controllo e quindi chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo per consentire le modifiche abbiano effetto.  
  
 Devono essere chiamate in sospeso per <xref:System.Windows.Forms.Control.SuspendLayout%2A> per <xref:System.Windows.Forms.Control.ResumeLayout%2A> sia chiamato correttamente.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge due pulsanti a un form. Nell'esempio viene eseguita l'aggiunta dei pulsanti utilizzando la <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">
          <see langword="true" /> per eseguire le richieste di layout in attesa; in caso contrario, <see langword="false" />.</param>
        <summary>Riprende la consueta logica di layout, imponendo, eventualmente, l'esecuzione di un layout immediato delle richieste di layout in sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo impone un layout immediato se vi sono in attesa di richieste di layout. Quando il `performLayout` parametro è impostato su `true`, si verifica un layout immediato se vi sono in attesa di richieste di layout.  
  
 Il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> vengono utilizzati insieme per eliminare più <xref:System.Windows.Forms.Control.Layout> eventi durante la regolazione di più attributi del controllo. Ad esempio, in genere chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> (metodo), quindi impostare il <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> le proprietà del controllo e quindi chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo per consentire le modifiche abbiano effetto.  
  
 Devono essere chiamate in sospeso per <xref:System.Windows.Forms.Control.SuspendLayout%2A> per <xref:System.Windows.Forms.Control.ResumeLayout%2A> sia chiamato correttamente.  
  
> [!NOTE]
>  Quando si aggiungono più controlli a un controllo padre, è consigliabile chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo prima di inizializzare i controlli da aggiungere. Dopo l'aggiunta di controlli al controllo padre, chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo. Ciò aumenta le prestazioni delle applicazioni con molti controlli.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la distanza in pixel tra il bordo destro del controllo e il bordo sinistro dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo destro del controllo e il bordo sinistro dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore del <xref:System.Windows.Forms.Control.Right%2A> proprietà è uguale alla somma dei valori di <xref:System.Windows.Forms.Control.Left%2A> valore della proprietà e <xref:System.Windows.Forms.Control.Width%2A> valore della proprietà.  
  
 La proprietà <xref:System.Windows.Forms.Control.Right%2A> è di sola lettura. È possibile modificare il valore della proprietà indirettamente modificando il valore del <xref:System.Windows.Forms.Control.Left%2A> o <xref:System.Windows.Forms.Control.Width%2A> proprietà o chiamare il <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, o <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> i controlli in un form e imposta le dimensioni e posizione utilizzando le varie dimensioni correlate e relative proprietà. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e l'altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se gli elementi del controllo sono allineati per supportare le impostazioni locali che prevedono la scrittura da destra a sinistra.</summary>
        <value>Uno dei valori di <see cref="T:System.Windows.Forms.RightToLeft" />. Il valore predefinito è <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà è una proprietà di ambiente. Una proprietà di ambiente è una proprietà del controllo che, se non impostato, viene recuperato dal controllo padre. Ad esempio, un <xref:System.Windows.Forms.Button> avrà lo stesso <xref:System.Windows.Forms.Control.BackColor%2A> come padre <xref:System.Windows.Forms.Form> per impostazione predefinita. Per ulteriori informazioni sulle proprietà di ambiente, vedere il <xref:System.Windows.Forms.AmbientProperties> classe o <xref:System.Windows.Forms.Control> Cenni preliminari sulla classe.  
  
 Il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà viene utilizzata per le applicazioni interne in cui la lingua è scritto da destra a sinistra, quale l'ebraico o l'arabo. Quando questa proprietà è impostata su <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>, gli elementi di controllo che includono testo vengono visualizzati da destra a sinistra.  
  
> [!NOTE]
>  Se il valore di <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà viene modificata in fase di esecuzione, viene mantenuto solo il testo non elaborato senza formattazione.  
  
 Ecco alcuni esempi di come gli elementi del controllo sono interessati i <xref:System.Windows.Forms.Control.RightToLeft%2A> valore della proprietà <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> :  
  
-   Vengono visualizzate barre di scorrimento verticale sul lato sinistro anziché sul lato destro dei controlli scorrevoli (ad esempio, <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>su più righe <xref:System.Windows.Forms.TextBox>, e <xref:System.Windows.Forms.RichTextBox>).  
  
-   Barre di scorrimento orizzontale iniziano con la casella di scorrimento (pulsante di scorrimento) allineata a destra.  
  
-   L'allineamento dell'elemento casella di controllo, applicando il `CheckAlign` proprietà, è invertita per <xref:System.Windows.Forms.CheckBox> e <xref:System.Windows.Forms.RadioButton> controlli.  
  
-   Gli elementi nella casella di riepilogo, casella combinata e controlli di scorrimento sono allineati a destra.  
  
-   Pulsanti su e giù sono allineati a sinistra in <xref:System.Windows.Forms.NumericUpDown> e <xref:System.Windows.Forms.DomainUpDown> controlli.  
  
-   Menu (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, e <xref:System.Windows.Forms.ContextMenu>) sono allineati a destra.  
  
-   L'allineamento dei pulsanti della barra degli strumenti in un <xref:System.Windows.Forms.ToolBar> controllo o l'allineamento del testo in un <xref:System.Windows.Forms.ToolBarButton> non è interessata dal <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà.  
  
-   <xref:System.Windows.Forms.AxHost> supporta l'allineamento a destra a sinistra; Tuttavia, l'effetto su un controllo ActiveX dipende l'entità a cui l'autore di controllo implementato il supporto per la visualizzazione da destra a sinistra.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore assegnato non è uno dei valori di <see cref="T:System.Windows.Forms.RightToLeft" />.</exception>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.RightToLeft" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.RightToLeft" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.RightToLeft" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.RightToLeft" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente è un gestore eventi che viene eseguita quando il <xref:System.Windows.Forms.Control.Text%2A> valore proprietà viene modificato. Il <xref:System.Windows.Forms.Control> classe dispone di diversi metodi con il modello di nome *PropertyName* `Changed` che sono generati quando corrispondente *PropertyName* modificato il valore (* PropertyName* rappresenta il nome della proprietà corrispondente).  
  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte l'allineamento corrente nell'allineamento appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Drawing.ContentAlignment" /> specificato nell'oggetto <see cref="T:System.Drawing.ContentAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostato su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostato su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostato su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Drawing.ContentAlignment" /> specificato nell'oggetto <see cref="T:System.Drawing.ContentAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostato su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.HorizontalAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostato su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> specificato nell'oggetto <see cref="T:System.Windows.Forms.LeftRightAlignment" /> appropriato per il supporto di testo con scrittura da destra a sinistra.</summary>
        <returns>Uno dei valori di <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.RightToLeft%2A> proprietà di <xref:System.Windows.Forms.RightToLeft> è impostato su `No`, il valore restituito è uguale al `align` parametro passato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scala il controllo e degli eventuali controlli figlio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="factor">Oggetto <see cref="T:System.Drawing.SizeF" /> contenente i fattori di scala orizzontale e verticale.</param>
        <summary>Ridimensiona il controllo e tutti i relativi controlli figlio in base al fattore di scala specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Scale%2A> metodo ridimensiona il controllo per la scala specificato `factor`. È inoltre Ridimensiona tutti i controlli figlio in modo ricorsivo se il <xref:System.Windows.Forms.Control.ScaleChildren%2A> proprietà `true`. Internamente, questo metodo chiama <xref:System.Windows.Forms.Control.ScaleControl%2A> per ridimensionare ogni controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">Il rapporto da usare per l'adattamento in scala.</param>
        <summary>Scala il controllo e degli eventuali controlli figlio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Fattore di scala orizzontale.</param>
        <param name="dy">Fattore di scala verticale.</param>
        <summary>Scala l'intero controllo ed eventuali controlli figlio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">Bitmap da ridimensionare.</param>
        <summary>Ridimensiona un valore di bitmap logica in base al valore unitario del dispositivo equivalente quando si verifica una modifica del valore DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che determina il ridimensionamento dei controlli figlio.</summary>
        <value>
          <see langword="true" /> se i controlli figlio verranno ridimensionati alla chiamata del metodo <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" /> su questo controllo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Forms.Control.ScaleChildren%2A> proprietà `true`, quindi il <xref:System.Windows.Forms.Control.Scale%2A> metodo verrà chiamata in modo ricorsivo il <xref:System.Windows.Forms.Control.ScaleControl%2A> metodo di ciascuno dei relativi controlli figlio.  
  
 L'implementazione predefinita di <xref:System.Windows.Forms.Control.ScaleChildren%2A> restituisce sempre `true`. Le classi derivate possono eseguire l'override <xref:System.Windows.Forms.Control.ScaleChildren%2A> per restituire `false` per indicare che il ridimensionamento non deve essere eseguito sugli elementi figlio.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Fattore di scala per l'altezza e la larghezza del controllo.</param>
        <param name="specified">Valore di <see cref="T:System.Windows.Forms.BoundsSpecified" /> che specifica i limiti del controllo da usare per definirne le dimensioni e la posizione.</param>
        <summary>Scala la posizione, le dimensioni, la spaziatura interna e il margine di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il controllo è di livello superiore, il percorso del controllo non verrà ridimensionata. Non consente una scalabilità elementi figlio o delle dimensioni dei controlli automaticamente ridimensionati. È possibile omettere il ridimensionamento in qualsiasi direzione modificando il valore della `specified` parametro.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Fattore di scala orizzontale.</param>
        <param name="dy">Fattore di scala verticale.</param>
        <summary>Questo metodo non è pertinente per questa classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attiva un controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attiva il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Select%2A> metodo attiva il controllo se il controllo `Selectable` bit di stile è impostato su `true` in <xref:System.Windows.Forms.ControlStyles>, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da controlli nell'elenco anche non saranno selezionabili.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
   
  
## Examples  
 L'esempio di codice seguente seleziona specificato <xref:System.Windows.Forms.Control>, se è selezionabile.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          <see langword="true" /> per specificare la direzione del controllo da selezionare; in caso contrario, <see langword="false" />.</param>
        <param name="forward">
          <see langword="true" /> per spostarsi in avanti nell'ordine di tabulazione, <see langword="false" /> per spostarsi all'indietro.</param>
        <summary>Attiva un controllo figlio. Può anche specificare la direzione nell'ordine di tabulazione da cui selezionare il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `directed` e `forward` parametri vengono utilizzati dai controlli contenitore. Quando il `directed` parametro è impostato su `true`, `forward` parametro viene valutato per determinare il controllo da selezionare. Quando `forward` è impostato su `true`, viene selezionato il controllo successivo nell'ordine di tabulazione; quando `false`, viene selezionato il controllo precedente nell'ordine di tabulazione.  
  
 Il <xref:System.Windows.Forms.Control.Select%2A> metodo attiva il controllo se il controllo `Selectable` bit di stile è impostato su `true` in <xref:System.Windows.Forms.ControlStyles>, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da controlli nell'elenco anche non saranno selezionabili.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Oggetto <see cref="T:System.Windows.Forms.Control" /> da cui iniziare la ricerca.</param>
        <param name="forward">
          <see langword="true" /> per spostarsi in avanti nell'ordine di tabulazione, <see langword="false" /> per spostarsi all'indietro.</param>
        <param name="tabStopOnly">
          <see langword="true" /> per ignorare i controlli con la proprietà <see cref="P:System.Windows.Forms.Control.TabStop" /> impostata su <see langword="false" />; in caso contrario, <see langword="false" />.</param>
        <param name="nested">
          <see langword="true" /> per includere controlli figlio annidati, ovvero controlli figlio di controlli figlio; in caso contrario, <see langword="false" />.</param>
        <param name="wrap">
          <see langword="true" /> per continuare la ricerca dal primo controllo nell'ordine di tabulazione dopo avere raggiunto l'ultimo controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Attiva il controllo successivo.</summary>
        <returns>
          <see langword="true" /> se il controllo è stato attivato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodo attiva il controllo successivo nell'ordine di tabulazione, se il controllo `Selectable` bit di stile è impostato su `true` in <xref:System.Windows.Forms.ControlStyles>, è contenuto in un altro controllo e tutti i controlli padre sono visibili e abilitati.  
  
 I controlli Windows Form nell'elenco seguente non sono selezionabili. I controlli derivati da controlli nell'elenco anche non saranno selezionabili.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (quando è presente alcun collegamento presente nel controllo)  
  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
   
  
## Examples  
 Nell'esempio di codice exampleshows il <xref:System.Windows.Forms.Control.SelectNextControl%2A> il metodo utilizzato in un form che dispone di alcuni controlli. Ogni volta che si fa clic su form, viene attivato il controllo successivo. Il <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> proprietà ottiene il controllo attualmente attivo nel controllo contenitore.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 Nell'esempio di codice riportato di seguito viene illustrato il <xref:System.Windows.Forms.Control.SelectNextControl%2A> il metodo utilizzato in un form con un <xref:System.Windows.Forms.Button> e altri controlli. Quando si fa clic il <xref:System.Windows.Forms.Button>, il controllo successivo dopo il <xref:System.Windows.Forms.Button> è attivato. Si noti che è necessario ottenere l'elemento padre del <xref:System.Windows.Forms.Button> controllo. Poiché <xref:System.Windows.Forms.Button> non è un contenitore, chiamare <xref:System.Windows.Forms.Control.SelectNextControl%2A> direttamente sul <xref:System.Windows.Forms.Button> non modifica l'attivazione.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Porta il controllo in background nell'ordine z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo viene spostato nella parte posteriore dello z-order. Se il controllo è un elemento figlio di un altro controllo, il controllo figlio viene spostato nella parte posteriore dello z-order. Se il controllo è un controllo di primo livello, questo metodo non funzionerà correttamente a meno che il controllo è attivo. Controllo di primo livello è un controllo, ad esempio un <xref:System.Windows.Forms.Form>, ovvero non è un figlio di un altro controllo. Un controllo attivo è un controllo visibile che contiene lo stato attivo di input. Utilizzare il <xref:System.Windows.Forms.Control.SendToBack%2A> metodo con un controllo di primo livello inattivo, chiamare innanzitutto il <xref:System.Windows.Forms.Control.BringToFront%2A> metodo sul controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno dei valori di <see cref="T:System.Windows.Forms.AutoSizeMode" />.</param>
        <summary>Imposta un valore che indica il comportamento di un controllo quando la relativa proprietà <see cref="P:System.Windows.Forms.Control.AutoSize" /> è abilitata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta i limiti del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Left" /> del controllo.</param>
        <param name="y">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Top" /> del controllo.</param>
        <param name="width">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Width" /> del controllo.</param>
        <param name="height">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Height" /> del controllo.</param>
        <summary>Imposta i limiti del controllo sulla posizione e le dimensioni specificate.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Left" /> del controllo.</param>
        <param name="y">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Top" /> del controllo.</param>
        <param name="width">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Width" /> del controllo.</param>
        <param name="height">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Height" /> del controllo.</param>
        <param name="specified">Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.BoundsSpecified" />. Nel caso di parametri non specificati, verrà usato il valore corrente.</param>
        <summary>Imposta i limiti specificati del controllo sulla posizione e le dimensioni specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 I centri di esempio di codice seguente un <xref:System.Windows.Forms.Form> nella schermata di <xref:System.Windows.Forms.Control.Layout> evento. Il modulo centrato durante il ridimensionamento verrà mantenuta. In questo esempio presuppone che sia stato creato un <xref:System.Windows.Forms.Form> controllo.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Left" /> del controllo.</param>
        <param name="y">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Top" /> del controllo.</param>
        <param name="width">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Width" /> del controllo.</param>
        <param name="height">Nuovo valore della proprietà <see cref="P:System.Windows.Forms.Control.Height" /> del controllo.</param>
        <param name="specified">Combinazione bit per bit dei valori di <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Imposta i limiti specificati di questo controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, i parametri che corrispondono ai limiti non inclusi nel `specified` parametro vengono passati con i relativi valori correnti. Ad esempio, il <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, o <xref:System.Drawing.Point.X%2A> o <xref:System.Drawing.Point.Y%2A> le proprietà del <xref:System.Windows.Forms.Control.Location%2A> proprietà può essere passata con un riferimento all'istanza corrente del controllo. I valori passati sono tuttavia rispettati e applicati al controllo.  
  
 Il `boundsSpecified` parametro rappresenta gli elementi dei controlli <xref:System.Windows.Forms.Control.Bounds%2A> modificato dall'applicazione. Ad esempio, se si modifica il <xref:System.Windows.Forms.Control.Size%2A> del controllo, il `boundsSpecified` valore del parametro è il `Size` valore <xref:System.Windows.Forms.BoundsSpecified>. Tuttavia, se il <xref:System.Windows.Forms.Control.Size%2A> viene modificata in risposta al <xref:System.Windows.Forms.Control.Dock%2A> proprietà viene impostata, il `boundsSpecified` valore del parametro è il `None` valore <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  Nei sistemi Windows Server 2003, le dimensioni di un <xref:System.Windows.Forms.Form> è limitato per la larghezza massima in pixel e l'altezza del monitoraggio.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.SetBoundsCore%2A> metodo per assicurarsi che il controllo resta a dimensione fissa. In questo esempio si suppone una classe derivata direttamente o indirettamente dalla <xref:System.Windows.Forms.Control> classe.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metodo per imporre i limiti del controllo da modificare. Le classi derivate possono aggiungere limitazioni di dimensione per la <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metodo.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Larghezza dell'area client in pixel.</param>
        <param name="y">Altezza dell'area client in pixel.</param>
        <summary>Imposta le dimensioni dell'area client del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area client inizia in corrispondenza di (0, 0) percorso ed estende di (`x`, `y`) percorso.  
  
 In genere, non è necessario impostare il <xref:System.Windows.Forms.Control.ClientSize%2A> del controllo.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodo per assicurarsi che il controllo rimanga quadrato. In questo esempio si suppone una classe derivata direttamente o indirettamente dalla <xref:System.Windows.Forms.Control> classe.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> metodo in modo che il <see cref="P:System.Windows.Forms.Control.ClientSize" /> proprietà viene regolata.  
  
 Per ulteriori informazioni sul disegno nei controlli, vedere [il Rendering di un controllo Windows Form](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> da impostare.</param>
        <param name="value">
          <see langword="true" /> per applicare lo stile specificato al controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta il flag specificato dell'oggetto <see cref="T:System.Windows.Forms.ControlStyles" /> o su <see langword="true" /> o su <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flag di bit di stile di controllo vengono utilizzati per classificare il comportamento supportato. Un controllo è possibile attivare uno stile chiamando il <xref:System.Windows.Forms.Control.SetStyle%2A> metodo e passando l'oggetto appropriato <xref:System.Windows.Forms.ControlStyles> bit (o bits) e il valore booleano per impostare i bit. Per determinare il valore assegnato a un oggetto specificato <xref:System.Windows.Forms.ControlStyles> bit, utilizzare il <xref:System.Windows.Forms.Control.GetStyle%2A> (metodo) e passare il <xref:System.Windows.Forms.ControlStyles> membro da valutare.  
  
> [!CAUTION]
>  Impostare il controllo dei bit di stile sostanzialmente cambiare il comportamento del controllo. Esaminare il <xref:System.Windows.Forms.ControlStyles> documentazione relativa all'enumerazione per comprendere gli effetti della modifica i bit di stile del controllo prima di chiamare il <xref:System.Windows.Forms.Control.SetStyle%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente consente il doppio buffer su un <xref:System.Windows.Forms.Form> e aggiorna gli stili per riflettere le modifiche.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" /> per impostare il controllo come controllo di primo livello; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta il controllo come controllo di primo livello.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si chiama il <xref:System.Windows.Forms.Control.SetTopLevel%2A> metodo di un <xref:System.Windows.Forms.Form> e passare un valore di `false`, la forma non sarà visibile finché non si chiama <xref:System.Windows.Forms.Control.SetTopLevel%2A> nuovamente, passando un valore di `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="value" /> è impostato su <see langword="true" /> e il controllo è un controllo ActiveX.</exception>
        <exception cref="T:System.Exception">Il valore <see cref="M:System.Windows.Forms.Control.GetTopLevel" /> restituito non è uguale al parametro <paramref name="value" /> e la proprietà <see cref="P:System.Windows.Forms.Control.Parent" /> non è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Per impostare il controllo come controllo di primo livello, se è di tipo diverso da <see cref="T:System.Windows.Forms.Form" />. Questa autorizzazione è richiesta solo se il <paramref name="value" /> parametro <see langword="true" /> e il controllo non è un controllo ActiveX. Enumerazione associata: <see langword="AllWindows" /> valore <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" /> per rendere visibile il controllo; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta il controllo sullo stato di visibilità specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generalmente è sottoposto a override questo metodo per modificare il comportamento di visibilità del controllo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> metodo per forzare la visibilità del controllo da modificare.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende visibile il controllo all'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visualizzare il controllo è equivalente all'impostazione di <xref:System.Windows.Forms.Control.Visible%2A> proprietà `true`. Dopo il <xref:System.Windows.Forms.Control.Show%2A> metodo viene chiamato, il <xref:System.Windows.Forms.Control.Visible%2A> proprietà restituisce un valore di `true` fino a quando il <xref:System.Windows.Forms.Control.Hide%2A> metodo viene chiamato.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza un finestra di dialogo e disegna temporaneamente un quadrato di colore blu relativa area. In questo esempio richiede che è stata definita una classe che deriva da <xref:System.Windows.Forms.Form> denominato `AboutDialog`.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se nel controllo devono essere visualizzati i rettangoli di attivazione.</summary>
        <value>
          <see langword="true" /> se nel controllo devono essere visualizzati i rettangoli di attivazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni su questa funzionalità, vedere il[argomenti WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)e [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)argomenti.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se lo stato dell'interfaccia utente consente di visualizzare o nascondere i tasti di scelta rapida.</summary>
        <value>
          <see langword="true" /> se i tasti di scelta rapida sono visibili; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nei controlli creati in Progettazione Windows Form, i tasti di scelta rapida sono visibili per impostazione predefinita.  
  
 Per ulteriori informazioni su questa funzionalità, vedere il[argomenti WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)e [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)argomenti.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il sito del controllo.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISite" /> associato all'oggetto <see cref="T:System.Windows.Forms.Control" />, se presente.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza e la larghezza del controllo.</summary>
        <value>Oggetto <see cref="T:System.Drawing.Size" /> che rappresenta l'altezza e la larghezza del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché il <xref:System.Drawing.Size> classe è un tipo valore (`Structure` in Visual Basic `struct` in Visual c#), viene restituito per valore, ovvero l'accesso alla proprietà restituisce una copia delle dimensioni del controllo. In tal caso, regolare il <xref:System.Drawing.Size.Width%2A> o <xref:System.Drawing.Size.Height%2A> le proprietà del <xref:System.Drawing.Size> restituito da questa non avrà effetto sulle proprietà di <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> del controllo. Per regolare il <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> del controllo, è necessario impostare il controllo <xref:System.Windows.Forms.Control.Width%2A> o <xref:System.Windows.Forms.Control.Height%2A> , proprietà o un set di <xref:System.Windows.Forms.Control.Size%2A> proprietà con un nuovo <xref:System.Drawing.Size>.  
  
> [!NOTE]
>  Per ottenere prestazioni migliori, non impostare il <xref:System.Drawing.Size> di un controllo nel relativo costruttore. Il metodo preferito consiste nell'eseguire l'override di <xref:System.Windows.Forms.Control.DefaultSize%2A> proprietà.  
  
> [!NOTE]
>  Nei sistemi Windows Server 2003, le dimensioni di un <xref:System.Windows.Forms.Form> è limitato per la larghezza massima in pixel e l'altezza del monitoraggio.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. L'esempio consente di limitare il pulsante nell'angolo in basso a destra del form in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> a `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Size" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È preferibile usare il <xref:System.Windows.Forms.Control.Layout> evento da gestire layout personalizzati. Il <xref:System.Windows.Forms.Control.Layout> evento viene generato in risposta a <xref:System.Windows.Forms.Control.Resize> eventi, ma anche in altre condizioni quando potrebbe essere necessario layout da applicare.  
  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Size%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Windows.Forms.Control.SizeChanged> evento. Un'istanza di un <xref:System.Windows.Forms.Button> controllo è stata fornita che può essere scalato orizzontalmente e verticalmente. Oggetto <xref:System.Windows.Forms.NumericUpDown> istanza fornisce il valore di scala orizzontale e verticale. Il <xref:System.Windows.Forms.Button> istanza denominata **OK** utilizzato per impostare i valori di scala per il <xref:System.Windows.Forms.Button> istanza del controllo. Ogni volta che cambiano le dimensioni del controllo, il gestore dell'evento associato il <xref:System.Windows.Forms.Control.SizeChanged> evento del controllo viene chiamato. Questo gestore eventi viene visualizzato un messaggio indicante che le dimensioni del controllo sono stato modificato.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize">Valore <see cref="T:System.Drawing.Size" /> che rappresenta l'altezza e la larghezza dell'area client del controllo.</param>
        <summary>Determina le dimensioni dell'intero controllo a partire dall'altezza e dalla larghezza della relativa area client.</summary>
        <returns>Valore <see cref="T:System.Drawing.Size" /> che rappresenta l'altezza e la larghezza dell'intero controllo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando lo stile del controllo viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.StyleChanged> evento si verifica quando <xref:System.Windows.Forms.ControlStyles> flag aggiunti o modificati.  
  
 Questo evento viene generato se lo stile del controllo viene modificato da una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.StyleChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.StyleChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sospende temporaneamente la logica di layout per il controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La logica di layout del controllo viene sospesa fino a quando il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo viene chiamato.  
  
 Il <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> vengono utilizzati insieme per eliminare più <xref:System.Windows.Forms.Control.Layout> eventi durante la regolazione di più attributi del controllo. Ad esempio, in genere chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> (metodo), quindi impostare il <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, o <xref:System.Windows.Forms.Control.Dock%2A> le proprietà del controllo e quindi chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo per consentire le modifiche abbiano effetto.  
  
 Devono essere chiamate in sospeso per <xref:System.Windows.Forms.Control.SuspendLayout%2A> per <xref:System.Windows.Forms.Control.ResumeLayout%2A> sia chiamato correttamente.  
  
> [!NOTE]
>  Quando si aggiungono più controlli a un controllo padre, è consigliabile chiamare il <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodo prima di inizializzare i controlli da aggiungere. Dopo l'aggiunta di controlli al controllo padre, chiamare il <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodo. Ciò aumenta le prestazioni delle applicazioni con molti controlli.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge due pulsanti a un form. Nell'esempio viene eseguita l'aggiunta dei pulsanti utilizzando la <xref:System.Windows.Forms.Control.SuspendLayout%2A> e <xref:System.Windows.Forms.Control.ResumeLayout%2A> metodi.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Oggetto <see cref="T:System.Windows.Forms.DragEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando i colori di sistema vengono modificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se il <xref:System.Drawing.SystemColors> viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.SystemColorsChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.SystemColorsChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'ordine di tabulazione del controllo all'interno del relativo contenitore.</summary>
        <value>Valore dell'indice del controllo nel set di controlli all'interno del relativo contenitore. Il controlli del contenitore sono inclusi nell'ordine di tabulazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un indice di tabulazione può essere costituito da qualsiasi numero intero valido maggiore o uguale a zero, i numeri più bassi in precedenza in ordine di tabulazione. Se l'indice della scheda stessa dispone di più di un controllo nello stesso controllo padre, l'ordine z dei controlli determina l'ordine per scorrere i controlli.  
  
 Per un controllo da includere nell'ordine di tabulazione, il relativo <xref:System.Windows.Forms.Control.TabStop%2A> proprietà deve essere impostata su `true`.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. L'esempio consente di limitare il pulsante nell'angolo in basso a destra del form in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> a `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.TabIndex" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.TabIndexChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.TabIndexChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'utente può assegnare lo stato attivo al controllo con TAB.</summary>
        <value>
          <see langword="true" /> se l'utente può assegnare lo stato attivo al controllo con TAB; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.  
  
 <block subset="none" type="note"><para>  
 La proprietà restituirà sempre <see langword="true" /> per un'istanza della classe <see cref="T:System.Windows.Forms.Form" />.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'utente preme il tasto TAB, viene impostato lo stato attivo al controllo successivo nell'ordine di tabulazione. Controlli con il <xref:System.Windows.Forms.Control.TabStop%2A> valore della proprietà `false` non sono inclusi nella raccolta di controlli nell'ordine di tabulazione. Ordine di tabulazione può essere modificato impostando il controllo <xref:System.Windows.Forms.Control.TabIndex%2A> valore della proprietà.  
  
   
  
## Examples  
 L'esempio di codice seguente aggiunge un <xref:System.Windows.Forms.Button> a un form e vengono impostate alcune proprietà comuni. L'esempio consente di limitare il pulsante nell'angolo in basso a destra del form in modo che mantiene la posizione relativa quando il form viene ridimensionato. Viene quindi impostata la <xref:System.Windows.Forms.Control.BackgroundImage%2A> e viene ridimensionato il pulsante per la stessa dimensione di <xref:System.Drawing.Image>. Nell'esempio viene quindi impostato il <xref:System.Windows.Forms.Control.TabStop%2A> a `true` e imposta il <xref:System.Windows.Forms.Control.TabIndex%2A> proprietà. Infine, viene aggiunto un gestore eventi per gestire il <xref:System.Windows.Forms.Control.Click> evento del pulsante. In questo esempio si suppone una <xref:System.Windows.Forms.ImageList> denominato `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.TabStop" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.TabStop%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo membro. Nell'esempio, un gestore eventi genera report sull'occorrenza del <xref:System.Windows.Forms.Control.TabStopChanged> evento. Questo report consente di capire quando l'evento si verifica e possa agevolare il debug. Per generare un report su più eventi o per gli eventi che si verificano di frequente, è possibile sostituire <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> con <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o aggiungere il messaggio a un controllo <xref:System.Windows.Forms.TextBox>.  
  
 Per eseguire l'esempio di codice, incollarlo in un progetto che contiene un'istanza di un tipo che eredita da <xref:System.Windows.Forms.Control>, ad esempio un <xref:System.Windows.Forms.Button> o <xref:System.Windows.Forms.ComboBox>. Quindi assegnare un nome di istanza `Control1` e assicurarsi che il gestore dell'evento è associato il <xref:System.Windows.Forms.Control.TabStopChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto che contiene i dati sul controllo.</summary>
        <value>Oggetto <see cref="T:System.Object" /> che contiene i dati sul controllo. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualsiasi tipo derivato dalla <xref:System.Object> classe può essere assegnata a questa proprietà. Se il <xref:System.Windows.Forms.Control.Tag%2A> è impostata tramite la finestra di progettazione Windows Form, è possibile assegnare solo testo.  
  
 Un utilizzo comune per il <xref:System.Windows.Forms.Control.Tag%2A> proprietà consiste nell'archiviare i dati che sono strettamente associati al controllo. Ad esempio, se si dispone di un controllo che visualizza le informazioni relative a un cliente, è possibile archiviare un <xref:System.Data.DataSet> che contiene la cronologia degli ordini del cliente in tale controllo <xref:System.Windows.Forms.Control.Tag%2A> proprietà accedere rapidamente ai dati.  
  
   
  
## Examples  
 L'esempio di codice seguente viene visualizzato un form e archivia un `Customer` nel relativo <xref:System.Windows.Forms.Control.Tag%2A> proprietà. In questo esempio richiede che è stata definita una classe che deriva da <xref:System.Windows.Forms.Form> denominato `CustomerForm` e che è stato definito un `Customer`.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il testo associato a questo controllo.</summary>
        <value>Testo associato a questo controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Text%2A> proprietà del controllo viene utilizzata in modo diverso da ogni classe derivata. Ad esempio il <xref:System.Windows.Forms.Control.Text%2A> proprietà di un <xref:System.Windows.Forms.Form> viene visualizzato nella barra del titolo nella parte superiore del form, è da un numero di caratteri limitato e in genere viene visualizzato il nome di applicazione o del documento. Tuttavia, il <xref:System.Windows.Forms.Control.Text%2A> proprietà di un <xref:System.Windows.Forms.RichTextBox> può essere elevato e può includere diversi caratteri non visivi utilizzate per formattare il testo. Ad esempio, il testo visualizzato un <xref:System.Windows.Forms.RichTextBox> possono essere formattati regolando il <xref:System.Drawing.Font> proprietà, o mediante l'aggiunta di spazi o caratteri di tabulazione per allineare il testo.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Windows.Forms.GroupBox> e vengono impostate alcune proprietà comuni. Nell'esempio viene creato un <xref:System.Windows.Forms.TextBox> e imposta il relativo <xref:System.Windows.Forms.Control.Location%2A> all'interno della casella di gruppo. Viene quindi impostata la <xref:System.Windows.Forms.Control.Text%2A> proprietà della casella di gruppo e il controllo viene ancorato casella del gruppo nella parte superiore del form. Infine, viene disabilitata la casella di gruppo impostando la <xref:System.Windows.Forms.Control.Enabled%2A> proprietà `false`, che fa sì che tutti i controlli contenuti all'interno della casella di gruppo deve essere disabilitata.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override di <see cref="P:System.Windows.Forms.Control.Text" /> proprietà in una classe derivata, utilizzare la classe base <see cref="P:System.Windows.Forms.Control.Text" /> proprietà per estendere l'implementazione di base. In caso contrario, è necessario fornire tutti l'implementazione. Non è necessario eseguire l'override di entrambi i <see langword="get" /> e <see langword="set" /> funzioni di accesso il <see cref="P:System.Windows.Forms.Control.Text" /> proprietà; è possibile sostituire un solo se necessario.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Text" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Text%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di <xref:System.Windows.Forms.Control.ForeColor%2A> di un <xref:System.Windows.Forms.TextBox> la visualizzazione dei dati di valuta. Nell'esempio converte il testo in un numero decimale e modifiche di <xref:System.Windows.Forms.Control.ForeColor%2A> a <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> se il numero è negativo e su <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> se il numero è positivo. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che contiene un <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la distanza in pixel tra il bordo superiore del controllo e il bordo superiore dell'area client del contenitore.</summary>
        <value>Oggetto <see cref="T:System.Int32" /> che rappresenta la distanza in pixel tra il bordo inferiore del controllo e il bordo superiore dell'area client del contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.Top%2A> è equivalente al valore della proprietà di <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> proprietà del <xref:System.Windows.Forms.Control.Location%2A> valore della proprietà del controllo.  
  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Height%2A> e <xref:System.Windows.Forms.Control.Top%2A> causa i valori delle proprietà di <xref:System.Windows.Forms.Control.Bottom%2A> valore della proprietà del controllo da modificare.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> i controlli in un form e imposta le dimensioni e posizione utilizzando le varie dimensioni correlate e relative proprietà. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e l'altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il controllo padre non associato a un altro controllo Windows Form. In genere, si tratta del <see cref="T:System.Windows.Forms.Form" /> più esterno in cui il controllo è contenuto.</summary>
        <value>Oggetto <see cref="T:System.Windows.Forms.Control" /> che rappresenta il controllo di primo livello che contiene il controllo corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controllo di primo livello è definito come il controllo padre non associato a un altro controllo Windows Form. In genere, si tratta del <xref:System.Windows.Forms.Form> più esterno in cui il controllo è contenuto. Ad esempio, se il controllo è contenuto in un figlio MDI <xref:System.Windows.Forms.Form>, controllo di primo livello è l'elemento padre dell'interfaccia a documenti multipli (MDI) <xref:System.Windows.Forms.Form>. Se non è associato il controllo su un <xref:System.Windows.Forms.Form>, questa proprietà restituirà `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per tutte le finestre ottenere il valore della proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina il nuovo disegno delle aree invalidate del controllo all'interno della relativa area client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esegue le richieste in sospeso per il disegno.  
  
 Esistono due modi per aggiornare la visualizzazione di un modulo e il relativo contenuto:  
  
-   È possibile utilizzare uno degli overload di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo con il <xref:System.Windows.Forms.Control.Update%2A> metodo.  
  
-   È possibile chiamare il <xref:System.Windows.Forms.Control.Refresh%2A> metodo, che impone il ridisegno se stesso e i relativi elementi figlio del controllo. Questo è equivalente all'impostazione di <xref:System.Windows.Forms.Control.Invalidate%2A> metodo `true` e l'uso con <xref:System.Windows.Forms.Control.Update%2A>.  
  
 Il <xref:System.Windows.Forms.Control.Invalidate%2A> metodo determina le aree di disegno o ridisegnata. Il <xref:System.Windows.Forms.Control.Update%2A> metodo determina quando vengono eseguite queste operazioni. Se si utilizza il <xref:System.Windows.Forms.Control.Invalidate%2A> e <xref:System.Windows.Forms.Control.Update%2A> insieme anziché chiamare i metodi <xref:System.Windows.Forms.Control.Refresh%2A>, cosa ridisegnare sul quale eseguire l'overload di <xref:System.Windows.Forms.Control.Invalidate%2A> utilizzare. Il <xref:System.Windows.Forms.Control.Update%2A> metodo impone soltanto il controllo da disegnare immediatamente, ma la <xref:System.Windows.Forms.Control.Invalidate%2A> metodo determina cosa disegnare quando chiama il <xref:System.Windows.Forms.Control.Update%2A> metodo.  
  
 Per ulteriori informazioni, vedere il[WM_PAINT](http://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)argomento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna i limiti del controllo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna i limiti del controllo in base alla posizione e alle dimensioni correnti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il nuovo <xref:System.Windows.Forms.Control.Size%2A> del controllo è diverso dal precedente <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> viene generato l'evento. Analogamente, se il <xref:System.Windows.Forms.Control.Location%2A> del controllo cambia, il <xref:System.Windows.Forms.Control.LocationChanged> viene generato l'evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordinata <see cref="P:System.Drawing.Point.X" /> del controllo.</param>
        <param name="y">Coordinata <see cref="P:System.Drawing.Point.Y" /> del controllo.</param>
        <param name="width">Valore <see cref="P:System.Drawing.Size.Width" /> del controllo.</param>
        <param name="height">Valore <see cref="P:System.Drawing.Size.Height" /> del controllo.</param>
        <summary>Aggiorna i limiti del controllo in base alla posizione e alle dimensioni specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il nuovo <xref:System.Windows.Forms.Control.Size%2A> di controllo è diverso dal precedente <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> viene generato l'evento. Analogamente, è il <xref:System.Windows.Forms.Control.Location%2A> del controllo cambia, il <xref:System.Windows.Forms.Control.LocationChanged> viene generato l'evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordinata <see cref="P:System.Drawing.Point.X" /> del controllo.</param>
        <param name="y">Coordinata <see cref="P:System.Drawing.Point.Y" /> del controllo.</param>
        <param name="width">Valore <see cref="P:System.Drawing.Size.Width" /> del controllo.</param>
        <param name="height">Valore <see cref="P:System.Drawing.Size.Height" /> del controllo.</param>
        <param name="clientWidth">Valore <see cref="P:System.Drawing.Size.Width" /> client del controllo.</param>
        <param name="clientHeight">Valore <see cref="P:System.Drawing.Size.Height" /> client del controllo.</param>
        <summary>Aggiorna i limiti del controllo in base alle dimensioni, alla posizione e alle dimensioni client specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il nuovo <xref:System.Windows.Forms.Control.Size%2A> del controllo è diverso dal precedente <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> viene generato l'evento. Analogamente, se il <xref:System.Windows.Forms.Control.Location%2A> del controllo cambia, il <xref:System.Windows.Forms.Control.LocationChanged> viene generato l'evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina la nuova applicazione degli stili assegnati al controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il <xref:System.Windows.Forms.Control.CreateParams%2A> metodo per ottenere lo stile da applicare. Gli stili assegnati per il <xref:System.Windows.Forms.CreateParams.Style%2A> e <xref:System.Windows.Forms.CreateParams.ExStyle%2A> le proprietà del <xref:System.Windows.Forms.CreateParams> assegnato al controllo <xref:System.Windows.Forms.Control.CreateParams%2A> vengono riapplicate proprietà. Il controllo viene ridisegnato per riflettere le modifiche dello stile, se necessario.  
  
 Il <xref:System.Windows.Forms.Control.UpdateStyles%2A> metodo non ha alcun effetto se la <xref:System.Windows.Forms.Control.IsHandleCreated%2A> valore della proprietà è `false`.  
  
   
  
## Examples  
 Esempio di codice seguente consente il doppio buffer su un <xref:System.Windows.Forms.Form> e aggiorna gli stili per riflettere le modifiche.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna il controllo nell'ordine z del controllo padre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Forms.Control.UpdateZOrder%2A> metodo aggiorna la posizione del controllo nell'ordine z del controllo padre. Ad esempio, se questo controllo è un controllo appena creato che è stato aggiunto a un <xref:System.Windows.Forms.Control.ControlCollection>, l'ordine z viene aggiornato con il nuovo controllo aggiunto alla fine.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se usare il cursore di attesa per il controllo corrente e per tutti i controlli figlio.</summary>
        <value>
          <see langword="true" /> per usare il cursore di attesa per il controllo corrente e per tutti i controlli figlio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni volta che si esegue un'operazione che richiede una notevole quantità di tempo, utilizzare un cursore di attesa. Si noti tuttavia che le operazioni che bloccano il thread dell'interfaccia utente verranno bloccata anche acursor cambia. Questa proprietà, pertanto, deve essere utilizzata solo durante l'esecuzione di operazioni lunghe ed elaborate in un altro thread. Per modificare il cursore globale e immediatamente, vedere <xref:System.Windows.Forms.Cursor.Current%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al termine della convalida del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Se il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> è impostato su `true` nel <xref:System.Windows.Forms.Control.Validating> delegato dell'evento, tutti gli eventi che in genere si verificano dopo il <xref:System.Windows.Forms.Control.Validating> evento verranno soppressi.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o del sistema operativo di rispondere. Per ulteriori informazioni, vedere il[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)argomento e la sezione "Messaggio deadlock" del [informazioni sui messaggi e le code di messaggi](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) argomento.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente viene utilizzata la classe derivata <xref:System.Windows.Forms.TextBox> e convalida un indirizzo di posta elettronica immesso dall'utente. Se l'indirizzo di posta elettronica non è nel formato standard (contenente "@" and "."), la convalida non riesce, un <xref:System.Windows.Forms.ErrorProvider> viene visualizzata l'icona e l'evento viene annullato. Questo esempio si presuppone che un <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.ErrorProvider> siano stati creati in un form.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante la convalida del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si modifica lo stato attivo dalla tastiera (TAB, MAIUSC + TAB e così via), chiamando la <xref:System.Windows.Forms.Control.Select%2A> o <xref:System.Windows.Forms.Control.SelectNextControl%2A> , metodi o impostando la <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> proprietà sul form corrente, gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Quando si modifica lo stato attivo usando il mouse o chiamando il <xref:System.Windows.Forms.Control.Focus%2A> (metodo), gli eventi di stato attivo si verificano nell'ordine seguente:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Se il <xref:System.Windows.Forms.Control.CausesValidation%2A> è impostata su `false`, <xref:System.Windows.Forms.Control.Validating> e <xref:System.Windows.Forms.Control.Validated> vengono soppressi.  
  
 Se il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> è impostato su `true` nel <xref:System.Windows.Forms.Control.Validating> delegato dell'evento, tutti gli eventi che in genere si verificano dopo il <xref:System.Windows.Forms.Control.Validating> evento verranno soppressi.  
  
> [!CAUTION]
>  Non tentare di impostare lo stato attivo dall'interno di <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, o <xref:System.Windows.Forms.Control.Validated> gestori eventi. Questa operazione può causare l'applicazione o del sistema operativo di rispondere. Per altre informazioni, vedere la `WM_KILLFOCUS` argomento nella sezione "Riferimenti di Input da tastiera" e la sezione "Messaggio deadlock" dell'argomento "Sui messaggi e code di messaggi" in MSDN all'indirizzo http://msdn.microsoft.com/library.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente viene utilizzata la classe derivata <xref:System.Windows.Forms.TextBox> e convalida un indirizzo di posta elettronica immesso dall'utente. Se l'indirizzo di posta elettronica non è nel formato standard (contenente "@" and "."), la convalida non riesce, un <xref:System.Windows.Forms.ErrorProvider> viene visualizzata l'icona e l'evento viene annullato. Questo esempio si presuppone che un <xref:System.Windows.Forms.TextBox> e <xref:System.Windows.Forms.ErrorProvider> siano stati creati in un form.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se vengono visualizzati il controllo e tutti i relativi controlli figlio.</summary>
        <value>
          <see langword="true" /> se vengono visualizzati il controllo e tutti i relativi controlli figlio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che, anche se `Visible` è impostato su `true`, il controllo potrebbe non essere visibile all'utente se è nascosto dietro altri controlli.  
  
   
  
## Examples  
 Esempio di codice seguente usa le classi derivate <xref:System.Windows.Forms.VScrollBar> e <xref:System.Windows.Forms.HScrollBar> e imposta i <xref:System.Windows.Forms.Control.Visible%2A> i valori delle proprietà in base alla dimensione di un <xref:System.Drawing.Image> visualizzato in un <xref:System.Windows.Forms.PictureBox> controllo. Questo esempio si presuppone che un <xref:System.Windows.Forms.PictureBox> è stato creato in un form e che <xref:System.Windows.Forms.HScrollBar> e <xref:System.Windows.Forms.VScrollBar> controlli sono stati creati nel <xref:System.Windows.Forms.PictureBox>. Questo codice deve essere chiamato quando l'immagine viene caricata nella casella di immagine e dal <xref:System.Windows.Forms.Control.Resize> eventi del modulo.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il valore della proprietà <see cref="P:System.Windows.Forms.Control.Visible" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato se la <xref:System.Windows.Forms.Control.Visible%2A> proprietà viene modificata una modifica a livello di codice o l'interazione dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Genera di esempio di codice seguente il <xref:System.Windows.Forms.Control.VisibleChanged> eventi quando il <xref:System.Windows.Forms.Control.Visible%2A> valore della proprietà di <xref:System.Windows.Forms.Label> controllo è stato modificato.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la larghezza del controllo.</summary>
        <value>Larghezza del controllo in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le modifiche apportate al <xref:System.Windows.Forms.Control.Width%2A> e <xref:System.Windows.Forms.Control.Left%2A> causa i valori delle proprietà di <xref:System.Windows.Forms.Control.Right%2A> valore della proprietà del controllo da modificare.  
  
   
  
## Examples  
 Esempio di codice seguente crea tre <xref:System.Windows.Forms.Button> i controlli in un form e imposta le dimensioni e posizione utilizzando le varie dimensioni correlate e relative proprietà. In questo esempio si suppone una <xref:System.Windows.Forms.Form> che ha una larghezza e l'altezza di almeno 300 pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questa proprietà non è pertinente per questa classe.</summary>
        <value>NativeWindow contenuto nel controllo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non è pertinente per questa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Oggetto <see cref="T:System.Windows.Forms.Message" /> di Windows da elaborare.</param>
        <summary>Elabora i messaggi di Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti i messaggi vengono inviati i <xref:System.Windows.Forms.Control.WndProc%2A> metodo filtrati tramite il <xref:System.Windows.Forms.Control.PreProcessMessage%2A> metodo.  
  
 Il metodo <xref:System.Windows.Forms.Control.WndProc%2A> corrisponde esattamente alla funzione `WindowProc` di Windows. Per ulteriori informazioni sull'elaborazione dei messaggi di Windows, vedere il [funzione WindowProc](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'override di <xref:System.Windows.Forms.Control.WndProc%2A> metodo per gestire i messaggi di sistema operativo identificati nella <xref:System.Windows.Forms.Message> struttura. Il[WM_ACTIVATEAPP](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)messaggio del sistema operativo è gestito in questo esempio per sapere quando un'altra applicazione diventa attiva. Vedere gli argomenti seguenti per comprendere il disponibili <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>, e <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> valori. I valori effettivi di costanti sono reperibile nel file di intestazione di Windows. h.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per il chiamante immediato chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>I controlli ereditano deve chiamare la classe base <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> metodo per elaborare i messaggi che non gestiti.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>